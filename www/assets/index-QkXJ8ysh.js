function __vite_legacy_guard() {
  import.meta.url;
  import("_").catch(() => 1);
  (async function* () {
  })().next();
}
;
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$2 = Symbol.for("react.element"), n$2 = Symbol.for("react.portal"), p$3 = Symbol.for("react.fragment"), q$2 = Symbol.for("react.strict_mode"), r$1 = Symbol.for("react.profiler"), t$1 = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$2 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$2(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = z$2 && a[z$2] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a, b2) {
  if ("object" !== typeof a && "function" !== typeof a && null != a)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b2, "setState");
};
E$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
var H$3 = G$1.prototype = new F();
H$3.constructor = G$1;
C$1(H$3, E$1.prototype);
H$3.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a && a.defaultProps)
    for (d2 in g2 = a.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$2, type: a, key: k2, ref: h2, props: c2, _owner: K$1.current };
}
function N$1(a, b2) {
  return { $$typeof: l$2, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$1(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$2;
}
function escape$1(a) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b2[a2];
  });
}
var P$1 = /\/+/g;
function Q$1(a, b2) {
  return "object" === typeof a && null !== a && null != a.key ? escape$1("" + a.key) : b2.toString(36);
}
function R$1(a, b2, e2, d2, c2) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2)
    a = null;
  var h2 = false;
  if (null === a)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l$2:
          case n$2:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a, c2 = c2(h2), a = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a2) {
      return a2;
    })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a))
    for (var g2 = 0; g2 < a.length; g2++) {
      k2 = a[g2];
      var f2 = d2 + Q$1(k2, g2);
      h2 += R$1(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$2(a), "function" === typeof f2)
    for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; )
      k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a, b2, e2) {
  if (null == a)
    return a;
  var d2 = [], c2 = 0;
  R$1(a, d2, "", "", function(a2) {
    return b2.call(e2, a2, c2++);
  });
  return d2;
}
function T$1(a) {
  if (-1 === a._status) {
    var b2 = a._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a._status || -1 === a._status)
        a._status = 1, a._result = b3;
    }, function(b3) {
      if (0 === a._status || -1 === a._status)
        a._status = 2, a._result = b3;
    });
    -1 === a._status && (a._status = 0, a._result = b2);
  }
  if (1 === a._status)
    return a._result.default;
  throw a._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
function X$1() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$1, forEach: function(a, b2, e2) {
  S$1(a, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a) {
  var b2 = 0;
  S$1(a, function() {
    b2++;
  });
  return b2;
}, toArray: function(a) {
  return S$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$1(a))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$3;
react_production_min.Profiler = r$1;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$2;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$1;
react_production_min.cloneElement = function(a, b2, e2) {
  if (null === a || void 0 === a)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d2 = C$1({}, a.props), c2 = a.key, k2 = a.ref, h2 = a._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a.type && a.type.defaultProps)
      var g2 = a.type.defaultProps;
    for (f2 in b2)
      J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$2, type: a.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t$1, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a) {
  var b2 = M$1.bind(null, a);
  b2.type = a;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$2, render: a };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a) {
  return { $$typeof: y$1, _payload: { _status: -1, _result: a }, _init: T$1 };
};
react_production_min.memo = function(a, b2) {
  return { $$typeof: x$1, type: a, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = X$1;
react_production_min.useCallback = function(a, b2) {
  return U$1.current.useCallback(a, b2);
};
react_production_min.useContext = function(a) {
  return U$1.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$1.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b2) {
  return U$1.current.useEffect(a, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a, b2, e2) {
  return U$1.current.useImperativeHandle(a, b2, e2);
};
react_production_min.useInsertionEffect = function(a, b2) {
  return U$1.current.useInsertionEffect(a, b2);
};
react_production_min.useLayoutEffect = function(a, b2) {
  return U$1.current.useLayoutEffect(a, b2);
};
react_production_min.useMemo = function(a, b2) {
  return U$1.current.useMemo(a, b2);
};
react_production_min.useReducer = function(a, b2, e2) {
  return U$1.current.useReducer(a, b2, e2);
};
react_production_min.useRef = function(a) {
  return U$1.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$1.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b2, e2) {
  return U$1.current.useSyncExternalStore(a, b2, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = reactExports, k$1 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$1 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
function q$1(c2, a, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a.key && (e2 = "" + a.key);
  void 0 !== a.ref && (h2 = a.ref);
  for (b2 in a)
    m$2.call(a, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a = c2.defaultProps, a)
      void 0 === d2[b2] && (d2[b2] = a[b2]);
  return { $$typeof: k$1, type: c2, key: e2, ref: h2, props: d2, _owner: n$1.current };
}
reactJsxRuntime_production_min.Fragment = l$1;
reactJsxRuntime_production_min.jsx = q$1;
reactJsxRuntime_production_min.jsxs = q$1;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a, b2) {
    var c2 = a.length;
    a.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a[d2];
        if (0 < g2(e2, b2))
          a[d2] = b2, a[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a) {
    return 0 === a.length ? null : a[0];
  }
  function k2(a) {
    if (0 === a.length)
      return null;
    var b2 = a[0], c2 = a.pop();
    if (c2 !== b2) {
      a[0] = c2;
      a:
        for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c2, d2 = n2) : (a[d2] = C2, a[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a[d2] = x2, a[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a, b2) {
    var c2 = a.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a);
      }
  }
  function J2(a, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a = exports.unstable_now();
      Q2 = a;
      var b2 = true;
      try {
        b2 = O2(true, a);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b2) {
    L2 = D2(function() {
      a(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c2 = y2;
    y2 = a;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a = { id: u2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a.sortIndex = c2, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$1(a) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b2) {
  ha(a, b2);
  ha(a + "Capture", b2);
}
function ha(a, b2) {
  ea[a] = b2;
  for (a = 0; a < b2.length; a++)
    da.add(b2[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a) {
  if (ja.call(ma, a))
    return true;
  if (ja.call(la, a))
    return false;
  if (ka.test(a))
    return ma[a] = true;
  la[a] = true;
  return false;
}
function pa(a, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qa(a, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$1(a, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z$1[a] = new v$1(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b2 = a[0];
  z$1[b2] = new v$1(b2, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z$1[a] = new v$1(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z$1[a] = new v$1(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z$1[a] = new v$1(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z$1[a] = new v$1(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z$1[a] = new v$1(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z$1[a] = new v$1(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z$1[a] = new v$1(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b2 = a.replace(
    ra,
    sa
  );
  z$1[b2] = new v$1(b2, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$1[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$1[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z$1[a] = new v$1(a, 1, false, a.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z$1[a] = new v$1(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta(a, b2, c2, d2) {
  var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A$1 = Object.assign, La;
function Ma(a) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a;
}
var Na = false;
function Oa(a, b2) {
  if (!a || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, false), a;
    case 11:
      return a = Oa(a.type.render, false), a;
    case 1:
      return a = Oa(a.type, true), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a)
    return null;
  if ("function" === typeof a)
    return a.displayName || a.name || null;
  if ("string" === typeof a)
    return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a)
    switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a.render;
        a = a.displayName;
        a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
      case Ha:
        b2 = a._payload;
        a = a._init;
        try {
          return Qa(a(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a) {
  var b2 = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b2 = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a) {
  var b2 = Ta(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
  if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d2 = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a2) {
      d2 = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b2];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a)
    return false;
  var b2 = a._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d2;
  return a !== c2 ? (b2.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a)
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b2) {
    return a.body;
  }
}
function Ya(a, b2) {
  var c2 = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
}
function Za(a, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a, b2) {
  b2 = b2.checked;
  null != b2 && ta(a, "checked", b2, false);
}
function bb(a, b2) {
  ab(a, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a.value || a.value != c2)
        a.value = "" + c2;
    } else
      a.value !== "" + c2 && (a.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
}
function db(a, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a._wrapperState.initialValue;
    c2 || b2 === a.value || (a.value = b2);
    a.defaultValue = b2;
  }
  c2 = a.name;
  "" !== c2 && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c2 && (a.name = c2);
}
function cb(a, b2, c2) {
  if ("number" !== b2 || Xa(a.ownerDocument) !== a)
    null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a, b2, c2, d2) {
  a = a.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a.length; c2++)
      e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c2) {
        a[e2].selected = true;
        d2 && (a[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a[e2].disabled || (b2 = a[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$1(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$1(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$1(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a._wrapperState = { initialValue: Sa(c2) };
}
function ib(a, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
  null != d2 && (a.defaultValue = "" + d2);
}
function jb(a) {
  var b2 = a.textContent;
  b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b2) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
}
var mb, nb = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b2, c2, d2, e2);
    });
  } : a;
}(function(a, b2) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
    a.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b2.firstChild; )
      a.appendChild(b2.firstChild);
  }
});
function ob(a, b2) {
  if (b2) {
    var c2 = a.firstChild;
    if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a) {
  qb.forEach(function(b2) {
    b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b2] = pb[a];
  });
});
function rb(a, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
}
function sb(a, b2) {
  a = a.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a.setProperty(c2, e2) : a[c2] = e2;
    }
}
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a, b2) {
  if (b2) {
    if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$1(137, a));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$1(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$1(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$1(62));
  }
}
function vb(a, b2) {
  if (-1 === a.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb)
      throw Error(p$1(280));
    var b2 = a.stateNode;
    b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a);
    if (b2)
      for (a = 0; a < b2.length; a++)
        Bb(b2[a]);
  }
}
function Gb(a, b2) {
  return a(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a, b2, c2) {
  if (Ib)
    return a(b2, c2);
  Ib = true;
  try {
    return Gb(a, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a, b2) {
  var c2 = a.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d2;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$1(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
function Nb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
  Ob = true;
  Pb = a;
} };
function Tb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$1(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a) {
  var b2 = a, c2 = a;
  if (a.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a = b2;
    do
      b2 = a, 0 !== (b2.flags & 4098) && (c2 = b2.return), a = b2.return;
    while (a);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b2 = a.memoizedState;
    null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a)
    throw Error(p$1(188));
}
function Yb(a) {
  var b2 = a.alternate;
  if (!b2) {
    b2 = Vb(a);
    if (null === b2)
      throw Error(p$1(188));
    return b2 !== a ? null : a;
  }
  for (var c2 = a, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$1(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$1(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$1(190));
  }
  if (3 !== c2.tag)
    throw Error(p$1(188));
  return c2.stateNode.current === c2 ? a : b2;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag)
    return a;
  for (a = a.child; null !== a; ) {
    var b2 = $b(a);
    if (null !== b2)
      return b2;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b2) {
  var c2 = a.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a.entangledLanes;
  if (0 !== b2)
    for (a = a.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
  return d2;
}
function vc(a, b2) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b2) {
  for (var c2 = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a);
  return b2;
}
function Ac(a, b2, c2) {
  a.pendingLanes |= b2;
  536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b2 = 31 - oc(b2);
  a[b2] = c2;
}
function Bc(a, b2) {
  var c2 = a.pendingLanes & ~b2;
  a.pendingLanes = b2;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b2;
  a.mutableReadLanes &= b2;
  a.entangledLanes &= b2;
  b2 = a.entanglements;
  var d2 = a.eventTimes;
  for (a = a.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a, b2) {
  var c2 = a.entangledLanes |= b2;
  for (a = a.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a[d2] & b2 && (a[d2] |= b2);
    c2 &= ~e2;
  }
}
var C = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b2) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a, b2, c2, d2, e2, f2) {
  if (null === a || a.nativeEvent !== f2)
    return a = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
  a.eventSystemFlags |= d2;
  b2 = a.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a;
}
function Uc(a, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a) {
  var b2 = Wc(a.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a.blockedOn = b2;
          Ic(a.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn)
    return false;
  for (var b2 = a.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
    if (null === c2) {
      c2 = a.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a, b2, c2) {
  Xc(a) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b2) {
  a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b2(b3) {
    return ad(b3, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function gd(a, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function fd(a, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a, b2, c2, d2);
    if (null === e2)
      hd(a, b2, d2, id, c2), Sc(a, d2);
    else if (Uc(e2, a, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a, b2, c2, d2);
        null === f2 && hd(a, b2, d2, id, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a, b2, c2, d2) {
  id = null;
  a = xb(d2);
  a = Wc(a);
  if (null !== a)
    if (b2 = Vb(a), null === b2)
      a = null;
    else if (c2 = b2.tag, 13 === c2) {
      a = Wb(b2);
      if (null !== a)
        return a;
      a = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a = null;
    } else
      b2 !== a && (a = null);
  id = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a = 0; a < c2 && b2[a] === e2[a]; a++)
    ;
  var g2 = c2 - a;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
}
function od(a) {
  var b2 = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a)
      a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a) {
  if (a.key) {
    var b2 = Md[a.key] || a.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b2) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b2) {
  switch (a) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b2.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b2) {
  if (ie)
    return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
}
function ne(a, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b2 = ue(a);
  if (Wa(b2))
    return a;
}
function ve(a, b2) {
  if ("change" === a)
    return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a, xb(a));
    Jb(re, b2);
  }
}
function Ce(a, b2, c2) {
  "focusin" === a ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a)
    return te(qe);
}
function Ee(a, b2) {
  if ("click" === a)
    return te(b2);
}
function Fe(a, b2) {
  if ("input" === a || "change" === a)
    return te(b2);
}
function Ge(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b2) {
  if (He(a, b2))
    return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Ke(a, b2) {
  var c2 = Je(a);
  a = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a + c2.textContent.length;
      if (a <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a };
      a = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a, b2) {
  return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a = b2.contentWindow;
    else
      break;
    b2 = Xa(a.document);
  }
  return b2;
}
function Ne(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
}
function Oe(a) {
  var b2 = Me(), c2 = a.focusedElem, d2 = a.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
      else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
      }
    }
    b2 = [];
    for (a = c2; a = a.parentNode; )
      1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a, b2) {
  var c2 = {};
  c2[a.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a] = "webkit" + b2;
  c2["Moz" + a] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a])
    return Xe[a];
  if (!We[a])
    return a;
  var b2 = We[a], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye)
      return Xe[a] = b2[c2];
  return a;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b2) {
  df.set(a, b2);
  fa(b2, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b2, c2) {
  var d2 = a.type || "unknown-event";
  a.currentTarget = c2;
  Ub(d2, b2, void 0, a);
  a.currentTarget = null;
}
function se(a, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a.length; c2++) {
    var d2 = a[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a = Rb, Qb = false, Rb = null, a;
}
function D(a, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a + "__bubble";
  c2.has(d2) || (pf(b2, a, 2, false), c2.add(d2));
}
function qf(a, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
    });
    var b2 = 9 === a.nodeType ? a : a.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
}
function hd(a, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a);
      if (void 0 !== h3) {
        var k3 = td, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve;
        else if (me(h3))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a, h3, d3);
        "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae)
        b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge(a, c2) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c2) : ke(a, c2))
        d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g3, b2);
  });
}
function tf(a, b2, c2) {
  return { instance: a, listener: b2, currentTarget: c2 };
}
function oe(a, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
    var e2 = a, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c2), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e2)));
    a = a.return;
  }
  return d2;
}
function vf(a) {
  if (null === a)
    return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b2, c2) {
  b2 = zf(b2);
  if (zf(a) !== b2 && c2)
    throw Error(p$1(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a, b2) {
  return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
function Kf(a, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b2 = a.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b2 = 0; a; ) {
    if (8 === a.nodeType) {
      var c2 = a.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b2 = a[Of];
  if (b2)
    return b2;
  for (var c2 = a.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a = Mf(a); null !== a; ) {
          if (c2 = a[Of])
            return c2;
          a = Mf(a);
        }
      return b2;
    }
    a = c2;
    c2 = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag)
    return a.stateNode;
  throw Error(p$1(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a, b2) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b2;
}
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b2) {
  var c2 = a.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E(Wf);
  E(H$2);
}
function ag(a, b2, c2) {
  if (H$2.current !== Vf)
    throw Error(p$1(168));
  G(H$2, b2);
  G(Wf, c2);
}
function bg(a, b2, c2) {
  var d2 = a.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$1(108, Ra(a) || "Unknown", e2));
  return A$1({}, c2, d2);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$2.current;
  G(H$2, a);
  G(Wf, Wf.current);
  return true;
}
function dg(a, b2, c2) {
  var d2 = a.stateNode;
  if (!d2)
    throw Error(p$1(169));
  c2 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H$2), G(H$2, a)) : E(Wf);
  G(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = true;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b2 = C;
    try {
      var c2 = eg;
      for (C = 1; a < c2.length; a++) {
        var d2 = c2[a];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b2;
}
function ug(a, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d2 = rg;
  a = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a;
  b2 = a.deletions;
  null === b2 ? (a.deletions = [c2], a.flags |= 16) : b2.push(c2);
}
function Cg(a, b2) {
  switch (a.tag) {
    case 5:
      var c2 = a.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a, a.child = c2, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a, b2)) {
        if (Dg(a))
          throw Error(p$1(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a, b2) ? Ag(d2, c2) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
      }
    } else {
      if (Dg(a))
        throw Error(p$1(418));
      a.flags = a.flags & -4097 | 2;
      I = false;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
    a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg)
    return false;
  if (!I)
    return Fg(a), I = true, false;
  var b2;
  (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a))
      throw Hg(), Error(p$1(418));
    for (; b2; )
      Ag(a, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a)
      throw Error(p$1(317));
    a: {
      a = a.nextSibling;
      for (b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c2 = a.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a = yg; a; )
    a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b2, c2) {
  a = c2.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$1(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$1(147, a));
      var e2 = d2, f2 = "" + a;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a2) {
        var b3 = e2.refs;
        null === a2 ? delete b3[f2] : b3[f2] = a2;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a)
      throw Error(p$1(284));
    if (!c2._owner)
      throw Error(p$1(290, a));
  }
  return a;
}
function Mg(a, b2) {
  a = Object.prototype.toString.call(b2);
  throw Error(p$1(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
}
function Ng(a) {
  var b2 = a._init;
  return b2(a._payload);
}
function Og(a) {
  function b2(b3, c3) {
    if (a) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a2, b3) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
    return a2;
  }
  function e2(a2, b3) {
    a2 = Pg(a2, b3);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a2, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = Qg(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function k2(a2, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a2, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = Lg(a2, b3, c3), d3.return = a2, d3;
    d3 = Rg(c3.type, c3.key, c3.props, null, a2.mode, d3);
    d3.ref = Lg(a2, b3, c3);
    d3.return = a2;
    return d3;
  }
  function l2(a2, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = Sg(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a2;
    return b3;
  }
  function m2(a2, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Tg(c3, a2.mode, d3, f3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function q2(a2, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = Qg("" + b3, a2.mode, c3), b3.return = a2, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = Rg(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = Lg(a2, null, b3), c3.return = a2, c3;
        case wa:
          return b3 = Sg(b3, a2.mode, c3), b3.return = a2, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a2, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Tg(b3, a2.mode, c3, null), b3.return = a2, b3;
      Mg(a2, b3);
    }
    return null;
  }
  function r2(a2, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a2,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a2, b3, c3, d3, null);
      Mg(a2, c3);
    }
    return null;
  }
  function y2(a2, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
        case wa:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a2, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
      Mg(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a && u2.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$1(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$1(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function J2(a2, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a2, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                  c2(a2, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = Lg(a2, l3, f3);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                }
                c2(a2, l3);
                break;
              } else
                b2(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Tg(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Lg(a2, d3, f3), h3.return = a2, a2 = h3);
          }
          return g2(a2);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a2, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                } else {
                  c2(a2, d3);
                  break;
                }
              else
                b2(a2, d3);
              d3 = d3.sibling;
            }
            d3 = Sg(f3, a2.mode, h3);
            d3.return = a2;
            a2 = d3;
          }
          return g2(a2);
        case Ha:
          return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a2, d3, f3, h3);
      if (Ka(f3))
        return t2(a2, d3, f3, h3);
      Mg(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = Qg(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c2(a2, d3);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a) {
  var b2 = Wg.current;
  E(Wg);
  a._currentValue = b2;
}
function bh(a, b2, c2) {
  for (; null !== a; ) {
    var d2 = a.alternate;
    (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a === c2)
      break;
    a = a.return;
  }
}
function ch(a, b2) {
  Xg = a;
  Zg = Yg = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (dh = true), a.firstContext = null);
}
function eh(a) {
  var b2 = a._currentValue;
  if (Zg !== a)
    if (a = { context: a, memoizedValue: b2, next: null }, null === Yg) {
      if (null === Xg)
        throw Error(p$1(308));
      Yg = a;
      Xg.dependencies = { lanes: 0, firstContext: a };
    } else
      Yg = Yg.next = a;
  return b2;
}
var fh = null;
function gh(a) {
  null === fh ? fh = [a] : fh.push(a);
}
function hh(a, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return ih(a, d2);
}
function ih(a, b2) {
  a.lanes |= b2;
  var c2 = a.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a;
  for (a = a.return; null !== a; )
    a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var jh = false;
function kh(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a, b2) {
  a = a.updateQueue;
  b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function mh(a, b2) {
  return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function nh(a, b2, c2) {
  var d2 = a.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return ih(a, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, gh(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return ih(a, c2);
}
function oh(a, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
function ph(a, b2) {
  var c2 = a.updateQueue, d2 = a.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a.updateQueue = c2;
    return;
  }
  a = c2.lastBaseUpdate;
  null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
  c2.lastBaseUpdate = b2;
}
function qh(a, b2, c2, d2) {
  var e2 = a.updateQueue;
  jh = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$1({}, q2, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    rh |= g2;
    a.lanes = g2;
    a.memoizedState = q2;
  }
}
function sh(a, b2, c2) {
  a = b2.effects;
  b2.effects = null;
  if (null !== a)
    for (b2 = 0; b2 < a.length; b2++) {
      var d2 = a[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$1(191, e2));
        e2.call(d2);
      }
    }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a) {
  if (a === th)
    throw Error(p$1(174));
  return a;
}
function yh(a, b2) {
  G(wh, b2);
  G(vh, a);
  G(uh, th);
  a = b2.nodeType;
  switch (a) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
  }
  E(uh);
  G(uh, b2);
}
function zh() {
  E(uh);
  E(vh);
  E(wh);
}
function Ah(a) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c2 = lb(b2, a.type);
  b2 !== c2 && (G(vh, a), G(uh, c2));
}
function Bh(a) {
  vh.current === a && (E(uh), E(vh));
}
var L = Uf(0);
function Ch(a) {
  for (var b2 = a; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a = 0; a < Dh.length; a++)
    Dh[a]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P() {
  throw Error(p$1(321));
}
function Mh(a, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++)
    if (!He(a[c2], b2[c2]))
      return false;
  return true;
}
function Nh(a, b2, c2, d2, e2, f2) {
  Hh = f2;
  M = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
  a = c2(d2, e2);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2)
        throw Error(p$1(301));
      f2 += 1;
      O = N = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a = c2(d2, e2);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = null !== N && null !== N.next;
  Hh = 0;
  O = N = M = null;
  Ih = false;
  if (b2)
    throw Error(p$1(300));
  return a;
}
function Sh() {
  var a = 0 !== Kh;
  Kh = 0;
  return a;
}
function Th() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O ? M.memoizedState = O = a : O = O.next = a;
  return O;
}
function Uh() {
  if (null === N) {
    var a = M.alternate;
    a = null !== a ? a.memoizedState : null;
  } else
    a = N.next;
  var b2 = null === O ? M.memoizedState : O.next;
  if (null !== b2)
    O = b2, N = a;
  else {
    if (null === a)
      throw Error(p$1(310));
    N = a;
    a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
  }
  return O;
}
function Vh(a, b2) {
  return "function" === typeof b2 ? b2(a) : b2;
}
function Wh(a) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$1(311));
  c2.lastRenderedReducer = a;
  var d2 = N, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        M.lanes |= m2;
        rh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (dh = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a = c2.interleaved;
  if (null !== a) {
    e2 = a;
    do
      f2 = e2.lane, M.lanes |= f2, rh |= f2, e2 = e2.next;
    while (e2 !== a);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function Xh(a) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$1(311));
  c2.lastRenderedReducer = a;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (dh = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function Yh() {
}
function Zh(a, b2) {
  var c2 = M, d2 = Uh(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, dh = true);
  d2 = d2.queue;
  $h(ai.bind(null, c2, d2, a), [a]);
  if (d2.getSnapshot !== b2 || f2 || null !== O && O.memoizedState.tag & 1) {
    c2.flags |= 2048;
    bi(9, ci.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === Q)
      throw Error(p$1(349));
    0 !== (Hh & 30) || di(c2, b2, e2);
  }
  return e2;
}
function di(a, b2, c2) {
  a.flags |= 16384;
  a = { getSnapshot: b2, value: c2 };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.stores = [a]) : (c2 = b2.stores, null === c2 ? b2.stores = [a] : c2.push(a));
}
function ci(a, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  ei(b2) && fi(a);
}
function ai(a, b2, c2) {
  return c2(function() {
    ei(b2) && fi(a);
  });
}
function ei(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var c2 = b2();
    return !He(a, c2);
  } catch (d2) {
    return true;
  }
}
function fi(a) {
  var b2 = ih(a, 1);
  null !== b2 && gi(b2, a, 1, -1);
}
function hi(a) {
  var b2 = Th();
  "function" === typeof a && (a = a());
  b2.memoizedState = b2.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
  b2.queue = a;
  a = a.dispatch = ii.bind(null, M, a);
  return [b2.memoizedState, a];
}
function bi(a, b2, c2, d2) {
  a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
  return a;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a, b2, c2, d2) {
  var e2 = Th();
  M.flags |= a;
  e2.memoizedState = bi(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function li(a, b2, c2, d2) {
  var e2 = Uh();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== N) {
    var g2 = N.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Mh(d2, g2.deps)) {
      e2.memoizedState = bi(b2, c2, f2, d2);
      return;
    }
  }
  M.flags |= a;
  e2.memoizedState = bi(1 | b2, c2, f2, d2);
}
function mi(a, b2) {
  return ki(8390656, 8, a, b2);
}
function $h(a, b2) {
  return li(2048, 8, a, b2);
}
function ni(a, b2) {
  return li(4, 2, a, b2);
}
function oi(a, b2) {
  return li(4, 4, a, b2);
}
function pi(a, b2) {
  if ("function" === typeof b2)
    return a = a(), b2(a), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a = a(), b2.current = a, function() {
      b2.current = null;
    };
}
function qi(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return li(4, 4, pi.bind(null, b2, a), c2);
}
function ri() {
}
function si(a, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a, b2];
  return a;
}
function ti(a, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1]))
    return d2[0];
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}
function ui(a, b2, c2) {
  if (0 === (Hh & 21))
    return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), M.lanes |= c2, rh |= c2, a.baseState = true);
  return b2;
}
function vi(a, b2) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a(true);
  var d2 = Gh.transition;
  Gh.transition = {};
  try {
    a(false), b2();
  } finally {
    C = c2, Gh.transition = d2;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a, b2, c2) {
  var d2 = yi(a);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a))
    Ai(b2, c2);
  else if (c2 = hh(a, b2, c2, d2), null !== c2) {
    var e2 = R();
    gi(c2, a, d2, e2);
    Bi(c2, b2, d2);
  }
}
function ii(a, b2, c2) {
  var d2 = yi(a), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a))
    Ai(b2, e2);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = hh(a, b2, e2, d2);
    null !== c2 && (e2 = R(), gi(c2, a, d2, e2), Bi(c2, b2, d2));
  }
}
function zi(a) {
  var b2 = a.alternate;
  return a === M || null !== b2 && b2 === M;
}
function Ai(a, b2) {
  Jh = Ih = true;
  var c2 = a.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a.pending = b2;
}
function Bi(a, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b2) {
  Th().memoizedState = [a, void 0 === b2 ? null : b2];
  return a;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b2, a),
    c2
  );
}, useLayoutEffect: function(a, b2) {
  return ki(4194308, 4, a, b2);
}, useInsertionEffect: function(a, b2) {
  return ki(4, 2, a, b2);
}, useMemo: function(a, b2) {
  var c2 = Th();
  b2 = void 0 === b2 ? null : b2;
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}, useReducer: function(a, b2, c2) {
  var d2 = Th();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
  d2.queue = a;
  a = a.dispatch = xi.bind(null, M, a);
  return [d2.memoizedState, a];
}, useRef: function(a) {
  var b2 = Th();
  a = { current: a };
  return b2.memoizedState = a;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
  return Th().memoizedState = a;
}, useTransition: function() {
  var a = hi(false), b2 = a[0];
  a = vi.bind(null, a[1]);
  Th().memoizedState = a;
  return [b2, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b2, c2) {
  var d2 = M, e2 = Th();
  if (I) {
    if (void 0 === c2)
      throw Error(p$1(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === Q)
      throw Error(p$1(349));
    0 !== (Hh & 30) || di(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  mi(ai.bind(
    null,
    d2,
    f2,
    a
  ), [a]);
  d2.flags |= 2048;
  bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a = Th(), b2 = Q.identifierPrefix;
  if (I) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Kh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a) {
    var b2 = Uh();
    return ui(b2, N.memoizedState, a);
  },
  useTransition: function() {
    var a = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a) {
  var b2 = Uh();
  return null === N ? b2.memoizedState = a : ui(b2, N.memoizedState, a);
}, useTransition: function() {
  var a = Xh(Vh)[0], b2 = Uh().memoizedState;
  return [a, b2];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a, b2) {
  if (a && a.defaultProps) {
    b2 = A$1({}, b2);
    a = a.defaultProps;
    for (var c2 in a)
      void 0 === b2[c2] && (b2[c2] = a[c2]);
    return b2;
  }
  return b2;
}
function Di(a, b2, c2, d2) {
  b2 = a.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
  a.memoizedState = c2;
  0 === a.lanes && (a.updateQueue.baseState = c2);
}
var Ei = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb(a) === a : false;
}, enqueueSetState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = R(), e2 = yi(a), f2 = mh(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a, f2, e2);
  null !== b2 && (gi(b2, a, e2, d2), oh(b2, a, e2));
}, enqueueReplaceState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = R(), e2 = yi(a), f2 = mh(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a, f2, e2);
  null !== b2 && (gi(b2, a, e2, d2), oh(b2, a, e2));
}, enqueueForceUpdate: function(a, b2) {
  a = a._reactInternals;
  var c2 = R(), d2 = yi(a), e2 = mh(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = nh(a, e2, d2);
  null !== b2 && (gi(b2, a, d2, c2), oh(b2, a, d2));
} };
function Fi(a, b2, c2, d2, e2, f2, g2) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function Gi(a, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H$2.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
  b2 = new b2(c2, f2);
  a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Ei;
  a.stateNode = b2;
  b2._reactInternals = a;
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Hi(a, b2, c2, d2) {
  a = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a && Ei.enqueueReplaceState(b2, b2.state, null);
}
function Ii(a, b2, c2, d2) {
  var e2 = a.stateNode;
  e2.props = c2;
  e2.state = a.memoizedState;
  e2.refs = {};
  kh(a);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H$2.current, e2.context = Yf(a, f2));
  e2.state = a.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a, b2, f2, c2), e2.state = a.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a, c2, e2, d2), e2.state = a.memoizedState);
  "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
}
function Ji(a, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b2, stack: e2, digest: null };
}
function Ki(a, b2, c2) {
  return { value: a, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Li(a, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Oi || (Oi = true, Pi = d2);
    Li(a, b2);
  };
  return c2;
}
function Qi(a, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  var d2 = a.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Li(a, b2);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Li(a, b2);
    "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Si(a, b2, c2) {
  var d2 = a.pingCache;
  if (null === d2) {
    d2 = a.pingCache = new Mi();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a = Ti.bind(null, a, b2, c2), b2.then(a, a));
}
function Ui(a) {
  do {
    var b2;
    if (b2 = 13 === a.tag)
      b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Vi(a, b2, c2, d2, e2) {
  if (0 === (a.mode & 1))
    return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e2;
  return a;
}
var Wi = ua.ReactCurrentOwner, dh = false;
function Xi(a, b2, c2, d2) {
  b2.child = null === a ? Vg(b2, null, c2, d2) : Ug(b2, a.child, c2, d2);
}
function Yi(a, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  ch(b2, e2);
  d2 = Nh(a, b2, c2, d2, f2, e2);
  c2 = Sh();
  if (null !== a && !dh)
    return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, Zi(a, b2, e2);
  I && c2 && vg(b2);
  b2.flags |= 1;
  Xi(a, b2, d2, e2);
  return b2.child;
}
function $i(a, b2, c2, d2, e2) {
  if (null === a) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, bj(a, b2, f2, d2, e2);
    a = Rg(c2.type, null, d2, b2, b2.mode, e2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a.ref === b2.ref)
      return Zi(a, b2, e2);
  }
  b2.flags |= 1;
  a = Pg(f2, d2);
  a.ref = b2.ref;
  a.return = b2;
  return b2.child = a;
}
function bj(a, b2, c2, d2, e2) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie(f2, d2) && a.ref === b2.ref)
      if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e2))
        0 !== (a.flags & 131072) && (dh = true);
      else
        return b2.lanes = a.lanes, Zi(a, b2, e2);
  }
  return cj(a, b2, c2, d2, e2);
}
function dj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G(ej, fj);
      fj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(ej, fj), fj |= d2;
  Xi(a, b2, e2, c2);
  return b2.child;
}
function gj(a, b2) {
  var c2 = b2.ref;
  if (null === a && null !== c2 || null !== a && a.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function cj(a, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$2.current;
  f2 = Yf(b2, f2);
  ch(b2, e2);
  c2 = Nh(a, b2, c2, d2, f2, e2);
  d2 = Sh();
  if (null !== a && !dh)
    return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, Zi(a, b2, e2);
  I && d2 && vg(b2);
  b2.flags |= 1;
  Xi(a, b2, c2, e2);
  return b2.child;
}
function hj(a, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  ch(b2, e2);
  if (null === b2.stateNode)
    ij(a, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e2), d2 = true;
  else if (null === a) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H$2.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
    jh = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    lh(a, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H$2.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g2, d2, k2);
    jh = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return jj(a, b2, c2, d2, f2, e2);
}
function jj(a, b2, c2, d2, e2, f2) {
  gj(a, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), Zi(a, b2, f2);
  d2 = b2.stateNode;
  Wi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a && g2 ? (b2.child = Ug(b2, a.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function kj(a) {
  var b2 = a.stateNode;
  b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
  yh(a, b2.containerInfo);
}
function lj(a, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Xi(a, b2, c2, d2);
  return b2.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function oj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = L.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a || null !== a.memoizedState)
    e2 |= 1;
  G(L, e2 & 1);
  if (null === a) {
    Eg(b2);
    a = b2.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a = Tg(a, d2, c2, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a) : qj(b2, g2);
  }
  e2 = a.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return rj(a, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a.child.memoizedState;
    g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a.childLanes & ~c2;
    b2.memoizedState = mj;
    return d2;
  }
  f2 = a.child;
  a = f2.sibling;
  d2 = Pg(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a], b2.flags |= 16) : c2.push(a));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function qj(a, b2) {
  b2 = pj({ mode: "visible", children: b2 }, a.mode, 0, null);
  b2.return = a;
  return a.child = b2;
}
function sj(a, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Ug(b2, a.child, null, c2);
  a = qj(b2, b2.pendingProps.children);
  a.flags |= 2;
  b2.memoizedState = null;
  return a;
}
function rj(a, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Ki(Error(p$1(422))), sj(a, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = pj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Tg(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Ug(b2, a.child, null, g2);
    b2.child.memoizedState = nj(g2);
    b2.memoizedState = mj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return sj(a, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$1(419));
    d2 = Ki(f2, d2, void 0);
    return sj(a, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a.childLanes);
  if (dh || h2) {
    d2 = Q;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a, e2), gi(d2, a, e2, -1));
    }
    tj();
    d2 = Ki(Error(p$1(421)));
    return sj(a, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a.child, b2 = uj.bind(null, a), e2._reactRetry = b2, null;
  a = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
  b2 = qj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function vj(a, b2, c2) {
  a.lanes |= b2;
  var d2 = a.alternate;
  null !== d2 && (d2.lanes |= b2);
  bh(a.return, b2, c2);
}
function wj(a, b2, c2, d2, e2) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function xj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Xi(a, b2, d2.children, c2);
  d2 = L.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128))
      a:
        for (a = b2.child; null !== a; ) {
          if (13 === a.tag)
            null !== a.memoizedState && vj(a, c2, b2);
          else if (19 === a.tag)
            vj(a, c2, b2);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b2)
            break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b2)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d2 &= 1;
  }
  G(L, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a = c2.alternate, null !== a && null === Ch(a) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        wj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a = e2.alternate;
          if (null !== a && null === Ch(a)) {
            b2.child = e2;
            break;
          }
          a = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a;
        }
        wj(b2, true, c2, null, f2);
        break;
      case "together":
        wj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function ij(a, b2) {
  0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function Zi(a, b2, c2) {
  null !== a && (b2.dependencies = a.dependencies);
  rh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a && b2.child !== a.child)
    throw Error(p$1(153));
  if (null !== b2.child) {
    a = b2.child;
    c2 = Pg(a, a.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a.sibling; )
      a = a.sibling, c2 = c2.sibling = Pg(a, a.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function yj(a, b2, c2) {
  switch (b2.tag) {
    case 3:
      kj(b2);
      Ig();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G(Wg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G(L, L.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return oj(a, b2, c2);
        G(L, L.current & 1);
        a = Zi(a, b2, c2);
        return null !== a ? a.sibling : null;
      }
      G(L, L.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d2)
          return xj(a, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(L, L.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a, b2, c2);
  }
  return Zi(a, b2, c2);
}
var zj, Aj, Bj, Cj;
zj = function(a, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Aj = function() {
};
Bj = function(a, b2, c2, d2) {
  var e2 = a.memoizedProps;
  if (e2 !== d2) {
    a = b2.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a, e2);
        d2 = Ya(a, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$1({}, e2, { value: void 0 });
        d2 = A$1({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a, e2);
        d2 = gb(a, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Cj = function(a, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Dj(a, b2) {
  if (!I)
    switch (a.tailMode) {
      case "hidden":
        b2 = a.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
    }
}
function S(a) {
  var b2 = null !== a.alternate && a.alternate.child === a.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
  else
    for (e2 = a.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
  a.subtreeFlags |= d2;
  a.childLanes = c2;
  return b2;
}
function Ej(a, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S(b2), null;
    case 3:
      d2 = b2.stateNode;
      zh();
      E(Wf);
      E(H$2);
      Eh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a || null === a.child)
        Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a, b2);
      S(b2);
      return null;
    case 5:
      Bh(b2);
      var e2 = xh(wh.current);
      c2 = b2.type;
      if (null !== a && null != b2.stateNode)
        Bj(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$1(166));
          S(b2);
          return null;
        }
        a = xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D("cancel", d2);
              D("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D(lf[e2], d2);
              break;
            case "source":
              D("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d2
              );
              D("load", d2);
              break;
            case "details":
              D("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c2));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
          a[Of] = b2;
          a[Pf] = d2;
          zj(a, b2, false, false);
          b2.stateNode = a;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D(lf[e2], a);
                e2 = d2;
                break;
              case "source":
                D("error", a);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a
                );
                D("load", a);
                e2 = d2;
                break;
              case "details":
                D("toggle", a);
                e2 = d2;
                break;
              case "input":
                Za(a, d2);
                e2 = Ya(a, d2);
                D("invalid", a);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$1({}, d2, { value: void 0 });
                D("invalid", a);
                break;
              case "textarea":
                hb(a, d2);
                e2 = gb(a, d2);
                D("invalid", a);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a);
                db(a, d2, false);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S(b2);
      return null;
    case 6:
      if (a && null != b2.stateNode)
        Cj(a, b2, a.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$1(166));
        c2 = xh(wh.current);
        xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a = xg, null !== a)
              switch (a.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S(b2);
      return null;
    case 13:
      E(L);
      d2 = b2.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a) {
            if (!f2)
              throw Error(p$1(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$1(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S(b2);
          f2 = false;
        } else
          null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S(b2);
      return null;
    case 4:
      return zh(), Aj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
    case 10:
      return ah(b2.type._context), S(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S(b2), null;
    case 19:
      E(L);
      f2 = b2.memoizedState;
      if (null === f2)
        return S(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Dj(f2, false);
        else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128))
            for (a = b2.child; null !== a; ) {
              g2 = Ch(a);
              if (null !== g2) {
                b2.flags |= 128;
                Dj(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
                G(L, L.current & 1 | 2);
                return b2.child;
              }
              a = a.sibling;
            }
          null !== f2.tail && B() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a = Ch(g2), null !== a) {
            if (b2.flags |= 128, d2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I)
              return S(b2), null;
          } else
            2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = L.current, G(L, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S(b2);
      return null;
    case 22:
    case 23:
      return Hj(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$1(156, b2.tag));
}
function Ij(a, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 3:
      return zh(), E(Wf), E(H$2), Eh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      E(L);
      a = b2.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$1(340));
        Ig();
      }
      a = b2.flags;
      return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 19:
      return E(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b2.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Lj(a, b2) {
  var c2 = a.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W(a, b2, d2);
      }
    else
      c2.current = null;
}
function Mj(a, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W(a, b2, d2);
  }
}
var Nj = false;
function Oj(a, b2) {
  Cf = dd;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a)
      var c2 = { start: a.selectionStart, end: a.selectionEnd };
    else
      a: {
        c2 = (c2 = a.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a, selectionRange: c2 };
  dd = false;
  for (V = b2; null !== V; )
    if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a)
      a.return = b2, V = a;
    else
      for (; null !== V; ) {
        b2 = V;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$1(163));
            }
        } catch (F2) {
          W(b2, b2.return, F2);
        }
        a = b2.sibling;
        if (null !== a) {
          a.return = b2.return;
          V = a;
          break;
        }
        V = b2.return;
      }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a) === a) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Mj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Qj(a, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a) === a) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Rj(a) {
  var b2 = a.ref;
  if (null !== b2) {
    var c2 = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c2;
        break;
      default:
        a = c2;
    }
    "function" === typeof b2 ? b2(a) : b2.current = a;
  }
}
function Sj(a) {
  var b2 = a.alternate;
  null !== b2 && (a.alternate = null, Sj(b2));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Tj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Uj(a) {
  a:
    for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Tj(a.return))
          return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2)
          continue a;
        if (null === a.child || 4 === a.tag)
          continue a;
        else
          a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2))
        return a.stateNode;
    }
}
function Vj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2)
    a = a.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a = a.child, null !== a))
    for (Vj(a, b2, c2), a = a.sibling; null !== a; )
      Vj(a, b2, c2), a = a.sibling;
}
function Wj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2)
    a = a.stateNode, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
  else if (4 !== d2 && (a = a.child, null !== a))
    for (Wj(a, b2, c2), a = a.sibling; null !== a; )
      Wj(a, b2, c2), a = a.sibling;
}
var X = null, Xj = false;
function Yj(a, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    Zj(a, b2, c2), c2 = c2.sibling;
}
function Zj(a, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U || Lj(c2, b2);
    case 6:
      var d2 = X, e2 = Xj;
      X = null;
      Yj(a, b2, c2);
      X = d2;
      Xj = e2;
      null !== X && (Xj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c2) : a.removeChild(c2)) : X.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X && (Xj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c2) : 1 === a.nodeType && Kf(a, c2), bd(a)) : Kf(X, c2.stateNode));
      break;
    case 4:
      d2 = X;
      e2 = Xj;
      X = c2.stateNode.containerInfo;
      Xj = true;
      Yj(a, b2, c2);
      X = d2;
      Xj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Yj(a, b2, c2);
      break;
    case 1:
      if (!U && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W(c2, b2, h2);
        }
      Yj(a, b2, c2);
      break;
    case 21:
      Yj(a, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Yj(a, b2, c2), U = d2) : Yj(a, b2, c2);
      break;
    default:
      Yj(a, b2, c2);
  }
}
function ak(a) {
  var b2 = a.updateQueue;
  if (null !== b2) {
    a.updateQueue = null;
    var c2 = a.stateNode;
    null === c2 && (c2 = a.stateNode = new Kj());
    b2.forEach(function(b3) {
      var d2 = bk.bind(null, a, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function ck(a, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X = h2.stateNode;
                Xj = false;
                break a;
              case 3:
                X = h2.stateNode.containerInfo;
                Xj = true;
                break a;
              case 4:
                X = h2.stateNode.containerInfo;
                Xj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X)
          throw Error(p$1(160));
        Zj(f2, g2, e2);
        X = null;
        Xj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      dk(b2, a), b2 = b2.sibling;
}
function dk(a, b2) {
  var c2 = a.alternate, d2 = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b2, a);
      ek(a);
      if (d2 & 4) {
        try {
          Pj(3, a, a.return), Qj(3, a);
        } catch (t2) {
          W(a, a.return, t2);
        }
        try {
          Pj(5, a, a.return);
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 1:
      ck(b2, a);
      ek(a);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      break;
    case 5:
      ck(b2, a);
      ek(a);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      if (a.flags & 32) {
        var e2 = a.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
        var f2 = a.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W(a, a.return, t2);
          }
      }
      break;
    case 6:
      ck(b2, a);
      ek(a);
      if (d2 & 4) {
        if (null === a.stateNode)
          throw Error(p$1(162));
        e2 = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 3:
      ck(b2, a);
      ek(a);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W(a, a.return, t2);
        }
      break;
    case 4:
      ck(b2, a);
      ek(a);
      break;
    case 13:
      ck(b2, a);
      ek(a);
      e2 = a.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
      d2 & 4 && ak(a);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a.mode & 1 ? (U = (l2 = U) || m2, ck(b2, a), U = l2) : ck(b2, a);
      ek(a);
      if (d2 & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
          for (V = a, m2 = a.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W(a, a.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W(a, a.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      ck(b2, a);
      ek(a);
      d2 & 4 && ak(a);
      break;
    case 21:
      break;
    default:
      ck(
        b2,
        a
      ), ek(a);
  }
}
function ek(a) {
  var b2 = a.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a.return; null !== c2; ) {
          if (Tj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$1(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Uj(a);
          Wj(a, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Uj(a);
          Vj(a, h2, g2);
          break;
        default:
          throw Error(p$1(161));
      }
    } catch (k2) {
      W(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b2 & 4096 && (a.flags &= -4097);
}
function hk(a, b2, c2) {
  V = a;
  ik(a);
}
function ik(a, b2, c2) {
  for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Jj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Jj;
        var l2 = U;
        Jj = g2;
        if ((U = k2) && !l2)
          for (V = e2; null !== V; )
            g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V = k2) : jk(e2);
        for (; null !== f2; )
          V = f2, ik(f2), f2 = f2.sibling;
        V = e2;
        Jj = h2;
        U = l2;
      }
      kk(a);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : kk(a);
  }
}
function kk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && sh(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                sh(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$1(163));
          }
        U || b2.flags & 512 && Rj(b2);
      } catch (r2) {
        W(b2, b2.return, r2);
      }
    }
    if (b2 === a) {
      V = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function gk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a) {
      V = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function jk(a) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Qj(4, b2);
          } catch (k2) {
            W(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, g2, k2);
          }
      }
    } catch (k2) {
      W(b2, b2.return, k2);
    }
    if (b2 === a) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok$2 = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R() {
  return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
}
function yi(a) {
  if (0 === (a.mode & 1))
    return 1;
  if (0 !== (K & 2) && 0 !== Z)
    return Z & -Z;
  if (null !== Kg.transition)
    return 0 === Bk && (Bk = yc()), Bk;
  a = C;
  if (0 !== a)
    return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function gi(a, b2, c2, d2) {
  if (50 < yk)
    throw yk = 0, zk = null, Error(p$1(185));
  Ac(a, c2, d2);
  if (0 === (K & 2) || a !== Q)
    a === Q && (0 === (K & 2) && (qk |= c2), 4 === T && Ck(a, Z)), Dk(a, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
}
function Dk(a, b2) {
  var c2 = a.callbackNode;
  wc(a, b2);
  var d2 = uc(a, a === Q ? Z : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a.callbackNode = null, a.callbackPriority = 0;
  else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
        0 === (K & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Fk(c2, Gk.bind(null, a));
    }
    a.callbackPriority = b2;
    a.callbackNode = c2;
  }
}
function Gk(a, b2) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K & 6))
    throw Error(p$1(327));
  var c2 = a.callbackNode;
  if (Hk() && a.callbackNode !== c2)
    return null;
  var d2 = uc(a, a === Q ? Z : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2)
    b2 = Ik(a, d2);
  else {
    b2 = d2;
    var e2 = K;
    K |= 2;
    var f2 = Jk();
    if (Q !== a || Z !== b2)
      uk = null, Gj = B() + 500, Kk(a, b2);
    do
      try {
        Lk();
        break;
      } catch (h2) {
        Mk(a, h2);
      }
    while (1);
    $g();
    mk.current = f2;
    K = e2;
    null !== Y ? b2 = 0 : (Q = null, Z = 0, b2 = T);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a), 0 !== e2 && (d2 = e2, b2 = Nk(a, e2)));
    if (1 === b2)
      throw c2 = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c2;
    if (6 === b2)
      Ck(a, d2);
    else {
      e2 = a.current.alternate;
      if (0 === (d2 & 30) && !Ok(e2) && (b2 = Ik(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Nk(a, f2))), 1 === b2))
        throw c2 = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c2;
      a.finishedWork = e2;
      a.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$1(345));
        case 2:
          Pk(a, tk, uk);
          break;
        case 3:
          Ck(a, d2);
          if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a, 0))
              break;
            e2 = a.suspendedLanes;
            if ((e2 & d2) !== d2) {
              R();
              a.pingedLanes |= a.suspendedLanes & e2;
              break;
            }
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b2);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 4:
          Ck(a, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
          if (10 < d2) {
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d2);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 5:
          Pk(a, tk, uk);
          break;
        default:
          throw Error(p$1(329));
      }
    }
  }
  Dk(a, B());
  return a.callbackNode === c2 ? Gk.bind(null, a) : null;
}
function Nk(a, b2) {
  var c2 = sk;
  a.current.memoizedState.isDehydrated && (Kk(a, b2).flags |= 256);
  a = Ik(a, b2);
  2 !== a && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
  return a;
}
function Fj(a) {
  null === tk ? tk = a : tk.push.apply(tk, a);
}
function Ok(a) {
  for (var b2 = a; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Ck(a, b2) {
  b2 &= ~rk;
  b2 &= ~qk;
  a.suspendedLanes |= b2;
  a.pingedLanes &= ~b2;
  for (a = a.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a[c2] = -1;
    b2 &= ~d2;
  }
}
function Ek(a) {
  if (0 !== (K & 6))
    throw Error(p$1(327));
  Hk();
  var b2 = uc(a, 0);
  if (0 === (b2 & 1))
    return Dk(a, B()), null;
  var c2 = Ik(a, b2);
  if (0 !== a.tag && 2 === c2) {
    var d2 = xc(a);
    0 !== d2 && (b2 = d2, c2 = Nk(a, d2));
  }
  if (1 === c2)
    throw c2 = pk, Kk(a, 0), Ck(a, b2), Dk(a, B()), c2;
  if (6 === c2)
    throw Error(p$1(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b2;
  Pk(a, tk, uk);
  Dk(a, B());
  return null;
}
function Qk(a, b2) {
  var c2 = K;
  K |= 1;
  try {
    return a(b2);
  } finally {
    K = c2, 0 === K && (Gj = B() + 500, fg && jg());
  }
}
function Rk(a) {
  null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
  var b2 = K;
  K |= 1;
  var c2 = ok$2.transition, d2 = C;
  try {
    if (ok$2.transition = null, C = 1, a)
      return a();
  } finally {
    C = d2, ok$2.transition = c2, K = b2, 0 === (K & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E(ej);
}
function Kk(a, b2) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c2 = a.timeoutHandle;
  -1 !== c2 && (a.timeoutHandle = -1, Gf(c2));
  if (null !== Y)
    for (c2 = Y.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H$2);
          Eh();
          break;
        case 5:
          Bh(d2);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d2.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c2 = c2.return;
    }
  Q = a;
  Y = a = Pg(a.current, null);
  Z = fj = b2;
  T = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b2 = 0; b2 < fh.length; b2++)
      if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    fh = null;
  }
  return a;
}
function Mk(a, b2) {
  do {
    var c2 = Y;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d2 = M.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Ih = false;
      }
      Hh = 0;
      O = N = M = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c2 || null === c2.return) {
        T = 1;
        pk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ui(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Vi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Si(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Si(f2, l2, b2);
              tj();
              break a;
            }
            k2 = Error(p$1(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Ui(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g2, h2, f2, b2);
            Jg(Ji(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ji(k2, h2);
        4 !== T && (T = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Ni(f2, k2, b2);
              ph(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Qi(f2, h2, b2);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c2);
    } catch (na) {
      b2 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a = mk.current;
  mk.current = Rh;
  return null === a ? Rh : a;
}
function tj() {
  if (0 === T || 3 === T || 2 === T)
    T = 4;
  null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
}
function Ik(a, b2) {
  var c2 = K;
  K |= 2;
  var d2 = Jk();
  if (Q !== a || Z !== b2)
    uk = null, Kk(a, b2);
  do
    try {
      Tk();
      break;
    } catch (e2) {
      Mk(a, e2);
    }
  while (1);
  $g();
  K = c2;
  mk.current = d2;
  if (null !== Y)
    throw Error(p$1(261));
  Q = null;
  Z = 0;
  return T;
}
function Tk() {
  for (; null !== Y; )
    Uk(Y);
}
function Lk() {
  for (; null !== Y && !cc(); )
    Uk(Y);
}
function Uk(a) {
  var b2 = Vk(a.alternate, a, fj);
  a.memoizedProps = a.pendingProps;
  null === b2 ? Sk(a) : Y = b2;
  nk.current = null;
}
function Sk(a) {
  var b2 = a;
  do {
    var c2 = b2.alternate;
    a = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Ej(c2, b2, fj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Ij(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a)
        a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a;
  } while (null !== b2);
  0 === T && (T = 5);
}
function Pk(a, b2, c2) {
  var d2 = C, e2 = ok$2.transition;
  try {
    ok$2.transition = null, C = 1, Wk(a, b2, c2, d2);
  } finally {
    ok$2.transition = e2, C = d2;
  }
  return null;
}
function Wk(a, b2, c2, d2) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K & 6))
    throw Error(p$1(327));
  c2 = a.finishedWork;
  var e2 = a.finishedLanes;
  if (null === c2)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c2 === a.current)
    throw Error(p$1(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a, f2);
  a === Q && (Y = Q = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = ok$2.transition;
    ok$2.transition = null;
    var g2 = C;
    C = 1;
    var h2 = K;
    K |= 4;
    nk.current = null;
    Oj(a, c2);
    dk(c2, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c2;
    hk(c2);
    dc();
    K = h2;
    C = g2;
    ok$2.transition = f2;
  } else
    a.current = c2;
  vk && (vk = false, wk = a, xk = e2);
  f2 = a.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c2.stateNode);
  Dk(a, B());
  if (null !== b2)
    for (d2 = a.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Oi)
    throw Oi = false, a = Pi, Pi = null, a;
  0 !== (xk & 1) && 0 !== a.tag && Hk();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a = Dc(xk), b2 = ok$2.transition, c2 = C;
    try {
      ok$2.transition = null;
      C = 16 > a ? 16 : a;
      if (null === wk)
        var d2 = false;
      else {
        a = wk;
        wk = null;
        xk = 0;
        if (0 !== (K & 6))
          throw Error(p$1(331));
        var e2 = K;
        K |= 4;
        for (V = a.current; null !== V; ) {
          var f2 = V, g2 = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V = q2;
                  else
                    for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y2 = m2.return;
                      Sj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V = g2;
          else
            b:
              for (; null !== V; ) {
                f2 = V;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V = x2;
                  break b;
                }
                V = f2.return;
              }
        }
        var w2 = a.current;
        for (V = w2; null !== V; ) {
          g2 = V;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V = u2;
          else
            b:
              for (g2 = w2; null !== V; ) {
                h2 = V;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, h2);
                    }
                  } catch (na) {
                    W(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V = F2;
                  break b;
                }
                V = h2.return;
              }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C = c2, ok$2.transition = b2;
    }
  }
  return false;
}
function Xk(a, b2, c2) {
  b2 = Ji(c2, b2);
  b2 = Ni(a, b2, 1);
  a = nh(a, b2, 1);
  b2 = R();
  null !== a && (Ac(a, 1, b2), Dk(a, b2));
}
function W(a, b2, c2) {
  if (3 === a.tag)
    Xk(a, a, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Xk(b2, a, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
          a = Ji(c2, a);
          a = Qi(b2, a, 1);
          b2 = nh(b2, a, 1);
          a = R();
          null !== b2 && (Ac(b2, 1, a), Dk(b2, a));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ti(a, b2, c2) {
  var d2 = a.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = R();
  a.pingedLanes |= a.suspendedLanes & c2;
  Q === a && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c2);
  Dk(a, b2);
}
function Yk(a, b2) {
  0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = R();
  a = ih(a, b2);
  null !== a && (Ac(a, b2, c2), Dk(a, c2));
}
function uj(a) {
  var b2 = a.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Yk(a, c2);
}
function bk(a, b2) {
  var c2 = 0;
  switch (a.tag) {
    case 13:
      var d2 = a.stateNode;
      var e2 = a.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a.stateNode;
      break;
    default:
      throw Error(p$1(314));
  }
  null !== d2 && d2.delete(b2);
  Yk(a, c2);
}
var Vk;
Vk = function(a, b2, c2) {
  if (null !== a)
    if (a.memoizedProps !== b2.pendingProps || Wf.current)
      dh = true;
    else {
      if (0 === (a.lanes & c2) && 0 === (b2.flags & 128))
        return dh = false, yj(a, b2, c2);
      dh = 0 !== (a.flags & 131072) ? true : false;
    }
  else
    dh = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      ij(a, b2);
      a = b2.pendingProps;
      var e2 = Yf(b2, H$2.current);
      ch(b2, c2);
      e2 = Nh(null, b2, d2, a, e2, c2);
      var f2 = Sh();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei, b2.stateNode = e2, e2._reactInternals = b2, Ii(b2, d2, a, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        ij(a, b2);
        a = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = Zk(d2);
        a = Ci(d2, a);
        switch (e2) {
          case 0:
            b2 = cj(null, b2, d2, a, c2);
            break a;
          case 1:
            b2 = hj(null, b2, d2, a, c2);
            break a;
          case 11:
            b2 = Yi(null, b2, d2, a, c2);
            break a;
          case 14:
            b2 = $i(null, b2, d2, Ci(d2.type, a), c2);
            break a;
        }
        throw Error(p$1(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), cj(a, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), hj(a, b2, d2, e2, c2);
    case 3:
      a: {
        kj(b2);
        if (null === a)
          throw Error(p$1(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        lh(a, b2);
        qh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ji(Error(p$1(423)), b2);
            b2 = lj(a, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ji(Error(p$1(424)), b2);
            b2 = lj(a, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = Zi(a, b2, c2);
            break a;
          }
          Xi(a, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), null === a && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a, b2), Xi(a, b2, g2, c2), b2.child;
    case 6:
      return null === a && Eg(b2), null;
    case 13:
      return oj(a, b2, c2);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Ug(b2, null, d2, c2) : Xi(a, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), Yi(a, b2, d2, e2, c2);
    case 7:
      return Xi(a, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Xi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Xi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G(Wg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = Zi(a, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = mh(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    bh(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$1(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                bh(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Xi(a, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d2 = d2(e2), b2.flags |= 1, Xi(a, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Ci(d2, b2.pendingProps), e2 = Ci(d2.type, e2), $i(a, b2, d2, e2, c2);
    case 15:
      return bj(a, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), ij(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, ch(b2, c2), Gi(b2, d2, e2), Ii(b2, d2, e2, c2), jj(null, b2, d2, true, a, c2);
    case 19:
      return xj(a, b2, c2);
    case 22:
      return dj(a, b2, c2);
  }
  throw Error(p$1(156, b2.tag));
};
function Fk(a, b2) {
  return ac(a, b2);
}
function $k(a, b2, c2, d2) {
  this.tag = a;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b2, c2, d2) {
  return new $k(a, b2, c2, d2);
}
function aj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function Zk(a) {
  if ("function" === typeof a)
    return aj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da)
      return 11;
    if (a === Ga)
      return 14;
  }
  return 2;
}
function Pg(a, b2) {
  var c2 = a.alternate;
  null === c2 ? (c2 = Bg(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a.flags & 14680064;
  c2.childLanes = a.childLanes;
  c2.lanes = a.lanes;
  c2.child = a.child;
  c2.memoizedProps = a.memoizedProps;
  c2.memoizedState = a.memoizedState;
  c2.updateQueue = a.updateQueue;
  b2 = a.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a.sibling;
  c2.index = a.index;
  c2.ref = a.ref;
  return c2;
}
function Rg(a, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a;
  if ("function" === typeof a)
    aj(a) && (g2 = 1);
  else if ("string" === typeof a)
    g2 = 5;
  else
    a:
      switch (a) {
        case ya:
          return Tg(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a = Bg(12, c2, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
        case Ea:
          return a = Bg(13, c2, b2, e2), a.elementType = Ea, a.lanes = f2, a;
        case Fa:
          return a = Bg(19, c2, b2, e2), a.elementType = Fa, a.lanes = f2, a;
        case Ia:
          return pj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a && null !== a)
            switch (a.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$1(130, null == a ? a : typeof a, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Tg(a, b2, c2, d2) {
  a = Bg(7, a, d2, b2);
  a.lanes = c2;
  return a;
}
function pj(a, b2, c2, d2) {
  a = Bg(22, a, d2, b2);
  a.elementType = Ia;
  a.lanes = c2;
  a.stateNode = { isHidden: false };
  return a;
}
function Qg(a, b2, c2) {
  a = Bg(6, a, null, b2);
  a.lanes = c2;
  return a;
}
function Sg(a, b2, c2) {
  b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b2;
}
function al(a, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = new al(a, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a;
}
function cl(a, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
}
function dl(a) {
  if (!a)
    return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag)
      throw Error(p$1(170));
    var b2 = a;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$1(171));
  }
  if (1 === a.tag) {
    var c2 = a.type;
    if (Zf(c2))
      return bg(a, c2, b2);
  }
  return b2;
}
function el(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = bl(c2, d2, true, a, e2, f2, g2, h2, k2);
  a.context = dl(null);
  c2 = a.current;
  d2 = R();
  e2 = yi(c2);
  f2 = mh(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  nh(c2, f2, e2);
  a.current.lanes = e2;
  Ac(a, e2, d2);
  Dk(a, d2);
  return a;
}
function fl(a, b2, c2, d2) {
  var e2 = b2.current, f2 = R(), g2 = yi(e2);
  c2 = dl(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = mh(f2, g2);
  b2.payload = { element: a };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a = nh(e2, b2, g2);
  null !== a && (gi(a, e2, g2, f2), oh(a, e2, g2));
  return g2;
}
function gl(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function hl(a, b2) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c2 = a.retryLane;
    a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function il(a, b2) {
  hl(a, b2);
  (a = a.alternate) && hl(a, b2);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ll(a) {
  this._internalRoot = a;
}
ml.prototype.render = ll.prototype.render = function(a) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$1(409));
  fl(a, b2, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b2 = a.containerInfo;
    Rk(function() {
      fl(null, a, null, null);
    });
    b2[uf] = null;
  }
};
function ml(a) {
  this._internalRoot = a;
}
ml.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b2 = Hc();
    a = { blockedOn: null, target: a, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a);
    0 === c2 && Vc(a);
  }
};
function nl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function pl() {
}
function ql(a, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a2 = gl(g2);
        f2.call(a2);
      };
    }
    var g2 = el(b2, d2, a, 0, null, false, false, "", pl);
    a._reactRootContainer = g2;
    a[uf] = g2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk();
    return g2;
  }
  for (; e2 = a.lastChild; )
    a.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a2 = gl(k2);
      h2.call(a2);
    };
  }
  var k2 = bl(a, 0, false, null, null, false, false, "", pl);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Rk(function() {
    fl(b2, k2, c2, d2);
  });
  return k2;
}
function rl(a, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a2 = gl(g2);
        h2.call(a2);
      };
    }
    fl(b2, g2, a, e2);
  } else
    g2 = ql(c2, b2, a, e2, d2);
  return gl(g2);
}
Ec = function(a) {
  switch (a.tag) {
    case 3:
      var b2 = a.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b3 = ih(a, 1);
        if (null !== b3) {
          var c3 = R();
          gi(b3, a, 1, c3);
        }
      }), il(a, 1);
  }
};
Fc = function(a) {
  if (13 === a.tag) {
    var b2 = ih(a, 134217728);
    if (null !== b2) {
      var c2 = R();
      gi(b2, a, 134217728, c2);
    }
    il(a, 134217728);
  }
};
Gc = function(a) {
  if (13 === a.tag) {
    var b2 = yi(a), c2 = ih(a, b2);
    if (null !== c2) {
      var d2 = R();
      gi(c2, a, b2, d2);
    }
    il(a, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a, b2) {
  var c2 = C;
  try {
    return C = a, b2();
  } finally {
    C = c2;
  }
};
yb = function(a, b2, c2) {
  switch (b2) {
    case "input":
      bb(a, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a && d2.form === a.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$1(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber)
    try {
      kc = vl.inject(ul), lc = vl;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b2))
    throw Error(p$1(200));
  return cl(a, b2, null, c2);
};
reactDom_production_min.createRoot = function(a, b2) {
  if (!nl(a))
    throw Error(p$1(299));
  var c2 = false, d2 = "", e2 = kl;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = bl(a, 1, false, null, null, c2, false, d2, e2);
  a[uf] = b2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ll(b2);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a)
    return null;
  if (1 === a.nodeType)
    return a;
  var b2 = a._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a.render)
      throw Error(p$1(188));
    a = Object.keys(a).join(",");
    throw Error(p$1(268, a));
  }
  a = Zb(b2);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Rk(a);
};
reactDom_production_min.hydrate = function(a, b2, c2) {
  if (!ol(b2))
    throw Error(p$1(200));
  return rl(null, a, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a, b2, c2) {
  if (!nl(a))
    throw Error(p$1(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = el(b2, null, a, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a[uf] = b2.current;
  sf(a);
  if (d2)
    for (a = 0; a < d2.length; a++)
      c2 = d2[a], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new ml(b2);
};
reactDom_production_min.render = function(a, b2, c2) {
  if (!ol(b2))
    throw Error(p$1(200));
  return rl(null, a, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!ol(a))
    throw Error(p$1(40));
  return a._reactRootContainer ? (Rk(function() {
    rl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
  if (!ol(c2))
    throw Error(p$1(200));
  if (null == a || void 0 === a._reactInternals)
    throw Error(p$1(38));
  return rl(a, b2, c2, false, d2);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err2) {
    console.error(err2);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var createRoot;
var m$1 = reactDomExports;
{
  createRoot = m$1.createRoot;
  m$1.hydrateRoot;
}
function _setPrototypeOf(t2, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf(t2, e2);
}
function _inheritsLoose(t2, o) {
  t2.prototype = Object.create(o.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o);
}
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location2, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err2 = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err2.name = "Invariant Violation";
    throw err2;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2)
        ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends.apply(null, arguments);
}
function isAbsolute(pathname) {
  return pathname.charAt(0) === "/";
}
function spliceOne(list, index) {
  for (var i = index, k2 = i + 1, n2 = list.length; k2 < n2; i += 1, k2 += 1) {
    list[i] = list[k2];
  }
  list.pop();
}
function resolvePathname(to, from) {
  if (from === void 0)
    from = "";
  var toParts = to && to.split("/") || [];
  var fromParts = from && from.split("/") || [];
  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;
  if (to && isAbsolute(to)) {
    fromParts = toParts;
  } else if (toParts.length) {
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }
  if (!fromParts.length)
    return "/";
  var hasTrailingSlash;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === "." || last === ".." || last === "";
  } else {
    hasTrailingSlash = false;
  }
  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];
    if (part === ".") {
      spliceOne(fromParts, i);
    } else if (part === "..") {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }
  if (!mustEndAbs)
    for (; up--; up)
      fromParts.unshift("..");
  if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0])))
    fromParts.unshift("");
  var result = fromParts.join("/");
  if (hasTrailingSlash && result.substr(-1) !== "/")
    result += "/";
  return result;
}
function valueOf(obj) {
  return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);
}
function valueEqual(a, b2) {
  if (a === b2)
    return true;
  if (a == null || b2 == null)
    return false;
  if (Array.isArray(a)) {
    return Array.isArray(b2) && a.length === b2.length && a.every(function(item, index) {
      return valueEqual(item, b2[index]);
    });
  }
  if (typeof a === "object" || typeof b2 === "object") {
    var aValue = valueOf(a);
    var bValue = valueOf(b2);
    if (aValue !== a || bValue !== b2)
      return valueEqual(aValue, bValue);
    return Object.keys(Object.assign({}, a, b2)).every(function(key) {
      return valueEqual(a[key], b2[key]);
    });
  }
  return false;
}
var prefix = "Invariant failed";
function invariant(condition, message) {
  {
    throw new Error(prefix);
  }
}
function parsePath$1(path) {
  var pathname = path || "/";
  var search = "";
  var hash = "";
  var hashIndex = pathname.indexOf("#");
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }
  var searchIndex = pathname.indexOf("?");
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }
  return {
    pathname,
    search: search === "?" ? "" : search,
    hash: hash === "#" ? "" : hash
  };
}
function createPath$1(location2) {
  var pathname = location2.pathname, search = location2.search, hash = location2.hash;
  var path = pathname || "/";
  if (search && search !== "?")
    path += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    path += hash.charAt(0) === "#" ? hash : "#" + hash;
  return path;
}
function createLocation(path, state, key, currentLocation) {
  var location2;
  if (typeof path === "string") {
    location2 = parsePath$1(path);
    location2.state = state;
  } else {
    location2 = _extends({}, path);
    if (location2.pathname === void 0)
      location2.pathname = "";
    if (location2.search) {
      if (location2.search.charAt(0) !== "?")
        location2.search = "?" + location2.search;
    } else {
      location2.search = "";
    }
    if (location2.hash) {
      if (location2.hash.charAt(0) !== "#")
        location2.hash = "#" + location2.hash;
    } else {
      location2.hash = "";
    }
    if (state !== void 0 && location2.state === void 0)
      location2.state = state;
  }
  try {
    location2.pathname = decodeURI(location2.pathname);
  } catch (e2) {
    if (e2 instanceof URIError) {
      throw new URIError('Pathname "' + location2.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.');
    } else {
      throw e2;
    }
  }
  if (key)
    location2.key = key;
  if (currentLocation) {
    if (!location2.pathname) {
      location2.pathname = currentLocation.pathname;
    } else if (location2.pathname.charAt(0) !== "/") {
      location2.pathname = resolvePathname(location2.pathname, currentLocation.pathname);
    }
  } else {
    if (!location2.pathname) {
      location2.pathname = "/";
    }
  }
  return location2;
}
function locationsAreEqual(a, b2) {
  return a.pathname === b2.pathname && a.search === b2.search && a.hash === b2.hash && a.key === b2.key && valueEqual(a.state, b2.state);
}
function createTransitionManager() {
  var prompt = null;
  function setPrompt(nextPrompt) {
    prompt = nextPrompt;
    return function() {
      if (prompt === nextPrompt)
        prompt = null;
    };
  }
  function confirmTransitionTo(location2, action, getUserConfirmation, callback) {
    if (prompt != null) {
      var result = typeof prompt === "function" ? prompt(location2, action) : prompt;
      if (typeof result === "string") {
        if (typeof getUserConfirmation === "function") {
          getUserConfirmation(result, callback);
        } else {
          callback(true);
        }
      } else {
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }
  var listeners = [];
  function appendListener(fn) {
    var isActive = true;
    function listener() {
      if (isActive)
        fn.apply(void 0, arguments);
    }
    listeners.push(listener);
    return function() {
      isActive = false;
      listeners = listeners.filter(function(item) {
        return item !== listener;
      });
    };
  }
  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    listeners.forEach(function(listener) {
      return listener.apply(void 0, args);
    });
  }
  return {
    setPrompt,
    confirmTransitionTo,
    appendListener,
    notifyListeners
  };
}
function clamp$1(n2, lowerBound, upperBound) {
  return Math.min(Math.max(n2, lowerBound), upperBound);
}
function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }
  var _props = props, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = _props$initialEntries === void 0 ? ["/"] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends(history2, nextState);
    history2.length = history2.entries.length;
    transitionManager.notifyListeners(history2.location, history2.action);
  }
  function createKey2() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var index = clamp$1(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function(entry) {
    return typeof entry === "string" ? createLocation(entry, void 0, createKey2()) : createLocation(entry, void 0, entry.key || createKey2());
  });
  var createHref = createPath$1;
  function push(path, state) {
    var action = "PUSH";
    var location2 = createLocation(path, state, createKey2(), history2.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var prevIndex = history2.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history2.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location2);
      } else {
        nextEntries.push(location2);
      }
      setState({
        action,
        location: location2,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }
  function replace(path, state) {
    var action = "REPLACE";
    var location2 = createLocation(path, state, createKey2(), history2.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      history2.entries[history2.index] = location2;
      setState({
        action,
        location: location2
      });
    });
  }
  function go(n2) {
    var nextIndex = clamp$1(history2.index + n2, 0, history2.entries.length - 1);
    var action = "POP";
    var location2 = history2.entries[nextIndex];
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (ok2) {
        setState({
          action,
          location: location2,
          index: nextIndex
        });
      } else {
        setState();
      }
    });
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  function canGo(n2) {
    var nextIndex = history2.index + n2;
    return nextIndex >= 0 && nextIndex < history2.entries.length;
  }
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    return transitionManager.setPrompt(prompt);
  }
  function listen(listener) {
    return transitionManager.appendListener(listener);
  }
  var history2 = {
    length: entries.length,
    action: "POP",
    location: entries[index],
    index,
    entries,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    canGo,
    block,
    listen
  };
  return history2;
}
var pathToRegexp$2 = { exports: {} };
var isarray$1 = Array.isArray || function(arr) {
  return Object.prototype.toString.call(arr) == "[object Array]";
};
var isarray = isarray$1;
pathToRegexp$2.exports = pathToRegexp;
pathToRegexp$2.exports.parse = parse;
pathToRegexp$2.exports.compile = compile;
pathToRegexp$2.exports.tokensToFunction = tokensToFunction;
pathToRegexp$2.exports.tokensToRegExp = tokensToRegExp;
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  "(\\\\.)",
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
].join("|"), "g");
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = "";
  var defaultDelimiter = options && options.delimiter || "/";
  var res;
  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m2 = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m2.length;
    if (escaped) {
      path += escaped[1];
      continue;
    }
    var next = str[index];
    var prefix2 = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];
    if (path) {
      tokens.push(path);
      path = "";
    }
    var partial = prefix2 != null && next != null && next !== prefix2;
    var repeat = modifier === "+" || modifier === "*";
    var optional = modifier === "?" || modifier === "*";
    var delimiter = prefix2 || defaultDelimiter;
    var pattern = capture || group;
    var prevText = prefix2 || (typeof tokens[tokens.length - 1] === "string" ? tokens[tokens.length - 1] : "");
    tokens.push({
      name: name || key++,
      prefix: prefix2 || "",
      delimiter,
      optional,
      repeat,
      partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? ".*" : restrictBacktrack(delimiter, prevText)
    });
  }
  if (index < str.length) {
    path += str.substr(index);
  }
  if (path) {
    tokens.push(path);
  }
  return tokens;
}
function restrictBacktrack(delimiter, prevText) {
  if (!prevText || prevText.indexOf(delimiter) > -1) {
    return "[^" + escapeString(delimiter) + "]+?";
  }
  return escapeString(prevText) + "|(?:(?!" + escapeString(prevText) + ")[^" + escapeString(delimiter) + "])+?";
}
function compile(str, options) {
  return tokensToFunction(parse(str, options), options);
}
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function tokensToFunction(tokens, options) {
  var matches2 = new Array(tokens.length);
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === "object") {
      matches2[i] = new RegExp("^(?:" + tokens[i].pattern + ")$", flags(options));
    }
  }
  return function(obj, opts) {
    var path = "";
    var data = obj || {};
    var options2 = opts || {};
    var encode2 = options2.pretty ? encodeURIComponentPretty : encodeURIComponent;
    for (var i2 = 0; i2 < tokens.length; i2++) {
      var token = tokens[i2];
      if (typeof token === "string") {
        path += token;
        continue;
      }
      var value = data[token.name];
      var segment;
      if (value == null) {
        if (token.optional) {
          if (token.partial) {
            path += token.prefix;
          }
          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }
      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + "`");
        }
        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }
        for (var j = 0; j < value.length; j++) {
          segment = encode2(value[j]);
          if (!matches2[i2].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + "`");
          }
          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }
        continue;
      }
      segment = token.asterisk ? encodeAsterisk(value) : encode2(value);
      if (!matches2[i2].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }
      path += token.prefix + segment;
    }
    return path;
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
}
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, "\\$1");
}
function attachKeys(re2, keys) {
  re2.keys = keys;
  return re2;
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path, keys) {
  var groups = path.source.match(/\((?!\?)/g);
  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }
  return attachKeys(path, keys);
}
function arrayToRegexp(path, keys, options) {
  var parts = [];
  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }
  var regexp = new RegExp("(?:" + parts.join("|") + ")", flags(options));
  return attachKeys(regexp, keys);
}
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */
    keys || options;
    keys = [];
  }
  options = options || {};
  var strict = options.strict;
  var end = options.end !== false;
  var route = "";
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    if (typeof token === "string") {
      route += escapeString(token);
    } else {
      var prefix2 = escapeString(token.prefix);
      var capture = "(?:" + token.pattern + ")";
      keys.push(token);
      if (token.repeat) {
        capture += "(?:" + prefix2 + capture + ")*";
      }
      if (token.optional) {
        if (!token.partial) {
          capture = "(?:" + prefix2 + "(" + capture + "))?";
        } else {
          capture = prefix2 + "(" + capture + ")?";
        }
      } else {
        capture = prefix2 + "(" + capture + ")";
      }
      route += capture;
    }
  }
  var delimiter = escapeString(options.delimiter || "/");
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?";
  }
  if (end) {
    route += "$";
  } else {
    route += strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)";
  }
  return attachKeys(new RegExp("^" + route, flags(options)), keys);
}
function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */
    keys || options;
    keys = [];
  }
  options = options || {};
  if (path instanceof RegExp) {
    return regexpToRegexp(
      path,
      /** @type {!Array} */
      keys
    );
  }
  if (isarray(path)) {
    return arrayToRegexp(
      /** @type {!Array} */
      path,
      /** @type {!Array} */
      keys,
      options
    );
  }
  return stringToRegexp(
    /** @type {string} */
    path,
    /** @type {!Array} */
    keys,
    options
  );
}
var pathToRegexpExports = pathToRegexp$2.exports;
const pathToRegexp$1 = /* @__PURE__ */ getDefaultExportFromCjs(pathToRegexpExports);
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h$2 = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
function z(a) {
  if ("object" === typeof a && null !== a) {
    var u2 = a.$$typeof;
    switch (u2) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n:
              case t:
              case r:
              case h$2:
                return a;
              default:
                return u2;
            }
        }
      case d:
        return u2;
    }
  }
}
function A(a) {
  return z(a) === m;
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h$2;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;
reactIs_production_min.isAsyncMode = function(a) {
  return A(a) || z(a) === l;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(a) {
  return z(a) === k;
};
reactIs_production_min.isContextProvider = function(a) {
  return z(a) === h$2;
};
reactIs_production_min.isElement = function(a) {
  return "object" === typeof a && null !== a && a.$$typeof === c;
};
reactIs_production_min.isForwardRef = function(a) {
  return z(a) === n;
};
reactIs_production_min.isFragment = function(a) {
  return z(a) === e;
};
reactIs_production_min.isLazy = function(a) {
  return z(a) === t;
};
reactIs_production_min.isMemo = function(a) {
  return z(a) === r;
};
reactIs_production_min.isPortal = function(a) {
  return z(a) === d;
};
reactIs_production_min.isProfiler = function(a) {
  return z(a) === g;
};
reactIs_production_min.isStrictMode = function(a) {
  return z(a) === f;
};
reactIs_production_min.isSuspense = function(a) {
  return z(a) === p;
};
reactIs_production_min.isValidElementType = function(a) {
  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h$2 || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};
reactIs_production_min.typeOf = z;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
function _objectWithoutPropertiesLoose(r2, e2) {
  if (null == r2)
    return {};
  var t2 = {};
  for (var n2 in r2)
    if ({}.hasOwnProperty.call(r2, n2)) {
      if (e2.includes(n2))
        continue;
      t2[n2] = r2[n2];
    }
  return t2;
}
var reactIs = reactIsExports;
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
function getStatics(component) {
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  }
  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== "string") {
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }
    var keys = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }
    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
        try {
          defineProperty(targetComponent, key, descriptor);
        } catch (e2) {
        }
      }
    }
  }
  return targetComponent;
}
var hoistNonReactStatics_cjs = hoistNonReactStatics;
const hoistStatics = /* @__PURE__ */ getDefaultExportFromCjs(hoistNonReactStatics_cjs);
var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal = typeof globalThis !== "undefined" ? (
  // eslint-disable-next-line no-undef
  globalThis
) : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
function getUniqueId() {
  var key = "__global_unique_id__";
  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
}
function objectIs(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function(h2) {
        return h2 !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function(handler) {
        return handler(value, changedBits);
      });
    }
  };
}
function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}
function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;
  var contextProp = "__create-react-context-" + getUniqueId() + "__";
  var Provider = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(Provider2, _React$Component);
    function Provider2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }
    var _proto = Provider2.prototype;
    _proto.getChildContext = function getChildContext() {
      var _ref;
      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };
    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;
        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
          changedBits |= 0;
          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };
    _proto.render = function render() {
      return this.props.children;
    };
    return Provider2;
  }(React.Component);
  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = PropTypes.object.isRequired, _Provider$childContex);
  var Consumer = /* @__PURE__ */ function(_React$Component2) {
    _inheritsLoose(Consumer2, _React$Component2);
    function Consumer2() {
      var _this2;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      _this2 = _React$Component2.call.apply(_React$Component2, [this].concat(args)) || this;
      _this2.observedBits = void 0;
      _this2.state = {
        value: _this2.getValue()
      };
      _this2.onUpdate = function(newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };
      return _this2;
    }
    var _proto2 = Consumer2.prototype;
    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };
    _proto2.getValue = function getValue2() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };
    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };
    return Consumer2;
  }(React.Component);
  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = PropTypes.object, _Consumer$contextType);
  return {
    Provider,
    Consumer
  };
}
var createContext = React.createContext || createReactContext;
var createNamedContext = function createNamedContext2(name) {
  var context2 = createContext();
  context2.displayName = name;
  return context2;
};
var historyContext = /* @__PURE__ */ createNamedContext("Router-History");
var context = /* @__PURE__ */ createNamedContext("Router");
var Router = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Router2, _React$Component);
  Router2.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };
  function Router2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    };
    _this._isMounted = false;
    _this._pendingLocation = null;
    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function(location2) {
        _this._pendingLocation = location2;
      });
    }
    return _this;
  }
  var _proto = Router2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;
    this._isMounted = true;
    if (this.unlisten) {
      this.unlisten();
    }
    if (!this.props.staticContext) {
      this.unlisten = this.props.history.listen(function(location2) {
        if (_this2._isMounted) {
          _this2.setState({
            location: location2
          });
        }
      });
    }
    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) {
      this.unlisten();
      this._isMounted = false;
      this._pendingLocation = null;
    }
  };
  _proto.render = function render() {
    return /* @__PURE__ */ React.createElement(context.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router2.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, /* @__PURE__ */ React.createElement(historyContext.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };
  return Router2;
}(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(MemoryRouter2, _React$Component);
  function MemoryRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }
  var _proto = MemoryRouter2.prototype;
  _proto.render = function render() {
    return /* @__PURE__ */ React.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return MemoryRouter2;
})(React.Component);
var Lifecycle = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Lifecycle2, _React$Component);
  function Lifecycle2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Lifecycle2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount)
      this.props.onMount.call(this, this);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate)
      this.props.onUpdate.call(this, this, prevProps);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount)
      this.props.onUnmount.call(this, this);
  };
  _proto.render = function render() {
    return null;
  };
  return Lifecycle2;
}(React.Component);
var cache = {};
var cacheLimit = 1e4;
var cacheCount = 0;
function compilePath(path) {
  if (cache[path])
    return cache[path];
  var generator = pathToRegexp$1.compile(path);
  if (cacheCount < cacheLimit) {
    cache[path] = generator;
    cacheCount++;
  }
  return generator;
}
function generatePath(path, params) {
  if (path === void 0) {
    path = "/";
  }
  if (params === void 0) {
    params = {};
  }
  return path === "/" ? path : compilePath(path)(params, {
    pretty: true
  });
}
function Redirect(_ref) {
  var computedMatch = _ref.computedMatch, to = _ref.to, _ref$push = _ref.push, push = _ref$push === void 0 ? false : _ref$push;
  return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context2) {
    !context2 ? invariant() : void 0;
    var history2 = context2.history, staticContext = context2.staticContext;
    var method = push ? history2.push : history2.replace;
    var location2 = createLocation(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : _extends({}, to, {
      pathname: generatePath(to.pathname, computedMatch.params)
    }) : to);
    if (staticContext) {
      method(location2);
      return null;
    }
    return /* @__PURE__ */ React.createElement(Lifecycle, {
      onMount: function onMount() {
        method(location2);
      },
      onUpdate: function onUpdate(self2, prevProps) {
        var prevLocation = createLocation(prevProps.to);
        if (!locationsAreEqual(prevLocation, _extends({}, location2, {
          key: prevLocation.key
        }))) {
          method(location2);
        }
      },
      to
    });
  });
}
var cache$1 = {};
var cacheLimit$1 = 1e4;
var cacheCount$1 = 0;
function compilePath$1(path, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path])
    return pathCache[path];
  var keys = [];
  var regexp = pathToRegexp$1(path, keys, options);
  var result = {
    regexp,
    keys
  };
  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path] = result;
    cacheCount$1++;
  }
  return result;
}
function matchPath$1(pathname, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }
  var _options = options, path = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path);
  return paths.reduce(function(matched, path2) {
    if (!path2 && path2 !== "")
      return null;
    if (matched)
      return matched;
    var _compilePath = compilePath$1(path2, {
      end: exact,
      strict,
      sensitive
    }), regexp = _compilePath.regexp, keys = _compilePath.keys;
    var match = regexp.exec(pathname);
    if (!match)
      return null;
    var url = match[0], values = match.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact)
      return null;
    return {
      path: path2,
      // the path used to match
      url: path2 === "/" && url === "" ? "/" : url,
      // the matched portion of the URL
      isExact,
      // whether or not we matched exactly
      params: keys.reduce(function(memo, key, index) {
        memo[key.name] = values[index];
        return memo;
      }, {})
    };
  }, null);
}
function isEmptyChildren(children) {
  return React.Children.count(children) === 0;
}
var Route = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Route2, _React$Component);
  function Route2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Route2.prototype;
  _proto.render = function render() {
    var _this = this;
    return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context$1) {
      !context$1 ? invariant() : void 0;
      var location2 = _this.props.location || context$1.location;
      var match = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath$1(location2.pathname, _this.props) : context$1.match;
      var props = _extends({}, context$1, {
        location: location2,
        match
      });
      var _this$props = _this.props, children = _this$props.children, component = _this$props.component, render2 = _this$props.render;
      if (Array.isArray(children) && isEmptyChildren(children)) {
        children = null;
      }
      return /* @__PURE__ */ React.createElement(context.Provider, {
        value: props
      }, props.match ? children ? typeof children === "function" ? children(props) : children : component ? /* @__PURE__ */ React.createElement(component, props) : render2 ? render2(props) : null : typeof children === "function" ? children(props) : null);
    });
  };
  return Route2;
}(React.Component);
function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}
function addBasename(basename, location2) {
  if (!basename)
    return location2;
  return _extends({}, location2, {
    pathname: addLeadingSlash(basename) + location2.pathname
  });
}
function stripBasename(basename, location2) {
  if (!basename)
    return location2;
  var base = addLeadingSlash(basename);
  if (location2.pathname.indexOf(base) !== 0)
    return location2;
  return _extends({}, location2, {
    pathname: location2.pathname.substr(base.length)
  });
}
function createURL(location2) {
  return typeof location2 === "string" ? location2 : createPath$1(location2);
}
function staticHandler(methodName) {
  return function() {
    invariant();
  };
}
function noop() {
}
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(StaticRouter2, _React$Component);
  function StaticRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.handlePush = function(location2) {
      return _this.navigateTo(location2, "PUSH");
    };
    _this.handleReplace = function(location2) {
      return _this.navigateTo(location2, "REPLACE");
    };
    _this.handleListen = function() {
      return noop;
    };
    _this.handleBlock = function() {
      return noop;
    };
    return _this;
  }
  var _proto = StaticRouter2.prototype;
  _proto.navigateTo = function navigateTo(location2, action) {
    var _this$props = this.props, _this$props$basename = _this$props.basename, basename = _this$props$basename === void 0 ? "" : _this$props$basename, _this$props$context = _this$props.context, context2 = _this$props$context === void 0 ? {} : _this$props$context;
    context2.action = action;
    context2.location = addBasename(basename, createLocation(location2));
    context2.url = createURL(context2.location);
  };
  _proto.render = function render() {
    var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename = _this$props2$basename === void 0 ? "" : _this$props2$basename, _this$props2$context = _this$props2.context, context2 = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location2 = _this$props2$location === void 0 ? "/" : _this$props2$location, rest = _objectWithoutPropertiesLoose(_this$props2, ["basename", "context", "location"]);
    var history2 = {
      createHref: function createHref(path) {
        return addLeadingSlash(basename + createURL(path));
      },
      action: "POP",
      location: stripBasename(basename, createLocation(location2)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler(),
      goBack: staticHandler(),
      goForward: staticHandler(),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return /* @__PURE__ */ React.createElement(Router, _extends({}, rest, {
      history: history2,
      staticContext: context2
    }));
  };
  return StaticRouter2;
})(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(Switch2, _React$Component);
  function Switch2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Switch2.prototype;
  _proto.render = function render() {
    var _this = this;
    return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context2) {
      !context2 ? invariant() : void 0;
      var location2 = _this.props.location || context2.location;
      var element, match;
      React.Children.forEach(_this.props.children, function(child) {
        if (match == null && /* @__PURE__ */ React.isValidElement(child)) {
          element = child;
          var path = child.props.path || child.props.from;
          match = path ? matchPath$1(location2.pathname, _extends({}, child.props, {
            path
          })) : context2.match;
        }
      });
      return match ? /* @__PURE__ */ React.cloneElement(element, {
        location: location2,
        computedMatch: match
      }) : null;
    });
  };
  return Switch2;
})(React.Component);
function withRouter(Component) {
  var displayName = "withRouter(" + (Component.displayName || Component.name) + ")";
  var C2 = function C22(props) {
    var wrappedComponentRef = props.wrappedComponentRef, remainingProps = _objectWithoutPropertiesLoose(props, ["wrappedComponentRef"]);
    return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context2) {
      !context2 ? invariant() : void 0;
      return /* @__PURE__ */ React.createElement(Component, _extends({}, remainingProps, context2, {
        ref: wrappedComponentRef
      }));
    });
  };
  C2.displayName = displayName;
  C2.WrappedComponent = Component;
  return hoistStatics(C2, Component);
}
React.useContext;
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    promise = Promise.all(deps.map((dep) => {
      dep = assetsURL(dep, importerUrl);
      if (dep in seen)
        return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      const isBaseRelative = !!importerUrl;
      if (isBaseRelative) {
        for (let i = links.length - 1; i >= 0; i--) {
          const link2 = links[i];
          if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
            return;
          }
        }
      } else if (document.querySelector('link[href="'.concat(dep, '"]').concat(cssSelector))) {
        return;
      }
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) {
        link.as = "script";
        link.crossOrigin = "";
      }
      link.href = dep;
      document.head.appendChild(link);
      if (isCss) {
        return new Promise((res, rej) => {
          link.addEventListener("load", res);
          link.addEventListener("error", () => rej(new Error("Unable to preload CSS for ".concat(dep))));
        });
      }
    }));
  }
  return promise.then(() => baseModule()).catch((err2) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err2;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err2;
    }
  });
};
var BUILD$1 = {
  allRenderFn: false,
  cmpDidLoad: true,
  cmpDidUnload: false,
  cmpDidUpdate: true,
  cmpDidRender: true,
  cmpWillLoad: true,
  cmpWillUpdate: true,
  cmpWillRender: true,
  connectedCallback: true,
  disconnectedCallback: true,
  element: true,
  event: true,
  hasRenderFn: true,
  lifecycle: true,
  hostListener: true,
  hostListenerTargetWindow: true,
  hostListenerTargetDocument: true,
  hostListenerTargetBody: true,
  hostListenerTargetParent: false,
  hostListenerTarget: true,
  member: true,
  method: true,
  mode: true,
  observeAttribute: true,
  prop: true,
  propMutable: true,
  reflect: true,
  scoped: true,
  shadowDom: true,
  slot: true,
  cssAnnotations: true,
  state: true,
  style: true,
  formAssociated: false,
  svg: true,
  updatable: true,
  vdomAttribute: true,
  vdomXlink: true,
  vdomClass: true,
  vdomFunctional: true,
  vdomKey: true,
  vdomListener: true,
  vdomRef: true,
  vdomPropOrAttr: true,
  vdomRender: true,
  vdomStyle: true,
  vdomText: true,
  watchCallback: true,
  taskQueue: true,
  hotModuleReplacement: false,
  isDebug: false,
  isDev: false,
  isTesting: false,
  hydrateServerSide: false,
  hydrateClientSide: false,
  lifecycleDOMEvents: false,
  lazyLoad: false,
  profile: false,
  slotRelocation: true,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: false,
  hydratedAttribute: false,
  hydratedClass: true,
  // TODO(STENCIL-1305): remove this option
  scriptDataOpts: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: false,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: false,
  invisiblePrehydration: true,
  propBoolean: true,
  propNumber: true,
  propString: true,
  constructableCSS: true,
  cmpShouldUpdate: true,
  devTools: false,
  shadowDelegatesFocus: true,
  initializeNextTick: false,
  asyncLoading: false,
  asyncQueue: false,
  transformTagName: false,
  attachStyles: true,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: false
};
var __defProp$1 = Object.defineProperty;
var __export$1 = (target, all) => {
  for (var name in all)
    __defProp$1(target, name, { get: all[name], enumerable: true });
};
var Build = {
  isDev: false,
  isBrowser: true,
  isServer: false,
  isTesting: false
};
var hostRefs$1 = /* @__PURE__ */ new WeakMap();
var getHostRef$1 = (ref) => hostRefs$1.get(ref);
var registerHost$1 = (hostElement, cmpMeta) => {
  const hostRef = {
    $flags$: 0,
    $hostElement$: hostElement,
    $cmpMeta$: cmpMeta,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  return hostRefs$1.set(hostElement, hostRef);
};
var isMemberInElement$1 = (elm, memberName) => memberName in elm;
var consoleError$1 = (e2, el2) => (0, console.error)(e2, el2);
var styles$1 = /* @__PURE__ */ new Map();
var modeResolutionChain$1 = [];
var SLOT_FB_CSS$1 = "slot-fb{display:contents}slot-fb[hidden]{display:none}";
var XLINK_NS$1 = "http://www.w3.org/1999/xlink";
var win$3 = typeof window !== "undefined" ? window : {};
var doc$2 = win$3.document || { head: {} };
var H$1 = win$3.HTMLElement || class {
};
var plt$1 = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (h2) => h2(),
  raf: (h2) => requestAnimationFrame(h2),
  ael: (el2, eventName, listener, opts) => el2.addEventListener(eventName, listener, opts),
  rel: (el2, eventName, listener, opts) => el2.removeEventListener(eventName, listener, opts),
  ce: (eventName, opts) => new CustomEvent(eventName, opts)
};
var setPlatformHelpers = (helpers) => {
  Object.assign(plt$1, helpers);
};
var supportsListenerOptions$1 = /* @__PURE__ */ (() => {
  let supportsListenerOptions2 = false;
  try {
    doc$2.addEventListener(
      "e",
      null,
      Object.defineProperty({}, "passive", {
        get() {
          supportsListenerOptions2 = true;
        }
      })
    );
  } catch (e2) {
  }
  return supportsListenerOptions2;
})();
var promiseResolve$1 = (v2) => Promise.resolve(v2);
var supportsConstructableStylesheets$1 = /* @__PURE__ */ (() => {
  try {
    new CSSStyleSheet();
    return typeof new CSSStyleSheet().replaceSync === "function";
  } catch (e2) {
  }
  return false;
})();
var queuePending$1 = false;
var queueDomReads$1 = [];
var queueDomWrites$1 = [];
var queueTask$1 = (queue, write) => (cb2) => {
  queue.push(cb2);
  if (!queuePending$1) {
    queuePending$1 = true;
    if (write && plt$1.$flags$ & 4) {
      nextTick$1(flush$1);
    } else {
      plt$1.raf(flush$1);
    }
  }
};
var consume$1 = (queue) => {
  for (let i2 = 0; i2 < queue.length; i2++) {
    try {
      queue[i2](performance.now());
    } catch (e2) {
      consoleError$1(e2);
    }
  }
  queue.length = 0;
};
var flush$1 = () => {
  consume$1(queueDomReads$1);
  {
    consume$1(queueDomWrites$1);
    if (queuePending$1 = queueDomReads$1.length > 0) {
      plt$1.raf(flush$1);
    }
  }
};
var nextTick$1 = (cb2) => promiseResolve$1().then(cb2);
var readTask = /* @__PURE__ */ queueTask$1(queueDomReads$1, false);
var writeTask$1 = /* @__PURE__ */ queueTask$1(queueDomWrites$1, true);
var getAssetPath$1 = (path) => {
  const assetUrl = new URL(path, plt$1.$resourcesUrl$);
  return assetUrl.origin !== win$3.location.origin ? assetUrl.href : assetUrl.pathname;
};
var EMPTY_OBJ$1 = {};
var SVG_NS$1 = "http://www.w3.org/2000/svg";
var HTML_NS$1 = "http://www.w3.org/1999/xhtml";
var isDef$1 = (v2) => v2 != null;
var isComplexType$1 = (o) => {
  o = typeof o;
  return o === "object" || o === "function";
};
function queryNonceMetaTagContent$1(doc2) {
  var _a, _b, _c;
  return (_c = (_b = (_a = doc2.head) == null ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) == null ? void 0 : _b.getAttribute("content")) != null ? _c : void 0;
}
var result_exports$1 = {};
__export$1(result_exports$1, {
  err: () => err$1,
  map: () => map$1,
  ok: () => ok$1,
  unwrap: () => unwrap$1,
  unwrapErr: () => unwrapErr$1
});
var ok$1 = (value) => ({
  isOk: true,
  isErr: false,
  value
});
var err$1 = (value) => ({
  isOk: false,
  isErr: true,
  value
});
function map$1(result, fn) {
  if (result.isOk) {
    const val = fn(result.value);
    if (val instanceof Promise) {
      return val.then((newVal) => ok$1(newVal));
    } else {
      return ok$1(val);
    }
  }
  if (result.isErr) {
    const value = result.value;
    return err$1(value);
  }
  throw "should never get here";
}
var unwrap$1 = (result) => {
  if (result.isOk) {
    return result.value;
  } else {
    throw result.value;
  }
};
var unwrapErr$1 = (result) => {
  if (result.isErr) {
    return result.value;
  } else {
    throw result.value;
  }
};
var createTime$1 = (fnName, tagName = "") => {
  {
    return () => {
      return;
    };
  }
};
var h$1 = (nodeName, vnodeData, ...children) => {
  let child = null;
  let key = null;
  let slotName = null;
  let simple = false;
  let lastSimple = false;
  const vNodeChildren = [];
  const walk = (c2) => {
    for (let i2 = 0; i2 < c2.length; i2++) {
      child = c2[i2];
      if (Array.isArray(child)) {
        walk(child);
      } else if (child != null && typeof child !== "boolean") {
        if (simple = typeof nodeName !== "function" && !isComplexType$1(child)) {
          child = String(child);
        }
        if (simple && lastSimple) {
          vNodeChildren[vNodeChildren.length - 1].$text$ += child;
        } else {
          vNodeChildren.push(simple ? newVNode$1(null, child) : child);
        }
        lastSimple = simple;
      }
    }
  };
  walk(children);
  if (vnodeData) {
    if (vnodeData.key) {
      key = vnodeData.key;
    }
    if (vnodeData.name) {
      slotName = vnodeData.name;
    }
    {
      const classData = vnodeData.className || vnodeData.class;
      if (classData) {
        vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k2) => classData[k2]).join(" ");
      }
    }
  }
  if (typeof nodeName === "function") {
    return nodeName(
      vnodeData === null ? {} : vnodeData,
      vNodeChildren,
      vdomFnUtils$1
    );
  }
  const vnode = newVNode$1(nodeName, null);
  vnode.$attrs$ = vnodeData;
  if (vNodeChildren.length > 0) {
    vnode.$children$ = vNodeChildren;
  }
  {
    vnode.$key$ = key;
  }
  {
    vnode.$name$ = slotName;
  }
  return vnode;
};
var newVNode$1 = (tag, text) => {
  const vnode = {
    $flags$: 0,
    $tag$: tag,
    $text$: text,
    $elm$: null,
    $children$: null
  };
  {
    vnode.$attrs$ = null;
  }
  {
    vnode.$key$ = null;
  }
  {
    vnode.$name$ = null;
  }
  return vnode;
};
var Host$1 = {};
var isHost$1 = (node) => node && node.$tag$ === Host$1;
var vdomFnUtils$1 = {
  forEach: (children, cb2) => children.map(convertToPublic$1).forEach(cb2),
  map: (children, cb2) => children.map(convertToPublic$1).map(cb2).map(convertToPrivate$1)
};
var convertToPublic$1 = (node) => ({
  vattrs: node.$attrs$,
  vchildren: node.$children$,
  vkey: node.$key$,
  vname: node.$name$,
  vtag: node.$tag$,
  vtext: node.$text$
});
var convertToPrivate$1 = (node) => {
  if (typeof node.vtag === "function") {
    const vnodeData = { ...node.vattrs };
    if (node.vkey) {
      vnodeData.key = node.vkey;
    }
    if (node.vname) {
      vnodeData.name = node.vname;
    }
    return h$1(node.vtag, vnodeData, ...node.vchildren || []);
  }
  const vnode = newVNode$1(node.vtag, node.vtext);
  vnode.$attrs$ = node.vattrs;
  vnode.$children$ = node.vchildren;
  vnode.$key$ = node.vkey;
  vnode.$name$ = node.vname;
  return vnode;
};
var computeMode$1 = (elm) => modeResolutionChain$1.map((h2) => h2(elm)).find((m2) => !!m2);
var setMode = (handler) => modeResolutionChain$1.push(handler);
var getMode = (ref) => getHostRef$1(ref).$modeName$;
var parsePropertyValue$1 = (propValue, propType) => {
  if (propValue != null && !isComplexType$1(propValue)) {
    if (propType & 4) {
      return propValue === "false" ? false : propValue === "" || !!propValue;
    }
    if (propType & 2) {
      return parseFloat(propValue);
    }
    if (propType & 1) {
      return String(propValue);
    }
    return propValue;
  }
  return propValue;
};
var getElement = (ref) => ref;
var createEvent = (ref, name, flags2) => {
  const elm = getElement(ref);
  return {
    emit: (detail) => {
      return emitEvent$1(elm, name, {
        bubbles: !!(flags2 & 4),
        composed: !!(flags2 & 2),
        cancelable: !!(flags2 & 1),
        detail
      });
    }
  };
};
var emitEvent$1 = (elm, name, opts) => {
  const ev = plt$1.ce(name, opts);
  elm.dispatchEvent(ev);
  return ev;
};
var rootAppliedStyles$1 = /* @__PURE__ */ new WeakMap();
var registerStyle$1 = (scopeId2, cssText, allowCS) => {
  let style = styles$1.get(scopeId2);
  if (supportsConstructableStylesheets$1 && allowCS) {
    style = style || new CSSStyleSheet();
    if (typeof style === "string") {
      style = cssText;
    } else {
      style.replaceSync(cssText);
    }
  } else {
    style = cssText;
  }
  styles$1.set(scopeId2, style);
};
var addStyle$1 = (styleContainerNode, cmpMeta, mode) => {
  var _a;
  const scopeId2 = getScopeId$1(cmpMeta, mode);
  const style = styles$1.get(scopeId2);
  styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : doc$2;
  if (style) {
    if (typeof style === "string") {
      styleContainerNode = styleContainerNode.head || styleContainerNode;
      let appliedStyles = rootAppliedStyles$1.get(styleContainerNode);
      let styleElm;
      if (!appliedStyles) {
        rootAppliedStyles$1.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
      }
      if (!appliedStyles.has(scopeId2)) {
        {
          styleElm = doc$2.createElement("style");
          styleElm.innerHTML = style;
          const nonce = (_a = plt$1.$nonce$) != null ? _a : queryNonceMetaTagContent$1(doc$2);
          if (nonce != null) {
            styleElm.setAttribute("nonce", nonce);
          }
          const injectStyle = (
            /**
             * we render a scoped component
             */
            !(cmpMeta.$flags$ & 1) || /**
            * we are using shadow dom and render the style tag within the shadowRoot
            */
            cmpMeta.$flags$ & 1 && styleContainerNode.nodeName !== "HEAD"
          );
          if (injectStyle) {
            styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector("link"));
          }
        }
        if (cmpMeta.$flags$ & 4) {
          styleElm.innerHTML += SLOT_FB_CSS$1;
        }
        if (appliedStyles) {
          appliedStyles.add(scopeId2);
        }
      }
    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
      styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
    }
  }
  return scopeId2;
};
var attachStyles$1 = (hostRef) => {
  const cmpMeta = hostRef.$cmpMeta$;
  const elm = hostRef.$hostElement$;
  const flags2 = cmpMeta.$flags$;
  const endAttachStyles = createTime$1("attachStyles", cmpMeta.$tagName$);
  const scopeId2 = addStyle$1(
    elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(),
    cmpMeta,
    hostRef.$modeName$
  );
  if (flags2 & 10 && flags2 & 2) {
    elm["s-sc"] = scopeId2;
    elm.classList.add(scopeId2 + "-h");
    if (flags2 & 2) {
      elm.classList.add(scopeId2 + "-s");
    }
  }
  endAttachStyles();
};
var getScopeId$1 = (cmp, mode) => "sc-" + (mode && cmp.$flags$ & 32 ? cmp.$tagName$ + "-" + mode : cmp.$tagName$);
var setAccessor$1 = (elm, memberName, oldValue, newValue, isSvg, flags2) => {
  if (oldValue !== newValue) {
    let isProp = isMemberInElement$1(elm, memberName);
    let ln = memberName.toLowerCase();
    if (memberName === "class") {
      const classList = elm.classList;
      const oldClasses = parseClassList$1(oldValue);
      const newClasses = parseClassList$1(newValue);
      classList.remove(...oldClasses.filter((c2) => c2 && !newClasses.includes(c2)));
      classList.add(...newClasses.filter((c2) => c2 && !oldClasses.includes(c2)));
    } else if (memberName === "style") {
      {
        for (const prop in oldValue) {
          if (!newValue || newValue[prop] == null) {
            if (prop.includes("-")) {
              elm.style.removeProperty(prop);
            } else {
              elm.style[prop] = "";
            }
          }
        }
      }
      for (const prop in newValue) {
        if (!oldValue || newValue[prop] !== oldValue[prop]) {
          if (prop.includes("-")) {
            elm.style.setProperty(prop, newValue[prop]);
          } else {
            elm.style[prop] = newValue[prop];
          }
        }
      }
    } else if (memberName === "key")
      ;
    else if (memberName === "ref") {
      if (newValue) {
        newValue(elm);
      }
    } else if (!elm.__lookupSetter__(memberName) && memberName[0] === "o" && memberName[1] === "n") {
      if (memberName[2] === "-") {
        memberName = memberName.slice(3);
      } else if (isMemberInElement$1(win$3, ln)) {
        memberName = ln.slice(2);
      } else {
        memberName = ln[2] + memberName.slice(3);
      }
      if (oldValue || newValue) {
        const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX$1);
        memberName = memberName.replace(CAPTURE_EVENT_REGEX$1, "");
        if (oldValue) {
          plt$1.rel(elm, memberName, oldValue, capture);
        }
        if (newValue) {
          plt$1.ael(elm, memberName, newValue, capture);
        }
      }
    } else {
      const isComplex = isComplexType$1(newValue);
      if ((isProp || isComplex && newValue !== null) && !isSvg) {
        try {
          if (!elm.tagName.includes("-")) {
            const n2 = newValue == null ? "" : newValue;
            if (memberName === "list") {
              isProp = false;
            } else if (oldValue == null || elm[memberName] != n2) {
              elm[memberName] = n2;
            }
          } else {
            elm[memberName] = newValue;
          }
        } catch (e2) {
        }
      }
      let xlink = false;
      {
        if (ln !== (ln = ln.replace(/^xlink\:?/, ""))) {
          memberName = ln;
          xlink = true;
        }
      }
      if (newValue == null || newValue === false) {
        if (newValue !== false || elm.getAttribute(memberName) === "") {
          if (xlink) {
            elm.removeAttributeNS(XLINK_NS$1, memberName);
          } else {
            elm.removeAttribute(memberName);
          }
        }
      } else if ((!isProp || flags2 & 4 || isSvg) && !isComplex) {
        newValue = newValue === true ? "" : newValue;
        if (xlink) {
          elm.setAttributeNS(XLINK_NS$1, memberName, newValue);
        } else {
          elm.setAttribute(memberName, newValue);
        }
      }
    }
  }
};
var parseClassListRegex$1 = /\s/;
var parseClassList$1 = (value) => !value ? [] : value.split(parseClassListRegex$1);
var CAPTURE_EVENT_SUFFIX$1 = "Capture";
var CAPTURE_EVENT_REGEX$1 = new RegExp(CAPTURE_EVENT_SUFFIX$1 + "$");
var updateElement$1 = (oldVnode, newVnode, isSvgMode2) => {
  const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ$1;
  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ$1;
  {
    for (const memberName of sortedAttrNames$1(Object.keys(oldVnodeAttrs))) {
      if (!(memberName in newVnodeAttrs)) {
        setAccessor$1(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
      }
    }
  }
  for (const memberName of sortedAttrNames$1(Object.keys(newVnodeAttrs))) {
    setAccessor$1(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
  }
};
function sortedAttrNames$1(attrNames) {
  return attrNames.includes("ref") ? (
    // we need to sort these to ensure that `'ref'` is the last attr
    [...attrNames.filter((attr) => attr !== "ref"), "ref"]
  ) : (
    // no need to sort, return the original array
    attrNames
  );
}
var scopeId$1;
var contentRef$1;
var hostTagName$1;
var useNativeShadowDom$1 = false;
var checkSlotFallbackVisibility$1 = false;
var checkSlotRelocate$1 = false;
var isSvgMode$1 = false;
var createElm$1 = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
  var _a;
  const newVNode2 = newParentVNode.$children$[childIndex];
  let i2 = 0;
  let elm;
  let childNode;
  let oldVNode;
  if (!useNativeShadowDom$1) {
    checkSlotRelocate$1 = true;
    if (newVNode2.$tag$ === "slot") {
      if (scopeId$1) {
        parentElm.classList.add(scopeId$1 + "-s");
      }
      newVNode2.$flags$ |= newVNode2.$children$ ? (
        // slot element has fallback content
        // still create an element that "mocks" the slot element
        2
      ) : (
        // slot element does not have fallback content
        // create an html comment we'll use to always reference
        // where actual slot content should sit next to
        1
      );
    }
  }
  if (newVNode2.$text$ !== null) {
    elm = newVNode2.$elm$ = doc$2.createTextNode(newVNode2.$text$);
  } else if (newVNode2.$flags$ & 1) {
    elm = newVNode2.$elm$ = doc$2.createTextNode("");
  } else {
    if (!isSvgMode$1) {
      isSvgMode$1 = newVNode2.$tag$ === "svg";
    }
    elm = newVNode2.$elm$ = doc$2.createElementNS(
      isSvgMode$1 ? SVG_NS$1 : HTML_NS$1,
      !useNativeShadowDom$1 && BUILD$1.slotRelocation && newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$
    );
    if (isSvgMode$1 && newVNode2.$tag$ === "foreignObject") {
      isSvgMode$1 = false;
    }
    {
      updateElement$1(null, newVNode2, isSvgMode$1);
    }
    const rootNode = elm.getRootNode();
    const isElementWithinShadowRoot = !rootNode.querySelector("body");
    if (!isElementWithinShadowRoot && BUILD$1.scoped && isDef$1(scopeId$1) && elm["s-si"] !== scopeId$1) {
      elm.classList.add(elm["s-si"] = scopeId$1);
    }
    {
      updateElementScopeIds$1(elm, parentElm);
    }
    if (newVNode2.$children$) {
      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {
        childNode = createElm$1(oldParentVNode, newVNode2, i2, elm);
        if (childNode) {
          elm.appendChild(childNode);
        }
      }
    }
    {
      if (newVNode2.$tag$ === "svg") {
        isSvgMode$1 = false;
      } else if (elm.tagName === "foreignObject") {
        isSvgMode$1 = true;
      }
    }
  }
  elm["s-hn"] = hostTagName$1;
  {
    if (newVNode2.$flags$ & (2 | 1)) {
      elm["s-sr"] = true;
      elm["s-cr"] = contentRef$1;
      elm["s-sn"] = newVNode2.$name$ || "";
      elm["s-rf"] = (_a = newVNode2.$attrs$) == null ? void 0 : _a.ref;
      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
      if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
        {
          putBackInOriginalLocation$1(oldParentVNode.$elm$, false);
        }
      }
    }
  }
  return elm;
};
var putBackInOriginalLocation$1 = (parentElm, recursive) => {
  plt$1.$flags$ |= 1;
  const oldSlotChildNodes = Array.from(parentElm.childNodes);
  if (parentElm["s-sr"] && BUILD$1.experimentalSlotFixes) {
    let node = parentElm;
    while (node = node.nextSibling) {
      if (node && node["s-sn"] === parentElm["s-sn"] && node["s-sh"] === hostTagName$1) {
        oldSlotChildNodes.push(node);
      }
    }
  }
  for (let i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--) {
    const childNode = oldSlotChildNodes[i2];
    if (childNode["s-hn"] !== hostTagName$1 && childNode["s-ol"]) {
      insertBefore$1(parentReferenceNode$1(childNode), childNode, referenceNode$1(childNode));
      childNode["s-ol"].remove();
      childNode["s-ol"] = void 0;
      childNode["s-sh"] = void 0;
      checkSlotRelocate$1 = true;
    }
    if (recursive) {
      putBackInOriginalLocation$1(childNode, recursive);
    }
  }
  plt$1.$flags$ &= ~1;
};
var addVnodes$1 = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
  let containerElm = parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
  let childNode;
  if (containerElm.shadowRoot && containerElm.tagName === hostTagName$1) {
    containerElm = containerElm.shadowRoot;
  }
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnodes[startIdx]) {
      childNode = createElm$1(null, parentVNode, startIdx, parentElm);
      if (childNode) {
        vnodes[startIdx].$elm$ = childNode;
        insertBefore$1(containerElm, childNode, referenceNode$1(before));
      }
    }
  }
};
var removeVnodes$1 = (vnodes, startIdx, endIdx) => {
  for (let index = startIdx; index <= endIdx; ++index) {
    const vnode = vnodes[index];
    if (vnode) {
      const elm = vnode.$elm$;
      nullifyVNodeRefs$1(vnode);
      if (elm) {
        {
          checkSlotFallbackVisibility$1 = true;
          if (elm["s-ol"]) {
            elm["s-ol"].remove();
          } else {
            putBackInOriginalLocation$1(elm, true);
          }
        }
        elm.remove();
      }
    }
  }
};
var updateChildren$1 = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let idxInOld = 0;
  let i2 = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let node;
  let elmToMove;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode$1(oldStartVnode, newStartVnode, isInitialRender)) {
      patch$1(oldStartVnode, newStartVnode, isInitialRender);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (isSameVnode$1(oldEndVnode, newEndVnode, isInitialRender)) {
      patch$1(oldEndVnode, newEndVnode, isInitialRender);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode$1(oldStartVnode, newEndVnode, isInitialRender)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation$1(oldStartVnode.$elm$.parentNode, false);
      }
      patch$1(oldStartVnode, newEndVnode, isInitialRender);
      insertBefore$1(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode$1(oldEndVnode, newStartVnode, isInitialRender)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation$1(oldEndVnode.$elm$.parentNode, false);
      }
      patch$1(oldEndVnode, newStartVnode, isInitialRender);
      insertBefore$1(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      idxInOld = -1;
      {
        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {
          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {
            idxInOld = i2;
            break;
          }
        }
      }
      if (idxInOld >= 0) {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.$tag$ !== newStartVnode.$tag$) {
          node = createElm$1(oldCh && oldCh[newStartIdx], newVNode2, idxInOld, parentElm);
        } else {
          patch$1(elmToMove, newStartVnode, isInitialRender);
          oldCh[idxInOld] = void 0;
          node = elmToMove.$elm$;
        }
        newStartVnode = newCh[++newStartIdx];
      } else {
        node = createElm$1(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);
        newStartVnode = newCh[++newStartIdx];
      }
      if (node) {
        {
          insertBefore$1(parentReferenceNode$1(oldStartVnode.$elm$), node, referenceNode$1(oldStartVnode.$elm$));
        }
      }
    }
  }
  if (oldStartIdx > oldEndIdx) {
    addVnodes$1(
      parentElm,
      newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$,
      newVNode2,
      newCh,
      newStartIdx,
      newEndIdx
    );
  } else if (newStartIdx > newEndIdx) {
    removeVnodes$1(oldCh, oldStartIdx, oldEndIdx);
  }
};
var isSameVnode$1 = (leftVNode, rightVNode, isInitialRender = false) => {
  if (leftVNode.$tag$ === rightVNode.$tag$) {
    if (leftVNode.$tag$ === "slot") {
      if (
        // The component gets hydrated and no VDOM has been initialized.
        // Here the comparison can't happen as $name$ property is not set for `leftNode`.
        "$nodeId$" in leftVNode && isInitialRender && // `leftNode` is not from type HTMLComment which would cause many
        // hydration comments to be removed
        leftVNode.$elm$.nodeType !== 8
      ) {
        return false;
      }
      return leftVNode.$name$ === rightVNode.$name$;
    }
    if (!isInitialRender) {
      return leftVNode.$key$ === rightVNode.$key$;
    }
    return true;
  }
  return false;
};
var referenceNode$1 = (node) => {
  return node && node["s-ol"] || node;
};
var parentReferenceNode$1 = (node) => (node["s-ol"] ? node["s-ol"] : node).parentNode;
var patch$1 = (oldVNode, newVNode2, isInitialRender = false) => {
  const elm = newVNode2.$elm$ = oldVNode.$elm$;
  const oldChildren = oldVNode.$children$;
  const newChildren = newVNode2.$children$;
  const tag = newVNode2.$tag$;
  const text = newVNode2.$text$;
  let defaultHolder;
  if (text === null) {
    {
      isSvgMode$1 = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode$1;
    }
    {
      if (tag === "slot" && !useNativeShadowDom$1)
        ;
      else {
        updateElement$1(oldVNode, newVNode2, isSvgMode$1);
      }
    }
    if (oldChildren !== null && newChildren !== null) {
      updateChildren$1(elm, oldChildren, newVNode2, newChildren, isInitialRender);
    } else if (newChildren !== null) {
      if (oldVNode.$text$ !== null) {
        elm.textContent = "";
      }
      addVnodes$1(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
    } else if (
      // don't do this on initial render as it can cause non-hydrated content to be removed
      !isInitialRender && BUILD$1.updatable && oldChildren !== null
    ) {
      removeVnodes$1(oldChildren, 0, oldChildren.length - 1);
    }
    if (isSvgMode$1 && tag === "svg") {
      isSvgMode$1 = false;
    }
  } else if (defaultHolder = elm["s-cr"]) {
    defaultHolder.parentNode.textContent = text;
  } else if (oldVNode.$text$ !== text) {
    elm.data = text;
  }
};
var updateFallbackSlotVisibility$1 = (elm) => {
  const childNodes = elm.childNodes;
  for (const childNode of childNodes) {
    if (childNode.nodeType === 1) {
      if (childNode["s-sr"]) {
        const slotName = childNode["s-sn"];
        childNode.hidden = false;
        for (const siblingNode of childNodes) {
          if (siblingNode !== childNode) {
            if (siblingNode["s-hn"] !== childNode["s-hn"] || slotName !== "") {
              if (siblingNode.nodeType === 1 && (slotName === siblingNode.getAttribute("slot") || slotName === siblingNode["s-sn"]) || siblingNode.nodeType === 3 && slotName === siblingNode["s-sn"]) {
                childNode.hidden = true;
                break;
              }
            } else {
              if (siblingNode.nodeType === 1 || siblingNode.nodeType === 3 && siblingNode.textContent.trim() !== "") {
                childNode.hidden = true;
                break;
              }
            }
          }
        }
      }
      updateFallbackSlotVisibility$1(childNode);
    }
  }
};
var relocateNodes$1 = [];
var markSlotContentForRelocation$1 = (elm) => {
  let node;
  let hostContentNodes;
  let j;
  for (const childNode of elm.childNodes) {
    if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
      hostContentNodes = node.parentNode.childNodes;
      const slotName = childNode["s-sn"];
      for (j = hostContentNodes.length - 1; j >= 0; j--) {
        node = hostContentNodes[j];
        if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"] && !BUILD$1.experimentalSlotFixes) {
          if (isNodeLocatedInSlot$1(node, slotName)) {
            let relocateNodeData = relocateNodes$1.find((r2) => r2.$nodeToRelocate$ === node);
            checkSlotFallbackVisibility$1 = true;
            node["s-sn"] = node["s-sn"] || slotName;
            if (relocateNodeData) {
              relocateNodeData.$nodeToRelocate$["s-sh"] = childNode["s-hn"];
              relocateNodeData.$slotRefNode$ = childNode;
            } else {
              node["s-sh"] = childNode["s-hn"];
              relocateNodes$1.push({
                $slotRefNode$: childNode,
                $nodeToRelocate$: node
              });
            }
            if (node["s-sr"]) {
              relocateNodes$1.map((relocateNode) => {
                if (isNodeLocatedInSlot$1(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                  relocateNodeData = relocateNodes$1.find((r2) => r2.$nodeToRelocate$ === node);
                  if (relocateNodeData && !relocateNode.$slotRefNode$) {
                    relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                  }
                }
              });
            }
          } else if (!relocateNodes$1.some((r2) => r2.$nodeToRelocate$ === node)) {
            relocateNodes$1.push({
              $nodeToRelocate$: node
            });
          }
        }
      }
    }
    if (childNode.nodeType === 1) {
      markSlotContentForRelocation$1(childNode);
    }
  }
};
var isNodeLocatedInSlot$1 = (nodeToRelocate, slotName) => {
  if (nodeToRelocate.nodeType === 1) {
    if (nodeToRelocate.getAttribute("slot") === null && slotName === "") {
      return true;
    }
    if (nodeToRelocate.getAttribute("slot") === slotName) {
      return true;
    }
    return false;
  }
  if (nodeToRelocate["s-sn"] === slotName) {
    return true;
  }
  return slotName === "";
};
var nullifyVNodeRefs$1 = (vNode) => {
  {
    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs$1);
  }
};
var insertBefore$1 = (parent2, newNode, reference) => {
  const inserted = parent2 == null ? void 0 : parent2.insertBefore(newNode, reference);
  {
    updateElementScopeIds$1(newNode, parent2);
  }
  return inserted;
};
var findScopeIds$1 = (element) => {
  const scopeIds = [];
  if (element) {
    scopeIds.push(
      ...element["s-scs"] || [],
      element["s-si"],
      element["s-sc"],
      ...findScopeIds$1(element.parentElement)
    );
  }
  return scopeIds;
};
var updateElementScopeIds$1 = (element, parent2, iterateChildNodes = false) => {
  var _a;
  if (element && parent2 && element.nodeType === 1) {
    const scopeIds = new Set(findScopeIds$1(parent2).filter(Boolean));
    if (scopeIds.size) {
      (_a = element.classList) == null ? void 0 : _a.add(...element["s-scs"] = [...scopeIds]);
      if (element["s-ol"] || iterateChildNodes) {
        for (const childNode of Array.from(element.childNodes)) {
          updateElementScopeIds$1(childNode, element, true);
        }
      }
    }
  }
};
var renderVdom$1 = (hostRef, renderFnResults, isInitialLoad = false) => {
  var _a, _b, _c, _d, _e;
  const hostElm = hostRef.$hostElement$;
  const cmpMeta = hostRef.$cmpMeta$;
  const oldVNode = hostRef.$vnode$ || newVNode$1(null, null);
  const rootVnode = isHost$1(renderFnResults) ? renderFnResults : h$1(null, null, renderFnResults);
  hostTagName$1 = hostElm.tagName;
  if (cmpMeta.$attrsToReflect$) {
    rootVnode.$attrs$ = rootVnode.$attrs$ || {};
    cmpMeta.$attrsToReflect$.map(
      ([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]
    );
  }
  if (isInitialLoad && rootVnode.$attrs$) {
    for (const key of Object.keys(rootVnode.$attrs$)) {
      if (hostElm.hasAttribute(key) && !["key", "ref", "style", "class"].includes(key)) {
        rootVnode.$attrs$[key] = hostElm[key];
      }
    }
  }
  rootVnode.$tag$ = null;
  rootVnode.$flags$ |= 4;
  hostRef.$vnode$ = rootVnode;
  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
  {
    scopeId$1 = hostElm["s-sc"];
  }
  useNativeShadowDom$1 = (cmpMeta.$flags$ & 1) !== 0;
  {
    contentRef$1 = hostElm["s-cr"];
    checkSlotFallbackVisibility$1 = false;
  }
  patch$1(oldVNode, rootVnode, isInitialLoad);
  {
    plt$1.$flags$ |= 1;
    if (checkSlotRelocate$1) {
      markSlotContentForRelocation$1(rootVnode.$elm$);
      for (const relocateData of relocateNodes$1) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        if (!nodeToRelocate["s-ol"]) {
          const orgLocationNode = doc$2.createTextNode("");
          orgLocationNode["s-nr"] = nodeToRelocate;
          insertBefore$1(nodeToRelocate.parentNode, nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
        }
      }
      for (const relocateData of relocateNodes$1) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        const slotRefNode = relocateData.$slotRefNode$;
        if (slotRefNode) {
          const parentNodeRef = slotRefNode.parentNode;
          let insertBeforeNode = slotRefNode.nextSibling;
          {
            let orgLocationNode = (_a = nodeToRelocate["s-ol"]) == null ? void 0 : _a.previousSibling;
            while (orgLocationNode) {
              let refNode = (_b = orgLocationNode["s-nr"]) != null ? _b : null;
              if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === refNode.parentNode) {
                refNode = refNode.nextSibling;
                while (refNode === nodeToRelocate || (refNode == null ? void 0 : refNode["s-sr"])) {
                  refNode = refNode == null ? void 0 : refNode.nextSibling;
                }
                if (!refNode || !refNode["s-nr"]) {
                  insertBeforeNode = refNode;
                  break;
                }
              }
              orgLocationNode = orgLocationNode.previousSibling;
            }
          }
          if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {
            if (nodeToRelocate !== insertBeforeNode) {
              if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
              }
              insertBefore$1(parentNodeRef, nodeToRelocate, insertBeforeNode);
              if (nodeToRelocate.nodeType === 1) {
                nodeToRelocate.hidden = (_c = nodeToRelocate["s-ih"]) != null ? _c : false;
              }
            }
          }
          nodeToRelocate && typeof slotRefNode["s-rf"] === "function" && slotRefNode["s-rf"](nodeToRelocate);
        } else {
          if (nodeToRelocate.nodeType === 1) {
            if (isInitialLoad) {
              nodeToRelocate["s-ih"] = (_d = nodeToRelocate.hidden) != null ? _d : false;
            }
            nodeToRelocate.hidden = true;
          }
        }
      }
    }
    if (checkSlotFallbackVisibility$1) {
      updateFallbackSlotVisibility$1(rootVnode.$elm$);
    }
    plt$1.$flags$ &= ~1;
    relocateNodes$1.length = 0;
  }
  if (BUILD$1.experimentalScopedSlotChanges && cmpMeta.$flags$ & 2) {
    for (const childNode of rootVnode.$elm$.childNodes) {
      if (childNode["s-hn"] !== hostTagName$1 && !childNode["s-sh"]) {
        if (isInitialLoad && childNode["s-ih"] == null) {
          childNode["s-ih"] = (_e = childNode.hidden) != null ? _e : false;
        }
        childNode.hidden = true;
      }
    }
  }
  contentRef$1 = void 0;
};
var attachToAncestor$1 = (hostRef, ancestorComponent) => {
};
var scheduleUpdate$1 = (hostRef, isInitialLoad) => {
  {
    hostRef.$flags$ |= 16;
  }
  attachToAncestor$1(hostRef, hostRef.$ancestorComponent$);
  const dispatch = () => dispatchHooks$1(hostRef, isInitialLoad);
  return writeTask$1(dispatch);
};
var dispatchHooks$1 = (hostRef, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endSchedule = createTime$1("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
  const instance = elm;
  if (!instance) {
    throw new Error(
      "Can't render component <".concat(elm.tagName.toLowerCase(), " /> with invalid Stencil runtime! Make sure this imported component is compiled with a `externalRuntime: true` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime")
    );
  }
  let maybePromise;
  if (isInitialLoad) {
    {
      maybePromise = safeCall$1(instance, "componentWillLoad");
    }
  } else {
    {
      maybePromise = safeCall$1(instance, "componentWillUpdate");
    }
  }
  {
    maybePromise = enqueue$1(maybePromise, () => safeCall$1(instance, "componentWillRender"));
  }
  endSchedule();
  return enqueue$1(maybePromise, () => updateComponent$1(hostRef, instance, isInitialLoad));
};
var enqueue$1 = (maybePromise, fn) => isPromisey$1(maybePromise) ? maybePromise.then(fn).catch((err2) => {
  console.error(err2);
  fn();
}) : fn();
var isPromisey$1 = (maybePromise) => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === "function";
var updateComponent$1 = async (hostRef, instance, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endUpdate = createTime$1("update", hostRef.$cmpMeta$.$tagName$);
  elm["s-rc"];
  if (isInitialLoad) {
    attachStyles$1(hostRef);
  }
  const endRender = createTime$1("render", hostRef.$cmpMeta$.$tagName$);
  {
    callRender$1(hostRef, instance, elm, isInitialLoad);
  }
  endRender();
  endUpdate();
  {
    postUpdateComponent$1(hostRef);
  }
};
var renderingRef$1 = null;
var callRender$1 = (hostRef, instance, elm, isInitialLoad) => {
  const allRenderFn = false;
  const lazyLoad = false;
  const taskQueue = true;
  const updatable = true;
  try {
    renderingRef$1 = instance;
    instance = allRenderFn ? instance.render() : instance.render && instance.render();
    if (updatable && taskQueue) {
      hostRef.$flags$ &= ~16;
    }
    if (updatable || lazyLoad) {
      hostRef.$flags$ |= 2;
    }
    if (BUILD$1.hasRenderFn || BUILD$1.reflect) {
      if (BUILD$1.vdomRender || BUILD$1.reflect) {
        if (BUILD$1.hydrateServerSide)
          ;
        else {
          renderVdom$1(hostRef, instance, isInitialLoad);
        }
      }
    }
  } catch (e2) {
    consoleError$1(e2, hostRef.$hostElement$);
  }
  renderingRef$1 = null;
  return null;
};
var postUpdateComponent$1 = (hostRef) => {
  const tagName = hostRef.$cmpMeta$.$tagName$;
  const elm = hostRef.$hostElement$;
  const endPostUpdate = createTime$1("postUpdate", tagName);
  const instance = elm;
  hostRef.$ancestorComponent$;
  {
    safeCall$1(instance, "componentDidRender");
  }
  if (!(hostRef.$flags$ & 64)) {
    hostRef.$flags$ |= 64;
    {
      safeCall$1(instance, "componentDidLoad");
    }
    endPostUpdate();
  } else {
    {
      safeCall$1(instance, "componentDidUpdate");
    }
    endPostUpdate();
  }
};
var forceUpdate = (ref) => {
  {
    const hostRef = getHostRef$1(ref);
    const isConnected = hostRef.$hostElement$.isConnected;
    if (isConnected && (hostRef.$flags$ & (2 | 16)) === 2) {
      scheduleUpdate$1(hostRef, false);
    }
    return isConnected;
  }
};
var safeCall$1 = (instance, method, arg) => {
  if (instance && instance[method]) {
    try {
      return instance[method](arg);
    } catch (e2) {
      consoleError$1(e2);
    }
  }
  return void 0;
};
var getValue$1 = (ref, propName) => getHostRef$1(ref).$instanceValues$.get(propName);
var setValue$1 = (ref, propName, newVal, cmpMeta) => {
  const hostRef = getHostRef$1(ref);
  const elm = ref;
  const oldVal = hostRef.$instanceValues$.get(propName);
  const flags2 = hostRef.$flags$;
  const instance = elm;
  newVal = parsePropertyValue$1(newVal, cmpMeta.$members$[propName][0]);
  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
  const didValueChange = newVal !== oldVal && !areBothNaN;
  if (didValueChange) {
    hostRef.$instanceValues$.set(propName, newVal);
    {
      if (cmpMeta.$watchers$ && flags2 & 128) {
        const watchMethods = cmpMeta.$watchers$[propName];
        if (watchMethods) {
          watchMethods.map((watchMethodName) => {
            try {
              instance[watchMethodName](newVal, oldVal, propName);
            } catch (e2) {
              consoleError$1(e2, elm);
            }
          });
        }
      }
      if ((flags2 & (2 | 16)) === 2) {
        if (instance.componentShouldUpdate) {
          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
            return;
          }
        }
        scheduleUpdate$1(hostRef, false);
      }
    }
  }
};
var proxyComponent$1 = (Cstr, cmpMeta, flags2) => {
  var _a, _b;
  const prototype = Cstr.prototype;
  if (cmpMeta.$members$ || (cmpMeta.$watchers$ || Cstr.watchers)) {
    if (Cstr.watchers && !cmpMeta.$watchers$) {
      cmpMeta.$watchers$ = Cstr.watchers;
    }
    const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});
    members.map(([memberName, [memberFlags]]) => {
      if (memberFlags & 31 || memberFlags & 32) {
        Object.defineProperty(prototype, memberName, {
          get() {
            return getValue$1(this, memberName);
          },
          set(newValue) {
            setValue$1(this, memberName, newValue, cmpMeta);
          },
          configurable: true,
          enumerable: true
        });
      }
    });
    {
      const attrNameToPropName = /* @__PURE__ */ new Map();
      prototype.attributeChangedCallback = function(attrName, oldValue, newValue) {
        plt$1.jmp(() => {
          var _a2;
          const propName = attrNameToPropName.get(attrName);
          if (this.hasOwnProperty(propName)) {
            newValue = this[propName];
            delete this[propName];
          } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && // cast type to number to avoid TS compiler issues
          this[propName] == newValue) {
            return;
          } else if (propName == null) {
            const hostRef = getHostRef$1(this);
            const flags22 = hostRef == null ? void 0 : hostRef.$flags$;
            if (flags22 && !(flags22 & 8) && flags22 & 128 && newValue !== oldValue) {
              const elm = this;
              const instance = elm;
              const entry = (_a2 = cmpMeta.$watchers$) == null ? void 0 : _a2[attrName];
              entry == null ? void 0 : entry.forEach((callbackName) => {
                if (instance[callbackName] != null) {
                  instance[callbackName].call(instance, newValue, oldValue, attrName);
                }
              });
            }
            return;
          }
          this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
        });
      };
      Cstr.observedAttributes = Array.from(
        /* @__PURE__ */ new Set([
          ...Object.keys((_b = cmpMeta.$watchers$) != null ? _b : {}),
          ...members.filter(
            ([_, m2]) => m2[0] & 15
            /* HasAttribute */
          ).map(([propName, m2]) => {
            var _a2;
            const attrName = m2[1] || propName;
            attrNameToPropName.set(attrName, propName);
            if (m2[0] & 512) {
              (_a2 = cmpMeta.$attrsToReflect$) == null ? void 0 : _a2.push([propName, attrName]);
            }
            return attrName;
          })
        ])
      );
    }
  }
  return Cstr;
};
var initializeComponent$1 = async (elm, hostRef, cmpMeta, hmrVersionId) => {
  let Cstr;
  if ((hostRef.$flags$ & 32) === 0) {
    hostRef.$flags$ |= 32;
    cmpMeta.$lazyBundleId$;
    {
      Cstr = elm.constructor;
      const cmpTag = elm.localName;
      customElements.whenDefined(cmpTag).then(
        () => hostRef.$flags$ |= 128
        /* isWatchReady */
      );
    }
    if (Cstr && Cstr.style) {
      let style;
      if (typeof Cstr.style === "string") {
        style = Cstr.style;
      } else if (typeof Cstr.style !== "string") {
        hostRef.$modeName$ = computeMode$1(elm);
        if (hostRef.$modeName$) {
          style = Cstr.style[hostRef.$modeName$];
        }
      }
      const scopeId2 = getScopeId$1(cmpMeta, hostRef.$modeName$);
      if (!styles$1.has(scopeId2)) {
        const endRegisterStyles = createTime$1("registerStyles", cmpMeta.$tagName$);
        registerStyle$1(scopeId2, style, !!(cmpMeta.$flags$ & 1));
        endRegisterStyles();
      }
    }
  }
  hostRef.$ancestorComponent$;
  const schedule = () => scheduleUpdate$1(hostRef, true);
  {
    schedule();
  }
};
var fireConnectedCallback$1 = (instance) => {
};
var connectedCallback$1 = (elm) => {
  if ((plt$1.$flags$ & 1) === 0) {
    const hostRef = getHostRef$1(elm);
    const cmpMeta = hostRef.$cmpMeta$;
    const endConnected = createTime$1("connectedCallback", cmpMeta.$tagName$);
    if (!(hostRef.$flags$ & 1)) {
      hostRef.$flags$ |= 1;
      {
        if (
          // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
          cmpMeta.$flags$ & (4 | 8)
        ) {
          setContentReference$1(elm);
        }
      }
      if (cmpMeta.$members$) {
        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
          if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
            const value = elm[memberName];
            delete elm[memberName];
            elm[memberName] = value;
          }
        });
      }
      {
        initializeComponent$1(elm, hostRef, cmpMeta);
      }
    } else {
      addHostEventListeners$1(elm, hostRef, cmpMeta.$listeners$);
      if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {
        fireConnectedCallback$1(hostRef.$lazyInstance$);
      } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {
        hostRef.$onReadyPromise$.then(() => fireConnectedCallback$1(hostRef.$lazyInstance$));
      }
    }
    endConnected();
  }
};
var setContentReference$1 = (elm) => {
  const contentRefElm = elm["s-cr"] = doc$2.createComment(
    ""
  );
  contentRefElm["s-cn"] = true;
  insertBefore$1(elm, contentRefElm, elm.firstChild);
};
var disconnectedCallback$1 = async (elm) => {
  if ((plt$1.$flags$ & 1) === 0) {
    const hostRef = getHostRef$1(elm);
    {
      if (hostRef.$rmListeners$) {
        hostRef.$rmListeners$.map((rmListener) => rmListener());
        hostRef.$rmListeners$ = void 0;
      }
    }
  }
};
var proxyCustomElement$1 = (Cstr, compactMeta) => {
  const cmpMeta = {
    $flags$: compactMeta[0],
    $tagName$: compactMeta[1]
  };
  {
    cmpMeta.$members$ = compactMeta[2];
  }
  {
    cmpMeta.$listeners$ = compactMeta[3];
  }
  {
    cmpMeta.$watchers$ = Cstr.$watchers$;
  }
  {
    cmpMeta.$attrsToReflect$ = [];
  }
  const originalConnectedCallback = Cstr.prototype.connectedCallback;
  const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
  Object.assign(Cstr.prototype, {
    __registerHost() {
      registerHost$1(this, cmpMeta);
    },
    connectedCallback() {
      const hostRef = getHostRef$1(this);
      addHostEventListeners$1(this, hostRef, cmpMeta.$listeners$);
      connectedCallback$1(this);
      if (originalConnectedCallback) {
        originalConnectedCallback.call(this);
      }
    },
    disconnectedCallback() {
      disconnectedCallback$1(this);
      if (originalDisconnectedCallback) {
        originalDisconnectedCallback.call(this);
      }
    },
    __attachShadow() {
      {
        if (!this.shadowRoot) {
          {
            this.attachShadow({
              mode: "open",
              delegatesFocus: !!(cmpMeta.$flags$ & 16)
            });
          }
        } else {
          if (this.shadowRoot.mode !== "open") {
            throw new Error(
              "Unable to re-use existing shadow root for ".concat(cmpMeta.$tagName$, "! Mode is set to ").concat(this.shadowRoot.mode, " but Stencil only supports open shadow roots.")
            );
          }
        }
      }
    }
  });
  Cstr.is = cmpMeta.$tagName$;
  return proxyComponent$1(Cstr, cmpMeta);
};
var addHostEventListeners$1 = (elm, hostRef, listeners, attachParentListeners) => {
  if (listeners) {
    listeners.map(([flags2, name, method]) => {
      const target = getHostListenerTarget$1(elm, flags2);
      const handler = hostListenerProxy$1(hostRef, method);
      const opts = hostListenerOpts$1(flags2);
      plt$1.ael(target, name, handler, opts);
      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt$1.rel(target, name, handler, opts));
    });
  }
};
var hostListenerProxy$1 = (hostRef, methodName) => (ev) => {
  var _a;
  try {
    if (BUILD$1.lazyLoad)
      ;
    else {
      hostRef.$hostElement$[methodName](ev);
    }
  } catch (e2) {
    consoleError$1(e2);
  }
};
var getHostListenerTarget$1 = (elm, flags2) => {
  if (flags2 & 4)
    return doc$2;
  if (flags2 & 8)
    return win$3;
  if (flags2 & 16)
    return doc$2.body;
  return elm;
};
var hostListenerOpts$1 = (flags2) => supportsListenerOptions$1 ? {
  passive: (flags2 & 1) !== 0,
  capture: (flags2 & 2) !== 0
} : (flags2 & 2) !== 0;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const win$2 = typeof window !== "undefined" ? window : void 0;
const doc$1 = typeof document !== "undefined" ? document : void 0;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
let animationPrefix;
const getAnimationPrefix = (el2) => {
  if (animationPrefix === void 0) {
    const supportsUnprefixed = el2.style.animationName !== void 0;
    const supportsWebkitPrefix = el2.style.webkitAnimationName !== void 0;
    animationPrefix = !supportsUnprefixed && supportsWebkitPrefix ? "-webkit-" : "";
  }
  return animationPrefix;
};
const setStyleProperty = (element, propertyName, value) => {
  const prefix2 = propertyName.startsWith("animation") ? getAnimationPrefix(element) : "";
  element.style.setProperty(prefix2 + propertyName, value);
};
const addClassToArray = (classes = [], className) => {
  if (className !== void 0) {
    const classNameToAppend = Array.isArray(className) ? className : [className];
    return [...classes, ...classNameToAppend];
  }
  return classes;
};
const createAnimation = (animationId) => {
  let _delay;
  let _duration;
  let _easing;
  let _iterations;
  let _fill;
  let _direction;
  let _keyframes = [];
  let beforeAddClasses = [];
  let beforeRemoveClasses = [];
  let initialized = false;
  let parentAnimation;
  let beforeStylesValue = {};
  let afterAddClasses = [];
  let afterRemoveClasses = [];
  let afterStylesValue = {};
  let numAnimationsRunning = 0;
  let shouldForceLinearEasing = false;
  let shouldForceSyncPlayback = false;
  let forceDirectionValue;
  let forceDurationValue;
  let forceDelayValue;
  let willComplete = true;
  let finished = false;
  let shouldCalculateNumAnimations = true;
  let ani;
  let paused = false;
  const id2 = animationId;
  const onFinishCallbacks = [];
  const onFinishOneTimeCallbacks = [];
  const onStopOneTimeCallbacks = [];
  const elements = [];
  const childAnimations = [];
  const stylesheets = [];
  const _beforeAddReadFunctions = [];
  const _beforeAddWriteFunctions = [];
  const _afterAddReadFunctions = [];
  const _afterAddWriteFunctions = [];
  const webAnimations = [];
  const supportsAnimationEffect = typeof AnimationEffect === "function" || win$2 !== void 0 && typeof win$2.AnimationEffect === "function";
  const supportsWebAnimations = typeof Element === "function" && typeof Element.prototype.animate === "function" && supportsAnimationEffect;
  const getWebAnimations = () => {
    return webAnimations;
  };
  const destroy = (clearStyleSheets) => {
    childAnimations.forEach((childAnimation) => {
      childAnimation.destroy(clearStyleSheets);
    });
    cleanUp(clearStyleSheets);
    elements.length = 0;
    childAnimations.length = 0;
    _keyframes.length = 0;
    clearOnFinish();
    initialized = false;
    shouldCalculateNumAnimations = true;
    return ani;
  };
  const cleanUp = (clearStyleSheets) => {
    cleanUpElements();
    if (clearStyleSheets) {
      cleanUpStyleSheets();
    }
  };
  const resetFlags = () => {
    shouldForceLinearEasing = false;
    shouldForceSyncPlayback = false;
    shouldCalculateNumAnimations = true;
    forceDirectionValue = void 0;
    forceDurationValue = void 0;
    forceDelayValue = void 0;
    numAnimationsRunning = 0;
    finished = false;
    willComplete = true;
    paused = false;
  };
  const isRunning = () => {
    return numAnimationsRunning !== 0 && !paused;
  };
  const clearCallback = (callbackToRemove, callbackObjects) => {
    const index = callbackObjects.findIndex((callbackObject) => callbackObject.c === callbackToRemove);
    if (index > -1) {
      callbackObjects.splice(index, 1);
    }
  };
  const onStop = (callback, opts) => {
    onStopOneTimeCallbacks.push({ c: callback, o: opts });
    return ani;
  };
  const onFinish = (callback, opts) => {
    const callbacks = (opts === null || opts === void 0 ? void 0 : opts.oneTimeCallback) ? onFinishOneTimeCallbacks : onFinishCallbacks;
    callbacks.push({ c: callback, o: opts });
    return ani;
  };
  const clearOnFinish = () => {
    onFinishCallbacks.length = 0;
    onFinishOneTimeCallbacks.length = 0;
    return ani;
  };
  const cleanUpElements = () => {
    if (supportsWebAnimations) {
      webAnimations.forEach((animation2) => {
        animation2.cancel();
      });
      webAnimations.length = 0;
    }
  };
  const cleanUpStyleSheets = () => {
    stylesheets.forEach((stylesheet) => {
      if (stylesheet === null || stylesheet === void 0 ? void 0 : stylesheet.parentNode) {
        stylesheet.parentNode.removeChild(stylesheet);
      }
    });
    stylesheets.length = 0;
  };
  const beforeAddRead = (readFn) => {
    _beforeAddReadFunctions.push(readFn);
    return ani;
  };
  const beforeAddWrite = (writeFn) => {
    _beforeAddWriteFunctions.push(writeFn);
    return ani;
  };
  const afterAddRead = (readFn) => {
    _afterAddReadFunctions.push(readFn);
    return ani;
  };
  const afterAddWrite = (writeFn) => {
    _afterAddWriteFunctions.push(writeFn);
    return ani;
  };
  const beforeAddClass = (className) => {
    beforeAddClasses = addClassToArray(beforeAddClasses, className);
    return ani;
  };
  const beforeRemoveClass = (className) => {
    beforeRemoveClasses = addClassToArray(beforeRemoveClasses, className);
    return ani;
  };
  const beforeStyles = (styles2 = {}) => {
    beforeStylesValue = styles2;
    return ani;
  };
  const beforeClearStyles = (propertyNames = []) => {
    for (const property of propertyNames) {
      beforeStylesValue[property] = "";
    }
    return ani;
  };
  const afterAddClass = (className) => {
    afterAddClasses = addClassToArray(afterAddClasses, className);
    return ani;
  };
  const afterRemoveClass = (className) => {
    afterRemoveClasses = addClassToArray(afterRemoveClasses, className);
    return ani;
  };
  const afterStyles = (styles2 = {}) => {
    afterStylesValue = styles2;
    return ani;
  };
  const afterClearStyles = (propertyNames = []) => {
    for (const property of propertyNames) {
      afterStylesValue[property] = "";
    }
    return ani;
  };
  const getFill = () => {
    if (_fill !== void 0) {
      return _fill;
    }
    if (parentAnimation) {
      return parentAnimation.getFill();
    }
    return "both";
  };
  const getDirection = () => {
    if (forceDirectionValue !== void 0) {
      return forceDirectionValue;
    }
    if (_direction !== void 0) {
      return _direction;
    }
    if (parentAnimation) {
      return parentAnimation.getDirection();
    }
    return "normal";
  };
  const getEasing = () => {
    if (shouldForceLinearEasing) {
      return "linear";
    }
    if (_easing !== void 0) {
      return _easing;
    }
    if (parentAnimation) {
      return parentAnimation.getEasing();
    }
    return "linear";
  };
  const getDuration = () => {
    if (shouldForceSyncPlayback) {
      return 0;
    }
    if (forceDurationValue !== void 0) {
      return forceDurationValue;
    }
    if (_duration !== void 0) {
      return _duration;
    }
    if (parentAnimation) {
      return parentAnimation.getDuration();
    }
    return 0;
  };
  const getIterations = () => {
    if (_iterations !== void 0) {
      return _iterations;
    }
    if (parentAnimation) {
      return parentAnimation.getIterations();
    }
    return 1;
  };
  const getDelay = () => {
    if (forceDelayValue !== void 0) {
      return forceDelayValue;
    }
    if (_delay !== void 0) {
      return _delay;
    }
    if (parentAnimation) {
      return parentAnimation.getDelay();
    }
    return 0;
  };
  const getKeyframes = () => {
    return _keyframes;
  };
  const direction = (animationDirection) => {
    _direction = animationDirection;
    update(true);
    return ani;
  };
  const fill = (animationFill) => {
    _fill = animationFill;
    update(true);
    return ani;
  };
  const delay = (animationDelay) => {
    _delay = animationDelay;
    update(true);
    return ani;
  };
  const easing = (animationEasing) => {
    _easing = animationEasing;
    update(true);
    return ani;
  };
  const duration = (animationDuration) => {
    if (!supportsWebAnimations && animationDuration === 0) {
      animationDuration = 1;
    }
    _duration = animationDuration;
    update(true);
    return ani;
  };
  const iterations = (animationIterations) => {
    _iterations = animationIterations;
    update(true);
    return ani;
  };
  const parent2 = (animation2) => {
    parentAnimation = animation2;
    return ani;
  };
  const addElement = (el2) => {
    if (el2 != null) {
      if (el2.nodeType === 1) {
        elements.push(el2);
      } else if (el2.length >= 0) {
        for (let i = 0; i < el2.length; i++) {
          elements.push(el2[i]);
        }
      } else {
        console.error("Invalid addElement value");
      }
    }
    return ani;
  };
  const addAnimation = (animationToAdd) => {
    if (animationToAdd != null) {
      if (Array.isArray(animationToAdd)) {
        for (const animation2 of animationToAdd) {
          animation2.parent(ani);
          childAnimations.push(animation2);
        }
      } else {
        animationToAdd.parent(ani);
        childAnimations.push(animationToAdd);
      }
    }
    return ani;
  };
  const keyframes = (keyframeValues) => {
    const different = _keyframes !== keyframeValues;
    _keyframes = keyframeValues;
    if (different) {
      updateKeyframes(_keyframes);
    }
    return ani;
  };
  const updateKeyframes = (keyframeValues) => {
    if (supportsWebAnimations) {
      getWebAnimations().forEach((animation2) => {
        const keyframeEffect = animation2.effect;
        if (keyframeEffect.setKeyframes) {
          keyframeEffect.setKeyframes(keyframeValues);
        } else {
          const newEffect = new KeyframeEffect(keyframeEffect.target, keyframeValues, keyframeEffect.getTiming());
          animation2.effect = newEffect;
        }
      });
    }
  };
  const beforeAnimation = () => {
    _beforeAddReadFunctions.forEach((callback) => callback());
    _beforeAddWriteFunctions.forEach((callback) => callback());
    const addClasses = beforeAddClasses;
    const removeClasses = beforeRemoveClasses;
    const styles2 = beforeStylesValue;
    elements.forEach((el2) => {
      const elementClassList = el2.classList;
      addClasses.forEach((c2) => elementClassList.add(c2));
      removeClasses.forEach((c2) => elementClassList.remove(c2));
      for (const property in styles2) {
        if (styles2.hasOwnProperty(property)) {
          setStyleProperty(el2, property, styles2[property]);
        }
      }
    });
  };
  const afterAnimation = () => {
    _afterAddReadFunctions.forEach((callback) => callback());
    _afterAddWriteFunctions.forEach((callback) => callback());
    const currentStep = willComplete ? 1 : 0;
    const addClasses = afterAddClasses;
    const removeClasses = afterRemoveClasses;
    const styles2 = afterStylesValue;
    elements.forEach((el2) => {
      const elementClassList = el2.classList;
      addClasses.forEach((c2) => elementClassList.add(c2));
      removeClasses.forEach((c2) => elementClassList.remove(c2));
      for (const property in styles2) {
        if (styles2.hasOwnProperty(property)) {
          setStyleProperty(el2, property, styles2[property]);
        }
      }
    });
    forceDurationValue = void 0;
    forceDirectionValue = void 0;
    forceDelayValue = void 0;
    onFinishCallbacks.forEach((onFinishCallback) => {
      return onFinishCallback.c(currentStep, ani);
    });
    onFinishOneTimeCallbacks.forEach((onFinishCallback) => {
      return onFinishCallback.c(currentStep, ani);
    });
    onFinishOneTimeCallbacks.length = 0;
    shouldCalculateNumAnimations = true;
    if (willComplete) {
      finished = true;
    }
    willComplete = true;
  };
  const animationFinish = () => {
    if (numAnimationsRunning === 0) {
      return;
    }
    numAnimationsRunning--;
    if (numAnimationsRunning === 0) {
      afterAnimation();
      if (parentAnimation) {
        parentAnimation.animationFinish();
      }
    }
  };
  const initializeWebAnimation = () => {
    elements.forEach((element) => {
      const animation2 = element.animate(_keyframes, {
        id: id2,
        delay: getDelay(),
        duration: getDuration(),
        easing: getEasing(),
        iterations: getIterations(),
        fill: getFill(),
        direction: getDirection()
      });
      animation2.pause();
      webAnimations.push(animation2);
    });
    if (webAnimations.length > 0) {
      webAnimations[0].onfinish = () => {
        animationFinish();
      };
    }
  };
  const initializeAnimation = () => {
    beforeAnimation();
    if (_keyframes.length > 0) {
      if (supportsWebAnimations) {
        initializeWebAnimation();
      }
    }
    initialized = true;
  };
  const setAnimationStep = (step) => {
    step = Math.min(Math.max(step, 0), 0.9999);
    if (supportsWebAnimations) {
      webAnimations.forEach((animation2) => {
        animation2.currentTime = animation2.effect.getComputedTiming().delay + getDuration() * step;
        animation2.pause();
      });
    }
  };
  const updateWebAnimation = (step) => {
    webAnimations.forEach((animation2) => {
      animation2.effect.updateTiming({
        delay: getDelay(),
        duration: getDuration(),
        easing: getEasing(),
        iterations: getIterations(),
        fill: getFill(),
        direction: getDirection()
      });
    });
    if (step !== void 0) {
      setAnimationStep(step);
    }
  };
  const update = (deep = false, toggleAnimationName = true, step) => {
    if (deep) {
      childAnimations.forEach((animation2) => {
        animation2.update(deep, toggleAnimationName, step);
      });
    }
    if (supportsWebAnimations) {
      updateWebAnimation(step);
    }
    return ani;
  };
  const progressStart = (forceLinearEasing = false, step) => {
    childAnimations.forEach((animation2) => {
      animation2.progressStart(forceLinearEasing, step);
    });
    pauseAnimation();
    shouldForceLinearEasing = forceLinearEasing;
    if (!initialized) {
      initializeAnimation();
    }
    update(false, true, step);
    return ani;
  };
  const progressStep = (step) => {
    childAnimations.forEach((animation2) => {
      animation2.progressStep(step);
    });
    setAnimationStep(step);
    return ani;
  };
  const progressEnd = (playTo, step, dur) => {
    shouldForceLinearEasing = false;
    childAnimations.forEach((animation2) => {
      animation2.progressEnd(playTo, step, dur);
    });
    if (dur !== void 0) {
      forceDurationValue = dur;
    }
    finished = false;
    willComplete = true;
    if (playTo === 0) {
      forceDirectionValue = getDirection() === "reverse" ? "normal" : "reverse";
      if (forceDirectionValue === "reverse") {
        willComplete = false;
      }
      if (supportsWebAnimations) {
        update();
        setAnimationStep(1 - step);
      } else {
        forceDelayValue = (1 - step) * getDuration() * -1;
        update(false, false);
      }
    } else if (playTo === 1) {
      if (supportsWebAnimations) {
        update();
        setAnimationStep(step);
      } else {
        forceDelayValue = step * getDuration() * -1;
        update(false, false);
      }
    }
    if (playTo !== void 0 && !parentAnimation) {
      play();
    }
    return ani;
  };
  const pauseAnimation = () => {
    if (initialized) {
      if (supportsWebAnimations) {
        webAnimations.forEach((animation2) => {
          animation2.pause();
        });
      } else {
        elements.forEach((element) => {
          setStyleProperty(element, "animation-play-state", "paused");
        });
      }
      paused = true;
    }
  };
  const pause = () => {
    childAnimations.forEach((animation2) => {
      animation2.pause();
    });
    pauseAnimation();
    return ani;
  };
  const playCSSAnimations = () => {
    animationFinish();
  };
  const playWebAnimations = () => {
    webAnimations.forEach((animation2) => {
      animation2.play();
    });
    if (_keyframes.length === 0 || elements.length === 0) {
      animationFinish();
    }
  };
  const resetAnimation = () => {
    if (supportsWebAnimations) {
      setAnimationStep(0);
      updateWebAnimation();
    }
  };
  const play = (opts) => {
    return new Promise((resolve) => {
      if (opts === null || opts === void 0 ? void 0 : opts.sync) {
        shouldForceSyncPlayback = true;
        onFinish(() => shouldForceSyncPlayback = false, { oneTimeCallback: true });
      }
      if (!initialized) {
        initializeAnimation();
      }
      if (finished) {
        resetAnimation();
        finished = false;
      }
      if (shouldCalculateNumAnimations) {
        numAnimationsRunning = childAnimations.length + 1;
        shouldCalculateNumAnimations = false;
      }
      const onStopCallback = () => {
        clearCallback(onFinishCallback, onFinishOneTimeCallbacks);
        resolve();
      };
      const onFinishCallback = () => {
        clearCallback(onStopCallback, onStopOneTimeCallbacks);
        resolve();
      };
      onFinish(onFinishCallback, { oneTimeCallback: true });
      onStop(onStopCallback, { oneTimeCallback: true });
      childAnimations.forEach((animation2) => {
        animation2.play();
      });
      if (supportsWebAnimations) {
        playWebAnimations();
      } else {
        playCSSAnimations();
      }
      paused = false;
    });
  };
  const stop = () => {
    childAnimations.forEach((animation2) => {
      animation2.stop();
    });
    if (initialized) {
      cleanUpElements();
      initialized = false;
    }
    resetFlags();
    onStopOneTimeCallbacks.forEach((onStopCallback) => onStopCallback.c(0, ani));
    onStopOneTimeCallbacks.length = 0;
  };
  const from = (property, value) => {
    const firstFrame = _keyframes[0];
    if (firstFrame !== void 0 && (firstFrame.offset === void 0 || firstFrame.offset === 0)) {
      firstFrame[property] = value;
    } else {
      _keyframes = [{ offset: 0, [property]: value }, ..._keyframes];
    }
    return ani;
  };
  const to = (property, value) => {
    const lastFrame = _keyframes[_keyframes.length - 1];
    if (lastFrame !== void 0 && (lastFrame.offset === void 0 || lastFrame.offset === 1)) {
      lastFrame[property] = value;
    } else {
      _keyframes = [..._keyframes, { offset: 1, [property]: value }];
    }
    return ani;
  };
  const fromTo = (property, fromValue, toValue) => {
    return from(property, fromValue).to(property, toValue);
  };
  return ani = {
    parentAnimation,
    elements,
    childAnimations,
    id: id2,
    animationFinish,
    from,
    to,
    fromTo,
    parent: parent2,
    play,
    pause,
    stop,
    destroy,
    keyframes,
    addAnimation,
    addElement,
    update,
    fill,
    direction,
    iterations,
    duration,
    easing,
    delay,
    getWebAnimations,
    getKeyframes,
    getFill,
    getDirection,
    getDelay,
    getIterations,
    getEasing,
    getDuration,
    afterAddRead,
    afterAddWrite,
    afterClearStyles,
    afterStyles,
    afterRemoveClass,
    afterAddClass,
    beforeAddRead,
    beforeAddWrite,
    beforeClearStyles,
    beforeStyles,
    beforeRemoveClass,
    beforeAddClass,
    onFinish,
    isRunning,
    progressStart,
    progressStep,
    progressEnd
  };
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
class Config {
  constructor() {
    this.m = /* @__PURE__ */ new Map();
  }
  reset(configObj) {
    this.m = new Map(Object.entries(configObj));
  }
  get(key, fallback) {
    const value = this.m.get(key);
    return value !== void 0 ? value : fallback;
  }
  getBoolean(key, fallback = false) {
    const val = this.m.get(key);
    if (val === void 0) {
      return fallback;
    }
    if (typeof val === "string") {
      return val === "true";
    }
    return !!val;
  }
  getNumber(key, fallback) {
    const val = parseFloat(this.m.get(key));
    return isNaN(val) ? fallback !== void 0 ? fallback : NaN : val;
  }
  set(key, value) {
    this.m.set(key, value);
  }
}
const config = /* @__PURE__ */ new Config();
const configFromSession = (win2) => {
  try {
    const configStr = win2.sessionStorage.getItem(IONIC_SESSION_KEY);
    return configStr !== null ? JSON.parse(configStr) : {};
  } catch (e2) {
    return {};
  }
};
const saveConfig = (win2, c2) => {
  try {
    win2.sessionStorage.setItem(IONIC_SESSION_KEY, JSON.stringify(c2));
  } catch (e2) {
    return;
  }
};
const configFromURL = (win2) => {
  const configObj = {};
  win2.location.search.slice(1).split("&").map((entry) => entry.split("=")).map(([key, value]) => {
    try {
      return [decodeURIComponent(key), decodeURIComponent(value)];
    } catch (e2) {
      return ["", ""];
    }
  }).filter(([key]) => startsWith(key, IONIC_PREFIX)).map(([key, value]) => [key.slice(IONIC_PREFIX.length), value]).forEach(([key, value]) => {
    configObj[key] = value;
  });
  return configObj;
};
const startsWith = (input, search) => {
  return input.substr(0, search.length) === search;
};
const IONIC_PREFIX = "ionic:";
const IONIC_SESSION_KEY = "ionic-persist-config";
const getPlatforms = (win2) => setupPlatforms(win2);
const isPlatform = (winOrPlatform, platform) => {
  if (typeof winOrPlatform === "string") {
    platform = winOrPlatform;
    winOrPlatform = void 0;
  }
  return getPlatforms(winOrPlatform).includes(platform);
};
const setupPlatforms = (win2 = window) => {
  if (typeof win2 === "undefined") {
    return [];
  }
  win2.Ionic = win2.Ionic || {};
  let platforms = win2.Ionic.platforms;
  if (platforms == null) {
    platforms = win2.Ionic.platforms = detectPlatforms(win2);
    platforms.forEach((p2) => win2.document.documentElement.classList.add("plt-".concat(p2)));
  }
  return platforms;
};
const detectPlatforms = (win2) => {
  const customPlatformMethods = config.get("platform");
  return Object.keys(PLATFORMS_MAP).filter((p2) => {
    const customMethod = customPlatformMethods === null || customPlatformMethods === void 0 ? void 0 : customPlatformMethods[p2];
    return typeof customMethod === "function" ? customMethod(win2) : PLATFORMS_MAP[p2](win2);
  });
};
const isMobileWeb = (win2) => isMobile(win2) && !isHybrid(win2);
const isIpad = (win2) => {
  if (testUserAgent(win2, /iPad/i)) {
    return true;
  }
  if (testUserAgent(win2, /Macintosh/i) && isMobile(win2)) {
    return true;
  }
  return false;
};
const isIphone = (win2) => testUserAgent(win2, /iPhone/i);
const isIOS = (win2) => testUserAgent(win2, /iPhone|iPod/i) || isIpad(win2);
const isAndroid = (win2) => testUserAgent(win2, /android|sink/i);
const isAndroidTablet = (win2) => {
  return isAndroid(win2) && !testUserAgent(win2, /mobile/i);
};
const isPhablet = (win2) => {
  const width = win2.innerWidth;
  const height = win2.innerHeight;
  const smallest = Math.min(width, height);
  const largest = Math.max(width, height);
  return smallest > 390 && smallest < 520 && largest > 620 && largest < 800;
};
const isTablet = (win2) => {
  const width = win2.innerWidth;
  const height = win2.innerHeight;
  const smallest = Math.min(width, height);
  const largest = Math.max(width, height);
  return isIpad(win2) || isAndroidTablet(win2) || smallest > 460 && smallest < 820 && largest > 780 && largest < 1400;
};
const isMobile = (win2) => matchMedia(win2, "(any-pointer:coarse)");
const isDesktop = (win2) => !isMobile(win2);
const isHybrid = (win2) => isCordova(win2) || isCapacitorNative(win2);
const isCordova = (win2) => !!(win2["cordova"] || win2["phonegap"] || win2["PhoneGap"]);
const isCapacitorNative = (win2) => {
  const capacitor = win2["Capacitor"];
  return !!(capacitor === null || capacitor === void 0 ? void 0 : capacitor.isNative);
};
const isElectron = (win2) => testUserAgent(win2, /electron/i);
const isPWA = (win2) => {
  var _a;
  return !!(((_a = win2.matchMedia) === null || _a === void 0 ? void 0 : _a.call(win2, "(display-mode: standalone)").matches) || win2.navigator.standalone);
};
const testUserAgent = (win2, expr) => expr.test(win2.navigator.userAgent);
const matchMedia = (win2, query) => {
  var _a;
  return (_a = win2.matchMedia) === null || _a === void 0 ? void 0 : _a.call(win2, query).matches;
};
const PLATFORMS_MAP = {
  ipad: isIpad,
  iphone: isIphone,
  ios: isIOS,
  android: isAndroid,
  phablet: isPhablet,
  tablet: isTablet,
  cordova: isCordova,
  capacitor: isCapacitorNative,
  electron: isElectron,
  pwa: isPWA,
  mobile: isMobile,
  mobileweb: isMobileWeb,
  desktop: isDesktop,
  hybrid: isHybrid
};
let defaultMode;
const getIonMode$2 = (ref) => {
  return ref && getMode(ref) || defaultMode;
};
const initialize = (userConfig = {}) => {
  if (typeof window === "undefined") {
    return;
  }
  const doc2 = window.document;
  const win2 = window;
  const Ionic = win2.Ionic = win2.Ionic || {};
  const platformHelpers = {};
  if (userConfig._ael) {
    platformHelpers.ael = userConfig._ael;
  }
  if (userConfig._rel) {
    platformHelpers.rel = userConfig._rel;
  }
  if (userConfig._ce) {
    platformHelpers.ce = userConfig._ce;
  }
  setPlatformHelpers(platformHelpers);
  const configObj = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, configFromSession(win2)), { persistConfig: false }), Ionic.config), configFromURL(win2)), userConfig);
  config.reset(configObj);
  if (config.getBoolean("persistConfig")) {
    saveConfig(win2, configObj);
  }
  setupPlatforms(win2);
  Ionic.config = config;
  Ionic.mode = defaultMode = config.get("mode", doc2.documentElement.getAttribute("mode") || (isPlatform(win2, "ios") ? "ios" : "md"));
  config.set("mode", defaultMode);
  doc2.documentElement.setAttribute("mode", defaultMode);
  doc2.documentElement.classList.add(defaultMode);
  if (config.getBoolean("_testing")) {
    config.set("animated", false);
  }
  const isIonicElement = (elm) => {
    var _a;
    return (_a = elm.tagName) === null || _a === void 0 ? void 0 : _a.startsWith("ION-");
  };
  const isAllowedIonicModeValue = (elmMode) => ["ios", "md"].includes(elmMode);
  setMode((elm) => {
    while (elm) {
      const elmMode = elm.mode || elm.getAttribute("mode");
      if (elmMode) {
        if (isAllowedIonicModeValue(elmMode)) {
          return elmMode;
        } else if (isIonicElement(elm)) {
          console.warn('Invalid ionic mode: "' + elmMode + '", expected: "ios" or "md"');
        }
      }
      elm = elm.parentElement;
    }
    return defaultMode;
  });
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const printIonWarning = (message, ...params) => {
  return console.warn("[Ionic Warning]: ".concat(message), ...params);
};
const printIonError = (message, ...params) => {
  return console.error("[Ionic Error]: ".concat(message), ...params);
};
const printRequiredElementError = (el2, ...targetSelectors) => {
  return console.error("<".concat(el2.tagName.toLowerCase(), "> must be used inside ").concat(targetSelectors.join(" or "), "."));
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const componentOnReady = (el2, callback) => {
  if (el2.componentOnReady) {
    el2.componentOnReady().then((resolvedEl) => callback(resolvedEl));
  } else {
    raf(() => callback(el2));
  }
};
const hasLazyBuild = (stencilEl) => {
  return stencilEl.componentOnReady !== void 0;
};
const inheritAttributes$2 = (el2, attributes = []) => {
  const attributeObject = {};
  attributes.forEach((attr) => {
    if (el2.hasAttribute(attr)) {
      const value = el2.getAttribute(attr);
      if (value !== null) {
        attributeObject[attr] = el2.getAttribute(attr);
      }
      el2.removeAttribute(attr);
    }
  });
  return attributeObject;
};
const ariaAttributes = [
  "role",
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-braillelabel",
  "aria-brailleroledescription",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colindextext",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-description",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowindextext",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext"
];
const inheritAriaAttributes = (el2, ignoreList) => {
  let attributesToInherit = ariaAttributes;
  return inheritAttributes$2(el2, attributesToInherit);
};
const addEventListener$1 = (el2, eventName, callback, opts) => {
  var _a;
  if (typeof window !== "undefined") {
    const win2 = window;
    const config2 = (_a = win2 === null || win2 === void 0 ? void 0 : win2.Ionic) === null || _a === void 0 ? void 0 : _a.config;
    if (config2) {
      const ael = config2.get("_ael");
      if (ael) {
        return ael(el2, eventName, callback, opts);
      } else if (config2._ael) {
        return config2._ael(el2, eventName, callback, opts);
      }
    }
  }
  return el2.addEventListener(eventName, callback, opts);
};
const removeEventListener = (el2, eventName, callback, opts) => {
  var _a;
  if (typeof window !== "undefined") {
    const win2 = window;
    const config2 = (_a = win2 === null || win2 === void 0 ? void 0 : win2.Ionic) === null || _a === void 0 ? void 0 : _a.config;
    if (config2) {
      const rel = config2.get("_rel");
      if (rel) {
        return rel(el2, eventName, callback, opts);
      } else if (config2._rel) {
        return config2._rel(el2, eventName, callback, opts);
      }
    }
  }
  return el2.removeEventListener(eventName, callback, opts);
};
const getElementRoot = (el2, fallback = el2) => {
  return el2.shadowRoot || fallback;
};
const raf = (h2) => {
  if (typeof __zone_symbol__requestAnimationFrame === "function") {
    return __zone_symbol__requestAnimationFrame(h2);
  }
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame(h2);
  }
  return setTimeout(h2);
};
const hasShadowDom = (el2) => {
  return !!el2.shadowRoot && !!el2.attachShadow;
};
const focusVisibleElement = (el2) => {
  el2.focus();
  if (el2.classList.contains("ion-focusable")) {
    const app = el2.closest("ion-app");
    if (app) {
      app.setFocus([el2]);
    }
  }
};
const renderHiddenInput = (always, container2, name, value, disabled) => {
  {
    let input = container2.querySelector("input.aux-input");
    if (!input) {
      input = container2.ownerDocument.createElement("input");
      input.type = "hidden";
      input.classList.add("aux-input");
      container2.appendChild(input);
    }
    input.disabled = disabled;
    input.name = name;
    input.value = value || "";
  }
};
const clamp = (min, n2, max) => {
  return Math.max(min, Math.min(n2, max));
};
const assert = (actual, reason) => {
  if (!actual) {
    const message = "ASSERT: " + reason;
    console.error(message);
    debugger;
    throw new Error(message);
  }
};
const pointerCoord = (ev) => {
  if (ev) {
    const changedTouches = ev.changedTouches;
    if (changedTouches && changedTouches.length > 0) {
      const touch = changedTouches[0];
      return { x: touch.clientX, y: touch.clientY };
    }
    if (ev.pageX !== void 0) {
      return { x: ev.pageX, y: ev.pageY };
    }
  }
  return { x: 0, y: 0 };
};
const debounceEvent = (event, wait) => {
  const original = event._original || event;
  return {
    _original: event,
    emit: debounce(original.emit.bind(original), wait)
  };
};
const debounce = (func, wait = 0) => {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(func, wait, ...args);
  };
};
const shallowEqualStringMap = (map1, map2) => {
  map1 !== null && map1 !== void 0 ? map1 : map1 = {};
  map2 !== null && map2 !== void 0 ? map2 : map2 = {};
  if (map1 === map2) {
    return true;
  }
  const keys1 = Object.keys(map1);
  if (keys1.length !== Object.keys(map2).length) {
    return false;
  }
  for (const k1 of keys1) {
    if (!(k1 in map2)) {
      return false;
    }
    if (map1[k1] !== map2[k1]) {
      return false;
    }
  }
  return true;
};
const LIFECYCLE_WILL_ENTER = "ionViewWillEnter";
const LIFECYCLE_DID_ENTER = "ionViewDidEnter";
const LIFECYCLE_WILL_LEAVE = "ionViewWillLeave";
const LIFECYCLE_DID_LEAVE = "ionViewDidLeave";
const LIFECYCLE_WILL_UNLOAD = "ionViewWillUnload";
const moveFocus = (el2) => {
  el2.tabIndex = -1;
  el2.focus();
};
const isVisible = (el2) => {
  return el2.offsetParent !== null;
};
const createFocusController = () => {
  const saveViewFocus = (referenceEl) => {
    const focusManagerEnabled = config.get("focusManagerPriority", false);
    if (focusManagerEnabled) {
      const activeEl = document.activeElement;
      if (activeEl !== null && (referenceEl === null || referenceEl === void 0 ? void 0 : referenceEl.contains(activeEl))) {
        activeEl.setAttribute(LAST_FOCUS, "true");
      }
    }
  };
  const setViewFocus = (referenceEl) => {
    const focusManagerPriorities = config.get("focusManagerPriority", false);
    if (Array.isArray(focusManagerPriorities) && !referenceEl.contains(document.activeElement)) {
      const lastFocus = referenceEl.querySelector("[".concat(LAST_FOCUS, "]"));
      if (lastFocus && isVisible(lastFocus)) {
        moveFocus(lastFocus);
        return;
      }
      for (const priority of focusManagerPriorities) {
        switch (priority) {
          case "content":
            const content = referenceEl.querySelector('main, [role="main"]');
            if (content && isVisible(content)) {
              moveFocus(content);
              return;
            }
            break;
          case "heading":
            const headingOne = referenceEl.querySelector('h1, [role="heading"][aria-level="1"]');
            if (headingOne && isVisible(headingOne)) {
              moveFocus(headingOne);
              return;
            }
            break;
          case "banner":
            const header = referenceEl.querySelector('header, [role="banner"]');
            if (header && isVisible(header)) {
              moveFocus(header);
              return;
            }
            break;
          default:
            printIonWarning("Unrecognized focus manager priority value ".concat(priority));
            break;
        }
      }
      moveFocus(referenceEl);
    }
  };
  return {
    saveViewFocus,
    setViewFocus
  };
};
const LAST_FOCUS = "ion-last-focus";
const iosTransitionAnimation = () => __vitePreload(() => import("./ios.transition-CYgTFrTn.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url);
const mdTransitionAnimation = () => __vitePreload(() => import("./md.transition-Dcfx6uNR.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url);
const focusController = createFocusController();
const transition = (opts) => {
  return new Promise((resolve, reject) => {
    writeTask$1(() => {
      beforeTransition(opts);
      runTransition(opts).then((result) => {
        if (result.animation) {
          result.animation.destroy();
        }
        afterTransition(opts);
        resolve(result);
      }, (error) => {
        afterTransition(opts);
        reject(error);
      });
    });
  });
};
const beforeTransition = (opts) => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  focusController.saveViewFocus(leavingEl);
  setZIndex(enteringEl, leavingEl, opts.direction);
  if (opts.showGoBack) {
    enteringEl.classList.add("can-go-back");
  } else {
    enteringEl.classList.remove("can-go-back");
  }
  setPageHidden(enteringEl, false);
  enteringEl.style.setProperty("pointer-events", "none");
  if (leavingEl) {
    setPageHidden(leavingEl, false);
    leavingEl.style.setProperty("pointer-events", "none");
  }
};
const runTransition = async (opts) => {
  const animationBuilder = await getAnimationBuilder(opts);
  const ani = animationBuilder && Build.isBrowser ? animation(animationBuilder, opts) : noAnimation(opts);
  return ani;
};
const afterTransition = (opts) => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  enteringEl.classList.remove("ion-page-invisible");
  enteringEl.style.removeProperty("pointer-events");
  if (leavingEl !== void 0) {
    leavingEl.classList.remove("ion-page-invisible");
    leavingEl.style.removeProperty("pointer-events");
  }
  focusController.setViewFocus(enteringEl);
};
const getAnimationBuilder = async (opts) => {
  if (!opts.leavingEl || !opts.animated || opts.duration === 0) {
    return void 0;
  }
  if (opts.animationBuilder) {
    return opts.animationBuilder;
  }
  const getAnimation = opts.mode === "ios" ? (await iosTransitionAnimation()).iosTransitionAnimation : (await mdTransitionAnimation()).mdTransitionAnimation;
  return getAnimation;
};
const animation = async (animationBuilder, opts) => {
  await waitForReady(opts, true);
  const trans = animationBuilder(opts.baseEl, opts);
  fireWillEvents(opts.enteringEl, opts.leavingEl);
  const didComplete = await playTransition(trans, opts);
  if (opts.progressCallback) {
    opts.progressCallback(void 0);
  }
  if (didComplete) {
    fireDidEvents(opts.enteringEl, opts.leavingEl);
  }
  return {
    hasCompleted: didComplete,
    animation: trans
  };
};
const noAnimation = async (opts) => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  const focusManagerEnabled = config.get("focusManagerPriority", false);
  await waitForReady(opts, focusManagerEnabled);
  fireWillEvents(enteringEl, leavingEl);
  fireDidEvents(enteringEl, leavingEl);
  return {
    hasCompleted: true
  };
};
const waitForReady = async (opts, defaultDeep) => {
  const deep = opts.deepWait !== void 0 ? opts.deepWait : defaultDeep;
  if (deep) {
    await Promise.all([deepReady(opts.enteringEl), deepReady(opts.leavingEl)]);
  }
  await notifyViewReady(opts.viewIsReady, opts.enteringEl);
};
const notifyViewReady = async (viewIsReady, enteringEl) => {
  if (viewIsReady) {
    await viewIsReady(enteringEl);
  }
};
const playTransition = (trans, opts) => {
  const progressCallback = opts.progressCallback;
  const promise = new Promise((resolve) => {
    trans.onFinish((currentStep) => resolve(currentStep === 1));
  });
  if (progressCallback) {
    trans.progressStart(true);
    progressCallback(trans);
  } else {
    trans.play();
  }
  return promise;
};
const fireWillEvents = (enteringEl, leavingEl) => {
  lifecycle(leavingEl, LIFECYCLE_WILL_LEAVE);
  lifecycle(enteringEl, LIFECYCLE_WILL_ENTER);
};
const fireDidEvents = (enteringEl, leavingEl) => {
  lifecycle(enteringEl, LIFECYCLE_DID_ENTER);
  lifecycle(leavingEl, LIFECYCLE_DID_LEAVE);
};
const lifecycle = (el2, eventName) => {
  if (el2) {
    const ev = new CustomEvent(eventName, {
      bubbles: false,
      cancelable: false
    });
    el2.dispatchEvent(ev);
  }
};
const waitForMount = () => {
  return new Promise((resolve) => raf(() => raf(() => resolve())));
};
const deepReady = async (el2) => {
  const element = el2;
  if (element) {
    if (element.componentOnReady != null) {
      const stencilEl = await element.componentOnReady();
      if (stencilEl != null) {
        return;
      }
    } else if (element.__registerHost != null) {
      const waitForCustomElement = new Promise((resolve) => raf(resolve));
      await waitForCustomElement;
      return;
    }
    await Promise.all(Array.from(element.children).map(deepReady));
  }
};
const setPageHidden = (el2, hidden) => {
  if (hidden) {
    el2.setAttribute("aria-hidden", "true");
    el2.classList.add("ion-page-hidden");
  } else {
    el2.hidden = false;
    el2.removeAttribute("aria-hidden");
    el2.classList.remove("ion-page-hidden");
  }
};
const setZIndex = (enteringEl, leavingEl, direction) => {
  if (enteringEl !== void 0) {
    enteringEl.style.zIndex = direction === "back" ? "99" : "101";
  }
  if (leavingEl !== void 0) {
    leavingEl.style.zIndex = "100";
  }
};
const getIonPageElement = (element) => {
  if (element.classList.contains("ion-page")) {
    return element;
  }
  const ionPage = element.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs");
  if (ionPage) {
    return ionPage;
  }
  return element;
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const getTimeGivenProgression = (p0, p1, p2, p3, progression) => {
  return solveCubicBezier(p0[1], p1[1], p2[1], p3[1], progression).map((tValue) => {
    return solveCubicParametricEquation(p0[0], p1[0], p2[0], p3[0], tValue);
  });
};
const solveCubicParametricEquation = (p0, p1, p2, p3, t2) => {
  const partA = 3 * p1 * Math.pow(t2 - 1, 2);
  const partB = -3 * p2 * t2 + 3 * p2 + p3 * t2;
  const partC = p0 * Math.pow(t2 - 1, 3);
  return t2 * (partA + t2 * partB) - partC;
};
const solveCubicBezier = (p0, p1, p2, p3, refPoint) => {
  p0 -= refPoint;
  p1 -= refPoint;
  p2 -= refPoint;
  p3 -= refPoint;
  const roots = solveCubicEquation(p3 - 3 * p2 + 3 * p1 - p0, 3 * p2 - 6 * p1 + 3 * p0, 3 * p1 - 3 * p0, p0);
  return roots.filter((root2) => root2 >= 0 && root2 <= 1);
};
const solveQuadraticEquation = (a, b2, c2) => {
  const discriminant = b2 * b2 - 4 * a * c2;
  if (discriminant < 0) {
    return [];
  } else {
    return [(-b2 + Math.sqrt(discriminant)) / (2 * a), (-b2 - Math.sqrt(discriminant)) / (2 * a)];
  }
};
const solveCubicEquation = (a, b2, c2, d2) => {
  if (a === 0) {
    return solveQuadraticEquation(b2, c2, d2);
  }
  b2 /= a;
  c2 /= a;
  d2 /= a;
  const p2 = (3 * c2 - b2 * b2) / 3;
  const q2 = (2 * b2 * b2 * b2 - 9 * b2 * c2 + 27 * d2) / 27;
  if (p2 === 0) {
    return [Math.pow(-q2, 1 / 3)];
  } else if (q2 === 0) {
    return [Math.sqrt(-p2), -Math.sqrt(-p2)];
  }
  const discriminant = Math.pow(q2 / 2, 2) + Math.pow(p2 / 3, 3);
  if (discriminant === 0) {
    return [Math.pow(q2 / 2, 1 / 2) - b2 / 3];
  } else if (discriminant > 0) {
    return [
      Math.pow(-(q2 / 2) + Math.sqrt(discriminant), 1 / 3) - Math.pow(q2 / 2 + Math.sqrt(discriminant), 1 / 3) - b2 / 3
    ];
  }
  const r2 = Math.sqrt(Math.pow(-(p2 / 3), 3));
  const phi = Math.acos(-(q2 / (2 * Math.sqrt(Math.pow(-(p2 / 3), 3)))));
  const s = 2 * Math.pow(r2, 1 / 3);
  return [
    s * Math.cos(phi / 3) - b2 / 3,
    s * Math.cos((phi + 2 * Math.PI) / 3) - b2 / 3,
    s * Math.cos((phi + 4 * Math.PI) / 3) - b2 / 3
  ];
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
class GestureController {
  constructor() {
    this.gestureId = 0;
    this.requestedStart = /* @__PURE__ */ new Map();
    this.disabledGestures = /* @__PURE__ */ new Map();
    this.disabledScroll = /* @__PURE__ */ new Set();
  }
  /**
   * Creates a gesture delegate based on the GestureConfig passed
   */
  createGesture(config2) {
    var _a;
    return new GestureDelegate(this, this.newID(), config2.name, (_a = config2.priority) !== null && _a !== void 0 ? _a : 0, !!config2.disableScroll);
  }
  /**
   * Creates a blocker that will block any other gesture events from firing. Set in the ion-gesture component.
   */
  createBlocker(opts = {}) {
    return new BlockerDelegate(this, this.newID(), opts.disable, !!opts.disableScroll);
  }
  start(gestureName, id2, priority) {
    if (!this.canStart(gestureName)) {
      this.requestedStart.delete(id2);
      return false;
    }
    this.requestedStart.set(id2, priority);
    return true;
  }
  capture(gestureName, id2, priority) {
    if (!this.start(gestureName, id2, priority)) {
      return false;
    }
    const requestedStart = this.requestedStart;
    let maxPriority = -1e4;
    requestedStart.forEach((value) => {
      maxPriority = Math.max(maxPriority, value);
    });
    if (maxPriority === priority) {
      this.capturedId = id2;
      requestedStart.clear();
      const event = new CustomEvent("ionGestureCaptured", { detail: { gestureName } });
      document.dispatchEvent(event);
      return true;
    }
    requestedStart.delete(id2);
    return false;
  }
  release(id2) {
    this.requestedStart.delete(id2);
    if (this.capturedId === id2) {
      this.capturedId = void 0;
    }
  }
  disableGesture(gestureName, id2) {
    let set = this.disabledGestures.get(gestureName);
    if (set === void 0) {
      set = /* @__PURE__ */ new Set();
      this.disabledGestures.set(gestureName, set);
    }
    set.add(id2);
  }
  enableGesture(gestureName, id2) {
    const set = this.disabledGestures.get(gestureName);
    if (set !== void 0) {
      set.delete(id2);
    }
  }
  disableScroll(id2) {
    this.disabledScroll.add(id2);
    if (this.disabledScroll.size === 1) {
      document.body.classList.add(BACKDROP_NO_SCROLL);
    }
  }
  enableScroll(id2) {
    this.disabledScroll.delete(id2);
    if (this.disabledScroll.size === 0) {
      document.body.classList.remove(BACKDROP_NO_SCROLL);
    }
  }
  canStart(gestureName) {
    if (this.capturedId !== void 0) {
      return false;
    }
    if (this.isDisabled(gestureName)) {
      return false;
    }
    return true;
  }
  isCaptured() {
    return this.capturedId !== void 0;
  }
  isScrollDisabled() {
    return this.disabledScroll.size > 0;
  }
  isDisabled(gestureName) {
    const disabled = this.disabledGestures.get(gestureName);
    if (disabled && disabled.size > 0) {
      return true;
    }
    return false;
  }
  newID() {
    this.gestureId++;
    return this.gestureId;
  }
}
class GestureDelegate {
  constructor(ctrl, id2, name, priority, disableScroll) {
    this.id = id2;
    this.name = name;
    this.disableScroll = disableScroll;
    this.priority = priority * 1e6 + id2;
    this.ctrl = ctrl;
  }
  canStart() {
    if (!this.ctrl) {
      return false;
    }
    return this.ctrl.canStart(this.name);
  }
  start() {
    if (!this.ctrl) {
      return false;
    }
    return this.ctrl.start(this.name, this.id, this.priority);
  }
  capture() {
    if (!this.ctrl) {
      return false;
    }
    const captured = this.ctrl.capture(this.name, this.id, this.priority);
    if (captured && this.disableScroll) {
      this.ctrl.disableScroll(this.id);
    }
    return captured;
  }
  release() {
    if (this.ctrl) {
      this.ctrl.release(this.id);
      if (this.disableScroll) {
        this.ctrl.enableScroll(this.id);
      }
    }
  }
  destroy() {
    this.release();
    this.ctrl = void 0;
  }
}
class BlockerDelegate {
  constructor(ctrl, id2, disable, disableScroll) {
    this.id = id2;
    this.disable = disable;
    this.disableScroll = disableScroll;
    this.ctrl = ctrl;
  }
  block() {
    if (!this.ctrl) {
      return;
    }
    if (this.disable) {
      for (const gesture of this.disable) {
        this.ctrl.disableGesture(gesture, this.id);
      }
    }
    if (this.disableScroll) {
      this.ctrl.disableScroll(this.id);
    }
  }
  unblock() {
    if (!this.ctrl) {
      return;
    }
    if (this.disable) {
      for (const gesture of this.disable) {
        this.ctrl.enableGesture(gesture, this.id);
      }
    }
    if (this.disableScroll) {
      this.ctrl.enableScroll(this.id);
    }
  }
  destroy() {
    this.unblock();
    this.ctrl = void 0;
  }
}
const BACKDROP_NO_SCROLL = "backdrop-no-scroll";
const GESTURE_CONTROLLER = new GestureController();
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const addEventListener = (el2, eventName, callback, opts) => {
  const listenerOpts = supportsPassive(el2) ? {
    capture: !!opts.capture,
    passive: !!opts.passive
  } : !!opts.capture;
  let add;
  let remove;
  if (el2["__zone_symbol__addEventListener"]) {
    add = "__zone_symbol__addEventListener";
    remove = "__zone_symbol__removeEventListener";
  } else {
    add = "addEventListener";
    remove = "removeEventListener";
  }
  el2[add](eventName, callback, listenerOpts);
  return () => {
    el2[remove](eventName, callback, listenerOpts);
  };
};
const supportsPassive = (node) => {
  if (_sPassive === void 0) {
    try {
      const opts = Object.defineProperty({}, "passive", {
        get: () => {
          _sPassive = true;
        }
      });
      node.addEventListener("optsTest", () => {
        return;
      }, opts);
    } catch (e2) {
      _sPassive = false;
    }
  }
  return !!_sPassive;
};
let _sPassive;
const MOUSE_WAIT = 2e3;
const createPointerEvents = (el2, pointerDown, pointerMove, pointerUp, options) => {
  let rmTouchStart;
  let rmTouchMove;
  let rmTouchEnd;
  let rmTouchCancel;
  let rmMouseStart;
  let rmMouseMove;
  let rmMouseUp;
  let lastTouchEvent = 0;
  const handleTouchStart = (ev) => {
    lastTouchEvent = Date.now() + MOUSE_WAIT;
    if (!pointerDown(ev)) {
      return;
    }
    if (!rmTouchMove && pointerMove) {
      rmTouchMove = addEventListener(el2, "touchmove", pointerMove, options);
    }
    if (!rmTouchEnd) {
      rmTouchEnd = addEventListener(ev.target, "touchend", handleTouchEnd, options);
    }
    if (!rmTouchCancel) {
      rmTouchCancel = addEventListener(ev.target, "touchcancel", handleTouchEnd, options);
    }
  };
  const handleMouseDown = (ev) => {
    if (lastTouchEvent > Date.now()) {
      return;
    }
    if (!pointerDown(ev)) {
      return;
    }
    if (!rmMouseMove && pointerMove) {
      rmMouseMove = addEventListener(getDocument(el2), "mousemove", pointerMove, options);
    }
    if (!rmMouseUp) {
      rmMouseUp = addEventListener(getDocument(el2), "mouseup", handleMouseUp, options);
    }
  };
  const handleTouchEnd = (ev) => {
    stopTouch();
    if (pointerUp) {
      pointerUp(ev);
    }
  };
  const handleMouseUp = (ev) => {
    stopMouse();
    if (pointerUp) {
      pointerUp(ev);
    }
  };
  const stopTouch = () => {
    if (rmTouchMove) {
      rmTouchMove();
    }
    if (rmTouchEnd) {
      rmTouchEnd();
    }
    if (rmTouchCancel) {
      rmTouchCancel();
    }
    rmTouchMove = rmTouchEnd = rmTouchCancel = void 0;
  };
  const stopMouse = () => {
    if (rmMouseMove) {
      rmMouseMove();
    }
    if (rmMouseUp) {
      rmMouseUp();
    }
    rmMouseMove = rmMouseUp = void 0;
  };
  const stop = () => {
    stopTouch();
    stopMouse();
  };
  const enable = (isEnabled = true) => {
    if (!isEnabled) {
      if (rmTouchStart) {
        rmTouchStart();
      }
      if (rmMouseStart) {
        rmMouseStart();
      }
      rmTouchStart = rmMouseStart = void 0;
      stop();
    } else {
      if (!rmTouchStart) {
        rmTouchStart = addEventListener(el2, "touchstart", handleTouchStart, options);
      }
      if (!rmMouseStart) {
        rmMouseStart = addEventListener(el2, "mousedown", handleMouseDown, options);
      }
    }
  };
  const destroy = () => {
    enable(false);
    pointerUp = pointerMove = pointerDown = void 0;
  };
  return {
    enable,
    stop,
    destroy
  };
};
const getDocument = (node) => {
  return node instanceof Document ? node : node.ownerDocument;
};
const createPanRecognizer = (direction, thresh, maxAngle) => {
  const radians = maxAngle * (Math.PI / 180);
  const isDirX = direction === "x";
  const maxCosine = Math.cos(radians);
  const threshold = thresh * thresh;
  let startX = 0;
  let startY = 0;
  let dirty = false;
  let isPan = 0;
  return {
    start(x2, y2) {
      startX = x2;
      startY = y2;
      isPan = 0;
      dirty = true;
    },
    detect(x2, y2) {
      if (!dirty) {
        return false;
      }
      const deltaX = x2 - startX;
      const deltaY = y2 - startY;
      const distance = deltaX * deltaX + deltaY * deltaY;
      if (distance < threshold) {
        return false;
      }
      const hypotenuse = Math.sqrt(distance);
      const cosine = (isDirX ? deltaX : deltaY) / hypotenuse;
      if (cosine > maxCosine) {
        isPan = 1;
      } else if (cosine < -maxCosine) {
        isPan = -1;
      } else {
        isPan = 0;
      }
      dirty = false;
      return true;
    },
    isGesture() {
      return isPan !== 0;
    },
    getDirection() {
      return isPan;
    }
  };
};
const createGesture = (config2) => {
  let hasCapturedPan = false;
  let hasStartedPan = false;
  let hasFiredStart = true;
  let isMoveQueued = false;
  const finalConfig = Object.assign({ disableScroll: false, direction: "x", gesturePriority: 0, passive: true, maxAngle: 40, threshold: 10 }, config2);
  const canStart = finalConfig.canStart;
  const onWillStart = finalConfig.onWillStart;
  const onStart = finalConfig.onStart;
  const onEnd = finalConfig.onEnd;
  const notCaptured = finalConfig.notCaptured;
  const onMove = finalConfig.onMove;
  const threshold = finalConfig.threshold;
  const passive = finalConfig.passive;
  const blurOnStart = finalConfig.blurOnStart;
  const detail = {
    type: "pan",
    startX: 0,
    startY: 0,
    startTime: 0,
    currentX: 0,
    currentY: 0,
    velocityX: 0,
    velocityY: 0,
    deltaX: 0,
    deltaY: 0,
    currentTime: 0,
    event: void 0,
    data: void 0
  };
  const pan = createPanRecognizer(finalConfig.direction, finalConfig.threshold, finalConfig.maxAngle);
  const gesture = GESTURE_CONTROLLER.createGesture({
    name: config2.gestureName,
    priority: config2.gesturePriority,
    disableScroll: config2.disableScroll
  });
  const pointerDown = (ev) => {
    const timeStamp = now(ev);
    if (hasStartedPan || !hasFiredStart) {
      return false;
    }
    updateDetail(ev, detail);
    detail.startX = detail.currentX;
    detail.startY = detail.currentY;
    detail.startTime = detail.currentTime = timeStamp;
    detail.velocityX = detail.velocityY = detail.deltaX = detail.deltaY = 0;
    detail.event = ev;
    if (canStart && canStart(detail) === false) {
      return false;
    }
    gesture.release();
    if (!gesture.start()) {
      return false;
    }
    hasStartedPan = true;
    if (threshold === 0) {
      return tryToCapturePan();
    }
    pan.start(detail.startX, detail.startY);
    return true;
  };
  const pointerMove = (ev) => {
    if (hasCapturedPan) {
      if (!isMoveQueued && hasFiredStart) {
        isMoveQueued = true;
        calcGestureData(detail, ev);
        requestAnimationFrame(fireOnMove);
      }
      return;
    }
    calcGestureData(detail, ev);
    if (pan.detect(detail.currentX, detail.currentY)) {
      if (!pan.isGesture() || !tryToCapturePan()) {
        abortGesture();
      }
    }
  };
  const fireOnMove = () => {
    if (!hasCapturedPan) {
      return;
    }
    isMoveQueued = false;
    if (onMove) {
      onMove(detail);
    }
  };
  const tryToCapturePan = () => {
    if (!gesture.capture()) {
      return false;
    }
    hasCapturedPan = true;
    hasFiredStart = false;
    detail.startX = detail.currentX;
    detail.startY = detail.currentY;
    detail.startTime = detail.currentTime;
    if (onWillStart) {
      onWillStart(detail).then(fireOnStart);
    } else {
      fireOnStart();
    }
    return true;
  };
  const blurActiveElement = () => {
    if (typeof document !== "undefined") {
      const activeElement = document.activeElement;
      if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur) {
        activeElement.blur();
      }
    }
  };
  const fireOnStart = () => {
    if (blurOnStart) {
      blurActiveElement();
    }
    if (onStart) {
      onStart(detail);
    }
    hasFiredStart = true;
  };
  const reset = () => {
    hasCapturedPan = false;
    hasStartedPan = false;
    isMoveQueued = false;
    hasFiredStart = true;
    gesture.release();
  };
  const pointerUp = (ev) => {
    const tmpHasCaptured = hasCapturedPan;
    const tmpHasFiredStart = hasFiredStart;
    reset();
    if (!tmpHasFiredStart) {
      return;
    }
    calcGestureData(detail, ev);
    if (tmpHasCaptured) {
      if (onEnd) {
        onEnd(detail);
      }
      return;
    }
    if (notCaptured) {
      notCaptured(detail);
    }
  };
  const pointerEvents = createPointerEvents(finalConfig.el, pointerDown, pointerMove, pointerUp, {
    capture: false,
    passive
  });
  const abortGesture = () => {
    reset();
    pointerEvents.stop();
    if (notCaptured) {
      notCaptured(detail);
    }
  };
  return {
    enable(enable = true) {
      if (!enable) {
        if (hasCapturedPan) {
          pointerUp(void 0);
        }
        reset();
      }
      pointerEvents.enable(enable);
    },
    destroy() {
      gesture.destroy();
      pointerEvents.destroy();
    }
  };
};
const calcGestureData = (detail, ev) => {
  if (!ev) {
    return;
  }
  const prevX = detail.currentX;
  const prevY = detail.currentY;
  const prevT = detail.currentTime;
  updateDetail(ev, detail);
  const currentX = detail.currentX;
  const currentY = detail.currentY;
  const timestamp = detail.currentTime = now(ev);
  const timeDelta = timestamp - prevT;
  if (timeDelta > 0 && timeDelta < 100) {
    const velocityX = (currentX - prevX) / timeDelta;
    const velocityY = (currentY - prevY) / timeDelta;
    detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;
    detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;
  }
  detail.deltaX = currentX - detail.startX;
  detail.deltaY = currentY - detail.startY;
  detail.event = ev;
};
const updateDetail = (ev, detail) => {
  let x2 = 0;
  let y2 = 0;
  if (ev) {
    const changedTouches = ev.changedTouches;
    if (changedTouches && changedTouches.length > 0) {
      const touch = changedTouches[0];
      x2 = touch.clientX;
      y2 = touch.clientY;
    } else if (ev.pageX !== void 0) {
      x2 = ev.pageX;
      y2 = ev.pageY;
    }
  }
  detail.currentX = x2;
  detail.currentY = y2;
};
const now = (ev) => {
  return ev.timeStamp || Date.now();
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const hostContext = (selector, el2) => {
  return el2.closest(selector) !== null;
};
const createColorClasses$2 = (color, cssClassMap) => {
  return typeof color === "string" && color.length > 0 ? Object.assign({ "ion-color": true, ["ion-color-".concat(color)]: true }, cssClassMap) : cssClassMap;
};
const getClassList = (classes) => {
  if (classes !== void 0) {
    const array = Array.isArray(classes) ? classes : classes.split(" ");
    return array.filter((c2) => c2 != null).map((c2) => c2.trim()).filter((c2) => c2 !== "");
  }
  return [];
};
const getClassMap = (classes) => {
  const map2 = {};
  getClassList(classes).forEach((c2) => map2[c2] = true);
  return map2;
};
const SCHEME = /^[a-z][a-z0-9+\-.]*:/;
const openURL = async (url, ev, direction, animation2) => {
  if (url != null && url[0] !== "#" && !SCHEME.test(url)) {
    const router = document.querySelector("ion-router");
    if (router) {
      if (ev != null) {
        ev.preventDefault();
      }
      return router.push(url, direction, animation2);
    }
  }
  return false;
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const shouldUseCloseWatcher = () => config.get("experimentalCloseWatcher", false) && win$2 !== void 0 && "CloseWatcher" in win$2;
const blockHardwareBackButton = () => {
  document.addEventListener("backbutton", () => {
  });
};
const startHardwareBackButton = () => {
  const doc2 = document;
  let busy = false;
  const backButtonCallback = () => {
    if (busy) {
      return;
    }
    let index = 0;
    let handlers = [];
    const ev = new CustomEvent("ionBackButton", {
      bubbles: false,
      detail: {
        register(priority, handler) {
          handlers.push({ priority, handler, id: index++ });
        }
      }
    });
    doc2.dispatchEvent(ev);
    const executeAction = async (handlerRegister) => {
      try {
        if (handlerRegister === null || handlerRegister === void 0 ? void 0 : handlerRegister.handler) {
          const result = handlerRegister.handler(processHandlers);
          if (result != null) {
            await result;
          }
        }
      } catch (e2) {
        console.error(e2);
      }
    };
    const processHandlers = () => {
      if (handlers.length > 0) {
        let selectedHandler = {
          priority: Number.MIN_SAFE_INTEGER,
          handler: () => void 0,
          id: -1
        };
        handlers.forEach((handler) => {
          if (handler.priority >= selectedHandler.priority) {
            selectedHandler = handler;
          }
        });
        busy = true;
        handlers = handlers.filter((handler) => handler.id !== selectedHandler.id);
        executeAction(selectedHandler).then(() => busy = false);
      }
    };
    processHandlers();
  };
  if (shouldUseCloseWatcher()) {
    let watcher;
    const configureWatcher = () => {
      watcher === null || watcher === void 0 ? void 0 : watcher.destroy();
      watcher = new win$2.CloseWatcher();
      watcher.onclose = () => {
        backButtonCallback();
        configureWatcher();
      };
    };
    configureWatcher();
  } else {
    doc2.addEventListener("backbutton", backButtonCallback);
  }
};
const OVERLAY_BACK_BUTTON_PRIORITY = 100;
const MENU_BACK_BUTTON_PRIORITY = 99;
const hardwareBackButton = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MENU_BACK_BUTTON_PRIORITY,
  OVERLAY_BACK_BUTTON_PRIORITY,
  blockHardwareBackButton,
  shouldUseCloseWatcher,
  startHardwareBackButton
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const attachComponent = async (delegate, container2, component, cssClasses, componentProps, inline) => {
  var _a;
  if (delegate) {
    return delegate.attachViewToDom(container2, component, componentProps, cssClasses);
  }
  if (!inline && typeof component !== "string" && !(component instanceof HTMLElement)) {
    throw new Error("framework delegate is missing");
  }
  const el2 = typeof component === "string" ? (_a = container2.ownerDocument) === null || _a === void 0 ? void 0 : _a.createElement(component) : component;
  if (cssClasses) {
    cssClasses.forEach((c2) => el2.classList.add(c2));
  }
  if (componentProps) {
    Object.assign(el2, componentProps);
  }
  container2.appendChild(el2);
  await new Promise((resolve) => componentOnReady(el2, resolve));
  return el2;
};
const detachComponent = (delegate, element) => {
  if (element) {
    if (delegate) {
      const container2 = element.parentElement;
      return delegate.removeViewFromDom(container2, element);
    }
    element.remove();
  }
  return Promise.resolve();
};
const CoreDelegate = () => {
  let BaseComponent;
  let Reference;
  const attachViewToDom = async (parentElement, userComponent, userComponentProps = {}, cssClasses = []) => {
    var _a, _b;
    BaseComponent = parentElement;
    let ChildComponent;
    if (userComponent) {
      const el2 = typeof userComponent === "string" ? (_a = BaseComponent.ownerDocument) === null || _a === void 0 ? void 0 : _a.createElement(userComponent) : userComponent;
      cssClasses.forEach((c2) => el2.classList.add(c2));
      Object.assign(el2, userComponentProps);
      BaseComponent.appendChild(el2);
      ChildComponent = el2;
      await new Promise((resolve) => componentOnReady(el2, resolve));
    } else if (BaseComponent.children.length > 0 && (BaseComponent.tagName === "ION-MODAL" || BaseComponent.tagName === "ION-POPOVER")) {
      const root2 = ChildComponent = BaseComponent.children[0];
      if (!root2.classList.contains("ion-delegate-host")) {
        const el2 = (_b = BaseComponent.ownerDocument) === null || _b === void 0 ? void 0 : _b.createElement("div");
        el2.classList.add("ion-delegate-host");
        cssClasses.forEach((c2) => el2.classList.add(c2));
        el2.append(...BaseComponent.children);
        BaseComponent.appendChild(el2);
        ChildComponent = el2;
      }
    }
    const app = document.querySelector("ion-app") || document.body;
    Reference = document.createComment("ionic teleport");
    BaseComponent.parentNode.insertBefore(Reference, BaseComponent);
    app.appendChild(BaseComponent);
    return ChildComponent !== null && ChildComponent !== void 0 ? ChildComponent : BaseComponent;
  };
  const removeViewFromDom = () => {
    if (BaseComponent && Reference) {
      Reference.parentNode.insertBefore(BaseComponent, Reference);
      Reference.remove();
    }
    return Promise.resolve();
  };
  return { attachViewToDom, removeViewFromDom };
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const focusableQueryString = '[tabindex]:not([tabindex^="-"]):not([hidden]):not([disabled]), input:not([type=hidden]):not([tabindex^="-"]):not([hidden]):not([disabled]), textarea:not([tabindex^="-"]):not([hidden]):not([disabled]), button:not([tabindex^="-"]):not([hidden]):not([disabled]), select:not([tabindex^="-"]):not([hidden]):not([disabled]), .ion-focusable:not([tabindex^="-"]):not([hidden]):not([disabled]), .ion-focusable[disabled="false"]:not([tabindex^="-"]):not([hidden])';
const focusFirstDescendant = (ref, fallbackElement) => {
  const firstInput = ref.querySelector(focusableQueryString);
  focusElementInContext(firstInput, fallbackElement !== null && fallbackElement !== void 0 ? fallbackElement : ref);
};
const focusLastDescendant = (ref, fallbackElement) => {
  const inputs = Array.from(ref.querySelectorAll(focusableQueryString));
  const lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;
  focusElementInContext(lastInput, fallbackElement !== null && fallbackElement !== void 0 ? fallbackElement : ref);
};
const focusElementInContext = (hostToFocus, fallbackElement) => {
  let elementToFocus = hostToFocus;
  const shadowRoot = hostToFocus === null || hostToFocus === void 0 ? void 0 : hostToFocus.shadowRoot;
  if (shadowRoot) {
    elementToFocus = shadowRoot.querySelector(focusableQueryString) || hostToFocus;
  }
  if (elementToFocus) {
    focusVisibleElement(elementToFocus);
  } else {
    fallbackElement.focus();
  }
};
let lastOverlayIndex = 0;
let lastId = 0;
const activeAnimations = /* @__PURE__ */ new WeakMap();
const prepareOverlay = (el2) => {
  if (typeof document !== "undefined") {
    connectListeners(document);
  }
  const overlayIndex = lastOverlayIndex++;
  el2.overlayIndex = overlayIndex;
};
const setOverlayId = (el2) => {
  if (!el2.hasAttribute("id")) {
    el2.id = "ion-overlay-".concat(++lastId);
  }
  return el2.id;
};
const isOverlayHidden = (overlay) => overlay.classList.contains("overlay-hidden");
const focusElementInOverlay = (hostToFocus, overlay) => {
  let elementToFocus = hostToFocus;
  const shadowRoot = hostToFocus === null || hostToFocus === void 0 ? void 0 : hostToFocus.shadowRoot;
  if (shadowRoot) {
    elementToFocus = shadowRoot.querySelector(focusableQueryString) || hostToFocus;
  }
  if (elementToFocus) {
    focusVisibleElement(elementToFocus);
  } else {
    overlay.focus();
  }
};
const trapKeyboardFocus = (ev, doc2) => {
  const lastOverlay = getPresentedOverlay(doc2, "ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker-legacy,ion-popover");
  const target = ev.target;
  if (!lastOverlay || !target) {
    return;
  }
  if (lastOverlay.classList.contains(FOCUS_TRAP_DISABLE_CLASS)) {
    return;
  }
  const trapScopedFocus = () => {
    if (lastOverlay === target) {
      lastOverlay.lastFocus = void 0;
    } else if (target.tagName === "ION-TOAST") {
      focusElementInOverlay(lastOverlay.lastFocus, lastOverlay);
    } else {
      const overlayRoot = getElementRoot(lastOverlay);
      if (!overlayRoot.contains(target)) {
        return;
      }
      const overlayWrapper = overlayRoot.querySelector(".ion-overlay-wrapper");
      if (!overlayWrapper) {
        return;
      }
      if (overlayWrapper.contains(target) || target === overlayRoot.querySelector("ion-backdrop")) {
        lastOverlay.lastFocus = target;
      } else {
        const lastFocus = lastOverlay.lastFocus;
        focusFirstDescendant(overlayWrapper, lastOverlay);
        if (lastFocus === doc2.activeElement) {
          focusLastDescendant(overlayWrapper, lastOverlay);
        }
        lastOverlay.lastFocus = doc2.activeElement;
      }
    }
  };
  const trapShadowFocus = () => {
    if (lastOverlay.contains(target)) {
      lastOverlay.lastFocus = target;
    } else if (target.tagName === "ION-TOAST") {
      focusElementInOverlay(lastOverlay.lastFocus, lastOverlay);
    } else {
      const lastFocus = lastOverlay.lastFocus;
      focusFirstDescendant(lastOverlay);
      if (lastFocus === doc2.activeElement) {
        focusLastDescendant(lastOverlay);
      }
      lastOverlay.lastFocus = doc2.activeElement;
    }
  };
  if (lastOverlay.shadowRoot) {
    trapShadowFocus();
  } else {
    trapScopedFocus();
  }
};
const connectListeners = (doc2) => {
  if (lastOverlayIndex === 0) {
    lastOverlayIndex = 1;
    doc2.addEventListener("focus", (ev) => {
      trapKeyboardFocus(ev, doc2);
    }, true);
    doc2.addEventListener("ionBackButton", (ev) => {
      const lastOverlay = getPresentedOverlay(doc2);
      if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {
        ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {
          lastOverlay.dismiss(void 0, BACKDROP);
        });
      }
    });
    if (!shouldUseCloseWatcher()) {
      doc2.addEventListener("keydown", (ev) => {
        if (ev.key === "Escape") {
          const lastOverlay = getPresentedOverlay(doc2);
          if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {
            lastOverlay.dismiss(void 0, BACKDROP);
          }
        }
      });
    }
  }
};
const getOverlays = (doc2, selector) => {
  if (selector === void 0) {
    selector = "ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker-legacy,ion-popover,ion-toast";
  }
  return Array.from(doc2.querySelectorAll(selector)).filter((c2) => c2.overlayIndex > 0);
};
const getPresentedOverlays = (doc2, overlayTag) => {
  return getOverlays(doc2, overlayTag).filter((o) => !isOverlayHidden(o));
};
const getPresentedOverlay = (doc2, overlayTag, id2) => {
  const overlays = getPresentedOverlays(doc2, overlayTag);
  return overlays[overlays.length - 1];
};
const setRootAriaHidden = (hidden = false) => {
  const root2 = getAppRoot(document);
  const viewContainer = root2.querySelector("ion-router-outlet, ion-nav, #ion-view-container-root");
  if (!viewContainer) {
    return;
  }
  if (hidden) {
    viewContainer.setAttribute("aria-hidden", "true");
  } else {
    viewContainer.removeAttribute("aria-hidden");
  }
};
const present = async (overlay, name, iosEnterAnimation2, mdEnterAnimation2, opts) => {
  var _a, _b;
  if (overlay.presented) {
    return;
  }
  if (overlay.el.tagName !== "ION-TOAST") {
    setRootAriaHidden(true);
  }
  document.body.classList.add(BACKDROP_NO_SCROLL);
  hideUnderlyingOverlaysFromScreenReaders(overlay.el);
  hideAnimatingOverlayFromScreenReaders(overlay.el);
  overlay.presented = true;
  overlay.willPresent.emit();
  (_a = overlay.willPresentShorthand) === null || _a === void 0 ? void 0 : _a.emit();
  const mode = getIonMode$2(overlay);
  const animationBuilder = overlay.enterAnimation ? overlay.enterAnimation : config.get(name, mode === "ios" ? iosEnterAnimation2 : mdEnterAnimation2);
  const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);
  if (completed) {
    overlay.didPresent.emit();
    (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();
  }
  if (overlay.el.tagName !== "ION-TOAST") {
    restoreElementFocus(overlay.el);
  }
  if (overlay.keyboardClose && (document.activeElement === null || !overlay.el.contains(document.activeElement))) {
    overlay.el.focus();
  }
  overlay.el.removeAttribute("aria-hidden");
};
const restoreElementFocus = async (overlayEl) => {
  let previousElement = document.activeElement;
  if (!previousElement) {
    return;
  }
  const shadowRoot = previousElement === null || previousElement === void 0 ? void 0 : previousElement.shadowRoot;
  if (shadowRoot) {
    previousElement = shadowRoot.querySelector(focusableQueryString) || previousElement;
  }
  await overlayEl.onDidDismiss();
  if (document.activeElement === null || document.activeElement === document.body) {
    previousElement.focus();
  }
};
const dismiss = async (overlay, data, role, name, iosLeaveAnimation2, mdLeaveAnimation2, opts) => {
  var _a, _b;
  if (!overlay.presented) {
    return false;
  }
  const overlaysNotToast = doc$1 !== void 0 ? getPresentedOverlays(doc$1).filter((o) => o.tagName !== "ION-TOAST") : [];
  const lastOverlayNotToast = overlaysNotToast.length === 1 && overlaysNotToast[0].id === overlay.el.id;
  if (lastOverlayNotToast) {
    setRootAriaHidden(false);
    document.body.classList.remove(BACKDROP_NO_SCROLL);
  }
  overlay.presented = false;
  try {
    hideAnimatingOverlayFromScreenReaders(overlay.el);
    overlay.el.style.setProperty("pointer-events", "none");
    overlay.willDismiss.emit({ data, role });
    (_a = overlay.willDismissShorthand) === null || _a === void 0 ? void 0 : _a.emit({ data, role });
    const mode = getIonMode$2(overlay);
    const animationBuilder = overlay.leaveAnimation ? overlay.leaveAnimation : config.get(name, mode === "ios" ? iosLeaveAnimation2 : mdLeaveAnimation2);
    if (role !== GESTURE) {
      await overlayAnimation(overlay, animationBuilder, overlay.el, opts);
    }
    overlay.didDismiss.emit({ data, role });
    (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({ data, role });
    const animations = activeAnimations.get(overlay) || [];
    animations.forEach((ani) => ani.destroy());
    activeAnimations.delete(overlay);
    overlay.el.classList.add("overlay-hidden");
    overlay.el.style.removeProperty("pointer-events");
    if (overlay.el.lastFocus !== void 0) {
      overlay.el.lastFocus = void 0;
    }
  } catch (err2) {
    console.error(err2);
  }
  overlay.el.remove();
  revealOverlaysToScreenReaders();
  return true;
};
const getAppRoot = (doc2) => {
  return doc2.querySelector("ion-app") || doc2.body;
};
const overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {
  baseEl.classList.remove("overlay-hidden");
  const aniRoot = overlay.el;
  const animation2 = animationBuilder(aniRoot, opts);
  if (!overlay.animated || !config.getBoolean("animated", true)) {
    animation2.duration(0);
  }
  if (overlay.keyboardClose) {
    animation2.beforeAddWrite(() => {
      const activeElement = baseEl.ownerDocument.activeElement;
      if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.matches("input,ion-input, ion-textarea")) {
        activeElement.blur();
      }
    });
  }
  const activeAni = activeAnimations.get(overlay) || [];
  activeAnimations.set(overlay, [...activeAni, animation2]);
  await animation2.play();
  return true;
};
const eventMethod = (element, eventName) => {
  let resolve;
  const promise = new Promise((r2) => resolve = r2);
  onceEvent(element, eventName, (event) => {
    resolve(event.detail);
  });
  return promise;
};
const onceEvent = (element, eventName, callback) => {
  const handler = (ev) => {
    removeEventListener(element, eventName, handler);
    callback(ev);
  };
  addEventListener$1(element, eventName, handler);
};
const BACKDROP = "backdrop";
const GESTURE = "gesture";
const OVERLAY_GESTURE_PRIORITY = 39;
const createTriggerController = () => {
  let destroyTriggerInteraction;
  const removeClickListener = () => {
    if (destroyTriggerInteraction) {
      destroyTriggerInteraction();
      destroyTriggerInteraction = void 0;
    }
  };
  const addClickListener = (el2, trigger) => {
    removeClickListener();
    const triggerEl = trigger !== void 0 ? document.getElementById(trigger) : null;
    if (!triggerEl) {
      printIonWarning('A trigger element with the ID "'.concat(trigger, '" was not found in the DOM. The trigger element must be in the DOM when the "trigger" property is set on an overlay component.'), el2);
      return;
    }
    const configureTriggerInteraction = (targetEl, overlayEl) => {
      const openOverlay = () => {
        overlayEl.present();
      };
      targetEl.addEventListener("click", openOverlay);
      return () => {
        targetEl.removeEventListener("click", openOverlay);
      };
    };
    destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el2);
  };
  return {
    addClickListener,
    removeClickListener
  };
};
const hideAnimatingOverlayFromScreenReaders = (overlay) => {
  if (doc$1 === void 0)
    return;
  overlay.setAttribute("aria-hidden", "true");
};
const hideUnderlyingOverlaysFromScreenReaders = (newTopMostOverlay) => {
  var _a;
  if (doc$1 === void 0)
    return;
  const overlays = getPresentedOverlays(doc$1);
  for (let i = overlays.length - 1; i >= 0; i--) {
    const presentedOverlay = overlays[i];
    const nextPresentedOverlay = (_a = overlays[i + 1]) !== null && _a !== void 0 ? _a : newTopMostOverlay;
    if (nextPresentedOverlay.hasAttribute("aria-hidden") || nextPresentedOverlay.tagName !== "ION-TOAST") {
      presentedOverlay.setAttribute("aria-hidden", "true");
    }
  }
};
const revealOverlaysToScreenReaders = () => {
  if (doc$1 === void 0)
    return;
  const overlays = getPresentedOverlays(doc$1);
  for (let i = overlays.length - 1; i >= 0; i--) {
    const currentOverlay = overlays[i];
    currentOverlay.removeAttribute("aria-hidden");
    if (currentOverlay.tagName !== "ION-TOAST") {
      break;
    }
  }
};
const FOCUS_TRAP_DISABLE_CLASS = "ion-disable-focus-trap";
function __rest(s, e2) {
  var t2 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const arrowBackSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='square' stroke-miterlimit='10' stroke-width='48' d='M244 400L100 256l144-144M120 256h292' class='ionicon-fill-none'/></svg>";
const chevronForward = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M184 112l144 144-144 144' class='ionicon-fill-none'/></svg>";
const closeCircle = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208 208-93.31 208-208S370.69 48 256 48zm75.31 260.69a16 16 0 11-22.62 22.62L256 278.63l-52.69 52.68a16 16 0 01-22.62-22.62L233.37 256l-52.68-52.69a16 16 0 0122.62-22.62L256 233.37l52.69-52.68a16 16 0 0122.62 22.62L278.63 256z'/></svg>";
const closeSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M400 145.49L366.51 112 256 222.51 145.49 112 112 145.49 222.51 256 112 366.51 145.49 400 256 289.49 366.51 400 400 366.51 289.49 256 400 145.49z'/></svg>";
const searchOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M221.09 64a157.09 157.09 0 10157.09 157.09A157.1 157.1 0 00221.09 64z' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><path stroke-linecap='round' stroke-miterlimit='10' d='M338.29 338.29L448 448' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const searchSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M464 428L339.92 303.9a160.48 160.48 0 0030.72-94.58C370.64 120.37 298.27 48 209.32 48S48 120.37 48 209.32s72.37 161.32 161.32 161.32a160.48 160.48 0 0094.58-30.72L428 464zM209.32 319.69a110.38 110.38 0 11110.37-110.37 110.5 110.5 0 01-110.37 110.37z'/></svg>";
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
let CACHED_MAP$1;
const getIconMap$1 = () => {
  if (typeof window === "undefined") {
    return /* @__PURE__ */ new Map();
  } else {
    if (!CACHED_MAP$1) {
      const win2 = window;
      win2.Ionicons = win2.Ionicons || {};
      CACHED_MAP$1 = win2.Ionicons.map = win2.Ionicons.map || /* @__PURE__ */ new Map();
    }
    return CACHED_MAP$1;
  }
};
const getUrl$1 = (i) => {
  let url = getSrc$1(i.src);
  if (url) {
    return url;
  }
  url = getName$1(i.name, i.icon, i.mode, i.ios, i.md);
  if (url) {
    return getNamedUrl$1(url, i);
  }
  if (i.icon) {
    url = getSrc$1(i.icon);
    if (url) {
      return url;
    }
    url = getSrc$1(i.icon[i.mode]);
    if (url) {
      return url;
    }
  }
  return null;
};
const getNamedUrl$1 = (iconName, iconEl) => {
  const url = getIconMap$1().get(iconName);
  if (url) {
    return url;
  }
  try {
    return getAssetPath$1("svg/".concat(iconName, ".svg"));
  } catch (e2) {
    console.warn('[Ionicons Warning]: Could not load icon with name "'.concat(iconName, '". Ensure that the icon is registered using addIcons or that the icon SVG data is passed directly to the icon component.'), iconEl);
  }
};
const getName$1 = (iconName, icon, mode, ios, md2) => {
  mode = (mode && toLower$1(mode)) === "ios" ? "ios" : "md";
  if (ios && mode === "ios") {
    iconName = toLower$1(ios);
  } else if (md2 && mode === "md") {
    iconName = toLower$1(md2);
  } else {
    if (!iconName && icon && !isSrc$1(icon)) {
      iconName = icon;
    }
    if (isStr$1(iconName)) {
      iconName = toLower$1(iconName);
    }
  }
  if (!isStr$1(iconName) || iconName.trim() === "") {
    return null;
  }
  const invalidChars = iconName.replace(/[a-z]|-|\d/gi, "");
  if (invalidChars !== "") {
    return null;
  }
  return iconName;
};
const getSrc$1 = (src) => {
  if (isStr$1(src)) {
    src = src.trim();
    if (isSrc$1(src)) {
      return src;
    }
  }
  return null;
};
const isSrc$1 = (str) => str.length > 0 && /(\/|\.)/.test(str);
const isStr$1 = (val) => typeof val === "string";
const toLower$1 = (val) => val.toLowerCase();
const inheritAttributes$1 = (el2, attributes = []) => {
  const attributeObject = {};
  attributes.forEach((attr) => {
    if (el2.hasAttribute(attr)) {
      const value = el2.getAttribute(attr);
      if (value !== null) {
        attributeObject[attr] = el2.getAttribute(attr);
      }
      el2.removeAttribute(attr);
    }
  });
  return attributeObject;
};
const isRTL$2 = (hostEl) => {
  if (hostEl) {
    if (hostEl.dir !== "") {
      return hostEl.dir.toLowerCase() === "rtl";
    }
  }
  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === "rtl";
};
const validateContent$1 = (svgContent) => {
  const div = document.createElement("div");
  div.innerHTML = svgContent;
  for (let i = div.childNodes.length - 1; i >= 0; i--) {
    if (div.childNodes[i].nodeName.toLowerCase() !== "svg") {
      div.removeChild(div.childNodes[i]);
    }
  }
  const svgElm = div.firstElementChild;
  if (svgElm && svgElm.nodeName.toLowerCase() === "svg") {
    const svgClass = svgElm.getAttribute("class") || "";
    svgElm.setAttribute("class", (svgClass + " s-ion-icon").trim());
    if (isValid$1(svgElm)) {
      return div.innerHTML;
    }
  }
  return "";
};
const isValid$1 = (elm) => {
  if (elm.nodeType === 1) {
    if (elm.nodeName.toLowerCase() === "script") {
      return false;
    }
    for (let i = 0; i < elm.attributes.length; i++) {
      const name = elm.attributes[i].name;
      if (isStr$1(name) && name.toLowerCase().indexOf("on") === 0) {
        return false;
      }
    }
    for (let i = 0; i < elm.childNodes.length; i++) {
      if (!isValid$1(elm.childNodes[i])) {
        return false;
      }
    }
  }
  return true;
};
const isSvgDataUrl$1 = (url) => url.startsWith("data:image/svg+xml");
const isEncodedDataUrl$1 = (url) => url.indexOf(";utf8,") !== -1;
const ioniconContent$1 = /* @__PURE__ */ new Map();
const requests$1 = /* @__PURE__ */ new Map();
let parser$1;
const getSvgContent$1 = (url, sanitize) => {
  let req = requests$1.get(url);
  if (!req) {
    if (typeof fetch !== "undefined" && typeof document !== "undefined") {
      if (isSvgDataUrl$1(url) && isEncodedDataUrl$1(url)) {
        if (!parser$1) {
          parser$1 = new DOMParser();
        }
        const doc2 = parser$1.parseFromString(url, "text/html");
        const svg = doc2.querySelector("svg");
        if (svg) {
          ioniconContent$1.set(url, svg.outerHTML);
        }
        return Promise.resolve();
      } else {
        req = fetch(url).then((rsp) => {
          if (rsp.ok) {
            return rsp.text().then((svgContent) => {
              if (svgContent && sanitize !== false) {
                svgContent = validateContent$1(svgContent);
              }
              ioniconContent$1.set(url, svgContent || "");
            });
          }
          ioniconContent$1.set(url, "");
        });
        requests$1.set(url, req);
      }
    } else {
      ioniconContent$1.set(url, "");
      return Promise.resolve();
    }
  }
  return req;
};
const iconCss$1 = ":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}@supports (background: -webkit-named-image(i)){:host(.icon-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}}@supports not selector(:dir(rtl)) and selector(:host-context([dir='rtl'])){:host(.icon-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}}:host(.flip-rtl):host-context([dir='rtl']) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}@supports selector(:dir(rtl)){:host(.flip-rtl:dir(rtl)) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.flip-rtl:dir(ltr)) .icon-inner{-webkit-transform:scaleX(1);transform:scaleX(1)}}:host(.icon-small){font-size:1.125rem !important}:host(.icon-large){font-size:2rem !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}";
const IonIconStyle0 = iconCss$1;
const Icon$1 = /* @__PURE__ */ proxyCustomElement$1(class Icon extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.iconName = null;
    this.inheritedAttributes = {};
    this.didLoadIcon = false;
    this.svgContent = void 0;
    this.isVisible = false;
    this.mode = getIonMode$1();
    this.color = void 0;
    this.ios = void 0;
    this.md = void 0;
    this.flipRtl = void 0;
    this.name = void 0;
    this.src = void 0;
    this.icon = void 0;
    this.size = void 0;
    this.lazy = false;
    this.sanitize = true;
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAttributes$1(this.el, ["aria-label"]);
  }
  connectedCallback() {
    this.waitUntilVisible(this.el, "50px", () => {
      this.isVisible = true;
      this.loadIcon();
    });
  }
  componentDidLoad() {
    if (!this.didLoadIcon) {
      this.loadIcon();
    }
  }
  disconnectedCallback() {
    if (this.io) {
      this.io.disconnect();
      this.io = void 0;
    }
  }
  waitUntilVisible(el2, rootMargin, cb2) {
    if (this.lazy && typeof window !== "undefined" && window.IntersectionObserver) {
      const io = this.io = new window.IntersectionObserver((data) => {
        if (data[0].isIntersecting) {
          io.disconnect();
          this.io = void 0;
          cb2();
        }
      }, { rootMargin });
      io.observe(el2);
    } else {
      cb2();
    }
  }
  loadIcon() {
    if (this.isVisible) {
      const url = getUrl$1(this);
      if (url) {
        if (ioniconContent$1.has(url)) {
          this.svgContent = ioniconContent$1.get(url);
        } else {
          getSvgContent$1(url, this.sanitize).then(() => this.svgContent = ioniconContent$1.get(url));
        }
        this.didLoadIcon = true;
      }
    }
    this.iconName = getName$1(this.name, this.icon, this.mode, this.ios, this.md);
  }
  render() {
    const { flipRtl, iconName, inheritedAttributes, el: el2 } = this;
    const mode = this.mode || "md";
    const shouldAutoFlip = iconName ? (iconName.includes("arrow") || iconName.includes("chevron")) && flipRtl !== false : false;
    const shouldBeFlippable = flipRtl || shouldAutoFlip;
    return h$1(Host$1, Object.assign({ role: "img", class: Object.assign(Object.assign({ [mode]: true }, createColorClasses$1(this.color)), { ["icon-".concat(this.size)]: !!this.size, "flip-rtl": shouldBeFlippable, "icon-rtl": shouldBeFlippable && isRTL$2(el2) }) }, inheritedAttributes), this.svgContent ? h$1("div", { class: "icon-inner", innerHTML: this.svgContent }) : h$1("div", { class: "icon-inner" }));
  }
  static get assetsDirs() {
    return ["svg"];
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "name": ["loadIcon"],
      "src": ["loadIcon"],
      "icon": ["loadIcon"],
      "ios": ["loadIcon"],
      "md": ["loadIcon"]
    };
  }
  static get style() {
    return IonIconStyle0;
  }
}, [1, "ion-icon", {
  "mode": [1025],
  "color": [1],
  "ios": [1],
  "md": [1],
  "flipRtl": [4, "flip-rtl"],
  "name": [513],
  "src": [1],
  "icon": [8],
  "size": [1],
  "lazy": [4],
  "sanitize": [4],
  "svgContent": [32],
  "isVisible": [32]
}, void 0, {
  "name": ["loadIcon"],
  "src": ["loadIcon"],
  "icon": ["loadIcon"],
  "ios": ["loadIcon"],
  "md": ["loadIcon"]
}]);
const getIonMode$1 = () => typeof document !== "undefined" && document.documentElement.getAttribute("mode") || "md";
const createColorClasses$1 = (color) => {
  return color ? {
    "ion-color": true,
    ["ion-color-".concat(color)]: true
  } : null;
};
function defineCustomElement$A() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-icon":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Icon$1);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const backdropIosCss = ":host{left:0;right:0;top:0;bottom:0;display:block;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);contain:strict;cursor:pointer;opacity:0.01;-ms-touch-action:none;touch-action:none;z-index:2}:host(.backdrop-hide){background:transparent}:host(.backdrop-no-tappable){cursor:auto}:host{background-color:var(--ion-backdrop-color, #000)}";
const IonBackdropIosStyle0 = backdropIosCss;
const backdropMdCss = ":host{left:0;right:0;top:0;bottom:0;display:block;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);contain:strict;cursor:pointer;opacity:0.01;-ms-touch-action:none;touch-action:none;z-index:2}:host(.backdrop-hide){background:transparent}:host(.backdrop-no-tappable){cursor:auto}:host{background-color:var(--ion-backdrop-color, #000)}";
const IonBackdropMdStyle0 = backdropMdCss;
const Backdrop = /* @__PURE__ */ proxyCustomElement$1(class Backdrop2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionBackdropTap = createEvent(this, "ionBackdropTap", 7);
    this.visible = true;
    this.tappable = true;
    this.stopPropagation = true;
  }
  onMouseDown(ev) {
    this.emitTap(ev);
  }
  emitTap(ev) {
    if (this.stopPropagation) {
      ev.preventDefault();
      ev.stopPropagation();
    }
    if (this.tappable) {
      this.ionBackdropTap.emit();
    }
  }
  render() {
    const mode = getIonMode$2(this);
    return h$1(Host$1, { key: "7abaf2c310aa399607451b14063265e8a5846938", "aria-hidden": "true", class: {
      [mode]: true,
      "backdrop-hide": !this.visible,
      "backdrop-no-tappable": !this.tappable
    } });
  }
  static get style() {
    return {
      ios: IonBackdropIosStyle0,
      md: IonBackdropMdStyle0
    };
  }
}, [33, "ion-backdrop", {
  "visible": [4],
  "tappable": [4],
  "stopPropagation": [4, "stop-propagation"]
}, [[2, "click", "onMouseDown"]]]);
function defineCustomElement$z() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-backdrop"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-backdrop":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Backdrop);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const buttonsIosCss = ".sc-ion-buttons-ios-h{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);z-index:99}.sc-ion-buttons-ios-s ion-button{--padding-top:0;--padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.sc-ion-buttons-ios-s ion-button{--padding-top:3px;--padding-bottom:3px;--padding-start:5px;--padding-end:5px;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;min-height:32px}.sc-ion-buttons-ios-s .button-has-icon-only{--padding-top:0;--padding-bottom:0}.sc-ion-buttons-ios-s ion-button:not(.button-round){--border-radius:4px}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button{--color:initial;--border-color:initial;--background-focused:var(--ion-color-contrast)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-solid,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-solid{--background:var(--ion-color-contrast);--background-focused:#000;--background-focused-opacity:.12;--background-activated:#000;--background-activated-opacity:.12;--background-hover:var(--ion-color-base);--background-hover-opacity:0.45;--color:var(--ion-color-base);--color-focused:var(--ion-color-base)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-clear,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-clear{--color-activated:var(--ion-color-contrast);--color-focused:var(--ion-color-contrast)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-outline,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-outline{--color-activated:var(--ion-color-base);--color-focused:var(--ion-color-contrast);--background-activated:var(--ion-color-contrast)}.sc-ion-buttons-ios-s .button-clear,.sc-ion-buttons-ios-s .button-outline{--background-activated:transparent;--background-focused:currentColor;--background-hover:transparent}.sc-ion-buttons-ios-s .button-solid:not(.ion-color){--background-focused:#000;--background-focused-opacity:.12;--background-activated:#000;--background-activated-opacity:.12}.sc-ion-buttons-ios-s ion-icon[slot=start]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-end:0.3em;margin-inline-end:0.3em;font-size:1.41em;line-height:0.67}.sc-ion-buttons-ios-s ion-icon[slot=end]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-start:0.4em;margin-inline-start:0.4em;font-size:1.41em;line-height:0.67}.sc-ion-buttons-ios-s ion-icon[slot=icon-only]{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;font-size:1.65em;line-height:0.67}";
const IonButtonsIosStyle0 = buttonsIosCss;
const buttonsMdCss = ".sc-ion-buttons-md-h{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);z-index:99}.sc-ion-buttons-md-s ion-button{--padding-top:0;--padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.sc-ion-buttons-md-s ion-button{--padding-top:3px;--padding-bottom:3px;--padding-start:8px;--padding-end:8px;--box-shadow:none;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;min-height:32px}.sc-ion-buttons-md-s .button-has-icon-only{--padding-top:0;--padding-bottom:0}.sc-ion-buttons-md-s ion-button:not(.button-round){--border-radius:2px}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button{--color:initial;--color-focused:var(--ion-color-contrast);--color-hover:var(--ion-color-contrast);--background-activated:transparent;--background-focused:var(--ion-color-contrast);--background-hover:var(--ion-color-contrast)}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button-solid,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button-solid{--background:var(--ion-color-contrast);--background-activated:transparent;--background-focused:var(--ion-color-shade);--background-hover:var(--ion-color-base);--color:var(--ion-color-base);--color-focused:var(--ion-color-base);--color-hover:var(--ion-color-base)}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button-outline,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button-outline{--border-color:var(--ion-color-contrast)}.sc-ion-buttons-md-s .button-has-icon-only.button-clear{--padding-top:12px;--padding-end:12px;--padding-bottom:12px;--padding-start:12px;--border-radius:50%;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;width:3rem;height:3rem}.sc-ion-buttons-md-s .button{--background-hover:currentColor}.sc-ion-buttons-md-s .button-solid{--color:var(--ion-toolbar-background, var(--ion-background-color, #fff));--background:var(--ion-toolbar-color, var(--ion-text-color, #424242));--background-activated:transparent;--background-focused:currentColor}.sc-ion-buttons-md-s .button-outline{--color:initial;--background:transparent;--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor;--border-color:currentColor}.sc-ion-buttons-md-s .button-clear{--color:initial;--background:transparent;--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor}.sc-ion-buttons-md-s ion-icon[slot=start]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-end:0.3em;margin-inline-end:0.3em;font-size:1.4em}.sc-ion-buttons-md-s ion-icon[slot=end]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-start:0.4em;margin-inline-start:0.4em;font-size:1.4em}.sc-ion-buttons-md-s ion-icon[slot=icon-only]{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;font-size:1.8em}";
const IonButtonsMdStyle0 = buttonsMdCss;
const Buttons = /* @__PURE__ */ proxyCustomElement$1(class Buttons2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.collapse = false;
  }
  render() {
    const mode = getIonMode$2(this);
    return h$1(Host$1, { key: "58c1fc5eb867d0731c63549b1ccb3ec3bbbe6e1b", class: {
      [mode]: true,
      ["buttons-collapse"]: this.collapse
    } }, h$1("slot", { key: "0c8f95b9840c8fa0c4e50be84c5159620a3eb5c8" }));
  }
  static get style() {
    return {
      ios: IonButtonsIosStyle0,
      md: IonButtonsMdStyle0
    };
  }
}, [38, "ion-buttons", {
  "collapse": [4]
}]);
function defineCustomElement$y() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-buttons"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-buttons":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Buttons);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$x = defineCustomElement$y;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const checkboxIosCss = ":host{--checkbox-background-checked:var(--ion-color-primary, #0054e9);--border-color-checked:var(--ion-color-primary, #0054e9);--checkmark-color:var(--ion-color-primary-contrast, #fff);--transition:none;display:inline-block;position:relative;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(.in-item){-ms-flex:1 1 0px;flex:1 1 0;width:100%;height:100%}:host([slot=start]),:host([slot=end]){-ms-flex:initial;flex:initial;width:auto}:host(.ion-color){--checkbox-background-checked:var(--ion-color-base);--border-color-checked:var(--ion-color-base);--checkmark-color:var(--ion-color-contrast)}.checkbox-wrapper{display:-ms-flexbox;display:flex;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;height:inherit;cursor:inherit}.label-text-wrapper{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}:host(.in-item) .label-text-wrapper,:host(.in-item:not(.checkbox-label-placement-stacked):not([slot])) .native-wrapper{margin-top:10px;margin-bottom:10px}:host(.in-item.checkbox-label-placement-stacked) .label-text-wrapper{margin-top:10px;margin-bottom:16px}:host(.in-item.checkbox-label-placement-stacked) .native-wrapper{margin-bottom:10px}.label-text-wrapper-hidden{display:none}input{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}.native-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}.checkbox-icon{border-radius:var(--border-radius);position:relative;width:var(--size);height:var(--size);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--checkbox-background);-webkit-box-sizing:border-box;box-sizing:border-box}.checkbox-icon path{fill:none;stroke:var(--checkmark-color);stroke-width:var(--checkmark-width);opacity:0}:host(.checkbox-justify-space-between) .checkbox-wrapper{-ms-flex-pack:justify;justify-content:space-between}:host(.checkbox-justify-start) .checkbox-wrapper{-ms-flex-pack:start;justify-content:start}:host(.checkbox-justify-end) .checkbox-wrapper{-ms-flex-pack:end;justify-content:end}:host(.checkbox-alignment-start) .checkbox-wrapper{-ms-flex-align:start;align-items:start}:host(.checkbox-alignment-center) .checkbox-wrapper{-ms-flex-align:center;align-items:center}:host(.checkbox-justify-space-between),:host(.checkbox-justify-start),:host(.checkbox-justify-end),:host(.checkbox-alignment-start),:host(.checkbox-alignment-center){display:block}:host(.checkbox-label-placement-start) .checkbox-wrapper{-ms-flex-direction:row;flex-direction:row}:host(.checkbox-label-placement-start) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px}:host(.checkbox-label-placement-end) .checkbox-wrapper{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.checkbox-label-placement-end) .label-text-wrapper{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0}:host(.checkbox-label-placement-fixed) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px}:host(.checkbox-label-placement-fixed) .label-text-wrapper{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}:host(.checkbox-label-placement-stacked) .checkbox-wrapper{-ms-flex-direction:column;flex-direction:column}:host(.checkbox-label-placement-stacked) .label-text-wrapper{-webkit-transform:scale(0.75);transform:scale(0.75);margin-left:0;margin-right:0;margin-bottom:16px;max-width:calc(100% / 0.75)}:host(.checkbox-label-placement-stacked.checkbox-alignment-start) .label-text-wrapper{-webkit-transform-origin:left top;transform-origin:left top}:host-context([dir=rtl]):host(.checkbox-label-placement-stacked.checkbox-alignment-start) .label-text-wrapper,:host-context([dir=rtl]).checkbox-label-placement-stacked.checkbox-alignment-start .label-text-wrapper{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){:host(.checkbox-label-placement-stacked.checkbox-alignment-start:dir(rtl)) .label-text-wrapper{-webkit-transform-origin:right top;transform-origin:right top}}:host(.checkbox-label-placement-stacked.checkbox-alignment-center) .label-text-wrapper{-webkit-transform-origin:center top;transform-origin:center top}:host-context([dir=rtl]):host(.checkbox-label-placement-stacked.checkbox-alignment-center) .label-text-wrapper,:host-context([dir=rtl]).checkbox-label-placement-stacked.checkbox-alignment-center .label-text-wrapper{-webkit-transform-origin:calc(100% - center) top;transform-origin:calc(100% - center) top}@supports selector(:dir(rtl)){:host(.checkbox-label-placement-stacked.checkbox-alignment-center:dir(rtl)) .label-text-wrapper{-webkit-transform-origin:calc(100% - center) top;transform-origin:calc(100% - center) top}}:host(.checkbox-checked) .checkbox-icon,:host(.checkbox-indeterminate) .checkbox-icon{border-color:var(--border-color-checked);background:var(--checkbox-background-checked)}:host(.checkbox-checked) .checkbox-icon path,:host(.checkbox-indeterminate) .checkbox-icon path{opacity:1}:host(.checkbox-disabled){pointer-events:none}:host{--border-radius:50%;--border-width:0.125rem;--border-style:solid;--border-color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.23);--checkbox-background:var(--ion-item-background, var(--ion-background-color, #fff));--size:min(1.375rem, 55.836px);--checkmark-width:1.5px}:host(.checkbox-disabled){opacity:0.3}";
const IonCheckboxIosStyle0 = checkboxIosCss;
const checkboxMdCss = ":host{--checkbox-background-checked:var(--ion-color-primary, #0054e9);--border-color-checked:var(--ion-color-primary, #0054e9);--checkmark-color:var(--ion-color-primary-contrast, #fff);--transition:none;display:inline-block;position:relative;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(.in-item){-ms-flex:1 1 0px;flex:1 1 0;width:100%;height:100%}:host([slot=start]),:host([slot=end]){-ms-flex:initial;flex:initial;width:auto}:host(.ion-color){--checkbox-background-checked:var(--ion-color-base);--border-color-checked:var(--ion-color-base);--checkmark-color:var(--ion-color-contrast)}.checkbox-wrapper{display:-ms-flexbox;display:flex;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;height:inherit;cursor:inherit}.label-text-wrapper{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}:host(.in-item) .label-text-wrapper,:host(.in-item:not(.checkbox-label-placement-stacked):not([slot])) .native-wrapper{margin-top:10px;margin-bottom:10px}:host(.in-item.checkbox-label-placement-stacked) .label-text-wrapper{margin-top:10px;margin-bottom:16px}:host(.in-item.checkbox-label-placement-stacked) .native-wrapper{margin-bottom:10px}.label-text-wrapper-hidden{display:none}input{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}.native-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}.checkbox-icon{border-radius:var(--border-radius);position:relative;width:var(--size);height:var(--size);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--checkbox-background);-webkit-box-sizing:border-box;box-sizing:border-box}.checkbox-icon path{fill:none;stroke:var(--checkmark-color);stroke-width:var(--checkmark-width);opacity:0}:host(.checkbox-justify-space-between) .checkbox-wrapper{-ms-flex-pack:justify;justify-content:space-between}:host(.checkbox-justify-start) .checkbox-wrapper{-ms-flex-pack:start;justify-content:start}:host(.checkbox-justify-end) .checkbox-wrapper{-ms-flex-pack:end;justify-content:end}:host(.checkbox-alignment-start) .checkbox-wrapper{-ms-flex-align:start;align-items:start}:host(.checkbox-alignment-center) .checkbox-wrapper{-ms-flex-align:center;align-items:center}:host(.checkbox-justify-space-between),:host(.checkbox-justify-start),:host(.checkbox-justify-end),:host(.checkbox-alignment-start),:host(.checkbox-alignment-center){display:block}:host(.checkbox-label-placement-start) .checkbox-wrapper{-ms-flex-direction:row;flex-direction:row}:host(.checkbox-label-placement-start) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px}:host(.checkbox-label-placement-end) .checkbox-wrapper{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.checkbox-label-placement-end) .label-text-wrapper{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0}:host(.checkbox-label-placement-fixed) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px}:host(.checkbox-label-placement-fixed) .label-text-wrapper{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}:host(.checkbox-label-placement-stacked) .checkbox-wrapper{-ms-flex-direction:column;flex-direction:column}:host(.checkbox-label-placement-stacked) .label-text-wrapper{-webkit-transform:scale(0.75);transform:scale(0.75);margin-left:0;margin-right:0;margin-bottom:16px;max-width:calc(100% / 0.75)}:host(.checkbox-label-placement-stacked.checkbox-alignment-start) .label-text-wrapper{-webkit-transform-origin:left top;transform-origin:left top}:host-context([dir=rtl]):host(.checkbox-label-placement-stacked.checkbox-alignment-start) .label-text-wrapper,:host-context([dir=rtl]).checkbox-label-placement-stacked.checkbox-alignment-start .label-text-wrapper{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){:host(.checkbox-label-placement-stacked.checkbox-alignment-start:dir(rtl)) .label-text-wrapper{-webkit-transform-origin:right top;transform-origin:right top}}:host(.checkbox-label-placement-stacked.checkbox-alignment-center) .label-text-wrapper{-webkit-transform-origin:center top;transform-origin:center top}:host-context([dir=rtl]):host(.checkbox-label-placement-stacked.checkbox-alignment-center) .label-text-wrapper,:host-context([dir=rtl]).checkbox-label-placement-stacked.checkbox-alignment-center .label-text-wrapper{-webkit-transform-origin:calc(100% - center) top;transform-origin:calc(100% - center) top}@supports selector(:dir(rtl)){:host(.checkbox-label-placement-stacked.checkbox-alignment-center:dir(rtl)) .label-text-wrapper{-webkit-transform-origin:calc(100% - center) top;transform-origin:calc(100% - center) top}}:host(.checkbox-checked) .checkbox-icon,:host(.checkbox-indeterminate) .checkbox-icon{border-color:var(--border-color-checked);background:var(--checkbox-background-checked)}:host(.checkbox-checked) .checkbox-icon path,:host(.checkbox-indeterminate) .checkbox-icon path{opacity:1}:host(.checkbox-disabled){pointer-events:none}:host{--border-radius:calc(var(--size) * .125);--border-width:2px;--border-style:solid;--border-color:rgb(var(--ion-text-color-rgb, 0, 0, 0), 0.6);--checkmark-width:3;--checkbox-background:var(--ion-item-background, var(--ion-background-color, #fff));--transition:background 180ms cubic-bezier(0.4, 0, 0.2, 1);--size:18px}.checkbox-icon path{stroke-dasharray:30;stroke-dashoffset:30}:host(.checkbox-checked) .checkbox-icon path,:host(.checkbox-indeterminate) .checkbox-icon path{stroke-dashoffset:0;-webkit-transition:stroke-dashoffset 90ms linear 90ms;transition:stroke-dashoffset 90ms linear 90ms}:host(.checkbox-disabled) .label-text-wrapper{opacity:0.38}:host(.checkbox-disabled) .native-wrapper{opacity:0.63}";
const IonCheckboxMdStyle0 = checkboxMdCss;
const Checkbox = /* @__PURE__ */ proxyCustomElement$1(class Checkbox2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.inputId = "ion-cb-".concat(checkboxIds++);
    this.inheritedAttributes = {};
    this.setChecked = (state) => {
      const isChecked = this.checked = state;
      this.ionChange.emit({
        checked: isChecked,
        value: this.value
      });
    };
    this.toggleChecked = (ev) => {
      ev.preventDefault();
      this.setFocus();
      this.setChecked(!this.checked);
      this.indeterminate = false;
    };
    this.onFocus = () => {
      this.ionFocus.emit();
    };
    this.onBlur = () => {
      this.ionBlur.emit();
    };
    this.onClick = (ev) => {
      if (this.disabled) {
        return;
      }
      this.toggleChecked(ev);
    };
    this.color = void 0;
    this.name = this.inputId;
    this.checked = false;
    this.indeterminate = false;
    this.disabled = false;
    this.value = "on";
    this.labelPlacement = "start";
    this.justify = void 0;
    this.alignment = void 0;
  }
  componentWillLoad() {
    this.inheritedAttributes = Object.assign({}, inheritAriaAttributes(this.el));
  }
  /** @internal */
  async setFocus() {
    if (this.focusEl) {
      this.focusEl.focus();
    }
  }
  render() {
    const { color, checked, disabled, el: el2, getSVGPath, indeterminate, inheritedAttributes, inputId, justify, labelPlacement, name, value, alignment } = this;
    const mode = getIonMode$2(this);
    const path = getSVGPath(mode, indeterminate);
    renderHiddenInput(true, el2, name, checked ? value : "", disabled);
    return h$1(Host$1, { key: "6dc787e1100521d08c4900104e1a3e2f594e919f", "aria-checked": indeterminate ? "mixed" : "".concat(checked), class: createColorClasses$2(color, {
      [mode]: true,
      "in-item": hostContext("ion-item", el2),
      "checkbox-checked": checked,
      "checkbox-disabled": disabled,
      "checkbox-indeterminate": indeterminate,
      interactive: true,
      ["checkbox-justify-".concat(justify)]: justify !== void 0,
      ["checkbox-alignment-".concat(alignment)]: alignment !== void 0,
      ["checkbox-label-placement-".concat(labelPlacement)]: true
    }), onClick: this.onClick }, h$1("label", { key: "68222fb736a5ec3f2e488649b0e2ce0417dcb224", class: "checkbox-wrapper" }, h$1("input", Object.assign({ key: "f12962d7e9b19c744cfdbdeccc67ae7f5d080281", type: "checkbox", checked: checked ? true : void 0, disabled, id: inputId, onChange: this.toggleChecked, onFocus: () => this.onFocus(), onBlur: () => this.onBlur(), ref: (focusEl) => this.focusEl = focusEl }, inheritedAttributes)), h$1("div", { key: "c72df2699414b1e5a41a1bc267bc634f0c93dcff", class: {
      "label-text-wrapper": true,
      "label-text-wrapper-hidden": el2.textContent === ""
    }, part: "label" }, h$1("slot", { key: "a2a80285178a7e0e3b536fc9ca26b8b444aa4307" })), h$1("div", { key: "c2b05e0d1fe8df5dcd72858220b5ff51ecaee4cc", class: "native-wrapper" }, h$1("svg", { key: "ee24913fded72258ebd9713654a6dba92a18fcf7", class: "checkbox-icon", viewBox: "0 0 24 24", part: "container" }, path))));
  }
  getSVGPath(mode, indeterminate) {
    let path = indeterminate ? h$1("path", { d: "M6 12L18 12", part: "mark" }) : h$1("path", { d: "M5.9,12.5l3.8,3.8l8.8-8.8", part: "mark" });
    if (mode === "md") {
      path = indeterminate ? h$1("path", { d: "M2 12H22", part: "mark" }) : h$1("path", { d: "M1.73,12.91 8.1,19.28 22.79,4.59", part: "mark" });
    }
    return path;
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: IonCheckboxIosStyle0,
      md: IonCheckboxMdStyle0
    };
  }
}, [33, "ion-checkbox", {
  "color": [513],
  "name": [1],
  "checked": [1028],
  "indeterminate": [1028],
  "disabled": [4],
  "value": [8],
  "labelPlacement": [1, "label-placement"],
  "justify": [1],
  "alignment": [1],
  "setFocus": [64]
}]);
let checkboxIds = 0;
function defineCustomElement$w() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-checkbox"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-checkbox":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Checkbox);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$v = defineCustomElement$w;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const rippleEffectCss = ":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:strict;pointer-events:none}:host(.unbounded){contain:layout size style}.ripple-effect{border-radius:50%;position:absolute;background-color:currentColor;color:inherit;contain:strict;opacity:0;-webkit-animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;will-change:transform, opacity;pointer-events:none}.fade-out{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1));-webkit-animation:150ms fadeOutAnimation forwards;animation:150ms fadeOutAnimation forwards}@-webkit-keyframes rippleAnimation{from{-webkit-animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@keyframes rippleAnimation{from{-webkit-animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@-webkit-keyframes fadeInAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:0.16}}@keyframes fadeInAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:0.16}}@-webkit-keyframes fadeOutAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0.16}to{opacity:0}}@keyframes fadeOutAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0.16}to{opacity:0}}";
const IonRippleEffectStyle0 = rippleEffectCss;
const RippleEffect = /* @__PURE__ */ proxyCustomElement$1(class RippleEffect2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.type = "bounded";
  }
  /**
   * Adds the ripple effect to the parent element.
   *
   * @param x The horizontal coordinate of where the ripple should start.
   * @param y The vertical coordinate of where the ripple should start.
   */
  async addRipple(x2, y2) {
    return new Promise((resolve) => {
      readTask(() => {
        const rect = this.el.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        const hypotenuse = Math.sqrt(width * width + height * height);
        const maxDim = Math.max(height, width);
        const maxRadius = this.unbounded ? maxDim : hypotenuse + PADDING;
        const initialSize = Math.floor(maxDim * INITIAL_ORIGIN_SCALE);
        const finalScale = maxRadius / initialSize;
        let posX = x2 - rect.left;
        let posY = y2 - rect.top;
        if (this.unbounded) {
          posX = width * 0.5;
          posY = height * 0.5;
        }
        const styleX = posX - initialSize * 0.5;
        const styleY = posY - initialSize * 0.5;
        const moveX = width * 0.5 - posX;
        const moveY = height * 0.5 - posY;
        writeTask$1(() => {
          const div = document.createElement("div");
          div.classList.add("ripple-effect");
          const style = div.style;
          style.top = styleY + "px";
          style.left = styleX + "px";
          style.width = style.height = initialSize + "px";
          style.setProperty("--final-scale", "".concat(finalScale));
          style.setProperty("--translate-end", "".concat(moveX, "px, ").concat(moveY, "px"));
          const container2 = this.el.shadowRoot || this.el;
          container2.appendChild(div);
          setTimeout(() => {
            resolve(() => {
              removeRipple(div);
            });
          }, 225 + 100);
        });
      });
    });
  }
  get unbounded() {
    return this.type === "unbounded";
  }
  render() {
    const mode = getIonMode$2(this);
    return h$1(Host$1, { key: "7ae559bda5d2c1856a45bfa150c2cb4f83373f8e", role: "presentation", class: {
      [mode]: true,
      unbounded: this.unbounded
    } });
  }
  get el() {
    return this;
  }
  static get style() {
    return IonRippleEffectStyle0;
  }
}, [1, "ion-ripple-effect", {
  "type": [1],
  "addRipple": [64]
}]);
const removeRipple = (ripple) => {
  ripple.classList.add("fade-out");
  setTimeout(() => {
    ripple.remove();
  }, 200);
};
const PADDING = 10;
const INITIAL_ORIGIN_SCALE = 0.5;
function defineCustomElement$u() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, RippleEffect);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const SIZE_TO_MEDIA = {
  xs: "(min-width: 0px)",
  sm: "(min-width: 576px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 992px)",
  xl: "(min-width: 1200px)"
};
const matchBreakpoint = (breakpoint) => {
  if (breakpoint === void 0 || breakpoint === "") {
    return true;
  }
  if (window.matchMedia) {
    const mediaQuery = SIZE_TO_MEDIA[breakpoint];
    return window.matchMedia(mediaQuery).matches;
  }
  return false;
};
const colCss = ":host{-webkit-padding-start:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-box-sizing:border-box;box-sizing:border-box;position:relative;-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;width:100%;max-width:100%;min-height:1px}@media (min-width: 576px){:host{-webkit-padding-start:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px))}}@media (min-width: 768px){:host{-webkit-padding-start:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px))}}@media (min-width: 992px){:host{-webkit-padding-start:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px))}}@media (min-width: 1200px){:host{-webkit-padding-start:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px))}}";
const IonColStyle0 = colCss;
const win$1 = typeof window !== "undefined" ? window : void 0;
const SUPPORTS_VARS = win$1 && !!(win$1.CSS && win$1.CSS.supports && win$1.CSS.supports("--a: 0"));
const BREAKPOINTS = ["", "xs", "sm", "md", "lg", "xl"];
const Col = /* @__PURE__ */ proxyCustomElement$1(class Col2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.offset = void 0;
    this.offsetXs = void 0;
    this.offsetSm = void 0;
    this.offsetMd = void 0;
    this.offsetLg = void 0;
    this.offsetXl = void 0;
    this.pull = void 0;
    this.pullXs = void 0;
    this.pullSm = void 0;
    this.pullMd = void 0;
    this.pullLg = void 0;
    this.pullXl = void 0;
    this.push = void 0;
    this.pushXs = void 0;
    this.pushSm = void 0;
    this.pushMd = void 0;
    this.pushLg = void 0;
    this.pushXl = void 0;
    this.size = void 0;
    this.sizeXs = void 0;
    this.sizeSm = void 0;
    this.sizeMd = void 0;
    this.sizeLg = void 0;
    this.sizeXl = void 0;
  }
  onResize() {
    forceUpdate(this);
  }
  // Loop through all of the breakpoints to see if the media query
  // matches and grab the column value from the relevant prop if so
  getColumns(property) {
    let matched;
    for (const breakpoint of BREAKPOINTS) {
      const matches2 = matchBreakpoint(breakpoint);
      const columns = this[property + breakpoint.charAt(0).toUpperCase() + breakpoint.slice(1)];
      if (matches2 && columns !== void 0) {
        matched = columns;
      }
    }
    return matched;
  }
  calculateSize() {
    const columns = this.getColumns("size");
    if (!columns || columns === "") {
      return;
    }
    const colSize = columns === "auto" ? "auto" : (
      // If CSS supports variables we should use the grid columns var
      SUPPORTS_VARS ? "calc(calc(".concat(columns, " / var(--ion-grid-columns, 12)) * 100%)") : (
        // Convert the columns to a percentage by dividing by the total number
        // of columns (12) and then multiplying by 100
        columns / 12 * 100 + "%"
      )
    );
    return {
      flex: "0 0 ".concat(colSize),
      width: "".concat(colSize),
      "max-width": "".concat(colSize)
    };
  }
  // Called by push, pull, and offset since they use the same calculations
  calculatePosition(property, modifier) {
    const columns = this.getColumns(property);
    if (!columns) {
      return;
    }
    const amount = SUPPORTS_VARS ? (
      // If CSS supports variables we should use the grid columns var
      "calc(calc(".concat(columns, " / var(--ion-grid-columns, 12)) * 100%)")
    ) : (
      // Convert the columns to a percentage by dividing by the total number
      // of columns (12) and then multiplying by 100
      columns > 0 && columns < 12 ? columns / 12 * 100 + "%" : "auto"
    );
    return {
      [modifier]: amount
    };
  }
  calculateOffset(isRTL2) {
    return this.calculatePosition("offset", isRTL2 ? "margin-right" : "margin-left");
  }
  calculatePull(isRTL2) {
    return this.calculatePosition("pull", isRTL2 ? "left" : "right");
  }
  calculatePush(isRTL2) {
    return this.calculatePosition("push", isRTL2 ? "right" : "left");
  }
  render() {
    const isRTL2 = document.dir === "rtl";
    const mode = getIonMode$2(this);
    return h$1(Host$1, { key: "32ed75d81dd09d9bc8999f6d42e5b3cb99c84d91", class: {
      [mode]: true
    }, style: Object.assign(Object.assign(Object.assign(Object.assign({}, this.calculateOffset(isRTL2)), this.calculatePull(isRTL2)), this.calculatePush(isRTL2)), this.calculateSize()) }, h$1("slot", { key: "38f8d0440c20cc6d1b1d6a654d07f16de61d8134" }));
  }
  static get style() {
    return IonColStyle0;
  }
}, [1, "ion-col", {
  "offset": [1],
  "offsetXs": [1, "offset-xs"],
  "offsetSm": [1, "offset-sm"],
  "offsetMd": [1, "offset-md"],
  "offsetLg": [1, "offset-lg"],
  "offsetXl": [1, "offset-xl"],
  "pull": [1],
  "pullXs": [1, "pull-xs"],
  "pullSm": [1, "pull-sm"],
  "pullMd": [1, "pull-md"],
  "pullLg": [1, "pull-lg"],
  "pullXl": [1, "pull-xl"],
  "push": [1],
  "pushXs": [1, "push-xs"],
  "pushSm": [1, "push-sm"],
  "pushMd": [1, "push-md"],
  "pushLg": [1, "push-lg"],
  "pushXl": [1, "push-xl"],
  "size": [1],
  "sizeXs": [1, "size-xs"],
  "sizeSm": [1, "size-sm"],
  "sizeMd": [1, "size-md"],
  "sizeLg": [1, "size-lg"],
  "sizeXl": [1, "size-xl"]
}, [[9, "resize", "onResize"]]]);
function defineCustomElement$1$b() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-col"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-col":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Col);
        }
        break;
    }
  });
}
const defineCustomElement$t = defineCustomElement$1$b;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const isRTL$1 = (hostEl) => {
  if (hostEl) {
    if (hostEl.dir !== "") {
      return hostEl.dir.toLowerCase() === "rtl";
    }
  }
  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === "rtl";
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const contentCss = ':host{--background:var(--ion-background-color, #fff);--color:var(--ion-text-color, #000);--padding-top:0px;--padding-bottom:0px;--padding-start:0px;--padding-end:0px;--keyboard-offset:0px;--offset-top:0px;--offset-bottom:0px;--overflow:auto;display:block;position:relative;-ms-flex:1;flex:1;width:100%;height:100%;margin:0 !important;padding:0 !important;font-family:var(--ion-font-family, inherit);contain:size style}:host(.ion-color) .inner-scroll{background:var(--ion-color-base);color:var(--ion-color-contrast)}#background-content{left:0px;right:0px;top:calc(var(--offset-top) * -1);bottom:calc(var(--offset-bottom) * -1);position:absolute;background:var(--background)}.inner-scroll{left:0px;right:0px;top:calc(var(--offset-top) * -1);bottom:calc(var(--offset-bottom) * -1);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:calc(var(--padding-top) + var(--offset-top));padding-bottom:calc(var(--padding-bottom) + var(--keyboard-offset) + var(--offset-bottom));position:absolute;color:var(--color);-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden;-ms-touch-action:pan-x pan-y pinch-zoom;touch-action:pan-x pan-y pinch-zoom}.scroll-y,.scroll-x{-webkit-overflow-scrolling:touch;z-index:0;will-change:scroll-position}.scroll-y{overflow-y:var(--overflow);overscroll-behavior-y:contain}.scroll-x{overflow-x:var(--overflow);overscroll-behavior-x:contain}.overscroll::before,.overscroll::after{position:absolute;width:1px;height:1px;content:""}.overscroll::before{bottom:-1px}.overscroll::after{top:-1px}:host(.content-sizing){display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;min-height:0;contain:none}:host(.content-sizing) .inner-scroll{position:relative;top:0;bottom:0;margin-top:calc(var(--offset-top) * -1);margin-bottom:calc(var(--offset-bottom) * -1)}.transition-effect{display:none;position:absolute;width:100%;height:100vh;opacity:0;pointer-events:none}:host(.content-ltr) .transition-effect{left:-100%;}:host(.content-rtl) .transition-effect{right:-100%;}.transition-cover{position:absolute;right:0;width:100%;height:100%;background:black;opacity:0.1}.transition-shadow{display:block;position:absolute;width:100%;height:100%;-webkit-box-shadow:inset -9px 0 9px 0 rgba(0, 0, 100, 0.03);box-shadow:inset -9px 0 9px 0 rgba(0, 0, 100, 0.03)}:host(.content-ltr) .transition-shadow{right:0;}:host(.content-rtl) .transition-shadow{left:0;-webkit-transform:scaleX(-1);transform:scaleX(-1)}::slotted([slot=fixed]){position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0)}';
const IonContentStyle0 = contentCss;
const Content = /* @__PURE__ */ proxyCustomElement$1(class Content2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionScrollStart = createEvent(this, "ionScrollStart", 7);
    this.ionScroll = createEvent(this, "ionScroll", 7);
    this.ionScrollEnd = createEvent(this, "ionScrollEnd", 7);
    this.watchDog = null;
    this.isScrolling = false;
    this.lastScroll = 0;
    this.queued = false;
    this.cTop = -1;
    this.cBottom = -1;
    this.isMainContent = true;
    this.resizeTimeout = null;
    this.inheritedAttributes = {};
    this.tabsElement = null;
    this.detail = {
      scrollTop: 0,
      scrollLeft: 0,
      type: "scroll",
      event: void 0,
      startX: 0,
      startY: 0,
      startTime: 0,
      currentX: 0,
      currentY: 0,
      velocityX: 0,
      velocityY: 0,
      deltaX: 0,
      deltaY: 0,
      currentTime: 0,
      data: void 0,
      isScrolling: true
    };
    this.color = void 0;
    this.fullscreen = false;
    this.fixedSlotPlacement = "after";
    this.forceOverscroll = void 0;
    this.scrollX = false;
    this.scrollY = true;
    this.scrollEvents = false;
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAriaAttributes(this.el);
  }
  connectedCallback() {
    this.isMainContent = this.el.closest("ion-menu, ion-popover, ion-modal") === null;
    if (hasLazyBuild(this.el)) {
      const closestTabs = this.tabsElement = this.el.closest("ion-tabs");
      if (closestTabs !== null) {
        this.tabsLoadCallback = () => this.resize();
        closestTabs.addEventListener("ionTabBarLoaded", this.tabsLoadCallback);
      }
    }
  }
  disconnectedCallback() {
    this.onScrollEnd();
    if (hasLazyBuild(this.el)) {
      const { tabsElement, tabsLoadCallback } = this;
      if (tabsElement !== null && tabsLoadCallback !== void 0) {
        tabsElement.removeEventListener("ionTabBarLoaded", tabsLoadCallback);
      }
      this.tabsElement = null;
      this.tabsLoadCallback = void 0;
    }
  }
  /**
   * Rotating certain devices can update
   * the safe area insets. As a result,
   * the fullscreen feature on ion-content
   * needs to be recalculated.
   *
   * We listen for "resize" because we
   * do not care what the orientation of
   * the device is. Other APIs
   * such as ScreenOrientation or
   * the deviceorientation event must have
   * permission from the user first whereas
   * the "resize" event does not.
   *
   * We also throttle the callback to minimize
   * thrashing when quickly resizing a window.
   */
  onResize() {
    if (this.resizeTimeout) {
      clearTimeout(this.resizeTimeout);
      this.resizeTimeout = null;
    }
    this.resizeTimeout = setTimeout(() => {
      if (this.el.offsetParent === null) {
        return;
      }
      this.resize();
    }, 100);
  }
  shouldForceOverscroll() {
    const { forceOverscroll } = this;
    const mode = getIonMode$2(this);
    return forceOverscroll === void 0 ? mode === "ios" && isPlatform("ios") : forceOverscroll;
  }
  resize() {
    {
      if (this.fullscreen) {
        readTask(() => this.readDimensions());
      } else if (this.cTop !== 0 || this.cBottom !== 0) {
        this.cTop = this.cBottom = 0;
        forceUpdate(this);
      }
    }
  }
  readDimensions() {
    const page = getPageElement(this.el);
    const top = Math.max(this.el.offsetTop, 0);
    const bottom = Math.max(page.offsetHeight - top - this.el.offsetHeight, 0);
    const dirty = top !== this.cTop || bottom !== this.cBottom;
    if (dirty) {
      this.cTop = top;
      this.cBottom = bottom;
      forceUpdate(this);
    }
  }
  onScroll(ev) {
    const timeStamp = Date.now();
    const shouldStart = !this.isScrolling;
    this.lastScroll = timeStamp;
    if (shouldStart) {
      this.onScrollStart();
    }
    if (!this.queued && this.scrollEvents) {
      this.queued = true;
      readTask((ts) => {
        this.queued = false;
        this.detail.event = ev;
        updateScrollDetail(this.detail, this.scrollEl, ts, shouldStart);
        this.ionScroll.emit(this.detail);
      });
    }
  }
  /**
   * Get the element where the actual scrolling takes place.
   * This element can be used to subscribe to `scroll` events or manually modify
   * `scrollTop`. However, it's recommended to use the API provided by `ion-content`:
   *
   * i.e. Using `ionScroll`, `ionScrollStart`, `ionScrollEnd` for scrolling events
   * and `scrollToPoint()` to scroll the content into a certain point.
   */
  async getScrollElement() {
    if (!this.scrollEl) {
      await new Promise((resolve) => componentOnReady(this.el, resolve));
    }
    return Promise.resolve(this.scrollEl);
  }
  /**
   * Returns the background content element.
   * @internal
   */
  async getBackgroundElement() {
    if (!this.backgroundContentEl) {
      await new Promise((resolve) => componentOnReady(this.el, resolve));
    }
    return Promise.resolve(this.backgroundContentEl);
  }
  /**
   * Scroll to the top of the component.
   *
   * @param duration The amount of time to take scrolling to the top. Defaults to `0`.
   */
  scrollToTop(duration = 0) {
    return this.scrollToPoint(void 0, 0, duration);
  }
  /**
   * Scroll to the bottom of the component.
   *
   * @param duration The amount of time to take scrolling to the bottom. Defaults to `0`.
   */
  async scrollToBottom(duration = 0) {
    const scrollEl = await this.getScrollElement();
    const y2 = scrollEl.scrollHeight - scrollEl.clientHeight;
    return this.scrollToPoint(void 0, y2, duration);
  }
  /**
   * Scroll by a specified X/Y distance in the component.
   *
   * @param x The amount to scroll by on the horizontal axis.
   * @param y The amount to scroll by on the vertical axis.
   * @param duration The amount of time to take scrolling by that amount.
   */
  async scrollByPoint(x2, y2, duration) {
    const scrollEl = await this.getScrollElement();
    return this.scrollToPoint(x2 + scrollEl.scrollLeft, y2 + scrollEl.scrollTop, duration);
  }
  /**
   * Scroll to a specified X/Y location in the component.
   *
   * @param x The point to scroll to on the horizontal axis.
   * @param y The point to scroll to on the vertical axis.
   * @param duration The amount of time to take scrolling to that point. Defaults to `0`.
   */
  async scrollToPoint(x2, y2, duration = 0) {
    const el2 = await this.getScrollElement();
    if (duration < 32) {
      if (y2 != null) {
        el2.scrollTop = y2;
      }
      if (x2 != null) {
        el2.scrollLeft = x2;
      }
      return;
    }
    let resolve;
    let startTime = 0;
    const promise = new Promise((r2) => resolve = r2);
    const fromY = el2.scrollTop;
    const fromX = el2.scrollLeft;
    const deltaY = y2 != null ? y2 - fromY : 0;
    const deltaX = x2 != null ? x2 - fromX : 0;
    const step = (timeStamp) => {
      const linearTime = Math.min(1, (timeStamp - startTime) / duration) - 1;
      const easedT = Math.pow(linearTime, 3) + 1;
      if (deltaY !== 0) {
        el2.scrollTop = Math.floor(easedT * deltaY + fromY);
      }
      if (deltaX !== 0) {
        el2.scrollLeft = Math.floor(easedT * deltaX + fromX);
      }
      if (easedT < 1) {
        requestAnimationFrame(step);
      } else {
        resolve();
      }
    };
    requestAnimationFrame((ts) => {
      startTime = ts;
      step(ts);
    });
    return promise;
  }
  onScrollStart() {
    this.isScrolling = true;
    this.ionScrollStart.emit({
      isScrolling: true
    });
    if (this.watchDog) {
      clearInterval(this.watchDog);
    }
    this.watchDog = setInterval(() => {
      if (this.lastScroll < Date.now() - 120) {
        this.onScrollEnd();
      }
    }, 100);
  }
  onScrollEnd() {
    if (this.watchDog)
      clearInterval(this.watchDog);
    this.watchDog = null;
    if (this.isScrolling) {
      this.isScrolling = false;
      this.ionScrollEnd.emit({
        isScrolling: false
      });
    }
  }
  render() {
    const { fixedSlotPlacement, inheritedAttributes, isMainContent, scrollX, scrollY, el: el2 } = this;
    const rtl = isRTL$1(el2) ? "rtl" : "ltr";
    const mode = getIonMode$2(this);
    const forceOverscroll = this.shouldForceOverscroll();
    const transitionShadow = mode === "ios";
    this.resize();
    return h$1(Host$1, Object.assign({ key: "f2a24aa66dbf5c76f9d4b06f708eb73cadc239df", role: isMainContent ? "main" : void 0, class: createColorClasses$2(this.color, {
      [mode]: true,
      "content-sizing": hostContext("ion-popover", this.el),
      overscroll: forceOverscroll,
      ["content-".concat(rtl)]: true
    }), style: {
      "--offset-top": "".concat(this.cTop, "px"),
      "--offset-bottom": "".concat(this.cBottom, "px")
    } }, inheritedAttributes), h$1("div", { key: "6480ca7648b278abb36477b3838bccbcd4995e2a", ref: (el3) => this.backgroundContentEl = el3, id: "background-content", part: "background" }), fixedSlotPlacement === "before" ? h$1("slot", { name: "fixed" }) : null, h$1("div", { key: "29a23b663f5f0215bb000820c01e1814c0d55985", class: {
      "inner-scroll": true,
      "scroll-x": scrollX,
      "scroll-y": scrollY,
      overscroll: (scrollX || scrollY) && forceOverscroll
    }, ref: (scrollEl) => this.scrollEl = scrollEl, onScroll: this.scrollEvents ? (ev) => this.onScroll(ev) : void 0, part: "scroll" }, h$1("slot", { key: "0fe1bd05609a4b88ae2ce9addf5d5dc5dc1806f0" })), transitionShadow ? h$1("div", { class: "transition-effect" }, h$1("div", { class: "transition-cover" }), h$1("div", { class: "transition-shadow" })) : null, fixedSlotPlacement === "after" ? h$1("slot", { name: "fixed" }) : null);
  }
  get el() {
    return this;
  }
  static get style() {
    return IonContentStyle0;
  }
}, [1, "ion-content", {
  "color": [513],
  "fullscreen": [4],
  "fixedSlotPlacement": [1, "fixed-slot-placement"],
  "forceOverscroll": [1028, "force-overscroll"],
  "scrollX": [4, "scroll-x"],
  "scrollY": [4, "scroll-y"],
  "scrollEvents": [4, "scroll-events"],
  "getScrollElement": [64],
  "getBackgroundElement": [64],
  "scrollToTop": [64],
  "scrollToBottom": [64],
  "scrollByPoint": [64],
  "scrollToPoint": [64]
}, [[9, "resize", "onResize"]]]);
const getParentElement = (el2) => {
  var _a;
  if (el2.parentElement) {
    return el2.parentElement;
  }
  if ((_a = el2.parentNode) === null || _a === void 0 ? void 0 : _a.host) {
    return el2.parentNode.host;
  }
  return null;
};
const getPageElement = (el2) => {
  const tabs = el2.closest("ion-tabs");
  if (tabs) {
    return tabs;
  }
  const page = el2.closest("ion-app, ion-page, .ion-page, page-inner, .popover-content");
  if (page) {
    return page;
  }
  return getParentElement(el2);
};
const updateScrollDetail = (detail, el2, timestamp, shouldStart) => {
  const prevX = detail.currentX;
  const prevY = detail.currentY;
  const prevT = detail.currentTime;
  const currentX = el2.scrollLeft;
  const currentY = el2.scrollTop;
  const timeDelta = timestamp - prevT;
  if (shouldStart) {
    detail.startTime = timestamp;
    detail.startX = currentX;
    detail.startY = currentY;
    detail.velocityX = detail.velocityY = 0;
  }
  detail.currentTime = timestamp;
  detail.currentX = detail.scrollLeft = currentX;
  detail.currentY = detail.scrollTop = currentY;
  detail.deltaX = currentX - detail.startX;
  detail.deltaY = currentY - detail.startY;
  if (timeDelta > 0 && timeDelta < 100) {
    const velocityX = (currentX - prevX) / timeDelta;
    const velocityY = (currentY - prevY) / timeDelta;
    detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;
    detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;
  }
};
function defineCustomElement$s() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-content"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-content":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Content);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$r = defineCustomElement$s;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const buttonIosCss = ':host{--overflow:hidden;--ripple-color:currentColor;--border-width:initial;--border-color:initial;--border-style:initial;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--box-shadow:none;display:inline-block;width:auto;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;white-space:normal;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:top;vertical-align:-webkit-baseline-middle;-webkit-font-kerning:none;font-kerning:none}:host(.button-disabled){cursor:default;opacity:0.5;pointer-events:none}:host(.button-solid){--background:var(--ion-color-primary, #0054e9);--color:var(--ion-color-primary-contrast, #fff)}:host(.button-outline){--border-color:var(--ion-color-primary, #0054e9);--background:transparent;--color:var(--ion-color-primary, #0054e9)}:host(.button-clear){--border-width:0;--background:transparent;--color:var(--ion-color-primary, #0054e9)}:host(.button-block){display:block}:host(.button-block) .button-native{margin-left:0;margin-right:0;width:100%;clear:both;contain:content}:host(.button-block) .button-native::after{clear:both}:host(.button-full){display:block}:host(.button-full) .button-native{margin-left:0;margin-right:0;width:100%;contain:content}:host(.button-full:not(.button-round)) .button-native{border-radius:0;border-right-width:0;border-left-width:0}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;width:100%;height:100%;min-height:inherit;-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);line-height:1;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);contain:layout style;cursor:pointer;opacity:var(--opacity);overflow:var(--overflow);z-index:0;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}.button-native::-moz-focus-inner{border:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}::slotted([slot=start]),::slotted([slot=end]){-ms-flex-negative:0;flex-shrink:0}::slotted(ion-icon){font-size:1.35em;pointer-events:none}::slotted(ion-icon[slot=start]){-webkit-margin-start:-0.3em;margin-inline-start:-0.3em;-webkit-margin-end:0.3em;margin-inline-end:0.3em;margin-top:0;margin-bottom:0}::slotted(ion-icon[slot=end]){-webkit-margin-start:0.3em;margin-inline-start:0.3em;-webkit-margin-end:-0.2em;margin-inline-end:-0.2em;margin-top:0;margin-bottom:0}ion-ripple-effect{color:var(--ripple-color)}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}:host(.ion-focused){color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){:host(:hover){color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.ion-activated){color:var(--color-activated)}:host(.ion-activated) .button-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.button-solid.ion-color) .button-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.button-outline.ion-color) .button-native{border-color:var(--ion-color-base);background:transparent;color:var(--ion-color-base)}:host(.button-clear.ion-color) .button-native{background:transparent;color:var(--ion-color-base)}:host(.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{color:var(--ion-toolbar-color, var(--color))}:host(.button-outline.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{border-color:var(--ion-toolbar-color, var(--color, var(--border-color)))}:host(.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--background));color:var(--ion-toolbar-background, var(--color))}:host{--border-radius:14px;--padding-top:13px;--padding-bottom:13px;--padding-start:1em;--padding-end:1em;--transition:background-color, opacity 100ms linear;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;margin-top:4px;margin-bottom:4px;min-height:3.1em;font-size:min(1rem, 48px);font-weight:500;letter-spacing:0}:host(.button-solid){--background-activated:var(--ion-color-primary-shade, #004acd);--background-focused:var(--ion-color-primary-shade, #004acd);--background-hover:var(--ion-color-primary-tint, #1a65eb);--background-activated-opacity:1;--background-focused-opacity:1;--background-hover-opacity:1}:host(.button-outline){--border-radius:14px;--border-width:1px;--border-style:solid;--background-activated:var(--ion-color-primary, #0054e9);--background-focused:var(--ion-color-primary, #0054e9);--background-hover:transparent;--background-focused-opacity:.1;--color-activated:var(--ion-color-primary-contrast, #fff)}:host(.button-clear){--background-activated:transparent;--background-activated-opacity:0;--background-focused:var(--ion-color-primary, #0054e9);--background-hover:transparent;--background-focused-opacity:.1;font-size:min(1.0625rem, 51px);font-weight:normal}:host(.in-buttons){font-size:clamp(17px, 1.0625rem, 21.08px);font-weight:400}:host(.button-large){--border-radius:16px;--padding-top:17px;--padding-start:1em;--padding-end:1em;--padding-bottom:17px;min-height:3.1em;font-size:min(1.25rem, 60px)}:host(.button-small){--border-radius:6px;--padding-top:4px;--padding-start:0.9em;--padding-end:0.9em;--padding-bottom:4px;min-height:2.1em;font-size:min(0.8125rem, 39px)}:host(.button-round){--border-radius:999px;--padding-top:0;--padding-start:26px;--padding-end:26px;--padding-bottom:0}:host(.button-strong){font-weight:600}:host(.button-has-icon-only){--padding-top:0;--padding-bottom:var(--padding-top);--padding-end:var(--padding-top);--padding-start:var(--padding-end);min-width:clamp(30px, 2.125em, 60px);min-height:clamp(30px, 2.125em, 60px)}::slotted(ion-icon[slot=icon-only]){font-size:clamp(15.12px, 1.125em, 43.02px)}:host(.button-small.button-has-icon-only){min-width:clamp(23px, 2.16em, 54px);min-height:clamp(23px, 2.16em, 54px)}:host(.button-small) ::slotted(ion-icon[slot=icon-only]){font-size:clamp(12.1394px, 1.308125em, 40.1856px)}:host(.button-large.button-has-icon-only){min-width:clamp(46px, 2.5em, 78px);min-height:clamp(46px, 2.5em, 78px)}:host(.button-large) ::slotted(ion-icon[slot=icon-only]){font-size:clamp(15.12px, 0.9em, 43.056px)}:host(.button-outline.ion-focused.ion-color) .button-native,:host(.button-clear.ion-focused.ion-color) .button-native{color:var(--ion-color-base)}:host(.button-outline.ion-focused.ion-color) .button-native::after,:host(.button-clear.ion-focused.ion-color) .button-native::after{background:var(--ion-color-base)}:host(.button-solid.ion-color.ion-focused) .button-native::after{background:var(--ion-color-shade)}@media (any-hover: hover){:host(.button-clear:not(.ion-activated):hover),:host(.button-outline:not(.ion-activated):hover){opacity:0.6}:host(.button-clear.ion-color:hover) .button-native,:host(.button-outline.ion-color:hover) .button-native{color:var(--ion-color-base)}:host(.button-clear.ion-color:hover) .button-native::after,:host(.button-outline.ion-color:hover) .button-native::after{background:transparent}:host(.button-solid.ion-color:hover) .button-native::after{background:var(--ion-color-tint)}:host(:hover.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color):not(.ion-activated)) .button-native::after{background:#fff;opacity:0.1}}:host(.button-clear.ion-activated){opacity:0.4}:host(.button-outline.ion-activated.ion-color) .button-native{color:var(--ion-color-contrast)}:host(.button-outline.ion-activated.ion-color) .button-native::after{background:var(--ion-color-base)}:host(.button-solid.ion-color.ion-activated) .button-native::after{background:var(--ion-color-shade)}:host(.button-outline.ion-activated.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--color));color:var(--ion-toolbar-background, var(--background), var(--ion-color-primary-contrast, #fff))}';
const IonButtonIosStyle0 = buttonIosCss;
const buttonMdCss = ':host{--overflow:hidden;--ripple-color:currentColor;--border-width:initial;--border-color:initial;--border-style:initial;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--box-shadow:none;display:inline-block;width:auto;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;white-space:normal;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:top;vertical-align:-webkit-baseline-middle;-webkit-font-kerning:none;font-kerning:none}:host(.button-disabled){cursor:default;opacity:0.5;pointer-events:none}:host(.button-solid){--background:var(--ion-color-primary, #0054e9);--color:var(--ion-color-primary-contrast, #fff)}:host(.button-outline){--border-color:var(--ion-color-primary, #0054e9);--background:transparent;--color:var(--ion-color-primary, #0054e9)}:host(.button-clear){--border-width:0;--background:transparent;--color:var(--ion-color-primary, #0054e9)}:host(.button-block){display:block}:host(.button-block) .button-native{margin-left:0;margin-right:0;width:100%;clear:both;contain:content}:host(.button-block) .button-native::after{clear:both}:host(.button-full){display:block}:host(.button-full) .button-native{margin-left:0;margin-right:0;width:100%;contain:content}:host(.button-full:not(.button-round)) .button-native{border-radius:0;border-right-width:0;border-left-width:0}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;width:100%;height:100%;min-height:inherit;-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);line-height:1;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);contain:layout style;cursor:pointer;opacity:var(--opacity);overflow:var(--overflow);z-index:0;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}.button-native::-moz-focus-inner{border:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}::slotted([slot=start]),::slotted([slot=end]){-ms-flex-negative:0;flex-shrink:0}::slotted(ion-icon){font-size:1.35em;pointer-events:none}::slotted(ion-icon[slot=start]){-webkit-margin-start:-0.3em;margin-inline-start:-0.3em;-webkit-margin-end:0.3em;margin-inline-end:0.3em;margin-top:0;margin-bottom:0}::slotted(ion-icon[slot=end]){-webkit-margin-start:0.3em;margin-inline-start:0.3em;-webkit-margin-end:-0.2em;margin-inline-end:-0.2em;margin-top:0;margin-bottom:0}ion-ripple-effect{color:var(--ripple-color)}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}:host(.ion-focused){color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){:host(:hover){color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.ion-activated){color:var(--color-activated)}:host(.ion-activated) .button-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.button-solid.ion-color) .button-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.button-outline.ion-color) .button-native{border-color:var(--ion-color-base);background:transparent;color:var(--ion-color-base)}:host(.button-clear.ion-color) .button-native{background:transparent;color:var(--ion-color-base)}:host(.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{color:var(--ion-toolbar-color, var(--color))}:host(.button-outline.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{border-color:var(--ion-toolbar-color, var(--color, var(--border-color)))}:host(.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--background));color:var(--ion-toolbar-background, var(--color))}:host{--border-radius:4px;--padding-top:8px;--padding-bottom:8px;--padding-start:1.1em;--padding-end:1.1em;--transition:box-shadow 280ms cubic-bezier(.4, 0, .2, 1),\n                background-color 15ms linear,\n                color 15ms linear;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;margin-top:4px;margin-bottom:4px;min-height:36px;font-size:0.875rem;font-weight:500;letter-spacing:0.06em;text-transform:uppercase}:host(.button-solid){--background-activated:transparent;--background-hover:var(--ion-color-primary-contrast, #fff);--background-focused:var(--ion-color-primary-contrast, #fff);--background-activated-opacity:0;--background-focused-opacity:.24;--background-hover-opacity:.08;--box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)}:host(.button-solid.ion-activated){--box-shadow:0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12)}:host(.button-outline){--border-width:2px;--border-style:solid;--box-shadow:none;--background-activated:transparent;--background-focused:var(--ion-color-primary, #0054e9);--background-hover:var(--ion-color-primary, #0054e9);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04}:host(.button-outline.ion-activated.ion-color) .button-native{background:transparent}:host(.button-clear){--background-activated:transparent;--background-focused:var(--ion-color-primary, #0054e9);--background-hover:var(--ion-color-primary, #0054e9);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04}:host(.button-round){--border-radius:999px;--padding-top:0;--padding-start:26px;--padding-end:26px;--padding-bottom:0}:host(.button-large){--padding-top:14px;--padding-start:1em;--padding-end:1em;--padding-bottom:14px;min-height:2.8em;font-size:1.25rem}:host(.button-small){--padding-top:4px;--padding-start:0.9em;--padding-end:0.9em;--padding-bottom:4px;min-height:2.1em;font-size:0.8125rem}:host(.button-strong){font-weight:bold}:host(.button-has-icon-only){--padding-top:0;--padding-bottom:var(--padding-top);--padding-end:var(--padding-top);--padding-start:var(--padding-end);min-width:clamp(30px, 2.86em, 60px);min-height:clamp(30px, 2.86em, 60px)}::slotted(ion-icon[slot=icon-only]){font-size:clamp(15.104px, 1.6em, 43.008px)}:host(.button-small.button-has-icon-only){min-width:clamp(23px, 2.16em, 54px);min-height:clamp(23px, 2.16em, 54px)}:host(.button-small) ::slotted(ion-icon[slot=icon-only]){font-size:clamp(13.002px, 1.23125em, 40.385px)}:host(.button-large.button-has-icon-only){min-width:clamp(46px, 2.5em, 78px);min-height:clamp(46px, 2.5em, 78px)}:host(.button-large) ::slotted(ion-icon[slot=icon-only]){font-size:clamp(15.008px, 1.4em, 43.008px)}:host(.button-solid.ion-color.ion-focused) .button-native::after{background:var(--ion-color-contrast)}:host(.button-clear.ion-color.ion-focused) .button-native::after,:host(.button-outline.ion-color.ion-focused) .button-native::after{background:var(--ion-color-base)}@media (any-hover: hover){:host(.button-solid.ion-color:hover) .button-native::after{background:var(--ion-color-contrast)}:host(.button-clear.ion-color:hover) .button-native::after,:host(.button-outline.ion-color:hover) .button-native::after{background:var(--ion-color-base)}}:host(.button-outline.ion-activated.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-background, var(--color));color:var(--ion-toolbar-color, var(--background), var(--ion-color-primary-contrast, #fff))}';
const IonButtonMdStyle0 = buttonMdCss;
const Button = /* @__PURE__ */ proxyCustomElement$1(class Button2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.inItem = false;
    this.inListHeader = false;
    this.inToolbar = false;
    this.formButtonEl = null;
    this.formEl = null;
    this.inheritedAttributes = {};
    this.handleClick = (ev) => {
      const { el: el2 } = this;
      if (this.type === "button") {
        openURL(this.href, ev, this.routerDirection, this.routerAnimation);
      } else if (hasShadowDom(el2)) {
        this.submitForm(ev);
      }
    };
    this.onFocus = () => {
      this.ionFocus.emit();
    };
    this.onBlur = () => {
      this.ionBlur.emit();
    };
    this.slotChanged = () => {
      this.isCircle = this.hasIconOnly;
    };
    this.isCircle = false;
    this.color = void 0;
    this.buttonType = "button";
    this.disabled = false;
    this.expand = void 0;
    this.fill = void 0;
    this.routerDirection = "forward";
    this.routerAnimation = void 0;
    this.download = void 0;
    this.href = void 0;
    this.rel = void 0;
    this.shape = void 0;
    this.size = void 0;
    this.strong = false;
    this.target = void 0;
    this.type = "button";
    this.form = void 0;
  }
  disabledChanged() {
    const { disabled } = this;
    if (this.formButtonEl) {
      this.formButtonEl.disabled = disabled;
    }
  }
  /**
   * This is responsible for rendering a hidden native
   * button element inside the associated form. This allows
   * users to submit a form by pressing "Enter" when a text
   * field inside of the form is focused. The native button
   * rendered inside of `ion-button` is in the Shadow DOM
   * and therefore does not participate in form submission
   * which is why the following code is necessary.
   */
  renderHiddenButton() {
    const formEl = this.formEl = this.findForm();
    if (formEl) {
      const { formButtonEl } = this;
      if (formButtonEl !== null && formEl.contains(formButtonEl)) {
        return;
      }
      const newFormButtonEl = this.formButtonEl = document.createElement("button");
      newFormButtonEl.type = this.type;
      newFormButtonEl.style.display = "none";
      newFormButtonEl.disabled = this.disabled;
      formEl.appendChild(newFormButtonEl);
    }
  }
  componentWillLoad() {
    this.inToolbar = !!this.el.closest("ion-buttons");
    this.inListHeader = !!this.el.closest("ion-list-header");
    this.inItem = !!this.el.closest("ion-item") || !!this.el.closest("ion-item-divider");
    this.inheritedAttributes = inheritAriaAttributes(this.el);
  }
  get hasIconOnly() {
    return !!this.el.querySelector('[slot="icon-only"]');
  }
  get rippleType() {
    const hasClearFill = this.fill === void 0 || this.fill === "clear";
    if (hasClearFill && this.hasIconOnly && this.inToolbar) {
      return "unbounded";
    }
    return "bounded";
  }
  /**
   * Finds the form element based on the provided `form` selector
   * or element reference provided.
   */
  findForm() {
    const { form } = this;
    if (form instanceof HTMLFormElement) {
      return form;
    }
    if (typeof form === "string") {
      const el2 = document.getElementById(form);
      if (el2) {
        if (el2 instanceof HTMLFormElement) {
          return el2;
        } else {
          printIonWarning('Form with selector: "#'.concat(form, '" could not be found. Verify that the id is attached to a <form> element.'), this.el);
          return null;
        }
      } else {
        printIonWarning('Form with selector: "#'.concat(form, '" could not be found. Verify that the id is correct and the form is rendered in the DOM.'), this.el);
        return null;
      }
    }
    if (form !== void 0) {
      printIonWarning('The provided "form" element is invalid. Verify that the form is a HTMLFormElement and rendered in the DOM.', this.el);
      return null;
    }
    return this.el.closest("form");
  }
  submitForm(ev) {
    if (this.formEl && this.formButtonEl) {
      ev.preventDefault();
      this.formButtonEl.click();
    }
  }
  render() {
    const mode = getIonMode$2(this);
    const { buttonType, type, disabled, rel, target, size, href, color, expand, hasIconOnly, shape, strong, inheritedAttributes } = this;
    const finalSize = size === void 0 && this.inItem ? "small" : size;
    const TagType = href === void 0 ? "button" : "a";
    const attrs = TagType === "button" ? { type } : {
      download: this.download,
      href,
      rel,
      target
    };
    let fill = this.fill;
    if (fill == null) {
      fill = this.inToolbar || this.inListHeader ? "clear" : "solid";
    }
    {
      type !== "button" && this.renderHiddenButton();
    }
    return h$1(Host$1, { key: "340a809d85698741bb36e796355cae89a970655f", onClick: this.handleClick, "aria-disabled": disabled ? "true" : null, class: createColorClasses$2(color, {
      [mode]: true,
      [buttonType]: true,
      ["".concat(buttonType, "-").concat(expand)]: expand !== void 0,
      ["".concat(buttonType, "-").concat(finalSize)]: finalSize !== void 0,
      ["".concat(buttonType, "-").concat(shape)]: shape !== void 0,
      ["".concat(buttonType, "-").concat(fill)]: true,
      ["".concat(buttonType, "-strong")]: strong,
      "in-toolbar": hostContext("ion-toolbar", this.el),
      "in-toolbar-color": hostContext("ion-toolbar[color]", this.el),
      "in-buttons": hostContext("ion-buttons", this.el),
      "button-has-icon-only": hasIconOnly,
      "button-disabled": disabled,
      "ion-activatable": true,
      "ion-focusable": true
    }) }, h$1(TagType, Object.assign({ key: "03ae1b94a0d606aa65aa6f82c2fc76abcf3f1300" }, attrs, { class: "button-native", part: "native", disabled, onFocus: this.onFocus, onBlur: this.onBlur }, inheritedAttributes), h$1("span", { key: "90bf53d4ffcab88ee596ece7113d5b6409e61143", class: "button-inner" }, h$1("slot", { key: "a7876695f0d8702e8bcb471ae4c0984f27d77458", name: "icon-only", onSlotchange: this.slotChanged }), h$1("slot", { key: "2c8551586f8726884d7797a6d3fee2d4b3aab35f", name: "start" }), h$1("slot", { key: "9ab07accdb22b08d0a463a7c821c9793507d1f7d" }), h$1("slot", { key: "8984afe177e6ba021435875a3798e2a64f3bdf2c", name: "end" })), mode === "md" && h$1("ion-ripple-effect", { key: "3e9f01e7a1198b6b7109502293a971da7072a4f3", type: this.rippleType })));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "disabled": ["disabledChanged"]
    };
  }
  static get style() {
    return {
      ios: IonButtonIosStyle0,
      md: IonButtonMdStyle0
    };
  }
}, [33, "ion-button", {
  "color": [513],
  "buttonType": [1025, "button-type"],
  "disabled": [516],
  "expand": [513],
  "fill": [1537],
  "routerDirection": [1, "router-direction"],
  "routerAnimation": [16],
  "download": [1],
  "href": [1],
  "rel": [1],
  "shape": [513],
  "size": [513],
  "strong": [4],
  "target": [1],
  "type": [1],
  "form": [1],
  "isCircle": [32]
}, void 0, {
  "disabled": ["disabledChanged"]
}]);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const getCapacitor = () => {
  if (win$2 !== void 0) {
    return win$2.Capacitor;
  }
  return void 0;
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const createLockController = () => {
  let waitPromise;
  const lock = async () => {
    const p2 = waitPromise;
    let resolve;
    waitPromise = new Promise((r2) => resolve = r2);
    if (p2 !== void 0) {
      await p2;
    }
    return resolve;
  };
  return {
    lock
  };
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const ION_CONTENT_TAG_NAME = "ION-CONTENT";
const ION_CONTENT_ELEMENT_SELECTOR = "ion-content";
const ION_CONTENT_CLASS_SELECTOR = ".ion-content-scroll-host";
const ION_CONTENT_SELECTOR = "".concat(ION_CONTENT_ELEMENT_SELECTOR, ", ").concat(ION_CONTENT_CLASS_SELECTOR);
const isIonContent = (el2) => el2.tagName === ION_CONTENT_TAG_NAME;
const getScrollElement = async (el2) => {
  if (isIonContent(el2)) {
    await new Promise((resolve) => componentOnReady(el2, resolve));
    return el2.getScrollElement();
  }
  return el2;
};
const findIonContent = (el2) => {
  const customContentHost = el2.querySelector(ION_CONTENT_CLASS_SELECTOR);
  if (customContentHost) {
    return customContentHost;
  }
  return el2.querySelector(ION_CONTENT_SELECTOR);
};
const findClosestIonContent = (el2) => {
  return el2.closest(ION_CONTENT_SELECTOR);
};
const scrollToTop = (el2, durationMs) => {
  if (isIonContent(el2)) {
    const content = el2;
    return content.scrollToTop(durationMs);
  }
  return Promise.resolve(el2.scrollTo({
    top: 0,
    left: 0,
    behavior: "smooth"
  }));
};
const scrollByPoint = (el2, x2, y2, durationMs) => {
  if (isIonContent(el2)) {
    const content = el2;
    return content.scrollByPoint(x2, y2, durationMs);
  }
  return Promise.resolve(el2.scrollBy({
    top: y2,
    left: x2,
    behavior: durationMs > 0 ? "smooth" : "auto"
  }));
};
const printIonContentErrorMsg = (el2) => {
  return printRequiredElementError(el2, ION_CONTENT_ELEMENT_SELECTOR);
};
const disableContentScrollY = (contentEl) => {
  if (isIonContent(contentEl)) {
    const ionContent = contentEl;
    const initialScrollY = ionContent.scrollY;
    ionContent.scrollY = false;
    return initialScrollY;
  } else {
    contentEl.style.setProperty("overflow", "hidden");
    return true;
  }
};
const resetContentScrollY = (contentEl, initialScrollY) => {
  if (isIonContent(contentEl)) {
    contentEl.scrollY = initialScrollY;
  } else {
    contentEl.style.removeProperty("overflow");
  }
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
var ExceptionCode$1;
(function(ExceptionCode2) {
  ExceptionCode2["Unimplemented"] = "UNIMPLEMENTED";
  ExceptionCode2["Unavailable"] = "UNAVAILABLE";
})(ExceptionCode$1 || (ExceptionCode$1 = {}));
var KeyboardResize;
(function(KeyboardResize2) {
  KeyboardResize2["Body"] = "body";
  KeyboardResize2["Ionic"] = "ionic";
  KeyboardResize2["Native"] = "native";
  KeyboardResize2["None"] = "none";
})(KeyboardResize || (KeyboardResize = {}));
const Keyboard = {
  getEngine() {
    const capacitor = getCapacitor();
    if (capacitor === null || capacitor === void 0 ? void 0 : capacitor.isPluginAvailable("Keyboard")) {
      return capacitor.Plugins.Keyboard;
    }
    return void 0;
  },
  getResizeMode() {
    const engine = this.getEngine();
    if (!(engine === null || engine === void 0 ? void 0 : engine.getResizeMode)) {
      return Promise.resolve(void 0);
    }
    return engine.getResizeMode().catch((e2) => {
      if (e2.code === ExceptionCode$1.Unimplemented) {
        return void 0;
      }
      throw e2;
    });
  }
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const getResizeContainer = (resizeMode) => {
  if (doc$1 === void 0 || resizeMode === KeyboardResize.None || resizeMode === void 0) {
    return null;
  }
  const ionApp = doc$1.querySelector("ion-app");
  return ionApp !== null && ionApp !== void 0 ? ionApp : doc$1.body;
};
const getResizeContainerHeight = (resizeMode) => {
  const containerElement = getResizeContainer(resizeMode);
  return containerElement === null ? 0 : containerElement.clientHeight;
};
const createKeyboardController = async (keyboardChangeCallback) => {
  let keyboardWillShowHandler;
  let keyboardWillHideHandler;
  let keyboardVisible;
  let initialResizeContainerHeight;
  const init = async () => {
    const resizeOptions = await Keyboard.getResizeMode();
    const resizeMode = resizeOptions === void 0 ? void 0 : resizeOptions.mode;
    keyboardWillShowHandler = () => {
      if (initialResizeContainerHeight === void 0) {
        initialResizeContainerHeight = getResizeContainerHeight(resizeMode);
      }
      keyboardVisible = true;
      fireChangeCallback(keyboardVisible, resizeMode);
    };
    keyboardWillHideHandler = () => {
      keyboardVisible = false;
      fireChangeCallback(keyboardVisible, resizeMode);
    };
    win$2 === null || win$2 === void 0 ? void 0 : win$2.addEventListener("keyboardWillShow", keyboardWillShowHandler);
    win$2 === null || win$2 === void 0 ? void 0 : win$2.addEventListener("keyboardWillHide", keyboardWillHideHandler);
  };
  const fireChangeCallback = (state, resizeMode) => {
    if (keyboardChangeCallback) {
      keyboardChangeCallback(state, createResizePromiseIfNeeded(resizeMode));
    }
  };
  const createResizePromiseIfNeeded = (resizeMode) => {
    if (
      /**
       * If we are in an SSR environment then there is
       * no window to resize. Additionally, if there
       * is no resize mode or the resize mode is "None"
       * then initialResizeContainerHeight will be 0
       */
      initialResizeContainerHeight === 0 || /**
       * If the keyboard is closed before the webview resizes initially
       * then the webview will never resize.
       */
      initialResizeContainerHeight === getResizeContainerHeight(resizeMode)
    ) {
      return;
    }
    const containerElement = getResizeContainer(resizeMode);
    if (containerElement === null) {
      return;
    }
    return new Promise((resolve) => {
      const callback = () => {
        if (containerElement.clientHeight === initialResizeContainerHeight) {
          ro.disconnect();
          resolve();
        }
      };
      const ro = new ResizeObserver(callback);
      ro.observe(containerElement);
    });
  };
  const destroy = () => {
    win$2 === null || win$2 === void 0 ? void 0 : win$2.removeEventListener("keyboardWillShow", keyboardWillShowHandler);
    win$2 === null || win$2 === void 0 ? void 0 : win$2.removeEventListener("keyboardWillHide", keyboardWillHideHandler);
    keyboardWillShowHandler = keyboardWillHideHandler = void 0;
  };
  const isKeyboardVisible = () => keyboardVisible;
  await init();
  return { init, destroy, isKeyboardVisible };
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const TRANSITION = "all 0.2s ease-in-out";
const cloneElement = (tagName) => {
  const getCachedEl = document.querySelector("".concat(tagName, ".ion-cloned-element"));
  if (getCachedEl !== null) {
    return getCachedEl;
  }
  const clonedEl = document.createElement(tagName);
  clonedEl.classList.add("ion-cloned-element");
  clonedEl.style.setProperty("display", "none");
  document.body.appendChild(clonedEl);
  return clonedEl;
};
const createHeaderIndex = (headerEl) => {
  if (!headerEl) {
    return;
  }
  const toolbars = headerEl.querySelectorAll("ion-toolbar");
  return {
    el: headerEl,
    toolbars: Array.from(toolbars).map((toolbar) => {
      const ionTitleEl = toolbar.querySelector("ion-title");
      return {
        el: toolbar,
        background: toolbar.shadowRoot.querySelector(".toolbar-background"),
        ionTitleEl,
        innerTitleEl: ionTitleEl ? ionTitleEl.shadowRoot.querySelector(".toolbar-title") : null,
        ionButtonsEl: Array.from(toolbar.querySelectorAll("ion-buttons"))
      };
    })
  };
};
const handleContentScroll = (scrollEl, scrollHeaderIndex, contentEl) => {
  readTask(() => {
    const scrollTop = scrollEl.scrollTop;
    const scale = clamp(1, 1 + -scrollTop / 500, 1.1);
    const nativeRefresher = contentEl.querySelector("ion-refresher.refresher-native");
    if (nativeRefresher === null) {
      writeTask$1(() => {
        scaleLargeTitles(scrollHeaderIndex.toolbars, scale);
      });
    }
  });
};
const setToolbarBackgroundOpacity = (headerEl, opacity) => {
  if (headerEl.collapse === "fade") {
    return;
  }
  if (opacity === void 0) {
    headerEl.style.removeProperty("--opacity-scale");
  } else {
    headerEl.style.setProperty("--opacity-scale", opacity.toString());
  }
};
const handleToolbarBorderIntersection = (ev, mainHeaderIndex, scrollTop) => {
  if (!ev[0].isIntersecting) {
    return;
  }
  const scale = ev[0].intersectionRatio > 0.9 || scrollTop <= 0 ? 0 : (1 - ev[0].intersectionRatio) * 100 / 75;
  setToolbarBackgroundOpacity(mainHeaderIndex.el, scale === 1 ? void 0 : scale);
};
const handleToolbarIntersection = (ev, mainHeaderIndex, scrollHeaderIndex, scrollEl) => {
  writeTask$1(() => {
    const scrollTop = scrollEl.scrollTop;
    handleToolbarBorderIntersection(ev, mainHeaderIndex, scrollTop);
    const event = ev[0];
    const intersection = event.intersectionRect;
    const intersectionArea = intersection.width * intersection.height;
    const rootArea = event.rootBounds.width * event.rootBounds.height;
    const isPageHidden = intersectionArea === 0 && rootArea === 0;
    const leftDiff = Math.abs(intersection.left - event.boundingClientRect.left);
    const rightDiff = Math.abs(intersection.right - event.boundingClientRect.right);
    const isPageTransitioning = intersectionArea > 0 && (leftDiff >= 5 || rightDiff >= 5);
    if (isPageHidden || isPageTransitioning) {
      return;
    }
    if (event.isIntersecting) {
      setHeaderActive(mainHeaderIndex, false);
      setHeaderActive(scrollHeaderIndex);
    } else {
      const hasValidIntersection = intersection.x === 0 && intersection.y === 0 || intersection.width !== 0 && intersection.height !== 0;
      if (hasValidIntersection && scrollTop > 0) {
        setHeaderActive(mainHeaderIndex);
        setHeaderActive(scrollHeaderIndex, false);
        setToolbarBackgroundOpacity(mainHeaderIndex.el);
      }
    }
  });
};
const setHeaderActive = (headerIndex, active = true) => {
  const headerEl = headerIndex.el;
  if (active) {
    headerEl.classList.remove("header-collapse-condense-inactive");
    headerEl.removeAttribute("aria-hidden");
  } else {
    headerEl.classList.add("header-collapse-condense-inactive");
    headerEl.setAttribute("aria-hidden", "true");
  }
};
const scaleLargeTitles = (toolbars = [], scale = 1, transition2 = false) => {
  toolbars.forEach((toolbar) => {
    const ionTitle = toolbar.ionTitleEl;
    const titleDiv = toolbar.innerTitleEl;
    if (!ionTitle || ionTitle.size !== "large") {
      return;
    }
    titleDiv.style.transition = transition2 ? TRANSITION : "";
    titleDiv.style.transform = "scale3d(".concat(scale, ", ").concat(scale, ", 1)");
  });
};
const handleHeaderFade = (scrollEl, baseEl, condenseHeader) => {
  readTask(() => {
    const scrollTop = scrollEl.scrollTop;
    const baseElHeight = baseEl.clientHeight;
    const fadeStart = condenseHeader ? condenseHeader.clientHeight : 0;
    if (condenseHeader !== null && scrollTop < fadeStart) {
      baseEl.style.setProperty("--opacity-scale", "0");
      scrollEl.style.setProperty("clip-path", "inset(".concat(baseElHeight, "px 0px 0px 0px)"));
      return;
    }
    const distanceToStart = scrollTop - fadeStart;
    const fadeDuration = 10;
    const scale = clamp(0, distanceToStart / fadeDuration, 1);
    writeTask$1(() => {
      scrollEl.style.removeProperty("clip-path");
      baseEl.style.setProperty("--opacity-scale", scale.toString());
    });
  });
};
const headerIosCss = "ion-header{display:block;position:relative;-ms-flex-order:-1;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-ios ion-toolbar:last-of-type{--border-width:0 0 0.55px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.header-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}.header-translucent-ios ion-toolbar{--opacity:.8}.header-collapse-condense-inactive .header-background{-webkit-backdrop-filter:blur(20px);backdrop-filter:blur(20px)}}.header-ios.ion-no-border ion-toolbar:last-of-type{--border-width:0}.header-collapse-fade ion-toolbar{--opacity-scale:inherit}.header-collapse-condense{z-index:9}.header-collapse-condense ion-toolbar{position:-webkit-sticky;position:sticky;top:0}.header-collapse-condense ion-toolbar:first-of-type{padding-top:0px;z-index:1}.header-collapse-condense ion-toolbar{--background:var(--ion-background-color, #fff);z-index:0}.header-collapse-condense ion-toolbar:last-of-type{--border-width:0px}.header-collapse-condense ion-toolbar ion-searchbar{padding-top:0px;padding-bottom:13px}.header-collapse-main{--opacity-scale:1}.header-collapse-main ion-toolbar{--opacity-scale:inherit}.header-collapse-main ion-toolbar.in-toolbar ion-title,.header-collapse-main ion-toolbar.in-toolbar ion-buttons{-webkit-transition:all 0.2s ease-in-out;transition:all 0.2s ease-in-out}.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-buttons.buttons-collapse{opacity:0;pointer-events:none}.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-buttons.buttons-collapse{visibility:hidden}ion-header.header-ios:not(.header-collapse-main):has(~ion-content ion-header.header-ios[collapse=condense],~ion-content ion-header.header-ios.header-collapse-condense){opacity:0}";
const IonHeaderIosStyle0 = headerIosCss;
const headerMdCss = "ion-header{display:block;position:relative;-ms-flex-order:-1;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-md{-webkit-box-shadow:0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12);box-shadow:0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12)}.header-collapse-condense{display:none}.header-md.ion-no-border{-webkit-box-shadow:none;box-shadow:none}";
const IonHeaderMdStyle0 = headerMdCss;
const Header = /* @__PURE__ */ proxyCustomElement$1(class Header2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.inheritedAttributes = {};
    this.setupFadeHeader = async (contentEl, condenseHeader) => {
      const scrollEl = this.scrollEl = await getScrollElement(contentEl);
      this.contentScrollCallback = () => {
        handleHeaderFade(this.scrollEl, this.el, condenseHeader);
      };
      scrollEl.addEventListener("scroll", this.contentScrollCallback);
      handleHeaderFade(this.scrollEl, this.el, condenseHeader);
    };
    this.collapse = void 0;
    this.translucent = false;
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAriaAttributes(this.el);
  }
  componentDidLoad() {
    this.checkCollapsibleHeader();
  }
  componentDidUpdate() {
    this.checkCollapsibleHeader();
  }
  disconnectedCallback() {
    this.destroyCollapsibleHeader();
  }
  async checkCollapsibleHeader() {
    const mode = getIonMode$2(this);
    if (mode !== "ios") {
      return;
    }
    const { collapse } = this;
    const hasCondense = collapse === "condense";
    const hasFade = collapse === "fade";
    this.destroyCollapsibleHeader();
    if (hasCondense) {
      const pageEl = this.el.closest("ion-app,ion-page,.ion-page,page-inner");
      const contentEl = pageEl ? findIonContent(pageEl) : null;
      writeTask$1(() => {
        const title = cloneElement("ion-title");
        title.size = "large";
        cloneElement("ion-back-button");
      });
      await this.setupCondenseHeader(contentEl, pageEl);
    } else if (hasFade) {
      const pageEl = this.el.closest("ion-app,ion-page,.ion-page,page-inner");
      const contentEl = pageEl ? findIonContent(pageEl) : null;
      if (!contentEl) {
        printIonContentErrorMsg(this.el);
        return;
      }
      const condenseHeader = contentEl.querySelector('ion-header[collapse="condense"]');
      await this.setupFadeHeader(contentEl, condenseHeader);
    }
  }
  destroyCollapsibleHeader() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      this.intersectionObserver = void 0;
    }
    if (this.scrollEl && this.contentScrollCallback) {
      this.scrollEl.removeEventListener("scroll", this.contentScrollCallback);
      this.contentScrollCallback = void 0;
    }
    if (this.collapsibleMainHeader) {
      this.collapsibleMainHeader.classList.remove("header-collapse-main");
      this.collapsibleMainHeader = void 0;
    }
  }
  async setupCondenseHeader(contentEl, pageEl) {
    if (!contentEl || !pageEl) {
      printIonContentErrorMsg(this.el);
      return;
    }
    if (typeof IntersectionObserver === "undefined") {
      return;
    }
    this.scrollEl = await getScrollElement(contentEl);
    const headers = pageEl.querySelectorAll("ion-header");
    this.collapsibleMainHeader = Array.from(headers).find((header) => header.collapse !== "condense");
    if (!this.collapsibleMainHeader) {
      return;
    }
    const mainHeaderIndex = createHeaderIndex(this.collapsibleMainHeader);
    const scrollHeaderIndex = createHeaderIndex(this.el);
    if (!mainHeaderIndex || !scrollHeaderIndex) {
      return;
    }
    setHeaderActive(mainHeaderIndex, false);
    setToolbarBackgroundOpacity(mainHeaderIndex.el, 0);
    const toolbarIntersection = (ev) => {
      handleToolbarIntersection(ev, mainHeaderIndex, scrollHeaderIndex, this.scrollEl);
    };
    this.intersectionObserver = new IntersectionObserver(toolbarIntersection, {
      root: contentEl,
      threshold: [0.25, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
    });
    this.intersectionObserver.observe(scrollHeaderIndex.toolbars[scrollHeaderIndex.toolbars.length - 1].el);
    this.contentScrollCallback = () => {
      handleContentScroll(this.scrollEl, scrollHeaderIndex, contentEl);
    };
    this.scrollEl.addEventListener("scroll", this.contentScrollCallback);
    writeTask$1(() => {
      if (this.collapsibleMainHeader !== void 0) {
        this.collapsibleMainHeader.classList.add("header-collapse-main");
      }
    });
  }
  render() {
    const { translucent, inheritedAttributes } = this;
    const mode = getIonMode$2(this);
    const collapse = this.collapse || "none";
    const roleType = hostContext("ion-menu", this.el) ? "none" : "banner";
    return h$1(Host$1, Object.assign({ key: "b6cc27f0b08afc9fcc889683525da765d80ba672", role: roleType, class: {
      [mode]: true,
      // Used internally for styling
      ["header-".concat(mode)]: true,
      ["header-translucent"]: this.translucent,
      ["header-collapse-".concat(collapse)]: true,
      ["header-translucent-".concat(mode)]: this.translucent
    } }, inheritedAttributes), mode === "ios" && translucent && h$1("div", { key: "395766d4dcee3398bc91960db21f922095292f14", class: "header-background" }), h$1("slot", { key: "09a67ece27b258ff1248805d43d92a49b2c6859a" }));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: IonHeaderIosStyle0,
      md: IonHeaderMdStyle0
    };
  }
}, [36, "ion-header", {
  "collapse": [1],
  "translucent": [4]
}]);
function defineCustomElement$q() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-header"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-header":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Header);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$p = defineCustomElement$q;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const imgCss = ":host{display:block;-o-object-fit:contain;object-fit:contain}img{display:block;width:100%;height:100%;-o-object-fit:inherit;object-fit:inherit;-o-object-position:inherit;object-position:inherit}";
const IonImgStyle0 = imgCss;
const Img = /* @__PURE__ */ proxyCustomElement$1(class Img2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionImgWillLoad = createEvent(this, "ionImgWillLoad", 7);
    this.ionImgDidLoad = createEvent(this, "ionImgDidLoad", 7);
    this.ionError = createEvent(this, "ionError", 7);
    this.inheritedAttributes = {};
    this.onLoad = () => {
      this.ionImgDidLoad.emit();
    };
    this.onError = () => {
      this.ionError.emit();
    };
    this.loadSrc = void 0;
    this.loadError = void 0;
    this.alt = void 0;
    this.src = void 0;
  }
  srcChanged() {
    this.addIO();
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAttributes$2(this.el, ["draggable"]);
  }
  componentDidLoad() {
    this.addIO();
  }
  addIO() {
    if (this.src === void 0) {
      return;
    }
    if (typeof window !== "undefined" && "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "isIntersecting" in window.IntersectionObserverEntry.prototype) {
      this.removeIO();
      this.io = new IntersectionObserver((data) => {
        if (data[data.length - 1].isIntersecting) {
          this.load();
          this.removeIO();
        }
      });
      this.io.observe(this.el);
    } else {
      setTimeout(() => this.load(), 200);
    }
  }
  load() {
    this.loadError = this.onError;
    this.loadSrc = this.src;
    this.ionImgWillLoad.emit();
  }
  removeIO() {
    if (this.io) {
      this.io.disconnect();
      this.io = void 0;
    }
  }
  render() {
    const { loadSrc, alt, onLoad, loadError, inheritedAttributes } = this;
    const { draggable } = inheritedAttributes;
    return h$1(Host$1, { key: "da600442894427dee1974a28e545613afac69fca", class: getIonMode$2(this) }, h$1("img", { key: "16df0c7069af86c0fa7ce5af598bc0f63b4eb71a", decoding: "async", src: loadSrc, alt, onLoad, onError: loadError, part: "image", draggable: isDraggable(draggable) }));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "src": ["srcChanged"]
    };
  }
  static get style() {
    return IonImgStyle0;
  }
}, [1, "ion-img", {
  "alt": [1],
  "src": [1],
  "loadSrc": [32],
  "loadError": [32]
}, void 0, {
  "src": ["srcChanged"]
}]);
const isDraggable = (draggable) => {
  switch (draggable) {
    case "true":
      return true;
    case "false":
      return false;
    default:
      return void 0;
  }
};
function defineCustomElement$1$a() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-img"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-img":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Img);
        }
        break;
    }
  });
}
const defineCustomElement$o = defineCustomElement$1$a;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const spinners = {
  bubbles: {
    dur: 1e3,
    circles: 9,
    fn: (dur, index, total) => {
      const animationDelay = "".concat(dur * index / total - dur, "ms");
      const angle = 2 * Math.PI * index / total;
      return {
        r: 5,
        style: {
          top: "".concat(32 * Math.sin(angle), "%"),
          left: "".concat(32 * Math.cos(angle), "%"),
          "animation-delay": animationDelay
        }
      };
    }
  },
  circles: {
    dur: 1e3,
    circles: 8,
    fn: (dur, index, total) => {
      const step = index / total;
      const animationDelay = "".concat(dur * step - dur, "ms");
      const angle = 2 * Math.PI * step;
      return {
        r: 5,
        style: {
          top: "".concat(32 * Math.sin(angle), "%"),
          left: "".concat(32 * Math.cos(angle), "%"),
          "animation-delay": animationDelay
        }
      };
    }
  },
  circular: {
    dur: 1400,
    elmDuration: true,
    circles: 1,
    fn: () => {
      return {
        r: 20,
        cx: 48,
        cy: 48,
        fill: "none",
        viewBox: "24 24 48 48",
        transform: "translate(0,0)",
        style: {}
      };
    }
  },
  crescent: {
    dur: 750,
    circles: 1,
    fn: () => {
      return {
        r: 26,
        style: {}
      };
    }
  },
  dots: {
    dur: 750,
    circles: 3,
    fn: (_, index) => {
      const animationDelay = -(110 * index) + "ms";
      return {
        r: 6,
        style: {
          left: "".concat(32 - 32 * index, "%"),
          "animation-delay": animationDelay
        }
      };
    }
  },
  lines: {
    dur: 1e3,
    lines: 8,
    fn: (dur, index, total) => {
      const transform = "rotate(".concat(360 / total * index + (index < total / 2 ? 180 : -180), "deg)");
      const animationDelay = "".concat(dur * index / total - dur, "ms");
      return {
        y1: 14,
        y2: 26,
        style: {
          transform,
          "animation-delay": animationDelay
        }
      };
    }
  },
  "lines-small": {
    dur: 1e3,
    lines: 8,
    fn: (dur, index, total) => {
      const transform = "rotate(".concat(360 / total * index + (index < total / 2 ? 180 : -180), "deg)");
      const animationDelay = "".concat(dur * index / total - dur, "ms");
      return {
        y1: 12,
        y2: 20,
        style: {
          transform,
          "animation-delay": animationDelay
        }
      };
    }
  },
  "lines-sharp": {
    dur: 1e3,
    lines: 12,
    fn: (dur, index, total) => {
      const transform = "rotate(".concat(30 * index + (index < 6 ? 180 : -180), "deg)");
      const animationDelay = "".concat(dur * index / total - dur, "ms");
      return {
        y1: 17,
        y2: 29,
        style: {
          transform,
          "animation-delay": animationDelay
        }
      };
    }
  },
  "lines-sharp-small": {
    dur: 1e3,
    lines: 12,
    fn: (dur, index, total) => {
      const transform = "rotate(".concat(30 * index + (index < 6 ? 180 : -180), "deg)");
      const animationDelay = "".concat(dur * index / total - dur, "ms");
      return {
        y1: 12,
        y2: 20,
        style: {
          transform,
          "animation-delay": animationDelay
        }
      };
    }
  }
};
const SPINNERS = spinners;
const spinnerCss = ":host{display:inline-block;position:relative;width:28px;height:28px;color:var(--color);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host(.ion-color){color:var(--ion-color-base)}svg{-webkit-transform-origin:center;transform-origin:center;position:absolute;top:0;left:0;width:100%;height:100%;-webkit-transform:translateZ(0);transform:translateZ(0)}:host-context([dir=rtl]) svg{-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}[dir=rtl] svg{-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}@supports selector(:dir(rtl)){svg:dir(rtl){-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}}:host(.spinner-lines) line,:host(.spinner-lines-small) line{stroke-width:7px}:host(.spinner-lines-sharp) line,:host(.spinner-lines-sharp-small) line{stroke-width:4px}:host(.spinner-lines) line,:host(.spinner-lines-small) line,:host(.spinner-lines-sharp) line,:host(.spinner-lines-sharp-small) line{stroke-linecap:round;stroke:currentColor}:host(.spinner-lines) svg,:host(.spinner-lines-small) svg,:host(.spinner-lines-sharp) svg,:host(.spinner-lines-sharp-small) svg{-webkit-animation:spinner-fade-out 1s linear infinite;animation:spinner-fade-out 1s linear infinite}:host(.spinner-bubbles) svg{-webkit-animation:spinner-scale-out 1s linear infinite;animation:spinner-scale-out 1s linear infinite;fill:currentColor}:host(.spinner-circles) svg{-webkit-animation:spinner-fade-out 1s linear infinite;animation:spinner-fade-out 1s linear infinite;fill:currentColor}:host(.spinner-crescent) circle{fill:transparent;stroke-width:4px;stroke-dasharray:128px;stroke-dashoffset:82px;stroke:currentColor}:host(.spinner-crescent) svg{-webkit-animation:spinner-rotate 1s linear infinite;animation:spinner-rotate 1s linear infinite}:host(.spinner-dots) circle{stroke-width:0;fill:currentColor}:host(.spinner-dots) svg{-webkit-animation:spinner-dots 1s linear infinite;animation:spinner-dots 1s linear infinite}:host(.spinner-circular) svg{-webkit-animation:spinner-circular linear infinite;animation:spinner-circular linear infinite}:host(.spinner-circular) circle{-webkit-animation:spinner-circular-inner ease-in-out infinite;animation:spinner-circular-inner ease-in-out infinite;stroke:currentColor;stroke-dasharray:80px, 200px;stroke-dashoffset:0px;stroke-width:5.6;fill:none}:host(.spinner-paused),:host(.spinner-paused) svg,:host(.spinner-paused) circle{-webkit-animation-play-state:paused;animation-play-state:paused}@-webkit-keyframes spinner-fade-out{0%{opacity:1}100%{opacity:0}}@keyframes spinner-fade-out{0%{opacity:1}100%{opacity:0}}@-webkit-keyframes spinner-scale-out{0%{-webkit-transform:scale(1, 1);transform:scale(1, 1)}100%{-webkit-transform:scale(0, 0);transform:scale(0, 0)}}@keyframes spinner-scale-out{0%{-webkit-transform:scale(1, 1);transform:scale(1, 1)}100%{-webkit-transform:scale(0, 0);transform:scale(0, 0)}}@-webkit-keyframes spinner-rotate{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-rotate{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes spinner-dots{0%{-webkit-transform:scale(1, 1);transform:scale(1, 1);opacity:0.9}50%{-webkit-transform:scale(0.4, 0.4);transform:scale(0.4, 0.4);opacity:0.3}100%{-webkit-transform:scale(1, 1);transform:scale(1, 1);opacity:0.9}}@keyframes spinner-dots{0%{-webkit-transform:scale(1, 1);transform:scale(1, 1);opacity:0.9}50%{-webkit-transform:scale(0.4, 0.4);transform:scale(0.4, 0.4);opacity:0.3}100%{-webkit-transform:scale(1, 1);transform:scale(1, 1);opacity:0.9}}@-webkit-keyframes spinner-circular{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-circular{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes spinner-circular-inner{0%{stroke-dasharray:1px, 200px;stroke-dashoffset:0px}50%{stroke-dasharray:100px, 200px;stroke-dashoffset:-15px}100%{stroke-dasharray:100px, 200px;stroke-dashoffset:-125px}}@keyframes spinner-circular-inner{0%{stroke-dasharray:1px, 200px;stroke-dashoffset:0px}50%{stroke-dasharray:100px, 200px;stroke-dashoffset:-15px}100%{stroke-dasharray:100px, 200px;stroke-dashoffset:-125px}}";
const IonSpinnerStyle0 = spinnerCss;
const Spinner = /* @__PURE__ */ proxyCustomElement$1(class Spinner2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.color = void 0;
    this.duration = void 0;
    this.name = void 0;
    this.paused = false;
  }
  getName() {
    const spinnerName = this.name || config.get("spinner");
    const mode = getIonMode$2(this);
    if (spinnerName) {
      return spinnerName;
    }
    return mode === "ios" ? "lines" : "circular";
  }
  render() {
    var _a;
    const self2 = this;
    const mode = getIonMode$2(self2);
    const spinnerName = self2.getName();
    const spinner = (_a = SPINNERS[spinnerName]) !== null && _a !== void 0 ? _a : SPINNERS["lines"];
    const duration = typeof self2.duration === "number" && self2.duration > 10 ? self2.duration : spinner.dur;
    const svgs = [];
    if (spinner.circles !== void 0) {
      for (let i = 0; i < spinner.circles; i++) {
        svgs.push(buildCircle(spinner, duration, i, spinner.circles));
      }
    } else if (spinner.lines !== void 0) {
      for (let i = 0; i < spinner.lines; i++) {
        svgs.push(buildLine(spinner, duration, i, spinner.lines));
      }
    }
    return h$1(Host$1, { key: "9d30ee9f5aa0dd0e220da07e75d05b8b2435224d", class: createColorClasses$2(self2.color, {
      [mode]: true,
      ["spinner-".concat(spinnerName)]: true,
      "spinner-paused": self2.paused || config.getBoolean("_testing")
    }), role: "progressbar", style: spinner.elmDuration ? { animationDuration: duration + "ms" } : {} }, svgs);
  }
  static get style() {
    return IonSpinnerStyle0;
  }
}, [1, "ion-spinner", {
  "color": [513],
  "duration": [2],
  "name": [1],
  "paused": [4]
}]);
const buildCircle = (spinner, duration, index, total) => {
  const data = spinner.fn(duration, index, total);
  data.style["animation-duration"] = duration + "ms";
  return h$1("svg", { viewBox: data.viewBox || "0 0 64 64", style: data.style }, h$1("circle", { transform: data.transform || "translate(32,32)", cx: data.cx, cy: data.cy, r: data.r, style: spinner.elmDuration ? { animationDuration: duration + "ms" } : {} }));
};
const buildLine = (spinner, duration, index, total) => {
  const data = spinner.fn(duration, index, total);
  data.style["animation-duration"] = duration + "ms";
  return h$1("svg", { viewBox: data.viewBox || "0 0 64 64", style: data.style }, h$1("line", { transform: "translate(32,32)", y1: data.y1, y2: data.y2 }));
};
function defineCustomElement$n() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-spinner"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-spinner":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Spinner);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const createNotchController = (el2, getNotchSpacerEl, getLabelSlot) => {
  let notchVisibilityIO;
  const needsExplicitNotchWidth = () => {
    const notchSpacerEl = getNotchSpacerEl();
    if (
      /**
       * If the notch is not being used
       * then we do not need to set the notch width.
       */
      notchSpacerEl === void 0 || /**
       * If either the label property is being
       * used or the label slot is not defined,
       * then we do not need to estimate the notch width.
       */
      el2.label !== void 0 || getLabelSlot() === null
    ) {
      return false;
    }
    return true;
  };
  const calculateNotchWidth = () => {
    if (needsExplicitNotchWidth()) {
      raf(() => {
        setNotchWidth();
      });
    }
  };
  const setNotchWidth = () => {
    const notchSpacerEl = getNotchSpacerEl();
    if (notchSpacerEl === void 0) {
      return;
    }
    if (!needsExplicitNotchWidth()) {
      notchSpacerEl.style.removeProperty("width");
      return;
    }
    const width = getLabelSlot().scrollWidth;
    if (
      /**
       * If the computed width of the label is 0
       * and notchSpacerEl's offsetParent is null
       * then that means the element is hidden.
       * As a result, we need to wait for the element
       * to become visible before setting the notch width.
       *
       * We do not check el.offsetParent because
       * that can be null if the host element has
       * position: fixed applied to it.
       * notchSpacerEl does not have position: fixed.
       */
      width === 0 && notchSpacerEl.offsetParent === null && win$2 !== void 0 && "IntersectionObserver" in win$2
    ) {
      if (notchVisibilityIO !== void 0) {
        return;
      }
      const io = notchVisibilityIO = new IntersectionObserver(
        (ev) => {
          if (ev[0].intersectionRatio === 1) {
            setNotchWidth();
            io.disconnect();
            notchVisibilityIO = void 0;
          }
        },
        /**
         * Set the root to be the host element
         * This causes the IO callback
         * to be fired in WebKit as soon as the element
         * is visible. If we used the default root value
         * then WebKit would only fire the IO callback
         * after any animations (such as a modal transition)
         * finished, and there would potentially be a flicker.
         */
        { threshold: 0.01, root: el2 }
      );
      io.observe(notchSpacerEl);
      return;
    }
    notchSpacerEl.style.setProperty("width", "".concat(width * 0.75, "px"));
  };
  const destroy = () => {
    if (notchVisibilityIO) {
      notchVisibilityIO.disconnect();
      notchVisibilityIO = void 0;
    }
  };
  return {
    calculateNotchWidth,
    destroy
  };
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const createSlotMutationController = (el2, slotName, mutationCallback) => {
  let hostMutationObserver;
  let slottedContentMutationObserver;
  if (win$2 !== void 0 && "MutationObserver" in win$2) {
    const slots = Array.isArray(slotName) ? slotName : [slotName];
    hostMutationObserver = new MutationObserver((entries) => {
      for (const entry of entries) {
        for (const node of entry.addedNodes) {
          if (node.nodeType === Node.ELEMENT_NODE && slots.includes(node.slot)) {
            mutationCallback();
            raf(() => watchForSlotChange(node));
            return;
          }
        }
      }
    });
    hostMutationObserver.observe(el2, {
      childList: true,
      /**
       * This fixes an issue with the `ion-input` and
       * `ion-textarea` not re-rendering in some cases
       * when using the label slot functionality.
       *
       * HTML element patches in Stencil that are enabled
       * by the `experimentalSlotFixes` flag in Stencil v4
       * result in DOM manipulations that won't trigger
       * the current mutation observer configuration and
       * callback.
       */
      subtree: true
    });
  }
  const watchForSlotChange = (slottedEl) => {
    var _a;
    if (slottedContentMutationObserver) {
      slottedContentMutationObserver.disconnect();
      slottedContentMutationObserver = void 0;
    }
    slottedContentMutationObserver = new MutationObserver((entries) => {
      mutationCallback();
      for (const entry of entries) {
        for (const node of entry.removedNodes) {
          if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {
            destroySlottedContentObserver();
          }
        }
      }
    });
    slottedContentMutationObserver.observe((_a = slottedEl.parentElement) !== null && _a !== void 0 ? _a : slottedEl, { subtree: true, childList: true });
  };
  const destroy = () => {
    if (hostMutationObserver) {
      hostMutationObserver.disconnect();
      hostMutationObserver = void 0;
    }
    destroySlottedContentObserver();
  };
  const destroySlottedContentObserver = () => {
    if (slottedContentMutationObserver) {
      slottedContentMutationObserver.disconnect();
      slottedContentMutationObserver = void 0;
    }
  };
  return {
    destroy
  };
};
const getCounterText = (value, maxLength, counterFormatter) => {
  const valueLength = value == null ? 0 : value.toString().length;
  const defaultCounterText = defaultCounterFormatter(valueLength, maxLength);
  if (counterFormatter === void 0) {
    return defaultCounterText;
  }
  try {
    return counterFormatter(valueLength, maxLength);
  } catch (e2) {
    printIonError("Exception in provided `counterFormatter`.", e2);
    return defaultCounterText;
  }
};
const defaultCounterFormatter = (length, maxlength) => {
  return "".concat(length, " / ").concat(maxlength);
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const inputIosCss = ".sc-ion-input-ios-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:var(--ion-placeholder-opacity, 0.6);--padding-top:0px;--padding-end:0px;--padding-bottom:0px;--padding-start:0px;--background:transparent;--color:initial;--border-style:solid;--highlight-color-focused:var(--ion-color-primary, #0054e9);--highlight-color-valid:var(--ion-color-success, #2dd55b);--highlight-color-invalid:var(--ion-color-danger, #c5000f);--highlight-color:var(--highlight-color-focused);display:block;position:relative;width:100%;min-height:44px;padding:0 !important;color:var(--color);font-family:var(--ion-font-family, inherit);z-index:2}ion-item[slot=start].sc-ion-input-ios-h,ion-item [slot=start].sc-ion-input-ios-h,ion-item[slot=end].sc-ion-input-ios-h,ion-item [slot=end].sc-ion-input-ios-h{width:auto}.ion-color.sc-ion-input-ios-h{--highlight-color-focused:var(--ion-color-base)}.input-label-placement-floating.sc-ion-input-ios-h,.input-label-placement-stacked.sc-ion-input-ios-h{min-height:56px}.native-input.sc-ion-input-ios{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:inline-block;position:relative;-ms-flex:1;flex:1;width:100%;max-width:100%;max-height:100%;border:0;outline:none;background:transparent;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none;z-index:1}.native-input.sc-ion-input-ios::-webkit-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios::-moz-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios:-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios::-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios:-webkit-autofill{background-color:transparent}.native-input.sc-ion-input-ios:invalid{-webkit-box-shadow:none;box-shadow:none}.native-input.sc-ion-input-ios::-ms-clear{display:none}.cloned-input.sc-ion-input-ios{top:0;bottom:0;position:absolute;pointer-events:none}.cloned-input.sc-ion-input-ios{inset-inline-start:0}.cloned-input.sc-ion-input-ios:disabled{opacity:1}.input-clear-icon.sc-ion-input-ios{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:auto;margin-bottom:auto;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;background-position:center;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:30px;height:30px;border:0;outline:none;background-color:transparent;background-repeat:no-repeat;color:var(--ion-color-step-600, var(--ion-text-color-step-400, #666666));visibility:hidden;-webkit-appearance:none;-moz-appearance:none;appearance:none}.in-item-color.sc-ion-input-ios-h .input-clear-icon.sc-ion-input-ios{color:inherit}.input-clear-icon.sc-ion-input-ios:focus{opacity:0.5}.has-value.sc-ion-input-ios-h .input-clear-icon.sc-ion-input-ios{visibility:visible}.input-wrapper.sc-ion-input-ios{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);border-radius:var(--border-radius);display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:stretch;align-items:stretch;height:inherit;min-height:inherit;-webkit-transition:background-color 15ms linear;transition:background-color 15ms linear;background:var(--background);line-height:normal}.native-wrapper.sc-ion-input-ios{display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;width:100%}.ion-touched.ion-invalid.sc-ion-input-ios-h{--highlight-color:var(--highlight-color-invalid)}.ion-valid.sc-ion-input-ios-h{--highlight-color:var(--highlight-color-valid)}.input-bottom.sc-ion-input-ios{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:5px;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;border-top:var(--border-width) var(--border-style) var(--border-color);font-size:0.75rem}.has-focus.ion-valid.sc-ion-input-ios-h,.ion-touched.ion-invalid.sc-ion-input-ios-h{--border-color:var(--highlight-color)}.input-bottom.sc-ion-input-ios .error-text.sc-ion-input-ios{display:none;color:var(--highlight-color-invalid)}.input-bottom.sc-ion-input-ios .helper-text.sc-ion-input-ios{display:block;color:var(--ion-color-step-550, var(--ion-text-color-step-450, #737373))}.ion-touched.ion-invalid.sc-ion-input-ios-h .input-bottom.sc-ion-input-ios .error-text.sc-ion-input-ios{display:block}.ion-touched.ion-invalid.sc-ion-input-ios-h .input-bottom.sc-ion-input-ios .helper-text.sc-ion-input-ios{display:none}.input-bottom.sc-ion-input-ios .counter.sc-ion-input-ios{-webkit-margin-start:auto;margin-inline-start:auto;color:var(--ion-color-step-550, var(--ion-text-color-step-450, #737373));white-space:nowrap;-webkit-padding-start:16px;padding-inline-start:16px}.has-focus.sc-ion-input-ios-h input.sc-ion-input-ios{caret-color:var(--highlight-color)}.label-text-wrapper.sc-ion-input-ios{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;max-width:200px;-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);pointer-events:none}.label-text.sc-ion-input-ios,.sc-ion-input-ios-s>[slot=label]{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.label-text-wrapper-hidden.sc-ion-input-ios,.input-outline-notch-hidden.sc-ion-input-ios{display:none}.input-wrapper.sc-ion-input-ios input.sc-ion-input-ios{-webkit-transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}.input-label-placement-start.sc-ion-input-ios-h .input-wrapper.sc-ion-input-ios{-ms-flex-direction:row;flex-direction:row}.input-label-placement-start.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.input-label-placement-end.sc-ion-input-ios-h .input-wrapper.sc-ion-input-ios{-ms-flex-direction:row-reverse;flex-direction:row-reverse}.input-label-placement-end.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}.input-label-placement-fixed.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.input-label-placement-fixed.sc-ion-input-ios-h .label-text.sc-ion-input-ios{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.input-label-placement-stacked.sc-ion-input-ios-h .input-wrapper.sc-ion-input-ios,.input-label-placement-floating.sc-ion-input-ios-h .input-wrapper.sc-ion-input-ios{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:start;align-items:start}.input-label-placement-stacked.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,.input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios{-webkit-transform-origin:left top;transform-origin:left top;max-width:100%;z-index:2}[dir=rtl].sc-ion-input-ios-h -no-combinator.input-label-placement-stacked.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,[dir=rtl] .sc-ion-input-ios-h -no-combinator.input-label-placement-stacked.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,[dir=rtl].input-label-placement-stacked.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,[dir=rtl] .input-label-placement-stacked.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,[dir=rtl].sc-ion-input-ios-h -no-combinator.input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,[dir=rtl] .sc-ion-input-ios-h -no-combinator.input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,[dir=rtl].input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,[dir=rtl] .input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.input-label-placement-stacked.sc-ion-input-ios-h:dir(rtl) .label-text-wrapper.sc-ion-input-ios,.input-label-placement-floating.sc-ion-input-ios-h:dir(rtl) .label-text-wrapper.sc-ion-input-ios{-webkit-transform-origin:right top;transform-origin:right top}}.input-label-placement-stacked.sc-ion-input-ios-h input.sc-ion-input-ios,.input-label-placement-floating.sc-ion-input-ios-h input.sc-ion-input-ios{margin-left:0;margin-right:0;margin-top:1px;margin-bottom:0}.input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios{-webkit-transform:translateY(100%) scale(1);transform:translateY(100%) scale(1)}.input-label-placement-floating.sc-ion-input-ios-h input.sc-ion-input-ios{opacity:0}.has-focus.input-label-placement-floating.sc-ion-input-ios-h input.sc-ion-input-ios,.has-value.input-label-placement-floating.sc-ion-input-ios-h input.sc-ion-input-ios{opacity:1}.label-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);max-width:calc(100% / 0.75)}.sc-ion-input-ios-s>[slot=start]:last-of-type{-webkit-margin-end:16px;margin-inline-end:16px;-webkit-margin-start:0;margin-inline-start:0}.sc-ion-input-ios-s>[slot=end]:first-of-type{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0}.sc-ion-input-ios-h[disabled].sc-ion-input-ios-s>ion-input-password-toggle,.sc-ion-input-ios-h[disabled] .sc-ion-input-ios-s>ion-input-password-toggle,.sc-ion-input-ios-h[readonly].sc-ion-input-ios-s>ion-input-password-toggle,.sc-ion-input-ios-h[readonly] .sc-ion-input-ios-s>ion-input-password-toggle{display:none}.sc-ion-input-ios-h{--border-width:0.55px;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, var(--ion-background-color-step-250, #c8c7cc))));--highlight-height:0px;font-size:inherit}.input-clear-icon.sc-ion-input-ios ion-icon.sc-ion-input-ios{width:18px;height:18px}.input-disabled.sc-ion-input-ios-h{opacity:0.3}.sc-ion-input-ios-s>ion-button[slot=start].button-has-icon-only,.sc-ion-input-ios-s>ion-button[slot=end].button-has-icon-only{--border-radius:50%;--padding-start:0;--padding-end:0;--padding-top:0;--padding-bottom:0;aspect-ratio:1}";
const IonInputIosStyle0 = inputIosCss;
const inputMdCss = ".sc-ion-input-md-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:var(--ion-placeholder-opacity, 0.6);--padding-top:0px;--padding-end:0px;--padding-bottom:0px;--padding-start:0px;--background:transparent;--color:initial;--border-style:solid;--highlight-color-focused:var(--ion-color-primary, #0054e9);--highlight-color-valid:var(--ion-color-success, #2dd55b);--highlight-color-invalid:var(--ion-color-danger, #c5000f);--highlight-color:var(--highlight-color-focused);display:block;position:relative;width:100%;min-height:44px;padding:0 !important;color:var(--color);font-family:var(--ion-font-family, inherit);z-index:2}ion-item[slot=start].sc-ion-input-md-h,ion-item [slot=start].sc-ion-input-md-h,ion-item[slot=end].sc-ion-input-md-h,ion-item [slot=end].sc-ion-input-md-h{width:auto}.ion-color.sc-ion-input-md-h{--highlight-color-focused:var(--ion-color-base)}.input-label-placement-floating.sc-ion-input-md-h,.input-label-placement-stacked.sc-ion-input-md-h{min-height:56px}.native-input.sc-ion-input-md{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:inline-block;position:relative;-ms-flex:1;flex:1;width:100%;max-width:100%;max-height:100%;border:0;outline:none;background:transparent;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none;z-index:1}.native-input.sc-ion-input-md::-webkit-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-md::-moz-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-md:-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-md::-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-md::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-md:-webkit-autofill{background-color:transparent}.native-input.sc-ion-input-md:invalid{-webkit-box-shadow:none;box-shadow:none}.native-input.sc-ion-input-md::-ms-clear{display:none}.cloned-input.sc-ion-input-md{top:0;bottom:0;position:absolute;pointer-events:none}.cloned-input.sc-ion-input-md{inset-inline-start:0}.cloned-input.sc-ion-input-md:disabled{opacity:1}.input-clear-icon.sc-ion-input-md{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:auto;margin-bottom:auto;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;background-position:center;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:30px;height:30px;border:0;outline:none;background-color:transparent;background-repeat:no-repeat;color:var(--ion-color-step-600, var(--ion-text-color-step-400, #666666));visibility:hidden;-webkit-appearance:none;-moz-appearance:none;appearance:none}.in-item-color.sc-ion-input-md-h .input-clear-icon.sc-ion-input-md{color:inherit}.input-clear-icon.sc-ion-input-md:focus{opacity:0.5}.has-value.sc-ion-input-md-h .input-clear-icon.sc-ion-input-md{visibility:visible}.input-wrapper.sc-ion-input-md{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);border-radius:var(--border-radius);display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:stretch;align-items:stretch;height:inherit;min-height:inherit;-webkit-transition:background-color 15ms linear;transition:background-color 15ms linear;background:var(--background);line-height:normal}.native-wrapper.sc-ion-input-md{display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;width:100%}.ion-touched.ion-invalid.sc-ion-input-md-h{--highlight-color:var(--highlight-color-invalid)}.ion-valid.sc-ion-input-md-h{--highlight-color:var(--highlight-color-valid)}.input-bottom.sc-ion-input-md{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:5px;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;border-top:var(--border-width) var(--border-style) var(--border-color);font-size:0.75rem}.has-focus.ion-valid.sc-ion-input-md-h,.ion-touched.ion-invalid.sc-ion-input-md-h{--border-color:var(--highlight-color)}.input-bottom.sc-ion-input-md .error-text.sc-ion-input-md{display:none;color:var(--highlight-color-invalid)}.input-bottom.sc-ion-input-md .helper-text.sc-ion-input-md{display:block;color:var(--ion-color-step-550, var(--ion-text-color-step-450, #737373))}.ion-touched.ion-invalid.sc-ion-input-md-h .input-bottom.sc-ion-input-md .error-text.sc-ion-input-md{display:block}.ion-touched.ion-invalid.sc-ion-input-md-h .input-bottom.sc-ion-input-md .helper-text.sc-ion-input-md{display:none}.input-bottom.sc-ion-input-md .counter.sc-ion-input-md{-webkit-margin-start:auto;margin-inline-start:auto;color:var(--ion-color-step-550, var(--ion-text-color-step-450, #737373));white-space:nowrap;-webkit-padding-start:16px;padding-inline-start:16px}.has-focus.sc-ion-input-md-h input.sc-ion-input-md{caret-color:var(--highlight-color)}.label-text-wrapper.sc-ion-input-md{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;max-width:200px;-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);pointer-events:none}.label-text.sc-ion-input-md,.sc-ion-input-md-s>[slot=label]{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.label-text-wrapper-hidden.sc-ion-input-md,.input-outline-notch-hidden.sc-ion-input-md{display:none}.input-wrapper.sc-ion-input-md input.sc-ion-input-md{-webkit-transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}.input-label-placement-start.sc-ion-input-md-h .input-wrapper.sc-ion-input-md{-ms-flex-direction:row;flex-direction:row}.input-label-placement-start.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.input-label-placement-end.sc-ion-input-md-h .input-wrapper.sc-ion-input-md{-ms-flex-direction:row-reverse;flex-direction:row-reverse}.input-label-placement-end.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}.input-label-placement-fixed.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.input-label-placement-fixed.sc-ion-input-md-h .label-text.sc-ion-input-md{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.input-label-placement-stacked.sc-ion-input-md-h .input-wrapper.sc-ion-input-md,.input-label-placement-floating.sc-ion-input-md-h .input-wrapper.sc-ion-input-md{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:start;align-items:start}.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-transform-origin:left top;transform-origin:left top;max-width:100%;z-index:2}[dir=rtl].sc-ion-input-md-h -no-combinator.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h -no-combinator.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl].input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl].sc-ion-input-md-h -no-combinator.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h -no-combinator.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl].input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.input-label-placement-stacked.sc-ion-input-md-h:dir(rtl) .label-text-wrapper.sc-ion-input-md,.input-label-placement-floating.sc-ion-input-md-h:dir(rtl) .label-text-wrapper.sc-ion-input-md{-webkit-transform-origin:right top;transform-origin:right top}}.input-label-placement-stacked.sc-ion-input-md-h input.sc-ion-input-md,.input-label-placement-floating.sc-ion-input-md-h input.sc-ion-input-md{margin-left:0;margin-right:0;margin-top:1px;margin-bottom:0}.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-transform:translateY(100%) scale(1);transform:translateY(100%) scale(1)}.input-label-placement-floating.sc-ion-input-md-h input.sc-ion-input-md{opacity:0}.has-focus.input-label-placement-floating.sc-ion-input-md-h input.sc-ion-input-md,.has-value.input-label-placement-floating.sc-ion-input-md-h input.sc-ion-input-md{opacity:1}.label-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);max-width:calc(100% / 0.75)}.sc-ion-input-md-s>[slot=start]:last-of-type{-webkit-margin-end:16px;margin-inline-end:16px;-webkit-margin-start:0;margin-inline-start:0}.sc-ion-input-md-s>[slot=end]:first-of-type{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0}.sc-ion-input-md-h[disabled].sc-ion-input-md-s>ion-input-password-toggle,.sc-ion-input-md-h[disabled] .sc-ion-input-md-s>ion-input-password-toggle,.sc-ion-input-md-h[readonly].sc-ion-input-md-s>ion-input-password-toggle,.sc-ion-input-md-h[readonly] .sc-ion-input-md-s>ion-input-password-toggle{display:none}.input-fill-solid.sc-ion-input-md-h{--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2));--border-color:var(--ion-color-step-500, var(--ion-background-color-step-500, gray));--border-radius:4px;--padding-start:16px;--padding-end:16px;min-height:56px}.input-fill-solid.sc-ion-input-md-h .input-wrapper.sc-ion-input-md{border-bottom:var(--border-width) var(--border-style) var(--border-color)}.has-focus.input-fill-solid.ion-valid.sc-ion-input-md-h,.input-fill-solid.ion-touched.ion-invalid.sc-ion-input-md-h{--border-color:var(--highlight-color)}.input-fill-solid.sc-ion-input-md-h .input-bottom.sc-ion-input-md{border-top:none}@media (any-hover: hover){.input-fill-solid.sc-ion-input-md-h:hover{--background:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6));--border-color:var(--ion-color-step-750, var(--ion-background-color-step-750, #404040))}}.input-fill-solid.has-focus.sc-ion-input-md-h{--background:var(--ion-color-step-150, var(--ion-background-color-step-150, #d9d9d9));--border-color:var(--ion-color-step-750, var(--ion-background-color-step-750, #404040))}.input-fill-solid.sc-ion-input-md-h .input-wrapper.sc-ion-input-md{border-start-start-radius:var(--border-radius);border-start-end-radius:var(--border-radius);border-end-end-radius:0px;border-end-start-radius:0px}.label-floating.input-fill-solid.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{max-width:calc(100% / 0.75)}.input-fill-outline.sc-ion-input-md-h{--border-color:var(--ion-color-step-300, var(--ion-background-color-step-300, #b3b3b3));--border-radius:4px;--padding-start:16px;--padding-end:16px;min-height:56px}.input-fill-outline.input-shape-round.sc-ion-input-md-h{--border-radius:28px;--padding-start:32px;--padding-end:32px}.has-focus.input-fill-outline.ion-valid.sc-ion-input-md-h,.input-fill-outline.ion-touched.ion-invalid.sc-ion-input-md-h{--border-color:var(--highlight-color)}@media (any-hover: hover){.input-fill-outline.sc-ion-input-md-h:hover{--border-color:var(--ion-color-step-750, var(--ion-background-color-step-750, #404040))}}.input-fill-outline.has-focus.sc-ion-input-md-h{--border-width:var(--highlight-height);--border-color:var(--highlight-color)}.input-fill-outline.sc-ion-input-md-h .input-bottom.sc-ion-input-md{border-top:none}.input-fill-outline.sc-ion-input-md-h .input-wrapper.sc-ion-input-md{border-bottom:none}.input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-transform-origin:left top;transform-origin:left top;position:absolute;max-width:calc(100% - var(--padding-start) - var(--padding-end))}[dir=rtl].sc-ion-input-md-h -no-combinator.input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h -no-combinator.input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl].input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl].sc-ion-input-md-h -no-combinator.input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h -no-combinator.input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl].input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h:dir(rtl) .label-text-wrapper.sc-ion-input-md,.input-fill-outline.input-label-placement-floating.sc-ion-input-md-h:dir(rtl) .label-text-wrapper.sc-ion-input-md{-webkit-transform-origin:right top;transform-origin:right top}}.input-fill-outline.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{position:relative}.label-floating.input-fill-outline.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-transform:translateY(-32%) scale(0.75);transform:translateY(-32%) scale(0.75);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;max-width:calc((100% - var(--padding-start) - var(--padding-end) - 8px) / 0.75)}.input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h input.sc-ion-input-md,.input-fill-outline.input-label-placement-floating.sc-ion-input-md-h input.sc-ion-input-md{margin-left:0;margin-right:0;margin-top:6px;margin-bottom:6px}.input-fill-outline.sc-ion-input-md-h .input-outline-container.sc-ion-input-md{left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;width:100%;height:100%}.input-fill-outline.sc-ion-input-md-h .input-outline-start.sc-ion-input-md,.input-fill-outline.sc-ion-input-md-h .input-outline-end.sc-ion-input-md{pointer-events:none}.input-fill-outline.sc-ion-input-md-h .input-outline-start.sc-ion-input-md,.input-fill-outline.sc-ion-input-md-h .input-outline-notch.sc-ion-input-md,.input-fill-outline.sc-ion-input-md-h .input-outline-end.sc-ion-input-md{border-top:var(--border-width) var(--border-style) var(--border-color);border-bottom:var(--border-width) var(--border-style) var(--border-color)}.input-fill-outline.sc-ion-input-md-h .input-outline-notch.sc-ion-input-md{max-width:calc(100% - var(--padding-start) - var(--padding-end))}.input-fill-outline.sc-ion-input-md-h .notch-spacer.sc-ion-input-md{-webkit-padding-end:8px;padding-inline-end:8px;font-size:calc(1em * 0.75);opacity:0;pointer-events:none;-webkit-box-sizing:content-box;box-sizing:content-box}.input-fill-outline.sc-ion-input-md-h .input-outline-start.sc-ion-input-md{border-start-start-radius:var(--border-radius);border-start-end-radius:0px;border-end-end-radius:0px;border-end-start-radius:var(--border-radius);-webkit-border-start:var(--border-width) var(--border-style) var(--border-color);border-inline-start:var(--border-width) var(--border-style) var(--border-color);width:calc(var(--padding-start) - 4px)}.input-fill-outline.sc-ion-input-md-h .input-outline-end.sc-ion-input-md{-webkit-border-end:var(--border-width) var(--border-style) var(--border-color);border-inline-end:var(--border-width) var(--border-style) var(--border-color);border-start-start-radius:0px;border-start-end-radius:var(--border-radius);border-end-end-radius:var(--border-radius);border-end-start-radius:0px;-ms-flex-positive:1;flex-grow:1}.label-floating.input-fill-outline.sc-ion-input-md-h .input-outline-notch.sc-ion-input-md{border-top:none}.sc-ion-input-md-h{--border-width:1px;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, var(--ion-background-color-step-150, rgba(0, 0, 0, 0.13)))));--highlight-height:2px;font-size:inherit}.input-clear-icon.sc-ion-input-md ion-icon.sc-ion-input-md{width:22px;height:22px}.input-disabled.sc-ion-input-md-h{opacity:0.38}.has-focus.ion-valid.sc-ion-input-md-h,.ion-touched.ion-invalid.sc-ion-input-md-h{--border-color:var(--highlight-color)}.input-bottom.sc-ion-input-md .counter.sc-ion-input-md{letter-spacing:0.0333333333em}.input-label-placement-floating.has-focus.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.input-label-placement-stacked.has-focus.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{color:var(--highlight-color)}.has-focus.input-label-placement-floating.ion-valid.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.input-label-placement-floating.ion-touched.ion-invalid.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.has-focus.input-label-placement-stacked.ion-valid.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.input-label-placement-stacked.ion-touched.ion-invalid.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{color:var(--highlight-color)}.input-highlight.sc-ion-input-md{bottom:-1px;position:absolute;width:100%;height:var(--highlight-height);-webkit-transform:scale(0);transform:scale(0);-webkit-transition:-webkit-transform 200ms;transition:-webkit-transform 200ms;transition:transform 200ms;transition:transform 200ms, -webkit-transform 200ms;background:var(--highlight-color)}.input-highlight.sc-ion-input-md{inset-inline-start:0}.has-focus.sc-ion-input-md-h .input-highlight.sc-ion-input-md{-webkit-transform:scale(1);transform:scale(1)}.in-item.sc-ion-input-md-h .input-highlight.sc-ion-input-md{bottom:0}.in-item.sc-ion-input-md-h .input-highlight.sc-ion-input-md{inset-inline-start:0}.input-shape-round.sc-ion-input-md-h{--border-radius:16px}.sc-ion-input-md-s>ion-button[slot=start].button-has-icon-only,.sc-ion-input-md-s>ion-button[slot=end].button-has-icon-only{--border-radius:50%;--padding-start:8px;--padding-end:8px;--padding-top:8px;--padding-bottom:8px;aspect-ratio:1;min-height:40px}";
const IonInputMdStyle0 = inputMdCss;
const Input = /* @__PURE__ */ proxyCustomElement$1(class Input2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.ionInput = createEvent(this, "ionInput", 7);
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.inputId = "ion-input-".concat(inputIds++);
    this.helperTextId = "".concat(this.inputId, "-helper-text");
    this.errorTextId = "".concat(this.inputId, "-error-text");
    this.inheritedAttributes = {};
    this.isComposing = false;
    this.didInputClearOnEdit = false;
    this.onInput = (ev) => {
      const input = ev.target;
      if (input) {
        this.value = input.value || "";
      }
      this.emitInputChange(ev);
    };
    this.onChange = (ev) => {
      this.emitValueChange(ev);
    };
    this.onBlur = (ev) => {
      this.hasFocus = false;
      if (this.focusedValue !== this.value) {
        this.emitValueChange(ev);
      }
      this.didInputClearOnEdit = false;
      this.ionBlur.emit(ev);
    };
    this.onFocus = (ev) => {
      this.hasFocus = true;
      this.focusedValue = this.value;
      this.ionFocus.emit(ev);
    };
    this.onKeydown = (ev) => {
      this.checkClearOnEdit(ev);
    };
    this.onCompositionStart = () => {
      this.isComposing = true;
    };
    this.onCompositionEnd = () => {
      this.isComposing = false;
    };
    this.clearTextInput = (ev) => {
      if (this.clearInput && !this.readonly && !this.disabled && ev) {
        ev.preventDefault();
        ev.stopPropagation();
        this.setFocus();
      }
      this.value = "";
      this.emitInputChange(ev);
    };
    this.hasFocus = false;
    this.color = void 0;
    this.autocapitalize = "off";
    this.autocomplete = "off";
    this.autocorrect = "off";
    this.autofocus = false;
    this.clearInput = false;
    this.clearInputIcon = void 0;
    this.clearOnEdit = void 0;
    this.counter = false;
    this.counterFormatter = void 0;
    this.debounce = void 0;
    this.disabled = false;
    this.enterkeyhint = void 0;
    this.errorText = void 0;
    this.fill = void 0;
    this.inputmode = void 0;
    this.helperText = void 0;
    this.label = void 0;
    this.labelPlacement = "start";
    this.max = void 0;
    this.maxlength = void 0;
    this.min = void 0;
    this.minlength = void 0;
    this.multiple = void 0;
    this.name = this.inputId;
    this.pattern = void 0;
    this.placeholder = void 0;
    this.readonly = false;
    this.required = false;
    this.shape = void 0;
    this.spellcheck = false;
    this.step = void 0;
    this.type = "text";
    this.value = "";
  }
  debounceChanged() {
    const { ionInput, debounce: debounce2, originalIonInput } = this;
    this.ionInput = debounce2 === void 0 ? originalIonInput !== null && originalIonInput !== void 0 ? originalIonInput : ionInput : debounceEvent(ionInput, debounce2);
  }
  /**
   * Whenever the type on the input changes we need
   * to update the internal type prop on the password
   * toggle so that that correct icon is shown.
   */
  onTypeChange() {
    const passwordToggle = this.el.querySelector("ion-input-password-toggle");
    if (passwordToggle) {
      passwordToggle.type = this.type;
    }
  }
  /**
   * Update the native input element when the value changes
   */
  valueChanged() {
    const nativeInput = this.nativeInput;
    const value = this.getValue();
    if (nativeInput && nativeInput.value !== value && !this.isComposing) {
      nativeInput.value = value;
    }
  }
  componentWillLoad() {
    this.inheritedAttributes = Object.assign(Object.assign({}, inheritAriaAttributes(this.el)), inheritAttributes$2(this.el, ["tabindex", "title", "data-form-type"]));
  }
  connectedCallback() {
    const { el: el2 } = this;
    this.slotMutationController = createSlotMutationController(el2, ["label", "start", "end"], () => forceUpdate(this));
    this.notchController = createNotchController(el2, () => this.notchSpacerEl, () => this.labelSlot);
    this.debounceChanged();
    {
      document.dispatchEvent(new CustomEvent("ionInputDidLoad", {
        detail: this.el
      }));
    }
  }
  componentDidLoad() {
    this.originalIonInput = this.ionInput;
    this.onTypeChange();
    this.debounceChanged();
  }
  componentDidRender() {
    var _a;
    (_a = this.notchController) === null || _a === void 0 ? void 0 : _a.calculateNotchWidth();
  }
  disconnectedCallback() {
    {
      document.dispatchEvent(new CustomEvent("ionInputDidUnload", {
        detail: this.el
      }));
    }
    if (this.slotMutationController) {
      this.slotMutationController.destroy();
      this.slotMutationController = void 0;
    }
    if (this.notchController) {
      this.notchController.destroy();
      this.notchController = void 0;
    }
  }
  /**
   * Sets focus on the native `input` in `ion-input`. Use this method instead of the global
   * `input.focus()`.
   *
   * Developers who wish to focus an input when a page enters
   * should call `setFocus()` in the `ionViewDidEnter()` lifecycle method.
   *
   * Developers who wish to focus an input when an overlay is presented
   * should call `setFocus` after `didPresent` has resolved.
   *
   * See [managing focus](/docs/developing/managing-focus) for more information.
   */
  async setFocus() {
    if (this.nativeInput) {
      this.nativeInput.focus();
    }
  }
  /**
   * Returns the native `<input>` element used under the hood.
   */
  async getInputElement() {
    if (!this.nativeInput) {
      await new Promise((resolve) => componentOnReady(this.el, resolve));
    }
    return Promise.resolve(this.nativeInput);
  }
  /**
   * Emits an `ionChange` event.
   *
   * This API should be called for user committed changes.
   * This API should not be used for external value changes.
   */
  emitValueChange(event) {
    const { value } = this;
    const newValue = value == null ? value : value.toString();
    this.focusedValue = newValue;
    this.ionChange.emit({ value: newValue, event });
  }
  /**
   * Emits an `ionInput` event.
   */
  emitInputChange(event) {
    const { value } = this;
    const newValue = value == null ? value : value.toString();
    this.ionInput.emit({ value: newValue, event });
  }
  shouldClearOnEdit() {
    const { type, clearOnEdit } = this;
    return clearOnEdit === void 0 ? type === "password" : clearOnEdit;
  }
  getValue() {
    return typeof this.value === "number" ? this.value.toString() : (this.value || "").toString();
  }
  checkClearOnEdit(ev) {
    if (!this.shouldClearOnEdit()) {
      return;
    }
    const IGNORED_KEYS = ["Enter", "Tab", "Shift", "Meta", "Alt", "Control"];
    const pressedIgnoredKey = IGNORED_KEYS.includes(ev.key);
    if (!this.didInputClearOnEdit && this.hasValue() && !pressedIgnoredKey) {
      this.value = "";
      this.emitInputChange(ev);
    }
    if (!pressedIgnoredKey) {
      this.didInputClearOnEdit = true;
    }
  }
  hasValue() {
    return this.getValue().length > 0;
  }
  /**
   * Renders the helper text or error text values
   */
  renderHintText() {
    const { helperText, errorText, helperTextId, errorTextId } = this;
    return [
      h$1("div", { id: helperTextId, class: "helper-text" }, helperText),
      h$1("div", { id: errorTextId, class: "error-text" }, errorText)
    ];
  }
  getHintTextID() {
    const { el: el2, helperText, errorText, helperTextId, errorTextId } = this;
    if (el2.classList.contains("ion-touched") && el2.classList.contains("ion-invalid") && errorText) {
      return errorTextId;
    }
    if (helperText) {
      return helperTextId;
    }
    return void 0;
  }
  renderCounter() {
    const { counter, maxlength, counterFormatter, value } = this;
    if (counter !== true || maxlength === void 0) {
      return;
    }
    return h$1("div", { class: "counter" }, getCounterText(value, maxlength, counterFormatter));
  }
  /**
   * Responsible for rendering helper text,
   * error text, and counter. This element should only
   * be rendered if hint text is set or counter is enabled.
   */
  renderBottomContent() {
    const { counter, helperText, errorText, maxlength } = this;
    const hasHintText = !!helperText || !!errorText;
    const hasCounter = counter === true && maxlength !== void 0;
    if (!hasHintText && !hasCounter) {
      return;
    }
    return h$1("div", { class: "input-bottom" }, this.renderHintText(), this.renderCounter());
  }
  renderLabel() {
    const { label } = this;
    return h$1("div", { class: {
      "label-text-wrapper": true,
      "label-text-wrapper-hidden": !this.hasLabel
    } }, label === void 0 ? h$1("slot", { name: "label" }) : h$1("div", { class: "label-text" }, label));
  }
  /**
   * Gets any content passed into the `label` slot,
   * not the <slot> definition.
   */
  get labelSlot() {
    return this.el.querySelector('[slot="label"]');
  }
  /**
   * Returns `true` if label content is provided
   * either by a prop or a content. If you want
   * to get the plaintext value of the label use
   * the `labelText` getter instead.
   */
  get hasLabel() {
    return this.label !== void 0 || this.labelSlot !== null;
  }
  /**
   * Renders the border container
   * when fill="outline".
   */
  renderLabelContainer() {
    const mode = getIonMode$2(this);
    const hasOutlineFill = mode === "md" && this.fill === "outline";
    if (hasOutlineFill) {
      return [
        h$1("div", { class: "input-outline-container" }, h$1("div", { class: "input-outline-start" }), h$1("div", { class: {
          "input-outline-notch": true,
          "input-outline-notch-hidden": !this.hasLabel
        } }, h$1("div", { class: "notch-spacer", "aria-hidden": "true", ref: (el2) => this.notchSpacerEl = el2 }, this.label)), h$1("div", { class: "input-outline-end" })),
        this.renderLabel()
      ];
    }
    return this.renderLabel();
  }
  render() {
    const { disabled, fill, readonly, shape, inputId, labelPlacement, el: el2, hasFocus, clearInputIcon } = this;
    const mode = getIonMode$2(this);
    const value = this.getValue();
    const inItem = hostContext("ion-item", this.el);
    const shouldRenderHighlight = mode === "md" && fill !== "outline" && !inItem;
    const defaultClearIcon = mode === "ios" ? closeCircle : closeSharp;
    const clearIconData = clearInputIcon !== null && clearInputIcon !== void 0 ? clearInputIcon : defaultClearIcon;
    const hasValue = this.hasValue();
    const hasStartEndSlots = el2.querySelector('[slot="start"], [slot="end"]') !== null;
    const labelShouldFloat = labelPlacement === "stacked" || labelPlacement === "floating" && (hasValue || hasFocus || hasStartEndSlots);
    return h$1(Host$1, { key: "54b5662d9a7f011a85e4119650c92b9af275bf96", class: createColorClasses$2(this.color, {
      [mode]: true,
      "has-value": hasValue,
      "has-focus": hasFocus,
      "label-floating": labelShouldFloat,
      ["input-fill-".concat(fill)]: fill !== void 0,
      ["input-shape-".concat(shape)]: shape !== void 0,
      ["input-label-placement-".concat(labelPlacement)]: true,
      "in-item": inItem,
      "in-item-color": hostContext("ion-item.ion-color", this.el),
      "input-disabled": disabled
    }) }, h$1("label", { key: "551cf8a932af3275689ecf32988b84355404e8f1", class: "input-wrapper", htmlFor: inputId }, this.renderLabelContainer(), h$1("div", { key: "b3601dca7e0f23517748f6e7feb899c953355bc4", class: "native-wrapper" }, h$1("slot", { key: "d687a9bb4c5778cfee35ce1b8d6d16ddc8eca768", name: "start" }), h$1("input", Object.assign({ key: "ab927e84e43bedf8b7827bb743888a1778292deb", class: "native-input", ref: (input) => this.nativeInput = input, id: inputId, disabled, autoCapitalize: this.autocapitalize, autoComplete: this.autocomplete, autoCorrect: this.autocorrect, autoFocus: this.autofocus, enterKeyHint: this.enterkeyhint, inputMode: this.inputmode, min: this.min, max: this.max, minLength: this.minlength, maxLength: this.maxlength, multiple: this.multiple, name: this.name, pattern: this.pattern, placeholder: this.placeholder || "", readOnly: readonly, required: this.required, spellcheck: this.spellcheck, step: this.step, type: this.type, value, onInput: this.onInput, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, onKeyDown: this.onKeydown, onCompositionstart: this.onCompositionStart, onCompositionend: this.onCompositionEnd, "aria-describedby": this.getHintTextID(), "aria-invalid": this.getHintTextID() === this.errorTextId }, this.inheritedAttributes)), this.clearInput && !readonly && !disabled && h$1("button", { key: "0d2ee3f7e69cee75f071f37b2e9bc174572c5a01", "aria-label": "reset", type: "button", class: "input-clear-icon", onPointerDown: (ev) => {
      ev.preventDefault();
    }, onFocusin: (ev) => {
      ev.stopPropagation();
    }, onClick: this.clearTextInput }, h$1("ion-icon", { key: "c7715111897f43839c10d38662616edb662cd49b", "aria-hidden": "true", icon: clearIconData })), h$1("slot", { key: "afc44cbe1ad50f17942d5297a12509abecbd6ecd", name: "end" })), shouldRenderHighlight && h$1("div", { key: "ee3af32cd9003d497f33e352e56313d43295f3a9", class: "input-highlight" })), this.renderBottomContent());
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "debounce": ["debounceChanged"],
      "type": ["onTypeChange"],
      "value": ["valueChanged"]
    };
  }
  static get style() {
    return {
      ios: IonInputIosStyle0,
      md: IonInputMdStyle0
    };
  }
}, [38, "ion-input", {
  "color": [513],
  "autocapitalize": [1],
  "autocomplete": [1],
  "autocorrect": [1],
  "autofocus": [4],
  "clearInput": [4, "clear-input"],
  "clearInputIcon": [1, "clear-input-icon"],
  "clearOnEdit": [4, "clear-on-edit"],
  "counter": [4],
  "counterFormatter": [16],
  "debounce": [2],
  "disabled": [516],
  "enterkeyhint": [1],
  "errorText": [1, "error-text"],
  "fill": [1],
  "inputmode": [1],
  "helperText": [1, "helper-text"],
  "label": [1],
  "labelPlacement": [1, "label-placement"],
  "max": [8],
  "maxlength": [2],
  "min": [8],
  "minlength": [2],
  "multiple": [4],
  "name": [1],
  "pattern": [1],
  "placeholder": [1],
  "readonly": [516],
  "required": [4],
  "shape": [1],
  "spellcheck": [4],
  "step": [1],
  "type": [1],
  "value": [1032],
  "hasFocus": [32],
  "setFocus": [64],
  "getInputElement": [64]
}, void 0, {
  "debounce": ["debounceChanged"],
  "type": ["onTypeChange"],
  "value": ["valueChanged"]
}]);
let inputIds = 0;
function defineCustomElement$1$9() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-input", "ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-input":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Input);
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$A();
        }
        break;
    }
  });
}
const defineCustomElement$m = defineCustomElement$1$9;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const labelIosCss = ".item.sc-ion-label-ios-h,.item .sc-ion-label-ios-h{--color:initial;display:block;color:var(--color);font-family:var(--ion-font-family, inherit);font-size:inherit;text-overflow:ellipsis;-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-label-ios-h{color:var(--ion-color-base)}.ion-text-nowrap.sc-ion-label-ios-h{overflow:hidden}.item-interactive-disabled.sc-ion-label-ios-h:not(.item-multiple-inputs),.item-interactive-disabled:not(.item-multiple-inputs) .sc-ion-label-ios-h{cursor:default;opacity:0.3;pointer-events:none}.item-input.sc-ion-label-ios-h,.item-input .sc-ion-label-ios-h{-ms-flex:initial;flex:initial;max-width:200px;pointer-events:none}.item-textarea.sc-ion-label-ios-h,.item-textarea .sc-ion-label-ios-h{-ms-flex-item-align:baseline;align-self:baseline}.item-skeleton-text.sc-ion-label-ios-h,.item-skeleton-text .sc-ion-label-ios-h{overflow:hidden}.label-fixed.sc-ion-label-ios-h{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.label-stacked.sc-ion-label-ios-h,.label-floating.sc-ion-label-ios-h{margin-bottom:0;-ms-flex-item-align:stretch;align-self:stretch;width:auto;max-width:100%}.label-no-animate.label-floating.sc-ion-label-ios-h{-webkit-transition:none;transition:none}.sc-ion-label-ios-s h1,.sc-ion-label-ios-s h2,.sc-ion-label-ios-s h3,.sc-ion-label-ios-s h4,.sc-ion-label-ios-s h5,.sc-ion-label-ios-s h6{text-overflow:inherit;overflow:inherit}.ion-text-wrap.sc-ion-label-ios-h{font-size:0.875rem;line-height:1.5}.label-stacked.sc-ion-label-ios-h{margin-bottom:4px;font-size:0.875rem}.label-floating.sc-ion-label-ios-h{margin-bottom:0;-webkit-transform:translate(0, 29px);transform:translate(0, 29px);-webkit-transform-origin:left top;transform-origin:left top;-webkit-transition:-webkit-transform 150ms ease-in-out;transition:-webkit-transform 150ms ease-in-out;transition:transform 150ms ease-in-out;transition:transform 150ms ease-in-out, -webkit-transform 150ms ease-in-out}[dir=rtl].sc-ion-label-ios-h -no-combinator.label-floating.sc-ion-label-ios-h,[dir=rtl] .sc-ion-label-ios-h -no-combinator.label-floating.sc-ion-label-ios-h,[dir=rtl].label-floating.sc-ion-label-ios-h,[dir=rtl] .label-floating.sc-ion-label-ios-h{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.label-floating.sc-ion-label-ios-h:dir(rtl){-webkit-transform-origin:right top;transform-origin:right top}}.item-textarea.label-floating.sc-ion-label-ios-h,.item-textarea .label-floating.sc-ion-label-ios-h{-webkit-transform:translate(0, 28px);transform:translate(0, 28px)}.item-has-focus.label-floating.sc-ion-label-ios-h,.item-has-focus .label-floating.sc-ion-label-ios-h,.item-has-placeholder.sc-ion-label-ios-h:not(.item-input).label-floating,.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-ios-h,.item-has-value.label-floating.sc-ion-label-ios-h,.item-has-value .label-floating.sc-ion-label-ios-h{-webkit-transform:scale(0.82);transform:scale(0.82)}.sc-ion-label-ios-s h1{margin-left:0;margin-right:0;margin-top:3px;margin-bottom:2px;font-size:1.375rem;font-weight:normal}.sc-ion-label-ios-s h2{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:1.0625rem;font-weight:normal}.sc-ion-label-ios-s h3,.sc-ion-label-ios-s h4,.sc-ion-label-ios-s h5,.sc-ion-label-ios-s h6{margin-left:0;margin-right:0;margin-top:0;margin-bottom:3px;font-size:0.875rem;font-weight:normal;line-height:normal}.sc-ion-label-ios-s p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:0.875rem;line-height:normal;text-overflow:inherit;overflow:inherit}.sc-ion-label-ios-s>p{color:var(--ion-color-step-400, var(--ion-text-color-step-600, #999999))}.sc-ion-label-ios-h.in-item-color.sc-ion-label-ios-s>p{color:inherit}.sc-ion-label-ios-s h2:last-child,.sc-ion-label-ios-s h3:last-child,.sc-ion-label-ios-s h4:last-child,.sc-ion-label-ios-s h5:last-child,.sc-ion-label-ios-s h6:last-child,.sc-ion-label-ios-s p:last-child{margin-bottom:0}";
const IonLabelIosStyle0 = labelIosCss;
const labelMdCss = ".item.sc-ion-label-md-h,.item .sc-ion-label-md-h{--color:initial;display:block;color:var(--color);font-family:var(--ion-font-family, inherit);font-size:inherit;text-overflow:ellipsis;-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-label-md-h{color:var(--ion-color-base)}.ion-text-nowrap.sc-ion-label-md-h{overflow:hidden}.item-interactive-disabled.sc-ion-label-md-h:not(.item-multiple-inputs),.item-interactive-disabled:not(.item-multiple-inputs) .sc-ion-label-md-h{cursor:default;opacity:0.3;pointer-events:none}.item-input.sc-ion-label-md-h,.item-input .sc-ion-label-md-h{-ms-flex:initial;flex:initial;max-width:200px;pointer-events:none}.item-textarea.sc-ion-label-md-h,.item-textarea .sc-ion-label-md-h{-ms-flex-item-align:baseline;align-self:baseline}.item-skeleton-text.sc-ion-label-md-h,.item-skeleton-text .sc-ion-label-md-h{overflow:hidden}.label-fixed.sc-ion-label-md-h{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.label-stacked.sc-ion-label-md-h,.label-floating.sc-ion-label-md-h{margin-bottom:0;-ms-flex-item-align:stretch;align-self:stretch;width:auto;max-width:100%}.label-no-animate.label-floating.sc-ion-label-md-h{-webkit-transition:none;transition:none}.sc-ion-label-md-s h1,.sc-ion-label-md-s h2,.sc-ion-label-md-s h3,.sc-ion-label-md-s h4,.sc-ion-label-md-s h5,.sc-ion-label-md-s h6{text-overflow:inherit;overflow:inherit}.ion-text-wrap.sc-ion-label-md-h{line-height:1.5}.label-stacked.sc-ion-label-md-h,.label-floating.sc-ion-label-md-h{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-transform-origin:top left;transform-origin:top left}.label-stacked.label-rtl.sc-ion-label-md-h,.label-floating.label-rtl.sc-ion-label-md-h{-webkit-transform-origin:top right;transform-origin:top right}.label-stacked.sc-ion-label-md-h{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1)}.label-floating.sc-ion-label-md-h{-webkit-transform:translateY(96%);transform:translateY(96%);-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1)}.ion-focused.label-floating.sc-ion-label-md-h,.ion-focused .label-floating.sc-ion-label-md-h,.item-has-focus.label-floating.sc-ion-label-md-h,.item-has-focus .label-floating.sc-ion-label-md-h,.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating,.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h,.item-has-value.label-floating.sc-ion-label-md-h,.item-has-value .label-floating.sc-ion-label-md-h{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75)}.ion-focused.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-focused .label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-primary, #0054e9)}.ion-focused.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-contrast)}.ion-invalid.ion-touched.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--highlight-color-invalid)}.sc-ion-label-md-s h1{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:1.5rem;font-weight:normal}.sc-ion-label-md-s h2{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:1rem;font-weight:normal}.sc-ion-label-md-s h3,.sc-ion-label-md-s h4,.sc-ion-label-md-s h5,.sc-ion-label-md-s h6{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:0.875rem;font-weight:normal;line-height:normal}.sc-ion-label-md-s p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:0.875rem;line-height:1.25rem;text-overflow:inherit;overflow:inherit}.sc-ion-label-md-s>p{color:var(--ion-color-step-600, var(--ion-text-color-step-400, #666666))}.sc-ion-label-md-h.in-item-color.sc-ion-label-md-s>p{color:inherit}";
const IonLabelMdStyle0 = labelMdCss;
const Label = /* @__PURE__ */ proxyCustomElement$1(class Label2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.ionColor = createEvent(this, "ionColor", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.inRange = false;
    this.color = void 0;
    this.position = void 0;
    this.noAnimate = false;
  }
  componentWillLoad() {
    this.inRange = !!this.el.closest("ion-range");
    this.noAnimate = this.position === "floating";
    this.emitStyle();
    this.emitColor();
  }
  componentDidLoad() {
    if (this.noAnimate) {
      setTimeout(() => {
        this.noAnimate = false;
      }, 1e3);
    }
  }
  colorChanged() {
    this.emitColor();
  }
  positionChanged() {
    this.emitStyle();
  }
  emitColor() {
    const { color } = this;
    this.ionColor.emit({
      "item-label-color": color !== void 0,
      ["ion-color-".concat(color)]: color !== void 0
    });
  }
  emitStyle() {
    const { inRange, position } = this;
    if (!inRange) {
      this.ionStyle.emit({
        label: true,
        ["label-".concat(position)]: position !== void 0
      });
    }
  }
  render() {
    const position = this.position;
    const mode = getIonMode$2(this);
    return h$1(Host$1, { key: "6353a70565ef6fbbbf4042b000e536c61bcf99a9", class: createColorClasses$2(this.color, {
      [mode]: true,
      "in-item-color": hostContext("ion-item.ion-color", this.el),
      ["label-".concat(position)]: position !== void 0,
      ["label-no-animate"]: this.noAnimate,
      "label-rtl": document.dir === "rtl"
    }) }, h$1("slot", { key: "6ef9c2758c0168442aa84941af0a6cec1ef1ec21" }));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "color": ["colorChanged"],
      "position": ["positionChanged"]
    };
  }
  static get style() {
    return {
      ios: IonLabelIosStyle0,
      md: IonLabelMdStyle0
    };
  }
}, [38, "ion-label", {
  "color": [513],
  "position": [1],
  "noAnimate": [32]
}, void 0, {
  "color": ["colorChanged"],
  "position": ["positionChanged"]
}]);
function defineCustomElement$l() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-label"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-label":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Label);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$k = defineCustomElement$l;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const listIosCss = "ion-list{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;contain:content;list-style-type:none}ion-list.list-inset{-webkit-transform:translateZ(0);transform:translateZ(0);overflow:hidden}.list-ios{background:var(--ion-item-background, var(--ion-background-color, #fff))}.list-ios.list-inset{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:16px;margin-bottom:16px;border-radius:10px}.list-ios.list-inset ion-item:only-child,.list-ios.list-inset ion-item:not(:only-of-type):last-of-type,.list-ios.list-inset ion-item-sliding:last-of-type ion-item{--border-width:0;--inner-border-width:0}.list-ios.list-inset+ion-list.list-inset{margin-top:0}.list-ios-lines-none .item-lines-default{--inner-border-width:0px;--border-width:0px}.list-ios-lines-full .item-lines-default{--inner-border-width:0px;--border-width:0 0 0.55px 0}.list-ios-lines-inset .item-lines-default{--inner-border-width:0 0 0.55px 0;--border-width:0px}ion-card .list-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}";
const IonListIosStyle0 = listIosCss;
const listMdCss = "ion-list{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;contain:content;list-style-type:none}ion-list.list-inset{-webkit-transform:translateZ(0);transform:translateZ(0);overflow:hidden}.list-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:8px;padding-bottom:8px;background:var(--ion-item-background, var(--ion-background-color, #fff))}.list-md>.input:last-child::after{inset-inline-start:0}.list-md.list-inset{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:16px;margin-bottom:16px;border-radius:2px}.list-md.list-inset ion-item:not(:only-of-type):last-of-type,.list-md.list-inset ion-item-sliding:last-of-type ion-item{--border-width:0;--inner-border-width:0}.list-md.list-inset ion-item:only-child{--border-width:0;--inner-border-width:0}.list-md.list-inset+ion-list.list-inset{margin-top:0}.list-md-lines-none .item-lines-default{--inner-border-width:0px;--border-width:0px}.list-md-lines-full .item-lines-default{--inner-border-width:0px;--border-width:0 0 1px 0}.list-md-lines-inset .item-lines-default{--inner-border-width:0 0 1px 0;--border-width:0px}ion-card .list-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}";
const IonListMdStyle0 = listMdCss;
const List = /* @__PURE__ */ proxyCustomElement$1(class List2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.lines = void 0;
    this.inset = false;
  }
  /**
   * If `ion-item-sliding` are used inside the list, this method closes
   * any open sliding item.
   *
   * Returns `true` if an actual `ion-item-sliding` is closed.
   */
  async closeSlidingItems() {
    const item = this.el.querySelector("ion-item-sliding");
    if (item === null || item === void 0 ? void 0 : item.closeOpened) {
      return item.closeOpened();
    }
    return false;
  }
  render() {
    const mode = getIonMode$2(this);
    const { lines, inset } = this;
    return h$1(Host$1, { key: "5ff2b0b3989cc99ce17abb8bcd7ec1847940d1ec", role: "list", class: {
      [mode]: true,
      // Used internally for styling
      ["list-".concat(mode)]: true,
      "list-inset": inset,
      ["list-lines-".concat(lines)]: lines !== void 0,
      ["list-".concat(mode, "-lines-").concat(lines)]: lines !== void 0
    } });
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: IonListIosStyle0,
      md: IonListMdStyle0
    };
  }
}, [32, "ion-list", {
  "lines": [1],
  "inset": [4],
  "closeSlidingItems": [64]
}]);
function defineCustomElement$j() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-list"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-list":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, List);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$i = defineCustomElement$j;
const VIEW_STATE_NEW = 1;
const VIEW_STATE_ATTACHED = 2;
const VIEW_STATE_DESTROYED = 3;
class ViewController {
  constructor(component, params) {
    this.component = component;
    this.params = params;
    this.state = VIEW_STATE_NEW;
  }
  async init(container2) {
    this.state = VIEW_STATE_ATTACHED;
    if (!this.element) {
      const component = this.component;
      this.element = await attachComponent(this.delegate, container2, component, ["ion-page", "ion-page-invisible"], this.params);
    }
  }
  /**
   * DOM WRITE
   */
  _destroy() {
    assert(this.state !== VIEW_STATE_DESTROYED, "view state must be ATTACHED");
    const element = this.element;
    if (element) {
      if (this.delegate) {
        this.delegate.removeViewFromDom(element.parentElement, element);
      } else {
        element.remove();
      }
    }
    this.nav = void 0;
    this.state = VIEW_STATE_DESTROYED;
  }
}
const matches = (view, id2, params) => {
  if (!view) {
    return false;
  }
  if (view.component !== id2) {
    return false;
  }
  return shallowEqualStringMap(view.params, params);
};
const convertToView = (page, params) => {
  if (!page) {
    return null;
  }
  if (page instanceof ViewController) {
    return page;
  }
  return new ViewController(page, params);
};
const convertToViews = (pages) => {
  return pages.map((page) => {
    if (page instanceof ViewController) {
      return page;
    }
    if ("component" in page) {
      return convertToView(page.component, page.componentProps === null ? void 0 : page.componentProps);
    }
    return convertToView(page, void 0);
  }).filter((v2) => v2 !== null);
};
const navCss = ":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;z-index:0}";
const IonNavStyle0 = navCss;
const Nav = /* @__PURE__ */ proxyCustomElement$1(class Nav2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionNavWillLoad = createEvent(this, "ionNavWillLoad", 7);
    this.ionNavWillChange = createEvent(this, "ionNavWillChange", 3);
    this.ionNavDidChange = createEvent(this, "ionNavDidChange", 3);
    this.transInstr = [];
    this.gestureOrAnimationInProgress = false;
    this.useRouter = false;
    this.isTransitioning = false;
    this.destroyed = false;
    this.views = [];
    this.didLoad = false;
    this.delegate = void 0;
    this.swipeGesture = void 0;
    this.animated = true;
    this.animation = void 0;
    this.rootParams = void 0;
    this.root = void 0;
  }
  swipeGestureChanged() {
    if (this.gesture) {
      this.gesture.enable(this.swipeGesture === true);
    }
  }
  rootChanged() {
    if (this.root === void 0) {
      return;
    }
    if (this.didLoad === false) {
      return;
    }
    if (!this.useRouter) {
      if (this.root !== void 0) {
        this.setRoot(this.root, this.rootParams);
      }
    }
  }
  componentWillLoad() {
    this.useRouter = document.querySelector("ion-router") !== null && this.el.closest("[no-router]") === null;
    if (this.swipeGesture === void 0) {
      const mode = getIonMode$2(this);
      this.swipeGesture = config.getBoolean("swipeBackEnabled", mode === "ios");
    }
    this.ionNavWillLoad.emit();
  }
  async componentDidLoad() {
    this.didLoad = true;
    this.rootChanged();
    this.gesture = (await __vitePreload(() => import("./swipe-back-XiZVxbRL.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url)).createSwipeBackGesture(this.el, this.canStart.bind(this), this.onStart.bind(this), this.onMove.bind(this), this.onEnd.bind(this));
    this.swipeGestureChanged();
  }
  connectedCallback() {
    this.destroyed = false;
  }
  disconnectedCallback() {
    for (const view of this.views) {
      lifecycle(view.element, LIFECYCLE_WILL_UNLOAD);
      view._destroy();
    }
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = void 0;
    }
    this.transInstr.length = 0;
    this.views.length = 0;
    this.destroyed = true;
  }
  /**
   * Push a new component onto the current navigation stack. Pass any additional
   * information along as an object. This additional information is accessible
   * through NavParams.
   *
   * @param component The component to push onto the navigation stack.
   * @param componentProps Any properties of the component.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  push(component, componentProps, opts, done) {
    return this.insert(-1, component, componentProps, opts, done);
  }
  /**
   * Inserts a component into the navigation stack at the specified index.
   * This is useful to add a component at any point in the navigation stack.
   *
   * @param insertIndex The index to insert the component at in the stack.
   * @param component The component to insert into the navigation stack.
   * @param componentProps Any properties of the component.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  insert(insertIndex, component, componentProps, opts, done) {
    return this.insertPages(insertIndex, [{ component, componentProps }], opts, done);
  }
  /**
   * Inserts an array of components into the navigation stack at the specified index.
   * The last component in the array will become instantiated as a view, and animate
   * in to become the active view.
   *
   * @param insertIndex The index to insert the components at in the stack.
   * @param insertComponents The components to insert into the navigation stack.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  insertPages(insertIndex, insertComponents, opts, done) {
    return this.queueTrns({
      insertStart: insertIndex,
      insertViews: insertComponents,
      opts
    }, done);
  }
  /**
   * Pop a component off of the navigation stack. Navigates back from the current
   * component.
   *
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  pop(opts, done) {
    return this.removeIndex(-1, 1, opts, done);
  }
  /**
   * Pop to a specific index in the navigation stack.
   *
   * @param indexOrViewCtrl The index or view controller to pop to.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  popTo(indexOrViewCtrl, opts, done) {
    const ti2 = {
      removeStart: -1,
      removeCount: -1,
      opts
    };
    if (typeof indexOrViewCtrl === "object" && indexOrViewCtrl.component) {
      ti2.removeView = indexOrViewCtrl;
      ti2.removeStart = 1;
    } else if (typeof indexOrViewCtrl === "number") {
      ti2.removeStart = indexOrViewCtrl + 1;
    }
    return this.queueTrns(ti2, done);
  }
  /**
   * Navigate back to the root of the stack, no matter how far back that is.
   *
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  popToRoot(opts, done) {
    return this.removeIndex(1, -1, opts, done);
  }
  /**
   * Removes a component from the navigation stack at the specified index.
   *
   * @param startIndex The number to begin removal at.
   * @param removeCount The number of components to remove.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  removeIndex(startIndex, removeCount = 1, opts, done) {
    return this.queueTrns({
      removeStart: startIndex,
      removeCount,
      opts
    }, done);
  }
  /**
   * Set the root for the current navigation stack to a component.
   *
   * @param component The component to set as the root of the navigation stack.
   * @param componentProps Any properties of the component.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  setRoot(component, componentProps, opts, done) {
    return this.setPages([{ component, componentProps }], opts, done);
  }
  /**
   * Set the views of the current navigation stack and navigate to the last view.
   * By default animations are disabled, but they can be enabled by passing options
   * to the navigation controller. Navigation parameters can also be passed to the
   * individual pages in the array.
   *
   * @param views The list of views to set as the navigation stack.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  setPages(views, opts, done) {
    opts !== null && opts !== void 0 ? opts : opts = {};
    if (opts.animated !== true) {
      opts.animated = false;
    }
    return this.queueTrns({
      insertStart: 0,
      insertViews: views,
      removeStart: 0,
      removeCount: -1,
      opts
    }, done);
  }
  /**
   * Called by the router to update the view.
   *
   * @param id The component tag.
   * @param params The component params.
   * @param direction A direction hint.
   * @param animation an AnimationBuilder.
   *
   * @return the status.
   * @internal
   */
  setRouteId(id2, params, direction, animation2) {
    const active = this.getActiveSync();
    if (matches(active, id2, params)) {
      return Promise.resolve({
        changed: false,
        element: active.element
      });
    }
    let resolve;
    const promise = new Promise((r2) => resolve = r2);
    let finish;
    const commonOpts = {
      updateURL: false,
      viewIsReady: (enteringEl) => {
        let mark;
        const p2 = new Promise((r2) => mark = r2);
        resolve({
          changed: true,
          element: enteringEl,
          markVisible: async () => {
            mark();
            await finish;
          }
        });
        return p2;
      }
    };
    if (direction === "root") {
      finish = this.setRoot(id2, params, commonOpts);
    } else {
      const viewController = this.views.find((v2) => matches(v2, id2, params));
      if (viewController) {
        finish = this.popTo(viewController, Object.assign(Object.assign({}, commonOpts), { direction: "back", animationBuilder: animation2 }));
      } else if (direction === "forward") {
        finish = this.push(id2, params, Object.assign(Object.assign({}, commonOpts), { animationBuilder: animation2 }));
      } else if (direction === "back") {
        finish = this.setRoot(id2, params, Object.assign(Object.assign({}, commonOpts), { direction: "back", animated: true, animationBuilder: animation2 }));
      }
    }
    return promise;
  }
  /**
   * Called by <ion-router> to retrieve the current component.
   *
   * @internal
   */
  async getRouteId() {
    const active = this.getActiveSync();
    if (active) {
      return {
        id: active.element.tagName,
        params: active.params,
        element: active.element
      };
    }
    return void 0;
  }
  /**
   * Get the active view.
   */
  async getActive() {
    return this.getActiveSync();
  }
  /**
   * Get the view at the specified index.
   *
   * @param index The index of the view.
   */
  async getByIndex(index) {
    return this.views[index];
  }
  /**
   * Returns `true` if the current view can go back.
   *
   * @param view The view to check.
   */
  async canGoBack(view) {
    return this.canGoBackSync(view);
  }
  /**
   * Get the previous view.
   *
   * @param view The view to get.
   */
  async getPrevious(view) {
    return this.getPreviousSync(view);
  }
  /**
   * Returns the number of views in the stack.
   */
  async getLength() {
    return Promise.resolve(this.views.length);
  }
  getActiveSync() {
    return this.views[this.views.length - 1];
  }
  canGoBackSync(view = this.getActiveSync()) {
    return !!(view && this.getPreviousSync(view));
  }
  getPreviousSync(view = this.getActiveSync()) {
    if (!view) {
      return void 0;
    }
    const views = this.views;
    const index = views.indexOf(view);
    return index > 0 ? views[index - 1] : void 0;
  }
  /**
   * Adds a navigation stack change to the queue and schedules it to run.
   *
   * @returns Whether the transition succeeds.
   */
  async queueTrns(ti2, done) {
    var _a, _b;
    if (this.isTransitioning && ((_a = ti2.opts) === null || _a === void 0 ? void 0 : _a.skipIfBusy)) {
      return false;
    }
    const promise = new Promise((resolve, reject) => {
      ti2.resolve = resolve;
      ti2.reject = reject;
    });
    ti2.done = done;
    if (ti2.opts && ti2.opts.updateURL !== false && this.useRouter) {
      const router = document.querySelector("ion-router");
      if (router) {
        const canTransition = await router.canTransition();
        if (canTransition === false) {
          return false;
        }
        if (typeof canTransition === "string") {
          router.push(canTransition, ti2.opts.direction || "back");
          return false;
        }
      }
    }
    if (((_b = ti2.insertViews) === null || _b === void 0 ? void 0 : _b.length) === 0) {
      ti2.insertViews = void 0;
    }
    this.transInstr.push(ti2);
    this.nextTrns();
    return promise;
  }
  success(result, ti2) {
    if (this.destroyed) {
      this.fireError("nav controller was destroyed", ti2);
      return;
    }
    if (ti2.done) {
      ti2.done(result.hasCompleted, result.requiresTransition, result.enteringView, result.leavingView, result.direction);
    }
    ti2.resolve(result.hasCompleted);
    if (ti2.opts.updateURL !== false && this.useRouter) {
      const router = document.querySelector("ion-router");
      if (router) {
        const direction = result.direction === "back" ? "back" : "forward";
        router.navChanged(direction);
      }
    }
  }
  failed(rejectReason, ti2) {
    if (this.destroyed) {
      this.fireError("nav controller was destroyed", ti2);
      return;
    }
    this.transInstr.length = 0;
    this.fireError(rejectReason, ti2);
  }
  fireError(rejectReason, ti2) {
    if (ti2.done) {
      ti2.done(false, false, rejectReason);
    }
    if (ti2.reject && !this.destroyed) {
      ti2.reject(rejectReason);
    } else {
      ti2.resolve(false);
    }
  }
  /**
   * Consumes the next transition in the queue.
   *
   * @returns whether the transition is executed.
   */
  nextTrns() {
    if (this.isTransitioning) {
      return false;
    }
    const ti2 = this.transInstr.shift();
    if (!ti2) {
      return false;
    }
    this.runTransition(ti2);
    return true;
  }
  /** Executes all the transition instruction from the queue. */
  async runTransition(ti2) {
    try {
      this.ionNavWillChange.emit();
      this.isTransitioning = true;
      this.prepareTI(ti2);
      const leavingView = this.getActiveSync();
      const enteringView = this.getEnteringView(ti2, leavingView);
      if (!leavingView && !enteringView) {
        throw new Error("no views in the stack to be removed");
      }
      if (enteringView && enteringView.state === VIEW_STATE_NEW) {
        await enteringView.init(this.el);
      }
      this.postViewInit(enteringView, leavingView, ti2);
      const requiresTransition = (ti2.enteringRequiresTransition || ti2.leavingRequiresTransition) && enteringView !== leavingView;
      if (requiresTransition && ti2.opts && leavingView) {
        const isBackDirection = ti2.opts.direction === "back";
        if (isBackDirection) {
          ti2.opts.animationBuilder = ti2.opts.animationBuilder || (enteringView === null || enteringView === void 0 ? void 0 : enteringView.animationBuilder);
        }
        leavingView.animationBuilder = ti2.opts.animationBuilder;
      }
      let result;
      if (requiresTransition) {
        result = await this.transition(enteringView, leavingView, ti2);
      } else {
        result = {
          hasCompleted: true,
          requiresTransition: false
        };
      }
      this.success(result, ti2);
      this.ionNavDidChange.emit();
    } catch (rejectReason) {
      this.failed(rejectReason, ti2);
    }
    this.isTransitioning = false;
    this.nextTrns();
  }
  prepareTI(ti2) {
    var _a, _b;
    var _c;
    const viewsLength = this.views.length;
    (_a = ti2.opts) !== null && _a !== void 0 ? _a : ti2.opts = {};
    (_b = (_c = ti2.opts).delegate) !== null && _b !== void 0 ? _b : _c.delegate = this.delegate;
    if (ti2.removeView !== void 0) {
      assert(ti2.removeStart !== void 0, "removeView needs removeStart");
      assert(ti2.removeCount !== void 0, "removeView needs removeCount");
      const index = this.views.indexOf(ti2.removeView);
      if (index < 0) {
        throw new Error("removeView was not found");
      }
      ti2.removeStart += index;
    }
    if (ti2.removeStart !== void 0) {
      if (ti2.removeStart < 0) {
        ti2.removeStart = viewsLength - 1;
      }
      if (ti2.removeCount < 0) {
        ti2.removeCount = viewsLength - ti2.removeStart;
      }
      ti2.leavingRequiresTransition = ti2.removeCount > 0 && ti2.removeStart + ti2.removeCount === viewsLength;
    }
    if (ti2.insertViews) {
      if (ti2.insertStart < 0 || ti2.insertStart > viewsLength) {
        ti2.insertStart = viewsLength;
      }
      ti2.enteringRequiresTransition = ti2.insertStart === viewsLength;
    }
    const insertViews = ti2.insertViews;
    if (!insertViews) {
      return;
    }
    assert(insertViews.length > 0, "length can not be zero");
    const viewControllers = convertToViews(insertViews);
    if (viewControllers.length === 0) {
      throw new Error("invalid views to insert");
    }
    for (const view of viewControllers) {
      view.delegate = ti2.opts.delegate;
      const nav = view.nav;
      if (nav && nav !== this) {
        throw new Error("inserted view was already inserted");
      }
      if (view.state === VIEW_STATE_DESTROYED) {
        throw new Error("inserted view was already destroyed");
      }
    }
    ti2.insertViews = viewControllers;
  }
  /**
   * Returns the view that will be entered considering the transition instructions.
   *
   * @param ti The instructions.
   * @param leavingView The view being left or undefined if none.
   *
   * @returns The view that will be entered, undefined if none.
   */
  getEnteringView(ti2, leavingView) {
    const insertViews = ti2.insertViews;
    if (insertViews !== void 0) {
      return insertViews[insertViews.length - 1];
    }
    const removeStart = ti2.removeStart;
    if (removeStart !== void 0) {
      const views = this.views;
      const removeEnd = removeStart + ti2.removeCount;
      for (let i = views.length - 1; i >= 0; i--) {
        const view = views[i];
        if ((i < removeStart || i >= removeEnd) && view !== leavingView) {
          return view;
        }
      }
    }
    return void 0;
  }
  /**
   * Adds and Removes the views from the navigation stack.
   *
   * @param enteringView The view being entered.
   * @param leavingView The view being left.
   * @param ti The instructions.
   */
  postViewInit(enteringView, leavingView, ti2) {
    var _a, _b, _c;
    assert(leavingView || enteringView, "Both leavingView and enteringView are null");
    assert(ti2.resolve, "resolve must be valid");
    assert(ti2.reject, "reject must be valid");
    const opts = ti2.opts;
    const { insertViews, removeStart, removeCount } = ti2;
    let destroyQueue;
    if (removeStart !== void 0 && removeCount !== void 0) {
      assert(removeStart >= 0, "removeStart can not be negative");
      assert(removeCount >= 0, "removeCount can not be negative");
      destroyQueue = [];
      for (let i = removeStart; i < removeStart + removeCount; i++) {
        const view = this.views[i];
        if (view !== void 0 && view !== enteringView && view !== leavingView) {
          destroyQueue.push(view);
        }
      }
      (_a = opts.direction) !== null && _a !== void 0 ? _a : opts.direction = "back";
    }
    const finalNumViews = this.views.length + ((_b = insertViews === null || insertViews === void 0 ? void 0 : insertViews.length) !== null && _b !== void 0 ? _b : 0) - (removeCount !== null && removeCount !== void 0 ? removeCount : 0);
    assert(finalNumViews >= 0, "final balance can not be negative");
    if (finalNumViews === 0) {
      console.warn("You can't remove all the pages in the navigation stack. nav.pop() is probably called too many times.", this, this.el);
      throw new Error("navigation stack needs at least one root page");
    }
    if (insertViews) {
      let insertIndex = ti2.insertStart;
      for (const view of insertViews) {
        this.insertViewAt(view, insertIndex);
        insertIndex++;
      }
      if (ti2.enteringRequiresTransition) {
        (_c = opts.direction) !== null && _c !== void 0 ? _c : opts.direction = "forward";
      }
    }
    if (destroyQueue && destroyQueue.length > 0) {
      for (const view of destroyQueue) {
        lifecycle(view.element, LIFECYCLE_WILL_LEAVE);
        lifecycle(view.element, LIFECYCLE_DID_LEAVE);
        lifecycle(view.element, LIFECYCLE_WILL_UNLOAD);
      }
      for (const view of destroyQueue) {
        this.destroyView(view);
      }
    }
  }
  async transition(enteringView, leavingView, ti2) {
    const opts = ti2.opts;
    const progressCallback = opts.progressAnimation ? (ani) => {
      if (ani !== void 0 && !this.gestureOrAnimationInProgress) {
        this.gestureOrAnimationInProgress = true;
        ani.onFinish(() => {
          this.gestureOrAnimationInProgress = false;
        }, { oneTimeCallback: true });
        ani.progressEnd(0, 0, 0);
      } else {
        this.sbAni = ani;
      }
    } : void 0;
    const mode = getIonMode$2(this);
    const enteringEl = enteringView.element;
    const leavingEl = leavingView && leavingView.element;
    const animationOpts = Object.assign(Object.assign({
      mode,
      showGoBack: this.canGoBackSync(enteringView),
      baseEl: this.el,
      progressCallback,
      animated: this.animated && config.getBoolean("animated", true),
      enteringEl,
      leavingEl
    }, opts), { animationBuilder: opts.animationBuilder || this.animation || config.get("navAnimation") });
    const { hasCompleted } = await transition(animationOpts);
    return this.transitionFinish(hasCompleted, enteringView, leavingView, opts);
  }
  transitionFinish(hasCompleted, enteringView, leavingView, opts) {
    const activeView = hasCompleted ? enteringView : leavingView;
    if (activeView) {
      this.unmountInactiveViews(activeView);
    }
    return {
      hasCompleted,
      requiresTransition: true,
      enteringView,
      leavingView,
      direction: opts.direction
    };
  }
  /**
   * Inserts a view at the specified index.
   *
   * When the view already is in the stack it will be moved to the new position.
   *
   * @param view The view to insert.
   * @param index The index where to insert the view.
   */
  insertViewAt(view, index) {
    const views = this.views;
    const existingIndex = views.indexOf(view);
    if (existingIndex > -1) {
      assert(view.nav === this, "view is not part of the nav");
      views.splice(existingIndex, 1);
      views.splice(index, 0, view);
    } else {
      assert(!view.nav, "nav is used");
      view.nav = this;
      views.splice(index, 0, view);
    }
  }
  /**
   * Removes a view from the stack.
   *
   * @param view The view to remove.
   */
  removeView(view) {
    assert(view.state === VIEW_STATE_ATTACHED || view.state === VIEW_STATE_DESTROYED, "view state should be loaded or destroyed");
    const views = this.views;
    const index = views.indexOf(view);
    assert(index > -1, "view must be part of the stack");
    if (index >= 0) {
      views.splice(index, 1);
    }
  }
  destroyView(view) {
    view._destroy();
    this.removeView(view);
  }
  /**
   * Unmounts all inactive views after the specified active view.
   *
   * DOM WRITE
   *
   * @param activeView The view that is actively visible in the stack. Used to calculate which views to unmount.
   */
  unmountInactiveViews(activeView) {
    if (this.destroyed) {
      return;
    }
    const views = this.views;
    const activeViewIndex = views.indexOf(activeView);
    for (let i = views.length - 1; i >= 0; i--) {
      const view = views[i];
      const element = view.element;
      if (element) {
        if (i > activeViewIndex) {
          lifecycle(element, LIFECYCLE_WILL_UNLOAD);
          this.destroyView(view);
        } else if (i < activeViewIndex) {
          setPageHidden(element, true);
        }
      }
    }
  }
  canStart() {
    return !this.gestureOrAnimationInProgress && !!this.swipeGesture && !this.isTransitioning && this.transInstr.length === 0 && this.canGoBackSync();
  }
  onStart() {
    this.gestureOrAnimationInProgress = true;
    this.pop({ direction: "back", progressAnimation: true });
  }
  onMove(stepValue) {
    if (this.sbAni) {
      this.sbAni.progressStep(stepValue);
    }
  }
  onEnd(shouldComplete, stepValue, dur) {
    if (this.sbAni) {
      this.sbAni.onFinish(() => {
        this.gestureOrAnimationInProgress = false;
      }, { oneTimeCallback: true });
      let newStepValue = shouldComplete ? -1e-3 : 1e-3;
      if (!shouldComplete) {
        this.sbAni.easing("cubic-bezier(1, 0, 0.68, 0.28)");
        newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], stepValue)[0];
      } else {
        newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], stepValue)[0];
      }
      this.sbAni.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);
    } else {
      this.gestureOrAnimationInProgress = false;
    }
  }
  render() {
    return h$1("slot", { key: "dfe98cb6604a2015a49f41beffebdd2da957dfff" });
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "swipeGesture": ["swipeGestureChanged"],
      "root": ["rootChanged"]
    };
  }
  static get style() {
    return IonNavStyle0;
  }
}, [1, "ion-nav", {
  "delegate": [16],
  "swipeGesture": [1028, "swipe-gesture"],
  "animated": [4],
  "animation": [16],
  "rootParams": [16],
  "root": [1],
  "push": [64],
  "insert": [64],
  "insertPages": [64],
  "pop": [64],
  "popTo": [64],
  "popToRoot": [64],
  "removeIndex": [64],
  "setRoot": [64],
  "setPages": [64],
  "setRouteId": [64],
  "getRouteId": [64],
  "getActive": [64],
  "getByIndex": [64],
  "canGoBack": [64],
  "getPrevious": [64],
  "getLength": [64]
}, void 0, {
  "swipeGesture": ["swipeGestureChanged"],
  "root": ["rootChanged"]
}]);
function defineCustomElement$1$8() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-nav"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-nav":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Nav);
        }
        break;
    }
  });
}
const defineCustomElement$h = defineCustomElement$1$8;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const rowCss = ":host{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}";
const IonRowStyle0 = rowCss;
const Row = /* @__PURE__ */ proxyCustomElement$1(class Row2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
  }
  render() {
    return h$1(Host$1, { key: "aea072a5005e3f1f309f0d1ae5be5ee19869b035", class: getIonMode$2(this) }, h$1("slot", { key: "2a481c2126ac6ca65f0a1bbd07c2d3365409cb78" }));
  }
  static get style() {
    return IonRowStyle0;
  }
}, [1, "ion-row"]);
function defineCustomElement$1$7() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-row"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-row":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Row);
        }
        break;
    }
  });
}
const defineCustomElement$g = defineCustomElement$1$7;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const searchbarIosCss = ".sc-ion-searchbar-ios-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:var(--ion-placeholder-opacity, 0.6);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-searchbar-ios-h{color:var(--ion-color-contrast)}.ion-color.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{background:var(--ion-color-base)}.ion-color.sc-ion-searchbar-ios-h .searchbar-clear-button.sc-ion-searchbar-ios,.ion-color.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.ion-color.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{color:inherit}.searchbar-search-icon.sc-ion-searchbar-ios{color:var(--icon-color);pointer-events:none}.searchbar-input-container.sc-ion-searchbar-ios{display:block;position:relative;-ms-flex-negative:1;flex-shrink:1;width:100%}.searchbar-input.sc-ion-searchbar-ios{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;border-radius:var(--border-radius);display:block;width:100%;min-height:inherit;border:0;outline:none;background:var(--background);font-family:inherit;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-input.sc-ion-searchbar-ios::-webkit-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios::-moz-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios:-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios::-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios::-webkit-search-cancel-button,.searchbar-input.sc-ion-searchbar-ios::-ms-clear{display:none}.searchbar-cancel-button.sc-ion-searchbar-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:none;height:100%;border:0;outline:none;color:var(--cancel-button-color);cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-cancel-button.sc-ion-searchbar-ios>div.sc-ion-searchbar-ios{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%}.searchbar-clear-button.sc-ion-searchbar-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:none;min-height:0;outline:none;color:var(--clear-button-color);-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-clear-button.sc-ion-searchbar-ios:focus{opacity:0.5}.searchbar-has-value.searchbar-should-show-clear.sc-ion-searchbar-ios-h .searchbar-clear-button.sc-ion-searchbar-ios{display:block}.searchbar-disabled.sc-ion-searchbar-ios-h{cursor:default;opacity:0.4;pointer-events:none}.sc-ion-searchbar-ios-h{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.07);--border-radius:10px;--box-shadow:none;--cancel-button-color:var(--ion-color-primary, #0054e9);--clear-button-color:var(--ion-color-step-600, var(--ion-text-color-step-400, #666666));--color:var(--ion-text-color, #000);--icon-color:var(--ion-color-step-600, var(--ion-text-color-step-400, #666666));-webkit-padding-start:12px;padding-inline-start:12px;-webkit-padding-end:12px;padding-inline-end:12px;padding-top:12px;padding-bottom:12px;min-height:60px;contain:content}.searchbar-input-container.sc-ion-searchbar-ios{min-height:36px}.searchbar-search-icon.sc-ion-searchbar-ios{-webkit-margin-start:calc(50% - 60px);margin-inline-start:calc(50% - 60px);top:0;position:absolute;width:1.375rem;height:100%;contain:strict}.searchbar-search-icon.sc-ion-searchbar-ios{inset-inline-start:5px}.searchbar-input.sc-ion-searchbar-ios{-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:6px;padding-bottom:6px;height:100%;font-size:1.0625rem;font-weight:400;contain:strict}.searchbar-has-value.searchbar-should-show-clear.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{-webkit-padding-start:1.75rem;padding-inline-start:1.75rem;-webkit-padding-end:1.75rem;padding-inline-end:1.75rem}.searchbar-clear-button.sc-ion-searchbar-ios{top:0;background-position:center;position:absolute;width:1.875rem;height:100%;border:0;background-color:transparent}.searchbar-clear-button.sc-ion-searchbar-ios{inset-inline-end:0}.searchbar-clear-icon.sc-ion-searchbar-ios{width:1.125rem;height:100%}.searchbar-cancel-button.sc-ion-searchbar-ios{-webkit-padding-start:12px;padding-inline-start:12px;-webkit-padding-end:0;padding-inline-end:0;padding-top:0;padding-bottom:0;-ms-flex-negative:0;flex-shrink:0;background-color:transparent;font-size:17px}.searchbar-left-aligned.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{-webkit-margin-start:0;margin-inline-start:0}.searchbar-left-aligned.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{-webkit-padding-start:1.875rem;padding-inline-start:1.875rem}.searchbar-has-focus.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.searchbar-should-show-cancel.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{display:block}.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{-webkit-transition:all 300ms ease;transition:all 300ms ease}.searchbar-animated.searchbar-has-focus.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.searchbar-animated.searchbar-should-show-cancel.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{opacity:1;pointer-events:auto}.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{-webkit-margin-end:-100%;margin-inline-end:-100%;-webkit-transform:translate3d(0,  0,  0);transform:translate3d(0,  0,  0);-webkit-transition:all 300ms ease;transition:all 300ms ease;opacity:0;pointer-events:none}.searchbar-no-animate.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,.searchbar-no-animate.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios,.searchbar-no-animate.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{-webkit-transition-duration:0ms;transition-duration:0ms}.ion-color.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{color:var(--ion-color-base)}@media (any-hover: hover){.ion-color.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios:hover{color:var(--ion-color-tint)}}ion-toolbar.sc-ion-searchbar-ios-h,ion-toolbar .sc-ion-searchbar-ios-h{padding-top:1px;padding-bottom:15px;min-height:52px}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color),ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color){color:inherit}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-cancel-button.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-cancel-button.sc-ion-searchbar-ios{color:currentColor}ion-toolbar.ion-color.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{color:currentColor;opacity:0.5}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-input.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-input.sc-ion-searchbar-ios{background:rgba(var(--ion-color-contrast-rgb), 0.07);color:currentColor}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-clear-button.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-clear-button.sc-ion-searchbar-ios{color:currentColor;opacity:0.5}";
const IonSearchbarIosStyle0 = searchbarIosCss;
const searchbarMdCss = ".sc-ion-searchbar-md-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:var(--ion-placeholder-opacity, 0.6);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-searchbar-md-h{color:var(--ion-color-contrast)}.ion-color.sc-ion-searchbar-md-h .searchbar-input.sc-ion-searchbar-md{background:var(--ion-color-base)}.ion-color.sc-ion-searchbar-md-h .searchbar-clear-button.sc-ion-searchbar-md,.ion-color.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md,.ion-color.sc-ion-searchbar-md-h .searchbar-search-icon.sc-ion-searchbar-md{color:inherit}.searchbar-search-icon.sc-ion-searchbar-md{color:var(--icon-color);pointer-events:none}.searchbar-input-container.sc-ion-searchbar-md{display:block;position:relative;-ms-flex-negative:1;flex-shrink:1;width:100%}.searchbar-input.sc-ion-searchbar-md{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;border-radius:var(--border-radius);display:block;width:100%;min-height:inherit;border:0;outline:none;background:var(--background);font-family:inherit;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-input.sc-ion-searchbar-md::-webkit-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md::-moz-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md:-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md::-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md::-webkit-search-cancel-button,.searchbar-input.sc-ion-searchbar-md::-ms-clear{display:none}.searchbar-cancel-button.sc-ion-searchbar-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:none;height:100%;border:0;outline:none;color:var(--cancel-button-color);cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-cancel-button.sc-ion-searchbar-md>div.sc-ion-searchbar-md{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%}.searchbar-clear-button.sc-ion-searchbar-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:none;min-height:0;outline:none;color:var(--clear-button-color);-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-clear-button.sc-ion-searchbar-md:focus{opacity:0.5}.searchbar-has-value.searchbar-should-show-clear.sc-ion-searchbar-md-h .searchbar-clear-button.sc-ion-searchbar-md{display:block}.searchbar-disabled.sc-ion-searchbar-md-h{cursor:default;opacity:0.4;pointer-events:none}.sc-ion-searchbar-md-h{--background:var(--ion-background-color, #fff);--border-radius:2px;--box-shadow:0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);--cancel-button-color:var(--ion-color-step-900, var(--ion-text-color-step-100, #1a1a1a));--clear-button-color:initial;--color:var(--ion-color-step-850, var(--ion-text-color-step-150, #262626));--icon-color:var(--ion-color-step-600, var(--ion-text-color-step-400, #666666));-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px;padding-top:8px;padding-bottom:8px;background:inherit}.searchbar-search-icon.sc-ion-searchbar-md{top:11px;width:1.3125rem;height:1.3125rem}.searchbar-search-icon.sc-ion-searchbar-md{inset-inline-start:16px}.searchbar-cancel-button.sc-ion-searchbar-md{top:0;background-color:transparent;font-size:1.5em}.searchbar-cancel-button.sc-ion-searchbar-md{inset-inline-start:9px}.searchbar-search-icon.sc-ion-searchbar-md,.searchbar-cancel-button.sc-ion-searchbar-md{position:absolute}.searchbar-search-icon.ion-activated.sc-ion-searchbar-md,.searchbar-cancel-button.ion-activated.sc-ion-searchbar-md{background-color:transparent}.searchbar-input.sc-ion-searchbar-md{-webkit-padding-start:3.4375rem;padding-inline-start:3.4375rem;-webkit-padding-end:3.4375rem;padding-inline-end:3.4375rem;padding-top:0.375rem;padding-bottom:0.375rem;background-position:left 8px center;height:auto;font-size:1rem;font-weight:400;line-height:30px}[dir=rtl].sc-ion-searchbar-md-h .searchbar-input.sc-ion-searchbar-md,[dir=rtl] .sc-ion-searchbar-md-h .searchbar-input.sc-ion-searchbar-md{background-position:right 8px center}[dir=rtl].sc-ion-searchbar-md .searchbar-input.sc-ion-searchbar-md{background-position:right 8px center}@supports selector(:dir(rtl)){.searchbar-input.sc-ion-searchbar-md:dir(rtl){background-position:right 8px center}}.searchbar-clear-button.sc-ion-searchbar-md{top:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;position:absolute;height:100%;border:0;background-color:transparent}.searchbar-clear-button.sc-ion-searchbar-md{inset-inline-end:13px}.searchbar-clear-button.ion-activated.sc-ion-searchbar-md{background-color:transparent}.searchbar-clear-icon.sc-ion-searchbar-md{width:1.375rem;height:100%}.searchbar-has-focus.sc-ion-searchbar-md-h .searchbar-search-icon.sc-ion-searchbar-md{display:block}.searchbar-has-focus.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md,.searchbar-should-show-cancel.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md{display:block}.searchbar-has-focus.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md+.searchbar-search-icon.sc-ion-searchbar-md,.searchbar-should-show-cancel.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md+.searchbar-search-icon.sc-ion-searchbar-md{display:none}ion-toolbar.sc-ion-searchbar-md-h,ion-toolbar .sc-ion-searchbar-md-h{-webkit-padding-start:7px;padding-inline-start:7px;-webkit-padding-end:7px;padding-inline-end:7px;padding-top:3px;padding-bottom:3px}";
const IonSearchbarMdStyle0 = searchbarMdCss;
const Searchbar = /* @__PURE__ */ proxyCustomElement$1(class Searchbar2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.ionInput = createEvent(this, "ionInput", 7);
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionCancel = createEvent(this, "ionCancel", 7);
    this.ionClear = createEvent(this, "ionClear", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.isCancelVisible = false;
    this.shouldAlignLeft = true;
    this.inputId = "ion-searchbar-".concat(searchbarIds++);
    this.inheritedAttributes = {};
    this.onClearInput = async (shouldFocus) => {
      this.ionClear.emit();
      return new Promise((resolve) => {
        setTimeout(() => {
          const value = this.getValue();
          if (value !== "") {
            this.value = "";
            this.emitInputChange();
            if (shouldFocus && !this.focused) {
              this.setFocus();
              this.focusedValue = value;
            }
          }
          resolve();
        }, 16 * 4);
      });
    };
    this.onCancelSearchbar = async (ev) => {
      if (ev) {
        ev.preventDefault();
        ev.stopPropagation();
      }
      this.ionCancel.emit();
      const value = this.getValue();
      const focused = this.focused;
      await this.onClearInput();
      if (value && !focused) {
        this.emitValueChange(ev);
      }
      if (this.nativeInput) {
        this.nativeInput.blur();
      }
    };
    this.onInput = (ev) => {
      const input = ev.target;
      if (input) {
        this.value = input.value;
      }
      this.emitInputChange(ev);
    };
    this.onChange = (ev) => {
      this.emitValueChange(ev);
    };
    this.onBlur = (ev) => {
      this.focused = false;
      this.ionBlur.emit();
      this.positionElements();
      if (this.focusedValue !== this.value) {
        this.emitValueChange(ev);
      }
      this.focusedValue = void 0;
    };
    this.onFocus = () => {
      this.focused = true;
      this.focusedValue = this.value;
      this.ionFocus.emit();
      this.positionElements();
    };
    this.focused = false;
    this.noAnimate = true;
    this.color = void 0;
    this.animated = false;
    this.autocapitalize = "off";
    this.autocomplete = "off";
    this.autocorrect = "off";
    this.cancelButtonIcon = config.get("backButtonIcon", arrowBackSharp);
    this.cancelButtonText = "Cancel";
    this.clearIcon = void 0;
    this.debounce = void 0;
    this.disabled = false;
    this.inputmode = void 0;
    this.enterkeyhint = void 0;
    this.maxlength = void 0;
    this.minlength = void 0;
    this.name = this.inputId;
    this.placeholder = "Search";
    this.searchIcon = void 0;
    this.showCancelButton = "never";
    this.showClearButton = "always";
    this.spellcheck = false;
    this.type = "search";
    this.value = "";
  }
  /**
   * lang and dir are globally enumerated attributes.
   * As a result, creating these as properties
   * can have unintended side effects. Instead, we
   * listen for attribute changes and inherit them
   * to the inner `<input>` element.
   */
  onLangChanged(newValue) {
    this.inheritedAttributes = Object.assign(Object.assign({}, this.inheritedAttributes), { lang: newValue });
    forceUpdate(this);
  }
  onDirChanged(newValue) {
    this.inheritedAttributes = Object.assign(Object.assign({}, this.inheritedAttributes), { dir: newValue });
    forceUpdate(this);
  }
  debounceChanged() {
    const { ionInput, debounce: debounce2, originalIonInput } = this;
    this.ionInput = debounce2 === void 0 ? originalIonInput !== null && originalIonInput !== void 0 ? originalIonInput : ionInput : debounceEvent(ionInput, debounce2);
  }
  valueChanged() {
    const inputEl = this.nativeInput;
    const value = this.getValue();
    if (inputEl && inputEl.value !== value) {
      inputEl.value = value;
    }
  }
  showCancelButtonChanged() {
    requestAnimationFrame(() => {
      this.positionElements();
      forceUpdate(this);
    });
  }
  connectedCallback() {
    this.emitStyle();
  }
  componentWillLoad() {
    this.inheritedAttributes = Object.assign({}, inheritAttributes$2(this.el, ["lang", "dir"]));
  }
  componentDidLoad() {
    this.originalIonInput = this.ionInput;
    this.positionElements();
    this.debounceChanged();
    setTimeout(() => {
      this.noAnimate = false;
    }, 300);
  }
  emitStyle() {
    this.ionStyle.emit({
      searchbar: true
    });
  }
  /**
   * Sets focus on the native `input` in `ion-searchbar`. Use this method instead of the global
   * `input.focus()`.
   *
   * Developers who wish to focus an input when a page enters
   * should call `setFocus()` in the `ionViewDidEnter()` lifecycle method.
   *
   * Developers who wish to focus an input when an overlay is presented
   * should call `setFocus` after `didPresent` has resolved.
   *
   * See [managing focus](/docs/developing/managing-focus) for more information.
   */
  async setFocus() {
    if (this.nativeInput) {
      this.nativeInput.focus();
    }
  }
  /**
   * Returns the native `<input>` element used under the hood.
   */
  async getInputElement() {
    if (!this.nativeInput) {
      await new Promise((resolve) => componentOnReady(this.el, resolve));
    }
    return Promise.resolve(this.nativeInput);
  }
  /**
   * Emits an `ionChange` event.
   *
   * This API should be called for user committed changes.
   * This API should not be used for external value changes.
   */
  emitValueChange(event) {
    const { value } = this;
    const newValue = value == null ? value : value.toString();
    this.focusedValue = newValue;
    this.ionChange.emit({ value: newValue, event });
  }
  /**
   * Emits an `ionInput` event.
   */
  emitInputChange(event) {
    const { value } = this;
    this.ionInput.emit({ value, event });
  }
  /**
   * Positions the input search icon, placeholder, and the cancel button
   * based on the input value and if it is focused. (ios only)
   */
  positionElements() {
    const value = this.getValue();
    const prevAlignLeft = this.shouldAlignLeft;
    const mode = getIonMode$2(this);
    const shouldAlignLeft = !this.animated || value.trim() !== "" || !!this.focused;
    this.shouldAlignLeft = shouldAlignLeft;
    if (mode !== "ios") {
      return;
    }
    if (prevAlignLeft !== shouldAlignLeft) {
      this.positionPlaceholder();
    }
    if (this.animated) {
      this.positionCancelButton();
    }
  }
  /**
   * Positions the input placeholder
   */
  positionPlaceholder() {
    const inputEl = this.nativeInput;
    if (!inputEl) {
      return;
    }
    const rtl = isRTL$1(this.el);
    const iconEl = (this.el.shadowRoot || this.el).querySelector(".searchbar-search-icon");
    if (this.shouldAlignLeft) {
      inputEl.removeAttribute("style");
      iconEl.removeAttribute("style");
    } else {
      const doc2 = document;
      const tempSpan = doc2.createElement("span");
      tempSpan.innerText = this.placeholder || "";
      doc2.body.appendChild(tempSpan);
      raf(() => {
        const textWidth = tempSpan.offsetWidth;
        tempSpan.remove();
        const inputLeft = "calc(50% - " + textWidth / 2 + "px)";
        const iconLeft = "calc(50% - " + (textWidth / 2 + iconEl.clientWidth + 8) + "px)";
        if (rtl) {
          inputEl.style.paddingRight = inputLeft;
          iconEl.style.marginRight = iconLeft;
        } else {
          inputEl.style.paddingLeft = inputLeft;
          iconEl.style.marginLeft = iconLeft;
        }
      });
    }
  }
  /**
   * Show the iOS Cancel button on focus, hide it offscreen otherwise
   */
  positionCancelButton() {
    const rtl = isRTL$1(this.el);
    const cancelButton = (this.el.shadowRoot || this.el).querySelector(".searchbar-cancel-button");
    const shouldShowCancel = this.shouldShowCancelButton();
    if (cancelButton !== null && shouldShowCancel !== this.isCancelVisible) {
      const cancelStyle = cancelButton.style;
      this.isCancelVisible = shouldShowCancel;
      if (shouldShowCancel) {
        if (rtl) {
          cancelStyle.marginLeft = "0";
        } else {
          cancelStyle.marginRight = "0";
        }
      } else {
        const offset = cancelButton.offsetWidth;
        if (offset > 0) {
          if (rtl) {
            cancelStyle.marginLeft = -offset + "px";
          } else {
            cancelStyle.marginRight = -offset + "px";
          }
        }
      }
    }
  }
  getValue() {
    return this.value || "";
  }
  hasValue() {
    return this.getValue() !== "";
  }
  /**
   * Determines whether or not the cancel button should be visible onscreen.
   * Cancel button should be shown if one of two conditions applies:
   * 1. `showCancelButton` is set to `always`.
   * 2. `showCancelButton` is set to `focus`, and the searchbar has been focused.
   */
  shouldShowCancelButton() {
    if (this.showCancelButton === "never" || this.showCancelButton === "focus" && !this.focused) {
      return false;
    }
    return true;
  }
  /**
   * Determines whether or not the clear button should be visible onscreen.
   * Clear button should be shown if one of two conditions applies:
   * 1. `showClearButton` is set to `always`.
   * 2. `showClearButton` is set to `focus`, and the searchbar has been focused.
   */
  shouldShowClearButton() {
    if (this.showClearButton === "never" || this.showClearButton === "focus" && !this.focused) {
      return false;
    }
    return true;
  }
  render() {
    const { cancelButtonText, autocapitalize } = this;
    const animated = this.animated && config.getBoolean("animated", true);
    const mode = getIonMode$2(this);
    const clearIcon = this.clearIcon || (mode === "ios" ? closeCircle : closeSharp);
    const searchIcon = this.searchIcon || (mode === "ios" ? searchOutline : searchSharp);
    const shouldShowCancelButton = this.shouldShowCancelButton();
    const cancelButton = this.showCancelButton !== "never" && h$1("button", { key: "0ef595eb1628928d4c7fdb166b8e41768700fa6e", "aria-label": cancelButtonText, "aria-hidden": shouldShowCancelButton ? void 0 : "true", type: "button", tabIndex: mode === "ios" && !shouldShowCancelButton ? -1 : void 0, onMouseDown: this.onCancelSearchbar, onTouchStart: this.onCancelSearchbar, class: "searchbar-cancel-button" }, h$1("div", { key: "ea2c9b36d991acf5af7662059cb6b045f683ca94", "aria-hidden": "true" }, mode === "md" ? h$1("ion-icon", { "aria-hidden": "true", mode, icon: this.cancelButtonIcon, lazy: false }) : cancelButtonText));
    return h$1(Host$1, { key: "17d57ece5852d03047e4d53ddad6c9d88a432a00", role: "search", "aria-disabled": this.disabled ? "true" : null, class: createColorClasses$2(this.color, {
      [mode]: true,
      "searchbar-animated": animated,
      "searchbar-disabled": this.disabled,
      "searchbar-no-animate": animated && this.noAnimate,
      "searchbar-has-value": this.hasValue(),
      "searchbar-left-aligned": this.shouldAlignLeft,
      "searchbar-has-focus": this.focused,
      "searchbar-should-show-clear": this.shouldShowClearButton(),
      "searchbar-should-show-cancel": this.shouldShowCancelButton()
    }) }, h$1("div", { key: "f67c2124e70c24eef0a271516e9c4bdaf7e98ceb", class: "searchbar-input-container" }, h$1("input", Object.assign({ key: "8c7f7ccc6809cca30ccc8c4e98e349d3f916321d", "aria-label": "search text", disabled: this.disabled, ref: (el2) => this.nativeInput = el2, class: "searchbar-input", inputMode: this.inputmode, enterKeyHint: this.enterkeyhint, name: this.name, onInput: this.onInput, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, minLength: this.minlength, maxLength: this.maxlength, placeholder: this.placeholder, type: this.type, value: this.getValue(), autoCapitalize: autocapitalize === "default" ? void 0 : autocapitalize, autoComplete: this.autocomplete, autoCorrect: this.autocorrect, spellcheck: this.spellcheck }, this.inheritedAttributes)), mode === "md" && cancelButton, h$1("ion-icon", { key: "f06524d3163b3883bbde937862aa1e0e8f49f6e1", "aria-hidden": "true", mode, icon: searchIcon, lazy: false, class: "searchbar-search-icon" }), h$1("button", { key: "9f7ba2bec93412ecb674b197be13db1de308bb57", "aria-label": "reset", type: "button", "no-blur": true, class: "searchbar-clear-button", onPointerDown: (ev) => {
      ev.preventDefault();
    }, onClick: () => this.onClearInput(true) }, h$1("ion-icon", { key: "19fc3dbc722acc47ff7eb3c94ad4de8aed38dff4", "aria-hidden": "true", mode, icon: clearIcon, lazy: false, class: "searchbar-clear-icon" }))), mode === "ios" && cancelButton);
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "lang": ["onLangChanged"],
      "dir": ["onDirChanged"],
      "debounce": ["debounceChanged"],
      "value": ["valueChanged"],
      "showCancelButton": ["showCancelButtonChanged"]
    };
  }
  static get style() {
    return {
      ios: IonSearchbarIosStyle0,
      md: IonSearchbarMdStyle0
    };
  }
}, [34, "ion-searchbar", {
  "color": [513],
  "animated": [4],
  "autocapitalize": [1],
  "autocomplete": [1],
  "autocorrect": [1],
  "cancelButtonIcon": [1, "cancel-button-icon"],
  "cancelButtonText": [1, "cancel-button-text"],
  "clearIcon": [1, "clear-icon"],
  "debounce": [2],
  "disabled": [4],
  "inputmode": [1],
  "enterkeyhint": [1],
  "maxlength": [2],
  "minlength": [2],
  "name": [1],
  "placeholder": [1],
  "searchIcon": [1, "search-icon"],
  "showCancelButton": [1, "show-cancel-button"],
  "showClearButton": [1, "show-clear-button"],
  "spellcheck": [4],
  "type": [1],
  "value": [1025],
  "focused": [32],
  "noAnimate": [32],
  "setFocus": [64],
  "getInputElement": [64]
}, void 0, {
  "lang": ["onLangChanged"],
  "dir": ["onDirChanged"],
  "debounce": ["debounceChanged"],
  "value": ["valueChanged"],
  "showCancelButton": ["showCancelButtonChanged"]
}]);
let searchbarIds = 0;
function defineCustomElement$1$6() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-searchbar", "ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-searchbar":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Searchbar);
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$A();
        }
        break;
    }
  });
}
const defineCustomElement$f = defineCustomElement$1$6;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const itemIosCss = ':host{--border-radius:0px;--border-width:0px;--border-style:solid;--padding-top:0px;--padding-bottom:0px;--padding-end:0px;--padding-start:0px;--inner-border-width:0px;--inner-padding-top:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;--inner-padding-end:0px;--inner-box-shadow:none;--detail-icon-color:initial;--detail-icon-font-size:1.25em;--detail-icon-opacity:0.25;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:initial;text-decoration:none;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color) .item-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.ion-color) .item-native,:host(.ion-color) .item-inner{border-color:var(--ion-color-shade)}:host(.ion-activated) .item-native{color:var(--color-activated)}:host(.ion-activated) .item-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.ion-color.ion-activated) .item-native{color:var(--ion-color-contrast)}:host(.ion-focused) .item-native{color:var(--color-focused)}:host(.ion-focused) .item-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}:host(.ion-color.ion-focused) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-focused) .item-native::after{background:var(--ion-color-contrast)}@media (any-hover: hover){:host(.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--color-hover)}:host(.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--ion-color-contrast)}}:host(.item-control-needs-pointer-cursor){cursor:pointer}:host(.item-interactive-disabled:not(.item-multiple-inputs)){cursor:default;pointer-events:none}:host(.item-disabled){cursor:default;opacity:0.3;pointer-events:none}.item-native{border-radius:var(--border-radius);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;padding-right:var(--padding-end);padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;min-height:var(--min-height);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);overflow:inherit;z-index:1;-webkit-box-sizing:border-box;box-sizing:border-box}:host-context([dir=rtl]) .item-native{padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px));padding-left:var(--padding-end)}[dir=rtl] .item-native{padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px));padding-left:var(--padding-end)}@supports selector(:dir(rtl)){.item-native:dir(rtl){padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px));padding-left:var(--padding-end)}}.item-native::-moz-focus-inner{border:0}.item-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0;-webkit-transition:var(--transition);transition:var(--transition);z-index:-1}button,a{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}.item-inner{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);padding-right:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-left:var(--inner-padding-start);display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);-webkit-box-shadow:var(--inner-box-shadow);box-shadow:var(--inner-box-shadow);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}:host-context([dir=rtl]) .item-inner{padding-right:var(--inner-padding-start);padding-left:calc(var(--ion-safe-area-left, 0px) + var(--inner-padding-end))}[dir=rtl] .item-inner{padding-right:var(--inner-padding-start);padding-left:calc(var(--ion-safe-area-left, 0px) + var(--inner-padding-end))}@supports selector(:dir(rtl)){.item-inner:dir(rtl){padding-right:var(--inner-padding-start);padding-left:calc(var(--ion-safe-area-left, 0px) + var(--inner-padding-end))}}.item-detail-icon{-webkit-margin-start:calc(var(--inner-padding-end) / 2);margin-inline-start:calc(var(--inner-padding-end) / 2);-webkit-margin-end:-6px;margin-inline-end:-6px;color:var(--detail-icon-color);font-size:var(--detail-icon-font-size);opacity:var(--detail-icon-opacity)}::slotted(ion-icon){font-size:1.6em}::slotted(ion-button){--margin-top:0;--margin-bottom:0;--margin-start:0;--margin-end:0;z-index:1}::slotted(ion-label:not([slot=end])){-ms-flex:1;flex:1;width:-webkit-min-content;width:-moz-min-content;width:min-content;max-width:100%}:host(.item-input){-ms-flex-align:center;align-items:center}.input-wrapper{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;text-overflow:ellipsis;overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.item-label-stacked),:host(.item-label-floating){-ms-flex-align:start;align-items:start}:host(.item-label-stacked) .input-wrapper,:host(.item-label-floating) .input-wrapper{-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column}:host(.item-multiple-inputs) ::slotted(ion-checkbox),:host(.item-multiple-inputs) ::slotted(ion-datetime),:host(.item-multiple-inputs) ::slotted(ion-radio){position:relative}:host(.item-textarea){-ms-flex-align:stretch;align-items:stretch}::slotted(ion-reorder[slot]){margin-top:0;margin-bottom:0}ion-ripple-effect{color:var(--ripple-color)}:host{--min-height:44px;--transition:background-color 200ms linear, opacity 200ms linear;--padding-start:16px;--inner-padding-end:16px;--inner-border-width:0px 0px 0.55px 0px;--background:var(--ion-item-background, var(--ion-background-color, #fff));--background-activated:var(--ion-text-color, #000);--background-focused:var(--ion-text-color, #000);--background-hover:currentColor;--background-activated-opacity:.12;--background-focused-opacity:.15;--background-hover-opacity:.04;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, var(--ion-background-color-step-250, #c8c7cc))));--color:var(--ion-item-color, var(--ion-text-color, #000));font-size:1rem}:host(.ion-activated){--transition:none}:host(.ion-color.ion-focused) .item-native::after{background:#000;opacity:0.15}:host(.ion-color.ion-activated) .item-native::after{background:#000;opacity:0.12}:host(.item-lines-full){--border-width:0px 0px 0.55px 0px}:host(.item-lines-inset){--inner-border-width:0px 0px 0.55px 0px}:host(.item-lines-inset),:host(.item-lines-none){--border-width:0px}:host(.item-lines-full),:host(.item-lines-none){--inner-border-width:0px}::slotted([slot=start]){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:2px;margin-bottom:2px}::slotted(ion-icon[slot=start]),::slotted(ion-icon[slot=end]){margin-top:7px;margin-bottom:7px}::slotted(ion-toggle[slot=start]),::slotted(ion-toggle[slot=end]){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}:host(.item-label-stacked) ::slotted([slot=end]),:host(.item-label-floating) ::slotted([slot=end]){margin-top:7px;margin-bottom:7px}::slotted(.button-small){--padding-top:1px;--padding-bottom:1px;--padding-start:.5em;--padding-end:.5em;min-height:24px;font-size:0.8125rem}::slotted(ion-avatar){width:36px;height:36px}::slotted(ion-thumbnail){--size:56px}::slotted(ion-avatar[slot=end]),::slotted(ion-thumbnail[slot=end]){-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:8px;margin-inline-end:8px;margin-top:8px;margin-bottom:8px}:host(.item-radio) ::slotted(ion-label),:host(.item-toggle) ::slotted(ion-label){-webkit-margin-start:0px;margin-inline-start:0px}::slotted(ion-label){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px;margin-top:10px;margin-bottom:10px}:host(.item-label-floating),:host(.item-label-stacked){--min-height:68px}';
const IonItemIosStyle0 = itemIosCss;
const itemMdCss = ':host{--border-radius:0px;--border-width:0px;--border-style:solid;--padding-top:0px;--padding-bottom:0px;--padding-end:0px;--padding-start:0px;--inner-border-width:0px;--inner-padding-top:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;--inner-padding-end:0px;--inner-box-shadow:none;--detail-icon-color:initial;--detail-icon-font-size:1.25em;--detail-icon-opacity:0.25;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:initial;text-decoration:none;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color) .item-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.ion-color) .item-native,:host(.ion-color) .item-inner{border-color:var(--ion-color-shade)}:host(.ion-activated) .item-native{color:var(--color-activated)}:host(.ion-activated) .item-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.ion-color.ion-activated) .item-native{color:var(--ion-color-contrast)}:host(.ion-focused) .item-native{color:var(--color-focused)}:host(.ion-focused) .item-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}:host(.ion-color.ion-focused) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-focused) .item-native::after{background:var(--ion-color-contrast)}@media (any-hover: hover){:host(.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--color-hover)}:host(.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--ion-color-contrast)}}:host(.item-control-needs-pointer-cursor){cursor:pointer}:host(.item-interactive-disabled:not(.item-multiple-inputs)){cursor:default;pointer-events:none}:host(.item-disabled){cursor:default;opacity:0.3;pointer-events:none}.item-native{border-radius:var(--border-radius);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;padding-right:var(--padding-end);padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;min-height:var(--min-height);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);overflow:inherit;z-index:1;-webkit-box-sizing:border-box;box-sizing:border-box}:host-context([dir=rtl]) .item-native{padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px));padding-left:var(--padding-end)}[dir=rtl] .item-native{padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px));padding-left:var(--padding-end)}@supports selector(:dir(rtl)){.item-native:dir(rtl){padding-right:calc(var(--padding-start) + var(--ion-safe-area-right, 0px));padding-left:var(--padding-end)}}.item-native::-moz-focus-inner{border:0}.item-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0;-webkit-transition:var(--transition);transition:var(--transition);z-index:-1}button,a{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}.item-inner{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);padding-right:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-left:var(--inner-padding-start);display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);-webkit-box-shadow:var(--inner-box-shadow);box-shadow:var(--inner-box-shadow);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}:host-context([dir=rtl]) .item-inner{padding-right:var(--inner-padding-start);padding-left:calc(var(--ion-safe-area-left, 0px) + var(--inner-padding-end))}[dir=rtl] .item-inner{padding-right:var(--inner-padding-start);padding-left:calc(var(--ion-safe-area-left, 0px) + var(--inner-padding-end))}@supports selector(:dir(rtl)){.item-inner:dir(rtl){padding-right:var(--inner-padding-start);padding-left:calc(var(--ion-safe-area-left, 0px) + var(--inner-padding-end))}}.item-detail-icon{-webkit-margin-start:calc(var(--inner-padding-end) / 2);margin-inline-start:calc(var(--inner-padding-end) / 2);-webkit-margin-end:-6px;margin-inline-end:-6px;color:var(--detail-icon-color);font-size:var(--detail-icon-font-size);opacity:var(--detail-icon-opacity)}::slotted(ion-icon){font-size:1.6em}::slotted(ion-button){--margin-top:0;--margin-bottom:0;--margin-start:0;--margin-end:0;z-index:1}::slotted(ion-label:not([slot=end])){-ms-flex:1;flex:1;width:-webkit-min-content;width:-moz-min-content;width:min-content;max-width:100%}:host(.item-input){-ms-flex-align:center;align-items:center}.input-wrapper{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;text-overflow:ellipsis;overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.item-label-stacked),:host(.item-label-floating){-ms-flex-align:start;align-items:start}:host(.item-label-stacked) .input-wrapper,:host(.item-label-floating) .input-wrapper{-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column}:host(.item-multiple-inputs) ::slotted(ion-checkbox),:host(.item-multiple-inputs) ::slotted(ion-datetime),:host(.item-multiple-inputs) ::slotted(ion-radio){position:relative}:host(.item-textarea){-ms-flex-align:stretch;align-items:stretch}::slotted(ion-reorder[slot]){margin-top:0;margin-bottom:0}ion-ripple-effect{color:var(--ripple-color)}:host{--min-height:48px;--background:var(--ion-item-background, var(--ion-background-color, #fff));--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor;--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, var(--ion-background-color-step-150, rgba(0, 0, 0, 0.13)))));--color:var(--ion-item-color, var(--ion-text-color, #000));--transition:opacity 15ms linear, background-color 15ms linear;--padding-start:16px;--inner-padding-end:16px;--inner-border-width:0 0 1px 0;font-size:1rem;font-weight:normal;text-transform:none}:host(.ion-color.ion-activated) .item-native::after{background:transparent}:host(.item-interactive){--border-width:0 0 1px 0;--inner-border-width:0}:host(.item-lines-full){--border-width:0 0 1px 0}:host(.item-lines-inset){--inner-border-width:0 0 1px 0}:host(.item-lines-inset),:host(.item-lines-none){--border-width:0}:host(.item-lines-full),:host(.item-lines-none){--inner-border-width:0}:host(.item-multi-line) ::slotted([slot=start]),:host(.item-multi-line) ::slotted([slot=end]){margin-top:16px;margin-bottom:16px;-ms-flex-item-align:start;align-self:flex-start}::slotted([slot=start]){-webkit-margin-end:16px;margin-inline-end:16px}::slotted([slot=end]){-webkit-margin-start:16px;margin-inline-start:16px}::slotted(ion-icon){color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54);font-size:1.5em}:host(.ion-color) ::slotted(ion-icon){color:var(--ion-color-contrast)}::slotted(ion-icon[slot]){margin-top:12px;margin-bottom:12px}::slotted(ion-icon[slot=start]){-webkit-margin-end:32px;margin-inline-end:32px}::slotted(ion-icon[slot=end]){-webkit-margin-start:16px;margin-inline-start:16px}::slotted(ion-toggle[slot=start]),::slotted(ion-toggle[slot=end]){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}::slotted(ion-note){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-ms-flex-item-align:start;align-self:flex-start;font-size:0.6875rem}::slotted(ion-note[slot]){padding-left:0;padding-right:0;padding-top:18px;padding-bottom:10px}::slotted(ion-avatar){width:40px;height:40px}::slotted(ion-thumbnail){--size:56px}::slotted(ion-avatar),::slotted(ion-thumbnail){margin-top:8px;margin-bottom:8px}::slotted(ion-avatar[slot=start]),::slotted(ion-thumbnail[slot=start]){-webkit-margin-end:16px;margin-inline-end:16px}::slotted(ion-avatar[slot=end]),::slotted(ion-thumbnail[slot=end]){-webkit-margin-start:16px;margin-inline-start:16px}::slotted(ion-label){margin-left:0;margin-right:0;margin-top:10px;margin-bottom:10px}:host(.item-label-stacked) ::slotted([slot=end]),:host(.item-label-floating) ::slotted([slot=end]){margin-top:7px;margin-bottom:7px}:host(.item-toggle) ::slotted(ion-label),:host(.item-radio) ::slotted(ion-label){-webkit-margin-start:0;margin-inline-start:0}::slotted(.button-small){--padding-top:2px;--padding-bottom:2px;--padding-start:.6em;--padding-end:.6em;min-height:25px;font-size:0.75rem}:host(.item-label-floating),:host(.item-label-stacked){--min-height:55px}:host(.ion-focused:not(.ion-color)) ::slotted(.label-stacked),:host(.ion-focused:not(.ion-color)) ::slotted(.label-floating),:host(.item-has-focus:not(.ion-color)) ::slotted(.label-stacked),:host(.item-has-focus:not(.ion-color)) ::slotted(.label-floating){color:var(--ion-color-primary, #0054e9)}';
const IonItemMdStyle0 = itemMdCss;
const Item = /* @__PURE__ */ proxyCustomElement$1(class Item2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.labelColorStyles = {};
    this.itemStyles = /* @__PURE__ */ new Map();
    this.inheritedAriaAttributes = {};
    this.multipleInputs = false;
    this.focusable = true;
    this.color = void 0;
    this.button = false;
    this.detail = void 0;
    this.detailIcon = chevronForward;
    this.disabled = false;
    this.download = void 0;
    this.href = void 0;
    this.rel = void 0;
    this.lines = void 0;
    this.routerAnimation = void 0;
    this.routerDirection = "forward";
    this.target = void 0;
    this.type = "button";
  }
  buttonChanged() {
    this.focusable = this.isFocusable();
  }
  labelColorChanged(ev) {
    const { color } = this;
    if (color === void 0) {
      this.labelColorStyles = ev.detail;
    }
  }
  itemStyle(ev) {
    ev.stopPropagation();
    const tagName = ev.target.tagName;
    const updatedStyles = ev.detail;
    const newStyles = {};
    const childStyles = this.itemStyles.get(tagName) || {};
    let hasStyleChange = false;
    Object.keys(updatedStyles).forEach((key) => {
      if (updatedStyles[key]) {
        const itemKey = "item-".concat(key);
        if (!childStyles[itemKey]) {
          hasStyleChange = true;
        }
        newStyles[itemKey] = true;
      }
    });
    if (!hasStyleChange && Object.keys(newStyles).length !== Object.keys(childStyles).length) {
      hasStyleChange = true;
    }
    if (hasStyleChange) {
      this.itemStyles.set(tagName, newStyles);
      forceUpdate(this);
    }
  }
  connectedCallback() {
    this.hasStartEl();
  }
  componentWillLoad() {
    this.inheritedAriaAttributes = inheritAttributes$2(this.el, ["aria-label"]);
  }
  componentDidLoad() {
    raf(() => {
      this.setMultipleInputs();
      this.focusable = this.isFocusable();
    });
  }
  // If the item contains multiple clickable elements and/or inputs, then the item
  // should not have a clickable input cover over the entire item to prevent
  // interfering with their individual click events
  setMultipleInputs() {
    const covers = this.el.querySelectorAll("ion-checkbox, ion-datetime, ion-select, ion-radio");
    const inputs = this.el.querySelectorAll("ion-input, ion-range, ion-searchbar, ion-segment, ion-textarea, ion-toggle");
    const clickables = this.el.querySelectorAll("ion-router-link, ion-button, a, button");
    this.multipleInputs = covers.length + inputs.length > 1 || covers.length + clickables.length > 1 || covers.length > 0 && this.isClickable();
  }
  // If the item contains an input including a checkbox, datetime, select, or radio
  // then the item will have a clickable input cover that covers the item
  // that should get the hover, focused and activated states UNLESS it has multiple
  // inputs, then those need to individually get each click
  hasCover() {
    const inputs = this.el.querySelectorAll("ion-checkbox, ion-datetime, ion-select, ion-radio");
    return inputs.length === 1 && !this.multipleInputs;
  }
  // If the item has an href or button property it will render a native
  // anchor or button that is clickable
  isClickable() {
    return this.href !== void 0 || this.button;
  }
  canActivate() {
    return this.isClickable() || this.hasCover();
  }
  isFocusable() {
    const focusableChild = this.el.querySelector(".ion-focusable");
    return this.canActivate() || focusableChild !== null;
  }
  hasStartEl() {
    const startEl = this.el.querySelector('[slot="start"]');
    if (startEl !== null) {
      this.el.classList.add("item-has-start-slot");
    }
  }
  getFirstInteractive() {
    const controls = this.el.querySelectorAll("ion-toggle:not([disabled]), ion-checkbox:not([disabled]), ion-radio:not([disabled]), ion-select:not([disabled]), ion-input:not([disabled]), ion-textarea:not([disabled])");
    return controls[0];
  }
  render() {
    const { detail, detailIcon, download, labelColorStyles, lines, disabled, href, rel, target, routerAnimation, routerDirection, inheritedAriaAttributes, multipleInputs } = this;
    const childStyles = {};
    const mode = getIonMode$2(this);
    const clickable = this.isClickable();
    const canActivate = this.canActivate();
    const TagType = clickable ? href === void 0 ? "button" : "a" : "div";
    const attrs = TagType === "button" ? { type: this.type } : {
      download,
      href,
      rel,
      target
    };
    let clickFn = {};
    const firstInteractive = this.getFirstInteractive();
    if (clickable || firstInteractive !== void 0 && !multipleInputs) {
      clickFn = {
        onClick: (ev) => {
          if (clickable) {
            openURL(href, ev, routerDirection, routerAnimation);
          }
          if (firstInteractive !== void 0 && !multipleInputs) {
            const path = ev.composedPath();
            const target2 = path[0];
            if (ev.isTrusted) {
              const clickedWithinShadowRoot = this.el.shadowRoot.contains(target2);
              if (clickedWithinShadowRoot) {
                if (firstInteractive.tagName === "ION-INPUT" || firstInteractive.tagName === "ION-TEXTAREA") {
                  firstInteractive.setFocus();
                } else {
                  firstInteractive.click();
                }
              }
            }
          }
        }
      };
    }
    const showDetail = detail !== void 0 ? detail : mode === "ios" && clickable;
    this.itemStyles.forEach((value) => {
      Object.assign(childStyles, value);
    });
    const ariaDisabled = disabled || childStyles["item-interactive-disabled"] ? "true" : null;
    const inList = hostContext("ion-list", this.el) && !hostContext("ion-radio-group", this.el);
    const firstInteractiveNeedsPointerCursor = firstInteractive !== void 0 && !["ION-INPUT", "ION-TEXTAREA"].includes(firstInteractive.tagName);
    return h$1(Host$1, { key: "02f540d8666146b5f2665ba6b39dfe774c65d5e6", "aria-disabled": ariaDisabled, class: Object.assign(Object.assign(Object.assign({}, childStyles), labelColorStyles), createColorClasses$2(this.color, {
      item: true,
      [mode]: true,
      "item-lines-default": lines === void 0,
      ["item-lines-".concat(lines)]: lines !== void 0,
      "item-control-needs-pointer-cursor": firstInteractiveNeedsPointerCursor,
      "item-disabled": disabled,
      "in-list": inList,
      "item-multiple-inputs": this.multipleInputs,
      "ion-activatable": canActivate,
      "ion-focusable": this.focusable,
      "item-rtl": document.dir === "rtl"
    })), role: inList ? "listitem" : null }, h$1(TagType, Object.assign({ key: "91cf3eedc2d7eca40a45fc3b0aaae5a87d387eb7" }, attrs, inheritedAriaAttributes, { class: "item-native", part: "native", disabled }, clickFn), h$1("slot", { key: "ae4c679ca903a78a7c933c1d02f21f5d677b6388", name: "start" }), h$1("div", { key: "a61de72dce135b6dce18e6fa19680524958924dd", class: "item-inner" }, h$1("div", { key: "d5b09966b6de8d6b4da8e139875edec4eeb1ae27", class: "input-wrapper" }, h$1("slot", { key: "79077e5708a1783b135fab6f8caff9fb2f6f387a" })), h$1("slot", { key: "cdcc71689a87e985d32170ab98538ef25227f384", name: "end" }), showDetail && h$1("ion-icon", { key: "1e82f2d0e2d2fc18bd3429a7c72e4e57447cad7a", icon: detailIcon, lazy: false, class: "item-detail-icon", part: "detail-icon", "aria-hidden": "true", "flip-rtl": detailIcon === chevronForward })), canActivate && mode === "md" && h$1("ion-ripple-effect", { key: "ab9842d0d9c64408573f07323e10f9ed29fbe6e2" })));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "button": ["buttonChanged"]
    };
  }
  static get style() {
    return {
      ios: IonItemIosStyle0,
      md: IonItemMdStyle0
    };
  }
}, [33, "ion-item", {
  "color": [513],
  "button": [4],
  "detail": [4],
  "detailIcon": [1, "detail-icon"],
  "disabled": [516],
  "download": [1],
  "href": [1],
  "rel": [1],
  "lines": [1],
  "routerAnimation": [16],
  "routerDirection": [1, "router-direction"],
  "target": [1],
  "type": [1],
  "multipleInputs": [32],
  "focusable": [32]
}, [[0, "ionColor", "labelColorChanged"], [0, "ionStyle", "itemStyle"]], {
  "button": ["buttonChanged"]
}]);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const KEYBOARD_DID_OPEN = "ionKeyboardDidShow";
const KEYBOARD_DID_CLOSE = "ionKeyboardDidHide";
const KEYBOARD_THRESHOLD = 150;
let previousVisualViewport = {};
let currentVisualViewport = {};
let keyboardOpen = false;
const resetKeyboardAssist = () => {
  previousVisualViewport = {};
  currentVisualViewport = {};
  keyboardOpen = false;
};
const startKeyboardAssist = (win2) => {
  const nativeEngine = Keyboard.getEngine();
  if (nativeEngine) {
    startNativeListeners(win2);
  } else {
    if (!win2.visualViewport) {
      return;
    }
    currentVisualViewport = copyVisualViewport(win2.visualViewport);
    win2.visualViewport.onresize = () => {
      trackViewportChanges(win2);
      if (keyboardDidOpen() || keyboardDidResize(win2)) {
        setKeyboardOpen(win2);
      } else if (keyboardDidClose(win2)) {
        setKeyboardClose(win2);
      }
    };
  }
};
const startNativeListeners = (win2) => {
  win2.addEventListener("keyboardDidShow", (ev) => setKeyboardOpen(win2, ev));
  win2.addEventListener("keyboardDidHide", () => setKeyboardClose(win2));
};
const setKeyboardOpen = (win2, ev) => {
  fireKeyboardOpenEvent(win2, ev);
  keyboardOpen = true;
};
const setKeyboardClose = (win2) => {
  fireKeyboardCloseEvent(win2);
  keyboardOpen = false;
};
const keyboardDidOpen = () => {
  const scaledHeightDifference = (previousVisualViewport.height - currentVisualViewport.height) * currentVisualViewport.scale;
  return !keyboardOpen && previousVisualViewport.width === currentVisualViewport.width && scaledHeightDifference > KEYBOARD_THRESHOLD;
};
const keyboardDidResize = (win2) => {
  return keyboardOpen && !keyboardDidClose(win2);
};
const keyboardDidClose = (win2) => {
  return keyboardOpen && currentVisualViewport.height === win2.innerHeight;
};
const fireKeyboardOpenEvent = (win2, nativeEv) => {
  const keyboardHeight = nativeEv ? nativeEv.keyboardHeight : win2.innerHeight - currentVisualViewport.height;
  const ev = new CustomEvent(KEYBOARD_DID_OPEN, {
    detail: { keyboardHeight }
  });
  win2.dispatchEvent(ev);
};
const fireKeyboardCloseEvent = (win2) => {
  const ev = new CustomEvent(KEYBOARD_DID_CLOSE);
  win2.dispatchEvent(ev);
};
const trackViewportChanges = (win2) => {
  previousVisualViewport = Object.assign({}, currentVisualViewport);
  currentVisualViewport = copyVisualViewport(win2.visualViewport);
};
const copyVisualViewport = (visualViewport) => {
  return {
    width: Math.round(visualViewport.width),
    height: Math.round(visualViewport.height),
    offsetTop: visualViewport.offsetTop,
    offsetLeft: visualViewport.offsetLeft,
    pageTop: visualViewport.pageTop,
    pageLeft: visualViewport.pageLeft,
    scale: visualViewport.scale
  };
};
const keyboard2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  KEYBOARD_DID_CLOSE,
  KEYBOARD_DID_OPEN,
  copyVisualViewport,
  keyboardDidClose,
  keyboardDidOpen,
  keyboardDidResize,
  resetKeyboardAssist,
  setKeyboardClose,
  setKeyboardOpen,
  startKeyboardAssist,
  trackViewportChanges
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
var Style;
(function(Style2) {
  Style2["Dark"] = "DARK";
  Style2["Light"] = "LIGHT";
  Style2["Default"] = "DEFAULT";
})(Style || (Style = {}));
const StatusBar = {
  getEngine() {
    const capacitor = getCapacitor();
    if (capacitor === null || capacitor === void 0 ? void 0 : capacitor.isPluginAvailable("StatusBar")) {
      return capacitor.Plugins.StatusBar;
    }
    return void 0;
  },
  setStyle(options) {
    const engine = this.getEngine();
    if (!engine) {
      return;
    }
    engine.setStyle(options);
  },
  getStyle: async function() {
    const engine = this.getEngine();
    if (!engine) {
      return Style.Default;
    }
    const { style } = await engine.getInfo();
    return style;
  }
};
const getBackdropValueForSheet = (x2, backdropBreakpoint) => {
  if (backdropBreakpoint === 1) {
    return 0;
  }
  const slope = 1 / (1 - backdropBreakpoint);
  const b2 = -(backdropBreakpoint * slope);
  return x2 * slope + b2;
};
const setCardStatusBarDark = () => {
  if (!win$2 || win$2.innerWidth >= 768) {
    return;
  }
  StatusBar.setStyle({ style: Style.Dark });
};
const setCardStatusBarDefault = (defaultStyle = Style.Default) => {
  if (!win$2 || win$2.innerWidth >= 768) {
    return;
  }
  StatusBar.setStyle({ style: defaultStyle });
};
const handleCanDismiss = async (el2, animation2) => {
  if (typeof el2.canDismiss !== "function") {
    return;
  }
  const shouldDismiss = await el2.canDismiss(void 0, GESTURE);
  if (!shouldDismiss) {
    return;
  }
  if (animation2.isRunning()) {
    animation2.onFinish(() => {
      el2.dismiss(void 0, "handler");
    }, { oneTimeCallback: true });
  } else {
    el2.dismiss(void 0, "handler");
  }
};
const calculateSpringStep = (t2) => {
  return 255275e-8 * 2.71828 ** (-14.9619 * t2) - 1.00255 * 2.71828 ** (-0.0380968 * t2) + 1;
};
const SwipeToCloseDefaults = {
  MIN_PRESENTING_SCALE: 0.915
};
const createSwipeToCloseGesture = (el2, animation2, statusBarStyle, onDismiss) => {
  const DISMISS_THRESHOLD = 0.5;
  const height = el2.offsetHeight;
  let isOpen = false;
  let canDismissBlocksGesture = false;
  let contentEl = null;
  let scrollEl = null;
  const canDismissMaxStep = 0.2;
  let initialScrollY = true;
  let lastStep = 0;
  const getScrollY = () => {
    if (contentEl && isIonContent(contentEl)) {
      return contentEl.scrollY;
    } else {
      return true;
    }
  };
  const canStart = (detail) => {
    const target = detail.event.target;
    if (target === null || !target.closest) {
      return true;
    }
    contentEl = findClosestIonContent(target);
    if (contentEl) {
      if (isIonContent(contentEl)) {
        const root2 = getElementRoot(contentEl);
        scrollEl = root2.querySelector(".inner-scroll");
      } else {
        scrollEl = contentEl;
      }
      const hasRefresherInContent = !!contentEl.querySelector("ion-refresher");
      return !hasRefresherInContent && scrollEl.scrollTop === 0;
    }
    const footer = target.closest("ion-footer");
    if (footer === null) {
      return true;
    }
    return false;
  };
  const onStart = (detail) => {
    const { deltaY } = detail;
    initialScrollY = getScrollY();
    canDismissBlocksGesture = el2.canDismiss !== void 0 && el2.canDismiss !== true;
    if (deltaY > 0 && contentEl) {
      disableContentScrollY(contentEl);
    }
    animation2.progressStart(true, isOpen ? 1 : 0);
  };
  const onMove = (detail) => {
    const { deltaY } = detail;
    if (deltaY > 0 && contentEl) {
      disableContentScrollY(contentEl);
    }
    const step = detail.deltaY / height;
    const isAttemptingDismissWithCanDismiss = step >= 0 && canDismissBlocksGesture;
    const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    const processedStep = isAttemptingDismissWithCanDismiss ? calculateSpringStep(step / maxStep) : step;
    const clampedStep = clamp(1e-4, processedStep, maxStep);
    animation2.progressStep(clampedStep);
    if (clampedStep >= DISMISS_THRESHOLD && lastStep < DISMISS_THRESHOLD) {
      setCardStatusBarDefault(statusBarStyle);
    } else if (clampedStep < DISMISS_THRESHOLD && lastStep >= DISMISS_THRESHOLD) {
      setCardStatusBarDark();
    }
    lastStep = clampedStep;
  };
  const onEnd = (detail) => {
    const velocity = detail.velocityY;
    const step = detail.deltaY / height;
    const isAttemptingDismissWithCanDismiss = step >= 0 && canDismissBlocksGesture;
    const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    const processedStep = isAttemptingDismissWithCanDismiss ? calculateSpringStep(step / maxStep) : step;
    const clampedStep = clamp(1e-4, processedStep, maxStep);
    const threshold = (detail.deltaY + velocity * 1e3) / height;
    const shouldComplete = !isAttemptingDismissWithCanDismiss && threshold >= DISMISS_THRESHOLD;
    let newStepValue = shouldComplete ? -1e-3 : 1e-3;
    if (!shouldComplete) {
      animation2.easing("cubic-bezier(1, 0, 0.68, 0.28)");
      newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], clampedStep)[0];
    } else {
      animation2.easing("cubic-bezier(0.32, 0.72, 0, 1)");
      newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], clampedStep)[0];
    }
    const duration = shouldComplete ? computeDuration(step * height, velocity) : computeDuration((1 - clampedStep) * height, velocity);
    isOpen = shouldComplete;
    gesture.enable(false);
    if (contentEl) {
      resetContentScrollY(contentEl, initialScrollY);
    }
    animation2.onFinish(() => {
      if (!shouldComplete) {
        gesture.enable(true);
      }
    }).progressEnd(shouldComplete ? 1 : 0, newStepValue, duration);
    if (isAttemptingDismissWithCanDismiss && clampedStep > maxStep / 4) {
      handleCanDismiss(el2, animation2);
    } else if (shouldComplete) {
      onDismiss();
    }
  };
  const gesture = createGesture({
    el: el2,
    gestureName: "modalSwipeToClose",
    gesturePriority: OVERLAY_GESTURE_PRIORITY,
    direction: "y",
    threshold: 10,
    canStart,
    onStart,
    onMove,
    onEnd
  });
  return gesture;
};
const computeDuration = (remaining, velocity) => {
  return clamp(400, remaining / Math.abs(velocity * 1.1), 500);
};
const createSheetEnterAnimation = (opts) => {
  const { currentBreakpoint, backdropBreakpoint } = opts;
  const shouldShowBackdrop = backdropBreakpoint === void 0 || backdropBreakpoint < currentBreakpoint;
  const initialBackdrop = shouldShowBackdrop ? "calc(var(--backdrop-opacity) * ".concat(currentBreakpoint, ")") : "0";
  const backdropAnimation = createAnimation("backdropAnimation").fromTo("opacity", 0, initialBackdrop);
  if (shouldShowBackdrop) {
    backdropAnimation.beforeStyles({
      "pointer-events": "none"
    }).afterClearStyles(["pointer-events"]);
  }
  const wrapperAnimation = createAnimation("wrapperAnimation").keyframes([
    { offset: 0, opacity: 1, transform: "translateY(100%)" },
    { offset: 1, opacity: 1, transform: "translateY(".concat(100 - currentBreakpoint * 100, "%)") }
  ]);
  return { wrapperAnimation, backdropAnimation };
};
const createSheetLeaveAnimation = (opts) => {
  const { currentBreakpoint, backdropBreakpoint } = opts;
  const backdropValue = "calc(var(--backdrop-opacity) * ".concat(getBackdropValueForSheet(currentBreakpoint, backdropBreakpoint), ")");
  const defaultBackdrop = [
    { offset: 0, opacity: backdropValue },
    { offset: 1, opacity: 0 }
  ];
  const customBackdrop = [
    { offset: 0, opacity: backdropValue },
    { offset: backdropBreakpoint, opacity: 0 },
    { offset: 1, opacity: 0 }
  ];
  const backdropAnimation = createAnimation("backdropAnimation").keyframes(backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop);
  const wrapperAnimation = createAnimation("wrapperAnimation").keyframes([
    { offset: 0, opacity: 1, transform: "translateY(".concat(100 - currentBreakpoint * 100, "%)") },
    { offset: 1, opacity: 1, transform: "translateY(100%)" }
  ]);
  return { wrapperAnimation, backdropAnimation };
};
const createEnterAnimation$1 = () => {
  const backdropAnimation = createAnimation().fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  const wrapperAnimation = createAnimation().fromTo("transform", "translateY(100vh)", "translateY(0vh)");
  return { backdropAnimation, wrapperAnimation };
};
const iosEnterAnimation = (baseEl, opts) => {
  const { presentingEl, currentBreakpoint } = opts;
  const root2 = getElementRoot(baseEl);
  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== void 0 ? createSheetEnterAnimation(opts) : createEnterAnimation$1();
  backdropAnimation.addElement(root2.querySelector("ion-backdrop"));
  wrapperAnimation.addElement(root2.querySelectorAll(".modal-wrapper, .modal-shadow")).beforeStyles({ opacity: 1 });
  const baseAnimation = createAnimation("entering-base").addElement(baseEl).easing("cubic-bezier(0.32,0.72,0,1)").duration(500).addAnimation(wrapperAnimation);
  if (presentingEl) {
    const isMobile2 = window.innerWidth < 768;
    const hasCardModal = presentingEl.tagName === "ION-MODAL" && presentingEl.presentingElement !== void 0;
    const presentingElRoot = getElementRoot(presentingEl);
    const presentingAnimation = createAnimation().beforeStyles({
      transform: "translateY(0)",
      "transform-origin": "top center",
      overflow: "hidden"
    });
    const bodyEl = document.body;
    if (isMobile2) {
      const transformOffset = !CSS.supports("width", "max(0px, 1px)") ? "30px" : "max(30px, var(--ion-safe-area-top))";
      const modalTransform = hasCardModal ? "-10px" : transformOffset;
      const toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;
      const finalTransform = "translateY(".concat(modalTransform, ") scale(").concat(toPresentingScale, ")");
      presentingAnimation.afterStyles({
        transform: finalTransform
      }).beforeAddWrite(() => bodyEl.style.setProperty("background-color", "black")).addElement(presentingEl).keyframes([
        { offset: 0, filter: "contrast(1)", transform: "translateY(0px) scale(1)", borderRadius: "0px" },
        { offset: 1, filter: "contrast(0.85)", transform: finalTransform, borderRadius: "10px 10px 0 0" }
      ]);
      baseAnimation.addAnimation(presentingAnimation);
    } else {
      baseAnimation.addAnimation(backdropAnimation);
      if (!hasCardModal) {
        wrapperAnimation.fromTo("opacity", "0", "1");
      } else {
        const toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;
        const finalTransform = "translateY(-10px) scale(".concat(toPresentingScale, ")");
        presentingAnimation.afterStyles({
          transform: finalTransform
        }).addElement(presentingElRoot.querySelector(".modal-wrapper")).keyframes([
          { offset: 0, filter: "contrast(1)", transform: "translateY(0) scale(1)" },
          { offset: 1, filter: "contrast(0.85)", transform: finalTransform }
        ]);
        const shadowAnimation = createAnimation().afterStyles({
          transform: finalTransform
        }).addElement(presentingElRoot.querySelector(".modal-shadow")).keyframes([
          { offset: 0, opacity: "1", transform: "translateY(0) scale(1)" },
          { offset: 1, opacity: "0", transform: finalTransform }
        ]);
        baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);
      }
    }
  } else {
    baseAnimation.addAnimation(backdropAnimation);
  }
  return baseAnimation;
};
const createLeaveAnimation$1 = () => {
  const backdropAnimation = createAnimation().fromTo("opacity", "var(--backdrop-opacity)", 0);
  const wrapperAnimation = createAnimation().fromTo("transform", "translateY(0vh)", "translateY(100vh)");
  return { backdropAnimation, wrapperAnimation };
};
const iosLeaveAnimation = (baseEl, opts, duration = 500) => {
  const { presentingEl, currentBreakpoint } = opts;
  const root2 = getElementRoot(baseEl);
  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== void 0 ? createSheetLeaveAnimation(opts) : createLeaveAnimation$1();
  backdropAnimation.addElement(root2.querySelector("ion-backdrop"));
  wrapperAnimation.addElement(root2.querySelectorAll(".modal-wrapper, .modal-shadow")).beforeStyles({ opacity: 1 });
  const baseAnimation = createAnimation("leaving-base").addElement(baseEl).easing("cubic-bezier(0.32,0.72,0,1)").duration(duration).addAnimation(wrapperAnimation);
  if (presentingEl) {
    const isMobile2 = window.innerWidth < 768;
    const hasCardModal = presentingEl.tagName === "ION-MODAL" && presentingEl.presentingElement !== void 0;
    const presentingElRoot = getElementRoot(presentingEl);
    const presentingAnimation = createAnimation().beforeClearStyles(["transform"]).afterClearStyles(["transform"]).onFinish((currentStep) => {
      if (currentStep !== 1) {
        return;
      }
      presentingEl.style.setProperty("overflow", "");
      const numModals = Array.from(bodyEl.querySelectorAll("ion-modal:not(.overlay-hidden)")).filter((m2) => m2.presentingElement !== void 0).length;
      if (numModals <= 1) {
        bodyEl.style.setProperty("background-color", "");
      }
    });
    const bodyEl = document.body;
    if (isMobile2) {
      const transformOffset = !CSS.supports("width", "max(0px, 1px)") ? "30px" : "max(30px, var(--ion-safe-area-top))";
      const modalTransform = hasCardModal ? "-10px" : transformOffset;
      const toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;
      const finalTransform = "translateY(".concat(modalTransform, ") scale(").concat(toPresentingScale, ")");
      presentingAnimation.addElement(presentingEl).keyframes([
        { offset: 0, filter: "contrast(0.85)", transform: finalTransform, borderRadius: "10px 10px 0 0" },
        { offset: 1, filter: "contrast(1)", transform: "translateY(0px) scale(1)", borderRadius: "0px" }
      ]);
      baseAnimation.addAnimation(presentingAnimation);
    } else {
      baseAnimation.addAnimation(backdropAnimation);
      if (!hasCardModal) {
        wrapperAnimation.fromTo("opacity", "1", "0");
      } else {
        const toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;
        const finalTransform = "translateY(-10px) scale(".concat(toPresentingScale, ")");
        presentingAnimation.addElement(presentingElRoot.querySelector(".modal-wrapper")).afterStyles({
          transform: "translate3d(0, 0, 0)"
        }).keyframes([
          { offset: 0, filter: "contrast(0.85)", transform: finalTransform },
          { offset: 1, filter: "contrast(1)", transform: "translateY(0) scale(1)" }
        ]);
        const shadowAnimation = createAnimation().addElement(presentingElRoot.querySelector(".modal-shadow")).afterStyles({
          transform: "translateY(0) scale(1)"
        }).keyframes([
          { offset: 0, opacity: "0", transform: finalTransform },
          { offset: 1, opacity: "1", transform: "translateY(0) scale(1)" }
        ]);
        baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);
      }
    }
  } else {
    baseAnimation.addAnimation(backdropAnimation);
  }
  return baseAnimation;
};
const createEnterAnimation = () => {
  const backdropAnimation = createAnimation().fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  const wrapperAnimation = createAnimation().keyframes([
    { offset: 0, opacity: 0.01, transform: "translateY(40px)" },
    { offset: 1, opacity: 1, transform: "translateY(0px)" }
  ]);
  return { backdropAnimation, wrapperAnimation };
};
const mdEnterAnimation = (baseEl, opts) => {
  const { currentBreakpoint } = opts;
  const root2 = getElementRoot(baseEl);
  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== void 0 ? createSheetEnterAnimation(opts) : createEnterAnimation();
  backdropAnimation.addElement(root2.querySelector("ion-backdrop"));
  wrapperAnimation.addElement(root2.querySelector(".modal-wrapper"));
  return createAnimation().addElement(baseEl).easing("cubic-bezier(0.36,0.66,0.04,1)").duration(280).addAnimation([backdropAnimation, wrapperAnimation]);
};
const createLeaveAnimation = () => {
  const backdropAnimation = createAnimation().fromTo("opacity", "var(--backdrop-opacity)", 0);
  const wrapperAnimation = createAnimation().keyframes([
    { offset: 0, opacity: 0.99, transform: "translateY(0px)" },
    { offset: 1, opacity: 0, transform: "translateY(40px)" }
  ]);
  return { backdropAnimation, wrapperAnimation };
};
const mdLeaveAnimation = (baseEl, opts) => {
  const { currentBreakpoint } = opts;
  const root2 = getElementRoot(baseEl);
  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== void 0 ? createSheetLeaveAnimation(opts) : createLeaveAnimation();
  backdropAnimation.addElement(root2.querySelector("ion-backdrop"));
  wrapperAnimation.addElement(root2.querySelector(".modal-wrapper"));
  return createAnimation().easing("cubic-bezier(0.47,0,0.745,0.715)").duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
};
const createSheetGesture = (baseEl, backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, animation2, breakpoints = [], getCurrentBreakpoint, onDismiss, onBreakpointChange) => {
  const defaultBackdrop = [
    { offset: 0, opacity: "var(--backdrop-opacity)" },
    { offset: 1, opacity: 0.01 }
  ];
  const customBackdrop = [
    { offset: 0, opacity: "var(--backdrop-opacity)" },
    { offset: 1 - backdropBreakpoint, opacity: 0 },
    { offset: 1, opacity: 0 }
  ];
  const SheetDefaults = {
    WRAPPER_KEYFRAMES: [
      { offset: 0, transform: "translateY(0%)" },
      { offset: 1, transform: "translateY(100%)" }
    ],
    BACKDROP_KEYFRAMES: backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop
  };
  const contentEl = baseEl.querySelector("ion-content");
  const height = wrapperEl.clientHeight;
  let currentBreakpoint = initialBreakpoint;
  let offset = 0;
  let canDismissBlocksGesture = false;
  const canDismissMaxStep = 0.95;
  const wrapperAnimation = animation2.childAnimations.find((ani) => ani.id === "wrapperAnimation");
  const backdropAnimation = animation2.childAnimations.find((ani) => ani.id === "backdropAnimation");
  const maxBreakpoint = breakpoints[breakpoints.length - 1];
  const minBreakpoint = breakpoints[0];
  const enableBackdrop = () => {
    baseEl.style.setProperty("pointer-events", "auto");
    backdropEl.style.setProperty("pointer-events", "auto");
    baseEl.classList.remove(FOCUS_TRAP_DISABLE_CLASS);
  };
  const disableBackdrop = () => {
    baseEl.style.setProperty("pointer-events", "none");
    backdropEl.style.setProperty("pointer-events", "none");
    baseEl.classList.add(FOCUS_TRAP_DISABLE_CLASS);
  };
  if (wrapperAnimation && backdropAnimation) {
    wrapperAnimation.keyframes([...SheetDefaults.WRAPPER_KEYFRAMES]);
    backdropAnimation.keyframes([...SheetDefaults.BACKDROP_KEYFRAMES]);
    animation2.progressStart(true, 1 - currentBreakpoint);
    const shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;
    if (shouldEnableBackdrop) {
      enableBackdrop();
    } else {
      disableBackdrop();
    }
  }
  if (contentEl && currentBreakpoint !== maxBreakpoint) {
    contentEl.scrollY = false;
  }
  const canStart = (detail) => {
    const contentEl2 = findClosestIonContent(detail.event.target);
    currentBreakpoint = getCurrentBreakpoint();
    if (currentBreakpoint === 1 && contentEl2) {
      const scrollEl = isIonContent(contentEl2) ? getElementRoot(contentEl2).querySelector(".inner-scroll") : contentEl2;
      const hasRefresherInContent = !!contentEl2.querySelector("ion-refresher");
      return !hasRefresherInContent && scrollEl.scrollTop === 0;
    }
    return true;
  };
  const onStart = (detail) => {
    canDismissBlocksGesture = baseEl.canDismiss !== void 0 && baseEl.canDismiss !== true && minBreakpoint === 0;
    if (detail.deltaY > 0 && contentEl) {
      contentEl.scrollY = false;
    }
    raf(() => {
      baseEl.focus();
    });
    animation2.progressStart(true, 1 - currentBreakpoint);
  };
  const onMove = (detail) => {
    if (detail.deltaY > 0 && contentEl) {
      contentEl.scrollY = false;
    }
    const initialStep = 1 - currentBreakpoint;
    const secondToLastBreakpoint = breakpoints.length > 1 ? 1 - breakpoints[1] : void 0;
    const step = initialStep + detail.deltaY / height;
    const isAttemptingDismissWithCanDismiss = secondToLastBreakpoint !== void 0 && step >= secondToLastBreakpoint && canDismissBlocksGesture;
    const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    const processedStep = isAttemptingDismissWithCanDismiss && secondToLastBreakpoint !== void 0 ? secondToLastBreakpoint + calculateSpringStep((step - secondToLastBreakpoint) / (maxStep - secondToLastBreakpoint)) : step;
    offset = clamp(1e-4, processedStep, maxStep);
    animation2.progressStep(offset);
  };
  const onEnd = (detail) => {
    const velocity = detail.velocityY;
    const threshold = (detail.deltaY + velocity * 350) / height;
    const diff = currentBreakpoint - threshold;
    const closest = breakpoints.reduce((a, b2) => {
      return Math.abs(b2 - diff) < Math.abs(a - diff) ? b2 : a;
    });
    moveSheetToBreakpoint({
      breakpoint: closest,
      breakpointOffset: offset,
      canDismiss: canDismissBlocksGesture,
      /**
       * The swipe is user-driven, so we should
       * always animate when the gesture ends.
       */
      animated: true
    });
  };
  const moveSheetToBreakpoint = (options) => {
    const { breakpoint, canDismiss, breakpointOffset, animated } = options;
    const shouldPreventDismiss = canDismiss && breakpoint === 0;
    const snapToBreakpoint = shouldPreventDismiss ? currentBreakpoint : breakpoint;
    const shouldRemainOpen = snapToBreakpoint !== 0;
    currentBreakpoint = 0;
    if (wrapperAnimation && backdropAnimation) {
      wrapperAnimation.keyframes([
        { offset: 0, transform: "translateY(".concat(breakpointOffset * 100, "%)") },
        { offset: 1, transform: "translateY(".concat((1 - snapToBreakpoint) * 100, "%)") }
      ]);
      backdropAnimation.keyframes([
        {
          offset: 0,
          opacity: "calc(var(--backdrop-opacity) * ".concat(getBackdropValueForSheet(1 - breakpointOffset, backdropBreakpoint), ")")
        },
        {
          offset: 1,
          opacity: "calc(var(--backdrop-opacity) * ".concat(getBackdropValueForSheet(snapToBreakpoint, backdropBreakpoint), ")")
        }
      ]);
      animation2.progressStep(0);
    }
    gesture.enable(false);
    if (shouldPreventDismiss) {
      handleCanDismiss(baseEl, animation2);
    } else if (!shouldRemainOpen) {
      onDismiss();
    }
    if (contentEl && snapToBreakpoint === breakpoints[breakpoints.length - 1]) {
      contentEl.scrollY = true;
    }
    return new Promise((resolve) => {
      animation2.onFinish(() => {
        if (shouldRemainOpen) {
          if (wrapperAnimation && backdropAnimation) {
            raf(() => {
              wrapperAnimation.keyframes([...SheetDefaults.WRAPPER_KEYFRAMES]);
              backdropAnimation.keyframes([...SheetDefaults.BACKDROP_KEYFRAMES]);
              animation2.progressStart(true, 1 - snapToBreakpoint);
              currentBreakpoint = snapToBreakpoint;
              onBreakpointChange(currentBreakpoint);
              const shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;
              if (shouldEnableBackdrop) {
                enableBackdrop();
              } else {
                disableBackdrop();
              }
              gesture.enable(true);
              resolve();
            });
          } else {
            gesture.enable(true);
            resolve();
          }
        } else {
          resolve();
        }
      }, { oneTimeCallback: true }).progressEnd(1, 0, animated ? 500 : 0);
    });
  };
  const gesture = createGesture({
    el: wrapperEl,
    gestureName: "modalSheet",
    gesturePriority: 40,
    direction: "y",
    threshold: 10,
    canStart,
    onStart,
    onMove,
    onEnd
  });
  return {
    gesture,
    moveSheetToBreakpoint
  };
};
const modalIosCss = ':host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;color:var(--ion-text-color, #000);contain:strict}.modal-wrapper,ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);border:0;background:var(--ion-color-step-350, var(--ion-background-color-step-350, #c0c0be));cursor:pointer;z-index:11}.modal-handle::before{-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px;padding-top:4px;padding-bottom:4px;position:absolute;width:36px;height:5px;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);content:""}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host{--backdrop-opacity:var(--ion-backdrop-opacity, 0.4)}:host(.modal-card),:host(.modal-sheet){--border-radius:10px}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:10px}}.modal-wrapper{-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0)}@media screen and (max-width: 767px){@supports (width: max(0px, 1px)){:host(.modal-card){--height:calc(100% - max(30px, var(--ion-safe-area-top)) - 10px)}}@supports not (width: max(0px, 1px)){:host(.modal-card){--height:calc(100% - 40px)}}:host(.modal-card) .modal-wrapper{border-start-start-radius:var(--border-radius);border-start-end-radius:var(--border-radius);border-end-end-radius:0;border-end-start-radius:0}:host(.modal-card){--backdrop-opacity:0;--width:100%;-ms-flex-align:end;align-items:flex-end}:host(.modal-card) .modal-shadow{display:none}:host(.modal-card) ion-backdrop{pointer-events:none}}@media screen and (min-width: 768px){:host(.modal-card){--width:calc(100% - 120px);--height:calc(100% - (120px + var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));--max-width:720px;--max-height:1000px;--backdrop-opacity:0;--box-shadow:0px 0px 30px 10px rgba(0, 0, 0, 0.1);-webkit-transition:all 0.5s ease-in-out;transition:all 0.5s ease-in-out}:host(.modal-card) .modal-wrapper{-webkit-box-shadow:none;box-shadow:none}:host(.modal-card) .modal-shadow{-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow)}}:host(.modal-sheet) .modal-wrapper{border-start-start-radius:var(--border-radius);border-start-end-radius:var(--border-radius);border-end-end-radius:0;border-end-start-radius:0}';
const IonModalIosStyle0 = modalIosCss;
const modalMdCss = ':host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;color:var(--ion-text-color, #000);contain:strict}.modal-wrapper,ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);border:0;background:var(--ion-color-step-350, var(--ion-background-color-step-350, #c0c0be));cursor:pointer;z-index:11}.modal-handle::before{-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px;padding-top:4px;padding-bottom:4px;position:absolute;width:36px;height:5px;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);content:""}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host{--backdrop-opacity:var(--ion-backdrop-opacity, 0.32)}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:2px;--box-shadow:0 28px 48px rgba(0, 0, 0, 0.4)}}.modal-wrapper{-webkit-transform:translate3d(0,  40px,  0);transform:translate3d(0,  40px,  0);opacity:0.01}';
const IonModalMdStyle0 = modalMdCss;
const Modal = /* @__PURE__ */ proxyCustomElement$1(class Modal2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.didPresent = createEvent(this, "ionModalDidPresent", 7);
    this.willPresent = createEvent(this, "ionModalWillPresent", 7);
    this.willDismiss = createEvent(this, "ionModalWillDismiss", 7);
    this.didDismiss = createEvent(this, "ionModalDidDismiss", 7);
    this.ionBreakpointDidChange = createEvent(this, "ionBreakpointDidChange", 7);
    this.didPresentShorthand = createEvent(this, "didPresent", 7);
    this.willPresentShorthand = createEvent(this, "willPresent", 7);
    this.willDismissShorthand = createEvent(this, "willDismiss", 7);
    this.didDismissShorthand = createEvent(this, "didDismiss", 7);
    this.ionMount = createEvent(this, "ionMount", 7);
    this.lockController = createLockController();
    this.triggerController = createTriggerController();
    this.coreDelegate = CoreDelegate();
    this.isSheetModal = false;
    this.inheritedAttributes = {};
    this.inline = false;
    this.gestureAnimationDismissing = false;
    this.onHandleClick = () => {
      const { sheetTransition, handleBehavior } = this;
      if (handleBehavior !== "cycle" || sheetTransition !== void 0) {
        return;
      }
      this.moveToNextBreakpoint();
    };
    this.onBackdropTap = () => {
      const { sheetTransition } = this;
      if (sheetTransition !== void 0) {
        return;
      }
      this.dismiss(void 0, BACKDROP);
    };
    this.onLifecycle = (modalEvent) => {
      const el2 = this.usersElement;
      const name = LIFECYCLE_MAP[modalEvent.type];
      if (el2 && name) {
        const ev = new CustomEvent(name, {
          bubbles: false,
          cancelable: false,
          detail: modalEvent.detail
        });
        el2.dispatchEvent(ev);
      }
    };
    this.presented = false;
    this.hasController = false;
    this.overlayIndex = void 0;
    this.delegate = void 0;
    this.keyboardClose = true;
    this.enterAnimation = void 0;
    this.leaveAnimation = void 0;
    this.breakpoints = void 0;
    this.initialBreakpoint = void 0;
    this.backdropBreakpoint = 0;
    this.handle = void 0;
    this.handleBehavior = "none";
    this.component = void 0;
    this.componentProps = void 0;
    this.cssClass = void 0;
    this.backdropDismiss = true;
    this.showBackdrop = true;
    this.animated = true;
    this.presentingElement = void 0;
    this.htmlAttributes = void 0;
    this.isOpen = false;
    this.trigger = void 0;
    this.keepContentsMounted = false;
    this.focusTrap = true;
    this.canDismiss = true;
  }
  onIsOpenChange(newValue, oldValue) {
    if (newValue === true && oldValue === false) {
      this.present();
    } else if (newValue === false && oldValue === true) {
      this.dismiss();
    }
  }
  triggerChanged() {
    const { trigger, el: el2, triggerController } = this;
    if (trigger) {
      triggerController.addClickListener(el2, trigger);
    }
  }
  breakpointsChanged(breakpoints) {
    if (breakpoints !== void 0) {
      this.sortedBreakpoints = breakpoints.sort((a, b2) => a - b2);
    }
  }
  connectedCallback() {
    const { el: el2 } = this;
    prepareOverlay(el2);
    this.triggerChanged();
  }
  disconnectedCallback() {
    this.triggerController.removeClickListener();
  }
  componentWillLoad() {
    var _a;
    const { breakpoints, initialBreakpoint, el: el2, htmlAttributes } = this;
    const isSheetModal = this.isSheetModal = breakpoints !== void 0 && initialBreakpoint !== void 0;
    const attributesToInherit = ["aria-label", "role"];
    this.inheritedAttributes = inheritAttributes$2(el2, attributesToInherit);
    if (htmlAttributes !== void 0) {
      attributesToInherit.forEach((attribute) => {
        const attributeValue = htmlAttributes[attribute];
        if (attributeValue) {
          this.inheritedAttributes = Object.assign(Object.assign({}, this.inheritedAttributes), { [attribute]: htmlAttributes[attribute] });
          delete htmlAttributes[attribute];
        }
      });
    }
    if (isSheetModal) {
      this.currentBreakpoint = this.initialBreakpoint;
    }
    if (breakpoints !== void 0 && initialBreakpoint !== void 0 && !breakpoints.includes(initialBreakpoint)) {
      printIonWarning("Your breakpoints array must include the initialBreakpoint value.");
    }
    if (!((_a = this.htmlAttributes) === null || _a === void 0 ? void 0 : _a.id)) {
      setOverlayId(this.el);
    }
  }
  componentDidLoad() {
    if (this.isOpen === true) {
      raf(() => this.present());
    }
    this.breakpointsChanged(this.breakpoints);
    this.triggerChanged();
  }
  /**
   * Determines whether or not an overlay
   * is being used inline or via a controller/JS
   * and returns the correct delegate.
   * By default, subsequent calls to getDelegate
   * will use a cached version of the delegate.
   * This is useful for calling dismiss after
   * present so that the correct delegate is given.
   */
  getDelegate(force = false) {
    if (this.workingDelegate && !force) {
      return {
        delegate: this.workingDelegate,
        inline: this.inline
      };
    }
    const parentEl = this.el.parentNode;
    const inline = this.inline = parentEl !== null && !this.hasController;
    const delegate = this.workingDelegate = inline ? this.delegate || this.coreDelegate : this.delegate;
    return { inline, delegate };
  }
  /**
   * Determines whether or not the
   * modal is allowed to dismiss based
   * on the state of the canDismiss prop.
   */
  async checkCanDismiss(data, role) {
    const { canDismiss } = this;
    if (typeof canDismiss === "function") {
      return canDismiss(data, role);
    }
    return canDismiss;
  }
  /**
   * Present the modal overlay after it has been created.
   */
  async present() {
    const unlock = await this.lockController.lock();
    if (this.presented) {
      unlock();
      return;
    }
    const { presentingElement, el: el2 } = this;
    this.currentBreakpoint = this.initialBreakpoint;
    const { inline, delegate } = this.getDelegate(true);
    this.ionMount.emit();
    this.usersElement = await attachComponent(delegate, el2, this.component, ["ion-page"], this.componentProps, inline);
    if (hasLazyBuild(el2)) {
      await deepReady(this.usersElement);
    } else if (!this.keepContentsMounted) {
      await waitForMount();
    }
    writeTask$1(() => this.el.classList.add("show-modal"));
    const hasCardModal = presentingElement !== void 0;
    if (hasCardModal && getIonMode$2(this) === "ios") {
      this.statusBarStyle = await StatusBar.getStyle();
      setCardStatusBarDark();
    }
    await present(this, "modalEnter", iosEnterAnimation, mdEnterAnimation, {
      presentingEl: presentingElement,
      currentBreakpoint: this.initialBreakpoint,
      backdropBreakpoint: this.backdropBreakpoint
    });
    if (typeof window !== "undefined") {
      this.keyboardOpenCallback = () => {
        if (this.gesture) {
          this.gesture.enable(false);
          raf(() => {
            if (this.gesture) {
              this.gesture.enable(true);
            }
          });
        }
      };
      window.addEventListener(KEYBOARD_DID_OPEN, this.keyboardOpenCallback);
    }
    if (this.isSheetModal) {
      this.initSheetGesture();
    } else if (hasCardModal) {
      this.initSwipeToClose();
    }
    unlock();
  }
  initSwipeToClose() {
    var _a;
    if (getIonMode$2(this) !== "ios") {
      return;
    }
    const { el: el2 } = this;
    const animationBuilder = this.leaveAnimation || config.get("modalLeave", iosLeaveAnimation);
    const ani = this.animation = animationBuilder(el2, { presentingEl: this.presentingElement });
    const contentEl = findIonContent(el2);
    if (!contentEl) {
      printIonContentErrorMsg(el2);
      return;
    }
    const statusBarStyle = (_a = this.statusBarStyle) !== null && _a !== void 0 ? _a : Style.Default;
    this.gesture = createSwipeToCloseGesture(el2, ani, statusBarStyle, () => {
      this.gestureAnimationDismissing = true;
      setCardStatusBarDefault(this.statusBarStyle);
      this.animation.onFinish(async () => {
        await this.dismiss(void 0, GESTURE);
        this.gestureAnimationDismissing = false;
      });
    });
    this.gesture.enable(true);
  }
  initSheetGesture() {
    const { wrapperEl, initialBreakpoint, backdropBreakpoint } = this;
    if (!wrapperEl || initialBreakpoint === void 0) {
      return;
    }
    const animationBuilder = this.enterAnimation || config.get("modalEnter", iosEnterAnimation);
    const ani = this.animation = animationBuilder(this.el, {
      presentingEl: this.presentingElement,
      currentBreakpoint: initialBreakpoint,
      backdropBreakpoint
    });
    ani.progressStart(true, 1);
    const { gesture, moveSheetToBreakpoint } = createSheetGesture(this.el, this.backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, ani, this.sortedBreakpoints, () => {
      var _a;
      return (_a = this.currentBreakpoint) !== null && _a !== void 0 ? _a : 0;
    }, () => this.sheetOnDismiss(), (breakpoint) => {
      if (this.currentBreakpoint !== breakpoint) {
        this.currentBreakpoint = breakpoint;
        this.ionBreakpointDidChange.emit({ breakpoint });
      }
    });
    this.gesture = gesture;
    this.moveSheetToBreakpoint = moveSheetToBreakpoint;
    this.gesture.enable(true);
  }
  sheetOnDismiss() {
    this.gestureAnimationDismissing = true;
    this.animation.onFinish(async () => {
      this.currentBreakpoint = 0;
      this.ionBreakpointDidChange.emit({ breakpoint: this.currentBreakpoint });
      await this.dismiss(void 0, GESTURE);
      this.gestureAnimationDismissing = false;
    });
  }
  /**
   * Dismiss the modal overlay after it has been presented.
   *
   * @param data Any data to emit in the dismiss events.
   * @param role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.
   *
   * This is a no-op if the overlay has not been presented yet. If you want
   * to remove an overlay from the DOM that was never presented, use the
   * [remove](https://developer.mozilla.org/en-US/docs/Web/API/Element/remove) method.
   */
  async dismiss(data, role) {
    var _a;
    if (this.gestureAnimationDismissing && role !== GESTURE) {
      return false;
    }
    const unlock = await this.lockController.lock();
    if (role !== "handler" && !await this.checkCanDismiss(data, role)) {
      unlock();
      return false;
    }
    const { presentingElement } = this;
    const hasCardModal = presentingElement !== void 0;
    if (hasCardModal && getIonMode$2(this) === "ios") {
      setCardStatusBarDefault(this.statusBarStyle);
    }
    if (typeof window !== "undefined" && this.keyboardOpenCallback) {
      window.removeEventListener(KEYBOARD_DID_OPEN, this.keyboardOpenCallback);
      this.keyboardOpenCallback = void 0;
    }
    const dismissed = await dismiss(this, data, role, "modalLeave", iosLeaveAnimation, mdLeaveAnimation, {
      presentingEl: presentingElement,
      currentBreakpoint: (_a = this.currentBreakpoint) !== null && _a !== void 0 ? _a : this.initialBreakpoint,
      backdropBreakpoint: this.backdropBreakpoint
    });
    if (dismissed) {
      const { delegate } = this.getDelegate();
      await detachComponent(delegate, this.usersElement);
      writeTask$1(() => this.el.classList.remove("show-modal"));
      if (this.animation) {
        this.animation.destroy();
      }
      if (this.gesture) {
        this.gesture.destroy();
      }
    }
    this.currentBreakpoint = void 0;
    this.animation = void 0;
    unlock();
    return dismissed;
  }
  /**
   * Returns a promise that resolves when the modal did dismiss.
   */
  onDidDismiss() {
    return eventMethod(this.el, "ionModalDidDismiss");
  }
  /**
   * Returns a promise that resolves when the modal will dismiss.
   */
  onWillDismiss() {
    return eventMethod(this.el, "ionModalWillDismiss");
  }
  /**
   * Move a sheet style modal to a specific breakpoint. The breakpoint value must
   * be a value defined in your `breakpoints` array.
   */
  async setCurrentBreakpoint(breakpoint) {
    if (!this.isSheetModal) {
      printIonWarning("setCurrentBreakpoint is only supported on sheet modals.");
      return;
    }
    if (!this.breakpoints.includes(breakpoint)) {
      printIonWarning("Attempted to set invalid breakpoint value ".concat(breakpoint, ". Please double check that the breakpoint value is part of your defined breakpoints."));
      return;
    }
    const { currentBreakpoint, moveSheetToBreakpoint, canDismiss, breakpoints, animated } = this;
    if (currentBreakpoint === breakpoint) {
      return;
    }
    if (moveSheetToBreakpoint) {
      this.sheetTransition = moveSheetToBreakpoint({
        breakpoint,
        breakpointOffset: 1 - currentBreakpoint,
        canDismiss: canDismiss !== void 0 && canDismiss !== true && breakpoints[0] === 0,
        animated
      });
      await this.sheetTransition;
      this.sheetTransition = void 0;
    }
  }
  /**
   * Returns the current breakpoint of a sheet style modal
   */
  async getCurrentBreakpoint() {
    return this.currentBreakpoint;
  }
  async moveToNextBreakpoint() {
    const { breakpoints, currentBreakpoint } = this;
    if (!breakpoints || currentBreakpoint == null) {
      return false;
    }
    const allowedBreakpoints = breakpoints.filter((b2) => b2 !== 0);
    const currentBreakpointIndex = allowedBreakpoints.indexOf(currentBreakpoint);
    const nextBreakpointIndex = (currentBreakpointIndex + 1) % allowedBreakpoints.length;
    const nextBreakpoint = allowedBreakpoints[nextBreakpointIndex];
    await this.setCurrentBreakpoint(nextBreakpoint);
    return true;
  }
  render() {
    const { handle, isSheetModal, presentingElement, htmlAttributes, handleBehavior, inheritedAttributes, focusTrap } = this;
    const showHandle = handle !== false && isSheetModal;
    const mode = getIonMode$2(this);
    const isCardModal = presentingElement !== void 0 && mode === "ios";
    const isHandleCycle = handleBehavior === "cycle";
    return h$1(Host$1, Object.assign({ key: "b4da5111fe4719fa450c39b2d4bd884a302a7924", "no-router": true, tabindex: "-1" }, htmlAttributes, { style: {
      zIndex: "".concat(2e4 + this.overlayIndex)
    }, class: Object.assign({ [mode]: true, ["modal-default"]: !isCardModal && !isSheetModal, ["modal-card"]: isCardModal, ["modal-sheet"]: isSheetModal, "overlay-hidden": true, [FOCUS_TRAP_DISABLE_CLASS]: focusTrap === false }, getClassMap(this.cssClass)), onIonBackdropTap: this.onBackdropTap, onIonModalDidPresent: this.onLifecycle, onIonModalWillPresent: this.onLifecycle, onIonModalWillDismiss: this.onLifecycle, onIonModalDidDismiss: this.onLifecycle }), h$1("ion-backdrop", { key: "c12dbf747e0eb914eaf1331798548ffc7e147763", ref: (el2) => this.backdropEl = el2, visible: this.showBackdrop, tappable: this.backdropDismiss, part: "backdrop" }), mode === "ios" && h$1("div", { key: "da546ee80c6576b5acc66e959fd5009e0b9a8160", class: "modal-shadow" }), h$1("div", Object.assign({
      key: "306ebe6427440ad5f7ed36d590e562d15a503b75",
      /*
        role and aria-modal must be used on the
        same element. They must also be set inside the
        shadow DOM otherwise ion-button will not be highlighted
        when using VoiceOver: https://bugs.webkit.org/show_bug.cgi?id=247134
      */
      role: "dialog"
    }, inheritedAttributes, { "aria-modal": "true", class: "modal-wrapper ion-overlay-wrapper", part: "content", ref: (el2) => this.wrapperEl = el2 }), showHandle && h$1("button", {
      key: "c5d17e346fe255a7c0cacbbf15c0083f2d09c488",
      class: "modal-handle",
      // Prevents the handle from receiving keyboard focus when it does not cycle
      tabIndex: !isHandleCycle ? -1 : 0,
      "aria-label": "Activate to adjust the size of the dialog overlaying the screen",
      onClick: isHandleCycle ? this.onHandleClick : void 0,
      part: "handle"
    }), h$1("slot", { key: "5cc714170a00b67f3eda0cd1d6f37c1489a99c83" })));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "isOpen": ["onIsOpenChange"],
      "trigger": ["triggerChanged"]
    };
  }
  static get style() {
    return {
      ios: IonModalIosStyle0,
      md: IonModalMdStyle0
    };
  }
}, [33, "ion-modal", {
  "hasController": [4, "has-controller"],
  "overlayIndex": [2, "overlay-index"],
  "delegate": [16],
  "keyboardClose": [4, "keyboard-close"],
  "enterAnimation": [16],
  "leaveAnimation": [16],
  "breakpoints": [16],
  "initialBreakpoint": [2, "initial-breakpoint"],
  "backdropBreakpoint": [2, "backdrop-breakpoint"],
  "handle": [4],
  "handleBehavior": [1, "handle-behavior"],
  "component": [1],
  "componentProps": [16],
  "cssClass": [1, "css-class"],
  "backdropDismiss": [4, "backdrop-dismiss"],
  "showBackdrop": [4, "show-backdrop"],
  "animated": [4],
  "presentingElement": [16],
  "htmlAttributes": [16],
  "isOpen": [4, "is-open"],
  "trigger": [1],
  "keepContentsMounted": [4, "keep-contents-mounted"],
  "focusTrap": [4, "focus-trap"],
  "canDismiss": [4, "can-dismiss"],
  "presented": [32],
  "present": [64],
  "dismiss": [64],
  "onDidDismiss": [64],
  "onWillDismiss": [64],
  "setCurrentBreakpoint": [64],
  "getCurrentBreakpoint": [64]
}, void 0, {
  "isOpen": ["onIsOpenChange"],
  "trigger": ["triggerChanged"]
}]);
const LIFECYCLE_MAP = {
  ionModalDidPresent: "ionViewDidEnter",
  ionModalWillPresent: "ionViewWillEnter",
  ionModalWillDismiss: "ionViewWillLeave",
  ionModalDidDismiss: "ionViewDidLeave"
};
function defineCustomElement$e() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-modal", "ion-backdrop"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-modal":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Modal);
        }
        break;
      case "ion-backdrop":
        if (!customElements.get(tagName)) {
          defineCustomElement$z();
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const titleIosCss = ":host{--color:initial;display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}.toolbar-title{display:block;width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;pointer-events:auto}:host(.title-small) .toolbar-title{white-space:normal}:host{top:0;-webkit-padding-start:90px;padding-inline-start:90px;-webkit-padding-end:90px;padding-inline-end:90px;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);position:absolute;width:100%;height:100%;-webkit-transform:translateZ(0);transform:translateZ(0);font-size:min(1.0625rem, 20.4px);font-weight:600;text-align:center;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}:host{inset-inline-start:0}:host(.title-small){-webkit-padding-start:9px;padding-inline-start:9px;-webkit-padding-end:9px;padding-inline-end:9px;padding-top:6px;padding-bottom:16px;position:relative;font-size:min(0.8125rem, 23.4px);font-weight:normal}:host(.title-large){-webkit-padding-start:12px;padding-inline-start:12px;-webkit-padding-end:12px;padding-inline-end:12px;padding-top:2px;padding-bottom:4px;-webkit-transform-origin:left center;transform-origin:left center;position:static;-ms-flex-align:end;align-items:flex-end;min-width:100%;font-size:min(2.125rem, 61.2px);font-weight:700;text-align:start}:host(.title-large.title-rtl){-webkit-transform-origin:right center;transform-origin:right center}:host(.title-large.ion-cloned-element){--color:var(--ion-text-color, #000);font-family:var(--ion-font-family)}:host(.title-large) .toolbar-title{-webkit-transform-origin:inherit;transform-origin:inherit;width:auto}:host-context([dir=rtl]):host(.title-large) .toolbar-title,:host-context([dir=rtl]).title-large .toolbar-title{-webkit-transform-origin:calc(100% - inherit);transform-origin:calc(100% - inherit)}@supports selector(:dir(rtl)){:host(.title-large:dir(rtl)) .toolbar-title{-webkit-transform-origin:calc(100% - inherit);transform-origin:calc(100% - inherit)}}";
const IonTitleIosStyle0 = titleIosCss;
const titleMdCss = ":host{--color:initial;display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}.toolbar-title{display:block;width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;pointer-events:auto}:host(.title-small) .toolbar-title{white-space:normal}:host{-webkit-padding-start:20px;padding-inline-start:20px;-webkit-padding-end:20px;padding-inline-end:20px;padding-top:0;padding-bottom:0;font-size:1.25rem;font-weight:500;letter-spacing:0.0125em}:host(.title-small){width:100%;height:100%;font-size:0.9375rem;font-weight:normal}";
const IonTitleMdStyle0 = titleMdCss;
const ToolbarTitle = /* @__PURE__ */ proxyCustomElement$1(class ToolbarTitle2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.color = void 0;
    this.size = void 0;
  }
  sizeChanged() {
    this.emitStyle();
  }
  connectedCallback() {
    this.emitStyle();
  }
  emitStyle() {
    const size = this.getSize();
    this.ionStyle.emit({
      ["title-".concat(size)]: true
    });
  }
  getSize() {
    return this.size !== void 0 ? this.size : "default";
  }
  render() {
    const mode = getIonMode$2(this);
    const size = this.getSize();
    return h$1(Host$1, { key: "7293d2ecd6262feb0d8d769effbb208230baed89", class: createColorClasses$2(this.color, {
      [mode]: true,
      ["title-".concat(size)]: true,
      "title-rtl": document.dir === "rtl"
    }) }, h$1("div", { key: "086ec3a361ebdf6506846a8704b457cda3a6f897", class: "toolbar-title" }, h$1("slot", { key: "59add7eb92b82d6832a8f0894f897c51fdf4f214" })));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "size": ["sizeChanged"]
    };
  }
  static get style() {
    return {
      ios: IonTitleIosStyle0,
      md: IonTitleMdStyle0
    };
  }
}, [33, "ion-title", {
  "color": [513],
  "size": [1]
}, void 0, {
  "size": ["sizeChanged"]
}]);
function defineCustomElement$d() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-title"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-title":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, ToolbarTitle);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const toolbarIosCss = ":host{--border-width:0;--border-style:solid;--opacity:1;--opacity-scale:1;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;width:100%;padding-right:var(--ion-safe-area-right);padding-left:var(--ion-safe-area-left);color:var(--color);font-family:var(--ion-font-family, inherit);contain:content;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color){color:var(--ion-color-contrast)}:host(.ion-color) .toolbar-background{background:var(--ion-color-base)}.toolbar-container{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:row;flex-direction:row;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:var(--min-height);contain:content;overflow:hidden;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}.toolbar-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;opacity:calc(var(--opacity) * var(--opacity-scale));z-index:-1;pointer-events:none}::slotted(ion-progress-bar){left:0;right:0;bottom:0;position:absolute}:host{--background:var(--ion-toolbar-background, var(--ion-color-step-50, var(--ion-background-color-step-50, #f7f7f7)));--color:var(--ion-toolbar-color, var(--ion-text-color, #000));--border-color:var(--ion-toolbar-border-color, var(--ion-border-color, var(--ion-color-step-150, var(--ion-background-color-step-150, rgba(0, 0, 0, 0.2)))));--padding-top:3px;--padding-bottom:3px;--padding-start:4px;--padding-end:4px;--min-height:44px}.toolbar-content{-ms-flex:1;flex:1;-ms-flex-order:4;order:4;min-width:0}:host(.toolbar-segment) .toolbar-content{display:-ms-inline-flexbox;display:inline-flex}:host(.toolbar-searchbar) .toolbar-container{padding-top:0;padding-bottom:0}:host(.toolbar-searchbar) ::slotted(*){-ms-flex-item-align:start;align-self:start}:host(.toolbar-searchbar) ::slotted(ion-chip){margin-top:3px}::slotted(ion-buttons){min-height:38px}::slotted([slot=start]){-ms-flex-order:2;order:2}::slotted([slot=secondary]){-ms-flex-order:3;order:3}::slotted([slot=primary]){-ms-flex-order:5;order:5;text-align:end}::slotted([slot=end]){-ms-flex-order:6;order:6;text-align:end}:host(.toolbar-title-large) .toolbar-container{-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:start;align-items:flex-start}:host(.toolbar-title-large) .toolbar-content ion-title{-ms-flex:1;flex:1;-ms-flex-order:8;order:8;min-width:100%}";
const IonToolbarIosStyle0 = toolbarIosCss;
const toolbarMdCss = ":host{--border-width:0;--border-style:solid;--opacity:1;--opacity-scale:1;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;width:100%;padding-right:var(--ion-safe-area-right);padding-left:var(--ion-safe-area-left);color:var(--color);font-family:var(--ion-font-family, inherit);contain:content;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color){color:var(--ion-color-contrast)}:host(.ion-color) .toolbar-background{background:var(--ion-color-base)}.toolbar-container{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:row;flex-direction:row;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:var(--min-height);contain:content;overflow:hidden;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}.toolbar-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;opacity:calc(var(--opacity) * var(--opacity-scale));z-index:-1;pointer-events:none}::slotted(ion-progress-bar){left:0;right:0;bottom:0;position:absolute}:host{--background:var(--ion-toolbar-background, var(--ion-background-color, #fff));--color:var(--ion-toolbar-color, var(--ion-text-color, #424242));--border-color:var(--ion-toolbar-border-color, var(--ion-border-color, var(--ion-color-step-150, var(--ion-background-color-step-150, #c1c4cd))));--padding-top:0;--padding-bottom:0;--padding-start:0;--padding-end:0;--min-height:56px}.toolbar-content{-ms-flex:1;flex:1;-ms-flex-order:3;order:3;min-width:0;max-width:100%}::slotted(.buttons-first-slot){-webkit-margin-start:4px;margin-inline-start:4px}::slotted(.buttons-last-slot){-webkit-margin-end:4px;margin-inline-end:4px}::slotted([slot=start]){-ms-flex-order:2;order:2}::slotted([slot=secondary]){-ms-flex-order:4;order:4}::slotted([slot=primary]){-ms-flex-order:5;order:5;text-align:end}::slotted([slot=end]){-ms-flex-order:6;order:6;text-align:end}";
const IonToolbarMdStyle0 = toolbarMdCss;
const Toolbar = /* @__PURE__ */ proxyCustomElement$1(class Toolbar2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.childrenStyles = /* @__PURE__ */ new Map();
    this.color = void 0;
  }
  componentWillLoad() {
    const buttons = Array.from(this.el.querySelectorAll("ion-buttons"));
    const firstButtons = buttons.find((button) => {
      return button.slot === "start";
    });
    if (firstButtons) {
      firstButtons.classList.add("buttons-first-slot");
    }
    const buttonsReversed = buttons.reverse();
    const lastButtons = buttonsReversed.find((button) => button.slot === "end") || buttonsReversed.find((button) => button.slot === "primary") || buttonsReversed.find((button) => button.slot === "secondary");
    if (lastButtons) {
      lastButtons.classList.add("buttons-last-slot");
    }
  }
  childrenStyle(ev) {
    ev.stopPropagation();
    const tagName = ev.target.tagName;
    const updatedStyles = ev.detail;
    const newStyles = {};
    const childStyles = this.childrenStyles.get(tagName) || {};
    let hasStyleChange = false;
    Object.keys(updatedStyles).forEach((key) => {
      const childKey = "toolbar-".concat(key);
      const newValue = updatedStyles[key];
      if (newValue !== childStyles[childKey]) {
        hasStyleChange = true;
      }
      if (newValue) {
        newStyles[childKey] = true;
      }
    });
    if (hasStyleChange) {
      this.childrenStyles.set(tagName, newStyles);
      forceUpdate(this);
    }
  }
  render() {
    const mode = getIonMode$2(this);
    const childStyles = {};
    this.childrenStyles.forEach((value) => {
      Object.assign(childStyles, value);
    });
    return h$1(Host$1, { key: "462538a5ecd01baf3cde116c9f029aeda26c81be", class: Object.assign(Object.assign({}, childStyles), createColorClasses$2(this.color, {
      [mode]: true,
      "in-toolbar": hostContext("ion-toolbar", this.el)
    })) }, h$1("div", { key: "c0b4415d3b2472de643a9be7cb3b13b3b628621b", class: "toolbar-background" }), h$1("div", { key: "0ccb8a2dbeaa28d8f9bed87629c0c097446690c2", class: "toolbar-container" }, h$1("slot", { key: "3e726dac359e923df21d80301651f16063a3de20", name: "start" }), h$1("slot", { key: "cd799330b56a7f8833bc61bb2807aafb21846f71", name: "secondary" }), h$1("div", { key: "395282e6ac8c53576922dcdb5f08c25d34638c86", class: "toolbar-content" }, h$1("slot", { key: "a437c60e4ba5aae65e55169ae82a6f379868ec1d" })), h$1("slot", { key: "711af9b9d321a7b31ede924c9bdcad767aa9a1ca", name: "primary" }), h$1("slot", { key: "ecc02edeaf80a837890bcb08d5096df1e22a0b9a", name: "end" })));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: IonToolbarIosStyle0,
      md: IonToolbarMdStyle0
    };
  }
}, [33, "ion-toolbar", {
  "color": [513]
}, [[0, "ionStyle", "childrenStyle"]]]);
function defineCustomElement$c() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-toolbar"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-toolbar":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Toolbar);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$b = defineCustomElement$n;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const textareaIosCss = '.sc-ion-textarea-ios-h{--background:initial;--color:initial;--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:var(--ion-placeholder-opacity, 0.6);--padding-top:0;--padding-end:0;--padding-bottom:8px;--padding-start:0;--border-radius:0;--border-style:solid;--highlight-color-focused:var(--ion-color-primary, #0054e9);--highlight-color-valid:var(--ion-color-success, #2dd55b);--highlight-color-invalid:var(--ion-color-danger, #c5000f);--highlight-color:var(--highlight-color-focused);display:block;position:relative;width:100%;min-height:44px;color:var(--color);font-family:var(--ion-font-family, inherit);z-index:2;-webkit-box-sizing:border-box;box-sizing:border-box}.textarea-label-placement-floating.sc-ion-textarea-ios-h,.textarea-label-placement-stacked.sc-ion-textarea-ios-h{--padding-top:0px;min-height:56px}[cols].sc-ion-textarea-ios-h:not([auto-grow]){width:-webkit-fit-content;width:-moz-fit-content;width:fit-content}.ion-color.sc-ion-textarea-ios-h{--highlight-color-focused:var(--ion-color-base);background:initial}ion-item.sc-ion-textarea-ios-h,ion-item .sc-ion-textarea-ios-h{-ms-flex-item-align:baseline;align-self:baseline}ion-item[slot=start].sc-ion-textarea-ios-h,ion-item [slot=start].sc-ion-textarea-ios-h,ion-item[slot=end].sc-ion-textarea-ios-h,ion-item [slot=end].sc-ion-textarea-ios-h{width:auto}.native-textarea.sc-ion-textarea-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;position:relative;-ms-flex:1;flex:1;width:100%;max-width:100%;max-height:100%;border:0;outline:none;background:transparent;white-space:pre-wrap;z-index:1;-webkit-box-sizing:border-box;box-sizing:border-box;resize:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.native-textarea.sc-ion-textarea-ios::-webkit-input-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-ios::-moz-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-ios:-ms-input-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-ios::-ms-input-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-ios::placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-ios{color:inherit;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-align:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;grid-area:1/1/2/2;word-break:break-word}.cloned-input.sc-ion-textarea-ios{top:0;bottom:0;position:absolute;pointer-events:none}.cloned-input.sc-ion-textarea-ios{inset-inline-start:0}.cloned-input.sc-ion-textarea-ios:disabled{opacity:1}[auto-grow].sc-ion-textarea-ios-h .cloned-input.sc-ion-textarea-ios{height:100%}[auto-grow].sc-ion-textarea-ios-h .native-textarea.sc-ion-textarea-ios{overflow:hidden}.textarea-wrapper.sc-ion-textarea-ios{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:0px;padding-bottom:0px;border-radius:var(--border-radius);display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:start;align-items:flex-start;height:inherit;min-height:inherit;-webkit-transition:background-color 15ms linear;transition:background-color 15ms linear;background:var(--background);line-height:normal}.native-wrapper.sc-ion-textarea-ios{position:relative;width:100%;height:100%}.has-focus.sc-ion-textarea-ios-h textarea.sc-ion-textarea-ios{caret-color:var(--highlight-color)}.native-wrapper.sc-ion-textarea-ios textarea.sc-ion-textarea-ios{-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom)}.native-wrapper.sc-ion-textarea-ios{display:grid;min-width:inherit;max-width:inherit;min-height:inherit;max-height:inherit;grid-auto-rows:100%}.native-wrapper.sc-ion-textarea-ios::after{white-space:pre-wrap;content:attr(data-replicated-value) " ";visibility:hidden}.native-wrapper.sc-ion-textarea-ios::after{padding-left:0;padding-right:0;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;border-radius:var(--border-radius);color:inherit;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-align:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;grid-area:1/1/2/2;word-break:break-word}.textarea-wrapper-inner.sc-ion-textarea-ios{display:-ms-flexbox;display:flex;width:100%;min-height:inherit}.ion-touched.ion-invalid.sc-ion-textarea-ios-h{--highlight-color:var(--highlight-color-invalid)}.ion-valid.sc-ion-textarea-ios-h{--highlight-color:var(--highlight-color-valid)}.textarea-bottom.sc-ion-textarea-ios{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:5px;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;border-top:var(--border-width) var(--border-style) var(--border-color);font-size:0.75rem}.has-focus.ion-valid.sc-ion-textarea-ios-h,.ion-touched.ion-invalid.sc-ion-textarea-ios-h{--border-color:var(--highlight-color)}.textarea-bottom.sc-ion-textarea-ios .error-text.sc-ion-textarea-ios{display:none;color:var(--highlight-color-invalid)}.textarea-bottom.sc-ion-textarea-ios .helper-text.sc-ion-textarea-ios{display:block;color:var(--ion-color-step-550, var(--ion-text-color-step-450, #737373))}.ion-touched.ion-invalid.sc-ion-textarea-ios-h .textarea-bottom.sc-ion-textarea-ios .error-text.sc-ion-textarea-ios{display:block}.ion-touched.ion-invalid.sc-ion-textarea-ios-h .textarea-bottom.sc-ion-textarea-ios .helper-text.sc-ion-textarea-ios{display:none}.textarea-bottom.sc-ion-textarea-ios .counter.sc-ion-textarea-ios{-webkit-margin-start:auto;margin-inline-start:auto;color:var(--ion-color-step-550, var(--ion-text-color-step-450, #737373));white-space:nowrap;-webkit-padding-start:16px;padding-inline-start:16px}.label-text-wrapper.sc-ion-textarea-ios{-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);max-width:200px;-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);pointer-events:none}.label-text.sc-ion-textarea-ios,.sc-ion-textarea-ios-s>[slot=label]{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.label-text-wrapper-hidden.sc-ion-textarea-ios,.textarea-outline-notch-hidden.sc-ion-textarea-ios{display:none}.textarea-wrapper.sc-ion-textarea-ios textarea.sc-ion-textarea-ios{-webkit-transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}.textarea-label-placement-start.sc-ion-textarea-ios-h .textarea-wrapper.sc-ion-textarea-ios{-ms-flex-direction:row;flex-direction:row}.textarea-label-placement-start.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.textarea-label-placement-end.sc-ion-textarea-ios-h .textarea-wrapper.sc-ion-textarea-ios{-ms-flex-direction:row-reverse;flex-direction:row-reverse}.textarea-label-placement-end.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}.textarea-label-placement-fixed.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.textarea-label-placement-fixed.sc-ion-textarea-ios-h .label-text.sc-ion-textarea-ios{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.textarea-label-placement-stacked.sc-ion-textarea-ios-h .textarea-wrapper.sc-ion-textarea-ios,.textarea-label-placement-floating.sc-ion-textarea-ios-h .textarea-wrapper.sc-ion-textarea-ios{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:start;align-items:start}.textarea-label-placement-stacked.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,.textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios{-webkit-transform-origin:left top;transform-origin:left top;-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:0px;padding-bottom:0px;max-width:100%;z-index:2}[dir=rtl].sc-ion-textarea-ios-h -no-combinator.textarea-label-placement-stacked.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,[dir=rtl] .sc-ion-textarea-ios-h -no-combinator.textarea-label-placement-stacked.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,[dir=rtl].textarea-label-placement-stacked.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,[dir=rtl] .textarea-label-placement-stacked.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,[dir=rtl].sc-ion-textarea-ios-h -no-combinator.textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,[dir=rtl] .sc-ion-textarea-ios-h -no-combinator.textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,[dir=rtl].textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,[dir=rtl] .textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.textarea-label-placement-stacked.sc-ion-textarea-ios-h:dir(rtl) .label-text-wrapper.sc-ion-textarea-ios,.textarea-label-placement-floating.sc-ion-textarea-ios-h:dir(rtl) .label-text-wrapper.sc-ion-textarea-ios{-webkit-transform-origin:right top;transform-origin:right top}}.textarea-label-placement-stacked.sc-ion-textarea-ios-h textarea.sc-ion-textarea-ios,.textarea-label-placement-floating.sc-ion-textarea-ios-h textarea.sc-ion-textarea-ios,.textarea-label-placement-stacked[auto-grow].sc-ion-textarea-ios-h .native-wrapper.sc-ion-textarea-ios::after,.textarea-label-placement-floating[auto-grow].sc-ion-textarea-ios-h .native-wrapper.sc-ion-textarea-ios::after{-webkit-margin-start:0px;margin-inline-start:0px;-webkit-margin-end:0px;margin-inline-end:0px;margin-top:8px;margin-bottom:0px}.sc-ion-textarea-ios-h.textarea-label-placement-stacked.sc-ion-textarea-ios-s>[slot=start],.sc-ion-textarea-ios-h.textarea-label-placement-stacked .sc-ion-textarea-ios-s>[slot=start],.sc-ion-textarea-ios-h.textarea-label-placement-stacked.sc-ion-textarea-ios-s>[slot=end],.sc-ion-textarea-ios-h.textarea-label-placement-stacked .sc-ion-textarea-ios-s>[slot=end],.sc-ion-textarea-ios-h.textarea-label-placement-floating.sc-ion-textarea-ios-s>[slot=start],.sc-ion-textarea-ios-h.textarea-label-placement-floating .sc-ion-textarea-ios-s>[slot=start],.sc-ion-textarea-ios-h.textarea-label-placement-floating.sc-ion-textarea-ios-s>[slot=end],.sc-ion-textarea-ios-h.textarea-label-placement-floating .sc-ion-textarea-ios-s>[slot=end]{margin-top:8px}.textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios{-webkit-transform:translateY(100%) scale(1);transform:translateY(100%) scale(1)}.textarea-label-placement-floating.sc-ion-textarea-ios-h textarea.sc-ion-textarea-ios{opacity:0}.has-focus.textarea-label-placement-floating.sc-ion-textarea-ios-h textarea.sc-ion-textarea-ios,.has-value.textarea-label-placement-floating.sc-ion-textarea-ios-h textarea.sc-ion-textarea-ios{opacity:1}.label-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);max-width:calc(100% / 0.75)}.start-slot-wrapper.sc-ion-textarea-ios,.end-slot-wrapper.sc-ion-textarea-ios{padding-left:0;padding-right:0;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;-ms-flex-negative:0;flex-shrink:0;-ms-flex-item-align:start;align-self:start}.sc-ion-textarea-ios-s>[slot=start],.sc-ion-textarea-ios-s>[slot=end]{margin-top:0}.sc-ion-textarea-ios-s>[slot=start]:last-of-type{-webkit-margin-end:16px;margin-inline-end:16px;-webkit-margin-start:0;margin-inline-start:0}.sc-ion-textarea-ios-s>[slot=end]:first-of-type{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0}.sc-ion-textarea-ios-h{--border-width:0.55px;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, var(--ion-background-color-step-250, #c8c7cc))));--padding-top:10px;--padding-end:0px;--padding-bottom:8px;--padding-start:0px;--highlight-height:0px;font-size:inherit}.textarea-disabled.sc-ion-textarea-ios-h{opacity:0.3}.sc-ion-textarea-ios-s>ion-button[slot=start].button-has-icon-only,.sc-ion-textarea-ios-s>ion-button[slot=end].button-has-icon-only{--border-radius:50%;--padding-start:0;--padding-end:0;--padding-top:0;--padding-bottom:0;aspect-ratio:1}';
const IonTextareaIosStyle0 = textareaIosCss;
const textareaMdCss = '.sc-ion-textarea-md-h{--background:initial;--color:initial;--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:var(--ion-placeholder-opacity, 0.6);--padding-top:0;--padding-end:0;--padding-bottom:8px;--padding-start:0;--border-radius:0;--border-style:solid;--highlight-color-focused:var(--ion-color-primary, #0054e9);--highlight-color-valid:var(--ion-color-success, #2dd55b);--highlight-color-invalid:var(--ion-color-danger, #c5000f);--highlight-color:var(--highlight-color-focused);display:block;position:relative;width:100%;min-height:44px;color:var(--color);font-family:var(--ion-font-family, inherit);z-index:2;-webkit-box-sizing:border-box;box-sizing:border-box}.textarea-label-placement-floating.sc-ion-textarea-md-h,.textarea-label-placement-stacked.sc-ion-textarea-md-h{--padding-top:0px;min-height:56px}[cols].sc-ion-textarea-md-h:not([auto-grow]){width:-webkit-fit-content;width:-moz-fit-content;width:fit-content}.ion-color.sc-ion-textarea-md-h{--highlight-color-focused:var(--ion-color-base);background:initial}ion-item.sc-ion-textarea-md-h,ion-item .sc-ion-textarea-md-h{-ms-flex-item-align:baseline;align-self:baseline}ion-item[slot=start].sc-ion-textarea-md-h,ion-item [slot=start].sc-ion-textarea-md-h,ion-item[slot=end].sc-ion-textarea-md-h,ion-item [slot=end].sc-ion-textarea-md-h{width:auto}.native-textarea.sc-ion-textarea-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;position:relative;-ms-flex:1;flex:1;width:100%;max-width:100%;max-height:100%;border:0;outline:none;background:transparent;white-space:pre-wrap;z-index:1;-webkit-box-sizing:border-box;box-sizing:border-box;resize:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.native-textarea.sc-ion-textarea-md::-webkit-input-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-md::-moz-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-md:-ms-input-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-md::-ms-input-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-md::placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-md{color:inherit;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-align:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;grid-area:1/1/2/2;word-break:break-word}.cloned-input.sc-ion-textarea-md{top:0;bottom:0;position:absolute;pointer-events:none}.cloned-input.sc-ion-textarea-md{inset-inline-start:0}.cloned-input.sc-ion-textarea-md:disabled{opacity:1}[auto-grow].sc-ion-textarea-md-h .cloned-input.sc-ion-textarea-md{height:100%}[auto-grow].sc-ion-textarea-md-h .native-textarea.sc-ion-textarea-md{overflow:hidden}.textarea-wrapper.sc-ion-textarea-md{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:0px;padding-bottom:0px;border-radius:var(--border-radius);display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:start;align-items:flex-start;height:inherit;min-height:inherit;-webkit-transition:background-color 15ms linear;transition:background-color 15ms linear;background:var(--background);line-height:normal}.native-wrapper.sc-ion-textarea-md{position:relative;width:100%;height:100%}.has-focus.sc-ion-textarea-md-h textarea.sc-ion-textarea-md{caret-color:var(--highlight-color)}.native-wrapper.sc-ion-textarea-md textarea.sc-ion-textarea-md{-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom)}.native-wrapper.sc-ion-textarea-md{display:grid;min-width:inherit;max-width:inherit;min-height:inherit;max-height:inherit;grid-auto-rows:100%}.native-wrapper.sc-ion-textarea-md::after{white-space:pre-wrap;content:attr(data-replicated-value) " ";visibility:hidden}.native-wrapper.sc-ion-textarea-md::after{padding-left:0;padding-right:0;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;border-radius:var(--border-radius);color:inherit;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-align:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;grid-area:1/1/2/2;word-break:break-word}.textarea-wrapper-inner.sc-ion-textarea-md{display:-ms-flexbox;display:flex;width:100%;min-height:inherit}.ion-touched.ion-invalid.sc-ion-textarea-md-h{--highlight-color:var(--highlight-color-invalid)}.ion-valid.sc-ion-textarea-md-h{--highlight-color:var(--highlight-color-valid)}.textarea-bottom.sc-ion-textarea-md{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:5px;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;border-top:var(--border-width) var(--border-style) var(--border-color);font-size:0.75rem}.has-focus.ion-valid.sc-ion-textarea-md-h,.ion-touched.ion-invalid.sc-ion-textarea-md-h{--border-color:var(--highlight-color)}.textarea-bottom.sc-ion-textarea-md .error-text.sc-ion-textarea-md{display:none;color:var(--highlight-color-invalid)}.textarea-bottom.sc-ion-textarea-md .helper-text.sc-ion-textarea-md{display:block;color:var(--ion-color-step-550, var(--ion-text-color-step-450, #737373))}.ion-touched.ion-invalid.sc-ion-textarea-md-h .textarea-bottom.sc-ion-textarea-md .error-text.sc-ion-textarea-md{display:block}.ion-touched.ion-invalid.sc-ion-textarea-md-h .textarea-bottom.sc-ion-textarea-md .helper-text.sc-ion-textarea-md{display:none}.textarea-bottom.sc-ion-textarea-md .counter.sc-ion-textarea-md{-webkit-margin-start:auto;margin-inline-start:auto;color:var(--ion-color-step-550, var(--ion-text-color-step-450, #737373));white-space:nowrap;-webkit-padding-start:16px;padding-inline-start:16px}.label-text-wrapper.sc-ion-textarea-md{-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);max-width:200px;-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);pointer-events:none}.label-text.sc-ion-textarea-md,.sc-ion-textarea-md-s>[slot=label]{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.label-text-wrapper-hidden.sc-ion-textarea-md,.textarea-outline-notch-hidden.sc-ion-textarea-md{display:none}.textarea-wrapper.sc-ion-textarea-md textarea.sc-ion-textarea-md{-webkit-transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}.textarea-label-placement-start.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md{-ms-flex-direction:row;flex-direction:row}.textarea-label-placement-start.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.textarea-label-placement-end.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md{-ms-flex-direction:row-reverse;flex-direction:row-reverse}.textarea-label-placement-end.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}.textarea-label-placement-fixed.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.textarea-label-placement-fixed.sc-ion-textarea-md-h .label-text.sc-ion-textarea-md{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.textarea-label-placement-stacked.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md,.textarea-label-placement-floating.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:start;align-items:start}.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-transform-origin:left top;transform-origin:left top;-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:0px;padding-bottom:0px;max-width:100%;z-index:2}[dir=rtl].sc-ion-textarea-md-h -no-combinator.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h -no-combinator.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl].textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl].sc-ion-textarea-md-h -no-combinator.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h -no-combinator.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl].textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.textarea-label-placement-stacked.sc-ion-textarea-md-h:dir(rtl) .label-text-wrapper.sc-ion-textarea-md,.textarea-label-placement-floating.sc-ion-textarea-md-h:dir(rtl) .label-text-wrapper.sc-ion-textarea-md{-webkit-transform-origin:right top;transform-origin:right top}}.textarea-label-placement-stacked.sc-ion-textarea-md-h textarea.sc-ion-textarea-md,.textarea-label-placement-floating.sc-ion-textarea-md-h textarea.sc-ion-textarea-md,.textarea-label-placement-stacked[auto-grow].sc-ion-textarea-md-h .native-wrapper.sc-ion-textarea-md::after,.textarea-label-placement-floating[auto-grow].sc-ion-textarea-md-h .native-wrapper.sc-ion-textarea-md::after{-webkit-margin-start:0px;margin-inline-start:0px;-webkit-margin-end:0px;margin-inline-end:0px;margin-top:8px;margin-bottom:0px}.sc-ion-textarea-md-h.textarea-label-placement-stacked.sc-ion-textarea-md-s>[slot=start],.sc-ion-textarea-md-h.textarea-label-placement-stacked .sc-ion-textarea-md-s>[slot=start],.sc-ion-textarea-md-h.textarea-label-placement-stacked.sc-ion-textarea-md-s>[slot=end],.sc-ion-textarea-md-h.textarea-label-placement-stacked .sc-ion-textarea-md-s>[slot=end],.sc-ion-textarea-md-h.textarea-label-placement-floating.sc-ion-textarea-md-s>[slot=start],.sc-ion-textarea-md-h.textarea-label-placement-floating .sc-ion-textarea-md-s>[slot=start],.sc-ion-textarea-md-h.textarea-label-placement-floating.sc-ion-textarea-md-s>[slot=end],.sc-ion-textarea-md-h.textarea-label-placement-floating .sc-ion-textarea-md-s>[slot=end]{margin-top:8px}.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-transform:translateY(100%) scale(1);transform:translateY(100%) scale(1)}.textarea-label-placement-floating.sc-ion-textarea-md-h textarea.sc-ion-textarea-md{opacity:0}.has-focus.textarea-label-placement-floating.sc-ion-textarea-md-h textarea.sc-ion-textarea-md,.has-value.textarea-label-placement-floating.sc-ion-textarea-md-h textarea.sc-ion-textarea-md{opacity:1}.label-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);max-width:calc(100% / 0.75)}.start-slot-wrapper.sc-ion-textarea-md,.end-slot-wrapper.sc-ion-textarea-md{padding-left:0;padding-right:0;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;-ms-flex-negative:0;flex-shrink:0;-ms-flex-item-align:start;align-self:start}.sc-ion-textarea-md-s>[slot=start],.sc-ion-textarea-md-s>[slot=end]{margin-top:0}.sc-ion-textarea-md-s>[slot=start]:last-of-type{-webkit-margin-end:16px;margin-inline-end:16px;-webkit-margin-start:0;margin-inline-start:0}.sc-ion-textarea-md-s>[slot=end]:first-of-type{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0}.textarea-fill-solid.sc-ion-textarea-md-h{--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2));--border-color:var(--ion-color-step-500, var(--ion-background-color-step-500, gray));--border-radius:4px;--padding-start:16px;--padding-end:16px;min-height:56px}.textarea-fill-solid.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md{border-bottom:var(--border-width) var(--border-style) var(--border-color)}.has-focus.textarea-fill-solid.ion-valid.sc-ion-textarea-md-h,.textarea-fill-solid.ion-touched.ion-invalid.sc-ion-textarea-md-h{--border-color:var(--highlight-color)}.textarea-fill-solid.sc-ion-textarea-md-h .textarea-bottom.sc-ion-textarea-md{border-top:none}@media (any-hover: hover){.textarea-fill-solid.sc-ion-textarea-md-h:hover{--background:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6));--border-color:var(--ion-color-step-750, var(--ion-background-color-step-750, #404040))}}.textarea-fill-solid.has-focus.sc-ion-textarea-md-h{--background:var(--ion-color-step-150, var(--ion-background-color-step-150, #d9d9d9));--border-color:var(--ion-color-step-750, var(--ion-background-color-step-750, #404040))}.textarea-fill-solid.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md{border-start-start-radius:var(--border-radius);border-start-end-radius:var(--border-radius);border-end-end-radius:0px;border-end-start-radius:0px}.label-floating.textarea-fill-solid.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{max-width:calc(100% / 0.75)}.textarea-fill-outline.sc-ion-textarea-md-h{--border-color:var(--ion-color-step-300, var(--ion-background-color-step-300, #b3b3b3));--border-radius:4px;--padding-start:16px;--padding-end:16px;min-height:56px}.textarea-fill-outline.textarea-shape-round.sc-ion-textarea-md-h{--border-radius:28px;--padding-start:32px;--padding-end:32px}.has-focus.textarea-fill-outline.ion-valid.sc-ion-textarea-md-h,.textarea-fill-outline.ion-touched.ion-invalid.sc-ion-textarea-md-h{--border-color:var(--highlight-color)}@media (any-hover: hover){.textarea-fill-outline.sc-ion-textarea-md-h:hover{--border-color:var(--ion-color-step-750, var(--ion-background-color-step-750, #404040))}}.textarea-fill-outline.has-focus.sc-ion-textarea-md-h{--border-width:var(--highlight-height);--border-color:var(--highlight-color)}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-bottom.sc-ion-textarea-md{border-top:none}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md{border-bottom:none}.textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-transform-origin:left top;transform-origin:left top;position:absolute;max-width:calc(100% - var(--padding-start) - var(--padding-end))}[dir=rtl].sc-ion-textarea-md-h -no-combinator.textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h -no-combinator.textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl].textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl].sc-ion-textarea-md-h -no-combinator.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h -no-combinator.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl].textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h:dir(rtl) .label-text-wrapper.sc-ion-textarea-md,.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h:dir(rtl) .label-text-wrapper.sc-ion-textarea-md{-webkit-transform-origin:right top;transform-origin:right top}}.textarea-fill-outline.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{position:relative}.label-floating.textarea-fill-outline.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-transform:translateY(-32%) scale(0.75);transform:translateY(-32%) scale(0.75);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;max-width:calc(\n    (100% - var(--padding-start) - var(--padding-end) - 8px) / 0.75\n  )}.textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h textarea.sc-ion-textarea-md,.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h textarea.sc-ion-textarea-md,.textarea-fill-outline.textarea-label-placement-stacked[auto-grow].sc-ion-textarea-md-h .native-wrapper.sc-ion-textarea-md::after,.textarea-fill-outline.textarea-label-placement-floating[auto-grow].sc-ion-textarea-md-h .native-wrapper.sc-ion-textarea-md::after{-webkit-margin-start:0px;margin-inline-start:0px;-webkit-margin-end:0px;margin-inline-end:0px;margin-top:12px;margin-bottom:0px}.sc-ion-textarea-md-h.textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-s>[slot=start],.sc-ion-textarea-md-h.textarea-fill-outline.textarea-label-placement-stacked .sc-ion-textarea-md-s>[slot=start],.sc-ion-textarea-md-h.textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-s>[slot=end],.sc-ion-textarea-md-h.textarea-fill-outline.textarea-label-placement-stacked .sc-ion-textarea-md-s>[slot=end],.sc-ion-textarea-md-h.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-s>[slot=start],.sc-ion-textarea-md-h.textarea-fill-outline.textarea-label-placement-floating .sc-ion-textarea-md-s>[slot=start],.sc-ion-textarea-md-h.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-s>[slot=end],.sc-ion-textarea-md-h.textarea-fill-outline.textarea-label-placement-floating .sc-ion-textarea-md-s>[slot=end]{margin-top:12px}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-container.sc-ion-textarea-md{left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;width:100%;height:100%}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-start.sc-ion-textarea-md,.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-end.sc-ion-textarea-md{pointer-events:none}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-start.sc-ion-textarea-md,.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-notch.sc-ion-textarea-md,.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-end.sc-ion-textarea-md{border-top:var(--border-width) var(--border-style) var(--border-color);border-bottom:var(--border-width) var(--border-style) var(--border-color)}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-notch.sc-ion-textarea-md{max-width:calc(100% - var(--padding-start) - var(--padding-end))}.textarea-fill-outline.sc-ion-textarea-md-h .notch-spacer.sc-ion-textarea-md{-webkit-padding-end:8px;padding-inline-end:8px;font-size:calc(1em * 0.75);opacity:0;pointer-events:none;-webkit-box-sizing:content-box;box-sizing:content-box}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-start.sc-ion-textarea-md{border-start-start-radius:var(--border-radius);border-start-end-radius:0px;border-end-end-radius:0px;border-end-start-radius:var(--border-radius);-webkit-border-start:var(--border-width) var(--border-style) var(--border-color);border-inline-start:var(--border-width) var(--border-style) var(--border-color);width:calc(var(--padding-start) - 4px)}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-end.sc-ion-textarea-md{-webkit-border-end:var(--border-width) var(--border-style) var(--border-color);border-inline-end:var(--border-width) var(--border-style) var(--border-color);border-start-start-radius:0px;border-start-end-radius:var(--border-radius);border-end-end-radius:var(--border-radius);border-end-start-radius:0px;-ms-flex-positive:1;flex-grow:1}.label-floating.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-notch.sc-ion-textarea-md{border-top:none}.sc-ion-textarea-md-h{--border-width:1px;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, var(--ion-background-color-step-150, rgba(0, 0, 0, 0.13)))));--padding-top:18px;--padding-end:0px;--padding-bottom:8px;--padding-start:0px;--highlight-height:2px;font-size:inherit}.textarea-bottom.sc-ion-textarea-md .counter.sc-ion-textarea-md{letter-spacing:0.0333333333em}.textarea-label-placement-floating.has-focus.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.textarea-label-placement-stacked.has-focus.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{color:var(--highlight-color)}.has-focus.textarea-label-placement-floating.ion-valid.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.textarea-label-placement-floating.ion-touched.ion-invalid.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.has-focus.textarea-label-placement-stacked.ion-valid.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.textarea-label-placement-stacked.ion-touched.ion-invalid.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{color:var(--highlight-color)}.textarea-disabled.sc-ion-textarea-md-h{opacity:0.38}.textarea-highlight.sc-ion-textarea-md{bottom:-1px;position:absolute;width:100%;height:var(--highlight-height);-webkit-transform:scale(0);transform:scale(0);-webkit-transition:-webkit-transform 200ms;transition:-webkit-transform 200ms;transition:transform 200ms;transition:transform 200ms, -webkit-transform 200ms;background:var(--highlight-color)}.textarea-highlight.sc-ion-textarea-md{inset-inline-start:0}.has-focus.sc-ion-textarea-md-h .textarea-highlight.sc-ion-textarea-md{-webkit-transform:scale(1);transform:scale(1)}.in-item.sc-ion-textarea-md-h .textarea-highlight.sc-ion-textarea-md{bottom:0}.in-item.sc-ion-textarea-md-h .textarea-highlight.sc-ion-textarea-md{inset-inline-start:0}.textarea-shape-round.sc-ion-textarea-md-h{--border-radius:16px}.sc-ion-textarea-md-s>ion-button[slot=start].button-has-icon-only,.sc-ion-textarea-md-s>ion-button[slot=end].button-has-icon-only{--border-radius:50%;--padding-start:8px;--padding-end:8px;--padding-top:8px;--padding-bottom:8px;aspect-ratio:1;min-height:40px}';
const IonTextareaMdStyle0 = textareaMdCss;
const Textarea = /* @__PURE__ */ proxyCustomElement$1(class Textarea2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionInput = createEvent(this, "ionInput", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.inputId = "ion-textarea-".concat(textareaIds++);
    this.helperTextId = "".concat(this.inputId, "-helper-text");
    this.errorTextId = "".concat(this.inputId, "-error-text");
    this.didTextareaClearOnEdit = false;
    this.inheritedAttributes = {};
    this.onInput = (ev) => {
      const input = ev.target;
      if (input) {
        this.value = input.value || "";
      }
      this.emitInputChange(ev);
    };
    this.onChange = (ev) => {
      this.emitValueChange(ev);
    };
    this.onFocus = (ev) => {
      this.hasFocus = true;
      this.focusedValue = this.value;
      this.ionFocus.emit(ev);
    };
    this.onBlur = (ev) => {
      this.hasFocus = false;
      if (this.focusedValue !== this.value) {
        this.emitValueChange(ev);
      }
      this.didTextareaClearOnEdit = false;
      this.ionBlur.emit(ev);
    };
    this.onKeyDown = (ev) => {
      this.checkClearOnEdit(ev);
    };
    this.hasFocus = false;
    this.color = void 0;
    this.autocapitalize = "none";
    this.autofocus = false;
    this.clearOnEdit = false;
    this.debounce = void 0;
    this.disabled = false;
    this.fill = void 0;
    this.inputmode = void 0;
    this.enterkeyhint = void 0;
    this.maxlength = void 0;
    this.minlength = void 0;
    this.name = this.inputId;
    this.placeholder = void 0;
    this.readonly = false;
    this.required = false;
    this.spellcheck = false;
    this.cols = void 0;
    this.rows = void 0;
    this.wrap = void 0;
    this.autoGrow = false;
    this.value = "";
    this.counter = false;
    this.counterFormatter = void 0;
    this.errorText = void 0;
    this.helperText = void 0;
    this.label = void 0;
    this.labelPlacement = "start";
    this.shape = void 0;
  }
  debounceChanged() {
    const { ionInput, debounce: debounce2, originalIonInput } = this;
    this.ionInput = debounce2 === void 0 ? originalIonInput !== null && originalIonInput !== void 0 ? originalIonInput : ionInput : debounceEvent(ionInput, debounce2);
  }
  /**
   * Update the native input element when the value changes
   */
  valueChanged() {
    const nativeInput = this.nativeInput;
    const value = this.getValue();
    if (nativeInput && nativeInput.value !== value) {
      nativeInput.value = value;
    }
    this.runAutoGrow();
  }
  connectedCallback() {
    const { el: el2 } = this;
    this.slotMutationController = createSlotMutationController(el2, ["label", "start", "end"], () => forceUpdate(this));
    this.notchController = createNotchController(el2, () => this.notchSpacerEl, () => this.labelSlot);
    this.debounceChanged();
    {
      document.dispatchEvent(new CustomEvent("ionInputDidLoad", {
        detail: el2
      }));
    }
  }
  disconnectedCallback() {
    {
      document.dispatchEvent(new CustomEvent("ionInputDidUnload", {
        detail: this.el
      }));
    }
    if (this.slotMutationController) {
      this.slotMutationController.destroy();
      this.slotMutationController = void 0;
    }
    if (this.notchController) {
      this.notchController.destroy();
      this.notchController = void 0;
    }
  }
  componentWillLoad() {
    this.inheritedAttributes = Object.assign(Object.assign({}, inheritAriaAttributes(this.el)), inheritAttributes$2(this.el, ["data-form-type", "title", "tabindex"]));
  }
  componentDidLoad() {
    this.originalIonInput = this.ionInput;
    this.runAutoGrow();
  }
  componentDidRender() {
    var _a;
    (_a = this.notchController) === null || _a === void 0 ? void 0 : _a.calculateNotchWidth();
  }
  /**
   * Sets focus on the native `textarea` in `ion-textarea`. Use this method instead of the global
   * `textarea.focus()`.
   *
   * See [managing focus](/docs/developing/managing-focus) for more information.
   */
  async setFocus() {
    if (this.nativeInput) {
      this.nativeInput.focus();
    }
  }
  /**
   * Returns the native `<textarea>` element used under the hood.
   */
  async getInputElement() {
    if (!this.nativeInput) {
      await new Promise((resolve) => componentOnReady(this.el, resolve));
    }
    return Promise.resolve(this.nativeInput);
  }
  /**
   * Emits an `ionChange` event.
   *
   * This API should be called for user committed changes.
   * This API should not be used for external value changes.
   */
  emitValueChange(event) {
    const { value } = this;
    const newValue = value == null ? value : value.toString();
    this.focusedValue = newValue;
    this.ionChange.emit({ value: newValue, event });
  }
  /**
   * Emits an `ionInput` event.
   */
  emitInputChange(event) {
    const { value } = this;
    this.ionInput.emit({ value, event });
  }
  runAutoGrow() {
    if (this.nativeInput && this.autoGrow) {
      writeTask$1(() => {
        var _a;
        if (this.textareaWrapper) {
          this.textareaWrapper.dataset.replicatedValue = (_a = this.value) !== null && _a !== void 0 ? _a : "";
        }
      });
    }
  }
  /**
   * Check if we need to clear the text input if clearOnEdit is enabled
   */
  checkClearOnEdit(ev) {
    if (!this.clearOnEdit) {
      return;
    }
    const IGNORED_KEYS = ["Tab", "Shift", "Meta", "Alt", "Control"];
    const pressedIgnoredKey = IGNORED_KEYS.includes(ev.key);
    if (!this.didTextareaClearOnEdit && this.hasValue() && !pressedIgnoredKey) {
      this.value = "";
      this.emitInputChange(ev);
    }
    if (!pressedIgnoredKey) {
      this.didTextareaClearOnEdit = true;
    }
  }
  hasValue() {
    return this.getValue() !== "";
  }
  getValue() {
    return this.value || "";
  }
  renderLabel() {
    const { label } = this;
    return h$1("div", { class: {
      "label-text-wrapper": true,
      "label-text-wrapper-hidden": !this.hasLabel
    } }, label === void 0 ? h$1("slot", { name: "label" }) : h$1("div", { class: "label-text" }, label));
  }
  /**
   * Gets any content passed into the `label` slot,
   * not the <slot> definition.
   */
  get labelSlot() {
    return this.el.querySelector('[slot="label"]');
  }
  /**
   * Returns `true` if label content is provided
   * either by a prop or a content. If you want
   * to get the plaintext value of the label use
   * the `labelText` getter instead.
   */
  get hasLabel() {
    return this.label !== void 0 || this.labelSlot !== null;
  }
  /**
   * Renders the border container when fill="outline".
   */
  renderLabelContainer() {
    const mode = getIonMode$2(this);
    const hasOutlineFill = mode === "md" && this.fill === "outline";
    if (hasOutlineFill) {
      return [
        h$1("div", { class: "textarea-outline-container" }, h$1("div", { class: "textarea-outline-start" }), h$1("div", { class: {
          "textarea-outline-notch": true,
          "textarea-outline-notch-hidden": !this.hasLabel
        } }, h$1("div", { class: "notch-spacer", "aria-hidden": "true", ref: (el2) => this.notchSpacerEl = el2 }, this.label)), h$1("div", { class: "textarea-outline-end" })),
        this.renderLabel()
      ];
    }
    return this.renderLabel();
  }
  /**
   * Renders the helper text or error text values
   */
  renderHintText() {
    const { helperText, errorText, helperTextId, errorTextId } = this;
    return [
      h$1("div", { id: helperTextId, class: "helper-text" }, helperText),
      h$1("div", { id: errorTextId, class: "error-text" }, errorText)
    ];
  }
  getHintTextID() {
    const { el: el2, helperText, errorText, helperTextId, errorTextId } = this;
    if (el2.classList.contains("ion-touched") && el2.classList.contains("ion-invalid") && errorText) {
      return errorTextId;
    }
    if (helperText) {
      return helperTextId;
    }
    return void 0;
  }
  renderCounter() {
    const { counter, maxlength, counterFormatter, value } = this;
    if (counter !== true || maxlength === void 0) {
      return;
    }
    return h$1("div", { class: "counter" }, getCounterText(value, maxlength, counterFormatter));
  }
  /**
   * Responsible for rendering helper text,
   * error text, and counter. This element should only
   * be rendered if hint text is set or counter is enabled.
   */
  renderBottomContent() {
    const { counter, helperText, errorText, maxlength } = this;
    const hasHintText = !!helperText || !!errorText;
    const hasCounter = counter === true && maxlength !== void 0;
    if (!hasHintText && !hasCounter) {
      return;
    }
    return h$1("div", { class: "textarea-bottom" }, this.renderHintText(), this.renderCounter());
  }
  render() {
    const { inputId, disabled, fill, shape, labelPlacement, el: el2, hasFocus } = this;
    const mode = getIonMode$2(this);
    const value = this.getValue();
    const inItem = hostContext("ion-item", this.el);
    const shouldRenderHighlight = mode === "md" && fill !== "outline" && !inItem;
    const hasValue = this.hasValue();
    const hasStartEndSlots = el2.querySelector('[slot="start"], [slot="end"]') !== null;
    const labelShouldFloat = labelPlacement === "stacked" || labelPlacement === "floating" && (hasValue || hasFocus || hasStartEndSlots);
    return h$1(Host$1, { key: "d6e25c83d8eab8cb1a5b6ab411c9a13847f69f8d", class: createColorClasses$2(this.color, {
      [mode]: true,
      "has-value": hasValue,
      "has-focus": hasFocus,
      "label-floating": labelShouldFloat,
      ["textarea-fill-".concat(fill)]: fill !== void 0,
      ["textarea-shape-".concat(shape)]: shape !== void 0,
      ["textarea-label-placement-".concat(labelPlacement)]: true,
      "textarea-disabled": disabled
    }) }, h$1("label", { key: "f840a5be2b776a4b9c18c6da24e0b7d3d4838fee", class: "textarea-wrapper", htmlFor: inputId }, this.renderLabelContainer(), h$1("div", { key: "979461fc0d4684926d79d75759c63c6867b7622b", class: "textarea-wrapper-inner" }, h$1("div", { key: "88f0d5d4bac29597cc2588e5b2ed72fb4fbe153d", class: "start-slot-wrapper" }, h$1("slot", { key: "21dcca0e59c1260e3d0d1e126c1c590de15c4bad", name: "start" })), h$1("div", { key: "3c48a4bb3d763a389d3429123e7c110064b9b8d4", class: "native-wrapper", ref: (el3) => this.textareaWrapper = el3 }, h$1("textarea", Object.assign({ key: "1550599ad15b3f215c104c014e90711f073ace8b", class: "native-textarea", ref: (el3) => this.nativeInput = el3, id: inputId, disabled, autoCapitalize: this.autocapitalize, autoFocus: this.autofocus, enterKeyHint: this.enterkeyhint, inputMode: this.inputmode, minLength: this.minlength, maxLength: this.maxlength, name: this.name, placeholder: this.placeholder || "", readOnly: this.readonly, required: this.required, spellcheck: this.spellcheck, cols: this.cols, rows: this.rows, wrap: this.wrap, onInput: this.onInput, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, onKeyDown: this.onKeyDown, "aria-describedby": this.getHintTextID(), "aria-invalid": this.getHintTextID() === this.errorTextId }, this.inheritedAttributes), value)), h$1("div", { key: "4f01ab4d2994a6de6f49eb9ed2e310d00daf21b2", class: "end-slot-wrapper" }, h$1("slot", { key: "501e288b6807e039972bb4f0b63906114255518a", name: "end" }))), shouldRenderHighlight && h$1("div", { key: "d3008eed34494aa9f8e98a28eac3b465dc4c2bd0", class: "textarea-highlight" })), this.renderBottomContent());
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "debounce": ["debounceChanged"],
      "value": ["valueChanged"]
    };
  }
  static get style() {
    return {
      ios: IonTextareaIosStyle0,
      md: IonTextareaMdStyle0
    };
  }
}, [38, "ion-textarea", {
  "color": [513],
  "autocapitalize": [1],
  "autofocus": [4],
  "clearOnEdit": [4, "clear-on-edit"],
  "debounce": [2],
  "disabled": [4],
  "fill": [1],
  "inputmode": [1],
  "enterkeyhint": [1],
  "maxlength": [2],
  "minlength": [2],
  "name": [1],
  "placeholder": [1],
  "readonly": [4],
  "required": [4],
  "spellcheck": [4],
  "cols": [514],
  "rows": [2],
  "wrap": [1],
  "autoGrow": [516, "auto-grow"],
  "value": [1025],
  "counter": [4],
  "counterFormatter": [16],
  "errorText": [1, "error-text"],
  "helperText": [1, "helper-text"],
  "label": [1],
  "labelPlacement": [1, "label-placement"],
  "shape": [1],
  "hasFocus": [32],
  "setFocus": [64],
  "getInputElement": [64]
}, void 0, {
  "debounce": ["debounceChanged"],
  "value": ["valueChanged"]
}]);
let textareaIds = 0;
function defineCustomElement$1$5() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-textarea"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-textarea":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Textarea);
        }
        break;
    }
  });
}
const defineCustomElement$a = defineCustomElement$1$5;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$9 = defineCustomElement$d;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$8 = defineCustomElement$c;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const IonButton$1 = Button;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const IonItem$1 = Item;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$7 = defineCustomElement$e;
const appCss = "html.plt-mobile ion-app{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}html.plt-mobile ion-app [contenteditable]{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text}ion-app.force-statusbar-padding{--ion-safe-area-top:20px}";
const IonAppStyle0 = appCss;
const App$1 = /* @__PURE__ */ proxyCustomElement$1(class App extends H$1 {
  constructor() {
    super();
    this.__registerHost();
  }
  componentDidLoad() {
    {
      rIC(async () => {
        const isHybrid2 = isPlatform(window, "hybrid");
        if (!config.getBoolean("_testing")) {
          __vitePreload(() => import("./index9-wmJsJe4f.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url).then((module) => module.startTapClick(config));
        }
        if (config.getBoolean("statusTap", isHybrid2)) {
          __vitePreload(() => import("./status-tap-75KF9s-R.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url).then((module) => module.startStatusTap());
        }
        if (config.getBoolean("inputShims", needInputShims())) {
          const platform = isPlatform(window, "ios") ? "ios" : "android";
          __vitePreload(() => import("./input-shims-DOIE6dkS.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url).then((module) => module.startInputShims(config, platform));
        }
        const hardwareBackButtonModule = await __vitePreload(() => Promise.resolve().then(() => hardwareBackButton), true ? void 0 : void 0, import.meta.url);
        const supportsHardwareBackButtonEvents = isHybrid2 || shouldUseCloseWatcher();
        if (config.getBoolean("hardwareBackButton", supportsHardwareBackButtonEvents)) {
          hardwareBackButtonModule.startHardwareBackButton();
        } else {
          if (shouldUseCloseWatcher()) {
            printIonWarning("experimentalCloseWatcher was set to `true`, but hardwareBackButton was set to `false`. Both config options must be `true` for the Close Watcher API to be used.");
          }
          hardwareBackButtonModule.blockHardwareBackButton();
        }
        if (typeof window !== "undefined") {
          __vitePreload(() => Promise.resolve().then(() => keyboard2), true ? void 0 : void 0, import.meta.url).then((module) => module.startKeyboardAssist(window));
        }
        __vitePreload(() => import("./focus-visible-rDEGL05U.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url).then((module) => this.focusVisible = module.startFocusVisible());
      });
    }
  }
  /**
   * Used to set focus on an element that uses `ion-focusable`.
   * Do not use this if focusing the element as a result of a keyboard
   * event as the focus utility should handle this for us. This method
   * should be used when we want to programmatically focus an element as
   * a result of another user action. (Ex: We focus the first element
   * inside of a popover when the user presents it, but the popover is not always
   * presented as a result of keyboard action.)
   */
  async setFocus(elements) {
    if (this.focusVisible) {
      this.focusVisible.setFocus(elements);
    }
  }
  render() {
    const mode = getIonMode$2(this);
    return h$1(Host$1, { key: "96715520fd05d6f0e6fa26a8ba78792cfccd4c0a", class: {
      [mode]: true,
      "ion-page": true,
      "force-statusbar-padding": config.getBoolean("_forceStatusbarPadding")
    } });
  }
  get el() {
    return this;
  }
  static get style() {
    return IonAppStyle0;
  }
}, [0, "ion-app", {
  "setFocus": [64]
}]);
const needInputShims = () => {
  const needsShimsIOS = isPlatform(window, "ios") && isPlatform(window, "mobile");
  if (needsShimsIOS) {
    return true;
  }
  const isAndroidMobileWeb = isPlatform(window, "android") && isPlatform(window, "mobileweb");
  if (isAndroidMobileWeb) {
    return true;
  }
  return false;
};
const rIC = (callback) => {
  if ("requestIdleCallback" in window) {
    window.requestIdleCallback(callback);
  } else {
    setTimeout(callback, 32);
  }
};
function defineCustomElement$1$4() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-app"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-app":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, App$1);
        }
        break;
    }
  });
}
const defineCustomElement$6 = defineCustomElement$1$4;
const routerOutletCss = ":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;z-index:0}";
const IonRouterOutletStyle0 = routerOutletCss;
const RouterOutlet = /* @__PURE__ */ proxyCustomElement$1(class RouterOutlet2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionNavWillLoad = createEvent(this, "ionNavWillLoad", 7);
    this.ionNavWillChange = createEvent(this, "ionNavWillChange", 3);
    this.ionNavDidChange = createEvent(this, "ionNavDidChange", 3);
    this.lockController = createLockController();
    this.gestureOrAnimationInProgress = false;
    this.mode = getIonMode$2(this);
    this.delegate = void 0;
    this.animated = true;
    this.animation = void 0;
    this.swipeHandler = void 0;
  }
  swipeHandlerChanged() {
    if (this.gesture) {
      this.gesture.enable(this.swipeHandler !== void 0);
    }
  }
  async connectedCallback() {
    const onStart = () => {
      this.gestureOrAnimationInProgress = true;
      if (this.swipeHandler) {
        this.swipeHandler.onStart();
      }
    };
    this.gesture = (await __vitePreload(() => import("./swipe-back-XiZVxbRL.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url)).createSwipeBackGesture(this.el, () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(), () => onStart(), (step) => {
      var _a;
      return (_a = this.ani) === null || _a === void 0 ? void 0 : _a.progressStep(step);
    }, (shouldComplete, step, dur) => {
      if (this.ani) {
        this.ani.onFinish(() => {
          this.gestureOrAnimationInProgress = false;
          if (this.swipeHandler) {
            this.swipeHandler.onEnd(shouldComplete);
          }
        }, { oneTimeCallback: true });
        let newStepValue = shouldComplete ? -1e-3 : 1e-3;
        if (!shouldComplete) {
          this.ani.easing("cubic-bezier(1, 0, 0.68, 0.28)");
          newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];
        } else {
          newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];
        }
        this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);
      } else {
        this.gestureOrAnimationInProgress = false;
      }
    });
    this.swipeHandlerChanged();
  }
  componentWillLoad() {
    this.ionNavWillLoad.emit();
  }
  disconnectedCallback() {
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = void 0;
    }
  }
  /** @internal */
  async commit(enteringEl, leavingEl, opts) {
    const unlock = await this.lockController.lock();
    let changed = false;
    try {
      changed = await this.transition(enteringEl, leavingEl, opts);
    } catch (e2) {
      console.error(e2);
    }
    unlock();
    return changed;
  }
  /** @internal */
  async setRouteId(id2, params, direction, animation2) {
    const changed = await this.setRoot(id2, params, {
      duration: direction === "root" ? 0 : void 0,
      direction: direction === "back" ? "back" : "forward",
      animationBuilder: animation2
    });
    return {
      changed,
      element: this.activeEl
    };
  }
  /** @internal */
  async getRouteId() {
    const active = this.activeEl;
    return active ? {
      id: active.tagName,
      element: active,
      params: this.activeParams
    } : void 0;
  }
  async setRoot(component, params, opts) {
    if (this.activeComponent === component && shallowEqualStringMap(params, this.activeParams)) {
      return false;
    }
    const leavingEl = this.activeEl;
    const enteringEl = await attachComponent(this.delegate, this.el, component, ["ion-page", "ion-page-invisible"], params);
    this.activeComponent = component;
    this.activeEl = enteringEl;
    this.activeParams = params;
    await this.commit(enteringEl, leavingEl, opts);
    await detachComponent(this.delegate, leavingEl);
    return true;
  }
  async transition(enteringEl, leavingEl, opts = {}) {
    if (leavingEl === enteringEl) {
      return false;
    }
    this.ionNavWillChange.emit();
    const { el: el2, mode } = this;
    const animated = this.animated && config.getBoolean("animated", true);
    const animationBuilder = opts.animationBuilder || this.animation || config.get("navAnimation");
    await transition(Object.assign(Object.assign({
      mode,
      animated,
      enteringEl,
      leavingEl,
      baseEl: el2,
      /**
       * We need to wait for all Stencil components
       * to be ready only when using the lazy
       * loaded bundle.
       */
      deepWait: hasLazyBuild(el2),
      progressCallback: opts.progressAnimation ? (ani) => {
        if (ani !== void 0 && !this.gestureOrAnimationInProgress) {
          this.gestureOrAnimationInProgress = true;
          ani.onFinish(() => {
            this.gestureOrAnimationInProgress = false;
            if (this.swipeHandler) {
              this.swipeHandler.onEnd(false);
            }
          }, { oneTimeCallback: true });
          ani.progressEnd(0, 0, 0);
        } else {
          this.ani = ani;
        }
      } : void 0
    }, opts), { animationBuilder }));
    this.ionNavDidChange.emit();
    return true;
  }
  render() {
    return h$1("slot", { key: "a70341f58d19df55de1dad00e3464388e446aa2a" });
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "swipeHandler": ["swipeHandlerChanged"]
    };
  }
  static get style() {
    return IonRouterOutletStyle0;
  }
}, [1, "ion-router-outlet", {
  "mode": [1025],
  "delegate": [16],
  "animated": [4],
  "animation": [16],
  "swipeHandler": [16],
  "commit": [64],
  "setRouteId": [64],
  "getRouteId": [64]
}, void 0, {
  "swipeHandler": ["swipeHandlerChanged"]
}]);
function defineCustomElement$1$3() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-router-outlet"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-router-outlet":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, RouterOutlet);
        }
        break;
    }
  });
}
const defineCustomElement$5 = defineCustomElement$1$3;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const tabBarIosCss = ":host{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-right:var(--ion-safe-area-right);padding-bottom:var(--ion-safe-area-bottom, 0);padding-left:var(--ion-safe-area-left);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb), 0.7)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none !important}:host{--background:var(--ion-tab-bar-background, var(--ion-color-step-50, var(--ion-background-color-step-50, #f7f7f7)));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:0.55px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, var(--ion-background-color-step-150, rgba(0, 0, 0, 0.2)))));--color:var(--ion-tab-bar-color, var(--ion-color-step-600, var(--ion-text-color-step-400, #666666)));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #0054e9));height:50px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.tab-bar-translucent){--background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);-webkit-backdrop-filter:saturate(210%) blur(20px);backdrop-filter:saturate(210%) blur(20px)}:host(.ion-color.tab-bar-translucent){background:rgba(var(--ion-color-base-rgb), 0.8)}:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.6)}}";
const IonTabBarIosStyle0 = tabBarIosCss;
const tabBarMdCss = ":host{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-right:var(--ion-safe-area-right);padding-bottom:var(--ion-safe-area-bottom, 0);padding-left:var(--ion-safe-area-left);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb), 0.7)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none !important}:host{--background:var(--ion-tab-bar-background, var(--ion-background-color, #fff));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:1px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, var(--ion-background-color-step-150, rgba(0, 0, 0, 0.07)))));--color:var(--ion-tab-bar-color, var(--ion-color-step-650, var(--ion-text-color-step-350, #595959)));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #0054e9));height:56px}";
const IonTabBarMdStyle0 = tabBarMdCss;
const TabBar = /* @__PURE__ */ proxyCustomElement$1(class TabBar2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionTabBarChanged = createEvent(this, "ionTabBarChanged", 7);
    this.ionTabBarLoaded = createEvent(this, "ionTabBarLoaded", 7);
    this.keyboardCtrl = null;
    this.keyboardVisible = false;
    this.color = void 0;
    this.selectedTab = void 0;
    this.translucent = false;
  }
  selectedTabChanged() {
    if (this.selectedTab !== void 0) {
      this.ionTabBarChanged.emit({
        tab: this.selectedTab
      });
    }
  }
  componentWillLoad() {
    this.selectedTabChanged();
  }
  async connectedCallback() {
    this.keyboardCtrl = await createKeyboardController(async (keyboardOpen2, waitForResize) => {
      if (keyboardOpen2 === false && waitForResize !== void 0) {
        await waitForResize;
      }
      this.keyboardVisible = keyboardOpen2;
    });
  }
  disconnectedCallback() {
    if (this.keyboardCtrl) {
      this.keyboardCtrl.destroy();
    }
  }
  componentDidLoad() {
    this.ionTabBarLoaded.emit();
  }
  render() {
    const { color, translucent, keyboardVisible } = this;
    const mode = getIonMode$2(this);
    const shouldHide = keyboardVisible && this.el.getAttribute("slot") !== "top";
    return h$1(Host$1, { key: "a87fd2ea5df053705a37ea7ffec043e75c4a9907", role: "tablist", "aria-hidden": shouldHide ? "true" : null, class: createColorClasses$2(color, {
      [mode]: true,
      "tab-bar-translucent": translucent,
      "tab-bar-hidden": shouldHide
    }) }, h$1("slot", { key: "81a6223299b6cab29d7ddced590e9152e2b3ded0" }));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "selectedTab": ["selectedTabChanged"]
    };
  }
  static get style() {
    return {
      ios: IonTabBarIosStyle0,
      md: IonTabBarMdStyle0
    };
  }
}, [33, "ion-tab-bar", {
  "color": [513],
  "selectedTab": [1, "selected-tab"],
  "translucent": [4],
  "keyboardVisible": [32]
}, void 0, {
  "selectedTab": ["selectedTabChanged"]
}]);
function defineCustomElement$1$2() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-tab-bar"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-tab-bar":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, TabBar);
        }
        break;
    }
  });
}
const defineCustomElement$4 = defineCustomElement$1$2;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const tabButtonIosCss = ':host{--ripple-color:var(--color-selected);--background-focused-opacity:1;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}.button-native{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none !important}:host(.tab-disabled){pointer-events:none;opacity:0.4}::slotted(ion-label),::slotted(ion-icon){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:2px;--padding-bottom:0;--padding-start:2px;max-width:240px;font-size:10px}::slotted(ion-badge){-webkit-padding-start:6px;padding-inline-start:6px;-webkit-padding-end:6px;padding-inline-end:6px;padding-top:1px;padding-bottom:1px;top:4px;height:auto;font-size:12px;line-height:16px}::slotted(ion-badge){inset-inline-start:calc(50% + 6px)}::slotted(ion-icon){margin-top:2px;margin-bottom:2px;font-size:24px}::slotted(ion-icon::before){vertical-align:top}::slotted(ion-label){margin-top:0;margin-bottom:1px;min-height:11px;font-weight:500}:host(.tab-has-label-only) ::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:12px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-label),:host(.tab-layout-icon-start) ::slotted(ion-label),:host(.tab-layout-icon-hide) ::slotted(ion-label){margin-top:2px;margin-bottom:2px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-icon),:host(.tab-layout-icon-start) ::slotted(ion-icon){min-width:24px;height:26px;margin-top:2px;margin-bottom:1px;font-size:24px}:host(.tab-layout-icon-bottom) ::slotted(ion-badge){inset-inline-start:calc(50% + 12px)}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:1px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:4px}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){top:10px}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){inset-inline-start:calc(50% + 35px)}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){top:10px}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){inset-inline-start:calc(50% + 30px)}:host(.tab-layout-label-hide) ::slotted(ion-badge),:host(.tab-has-icon-only) ::slotted(ion-badge){top:10px}:host(.tab-layout-label-hide) ::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}:host(.tab-layout-label-hide) ::slotted(ion-icon),:host(.tab-has-icon-only) ::slotted(ion-icon){font-size:30px}';
const IonTabButtonIosStyle0 = tabButtonIosCss;
const tabButtonMdCss = ':host{--ripple-color:var(--color-selected);--background-focused-opacity:1;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}.button-native{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none !important}:host(.tab-disabled){pointer-events:none;opacity:0.4}::slotted(ion-label),::slotted(ion-icon){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:12px;--padding-bottom:0;--padding-start:12px;max-width:168px;font-size:12px;font-weight:normal;letter-spacing:0.03em}::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;text-transform:none}::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:16px;margin-bottom:16px;-webkit-transform-origin:center center;transform-origin:center center;font-size:22px}:host-context([dir=rtl]) ::slotted(ion-icon){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}[dir=rtl] ::slotted(ion-icon){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}@supports selector(:dir(rtl)){::slotted(ion-icon):dir(rtl){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}}::slotted(ion-badge){border-radius:8px;-webkit-padding-start:2px;padding-inline-start:2px;-webkit-padding-end:2px;padding-inline-end:2px;padding-top:3px;padding-bottom:2px;top:8px;min-width:12px;font-size:8px;font-weight:normal}::slotted(ion-badge){inset-inline-start:calc(50% + 6px)}::slotted(ion-badge:empty){display:block;min-width:8px;height:8px}:host(.tab-layout-icon-top) ::slotted(ion-icon){margin-top:6px;margin-bottom:2px}:host(.tab-layout-icon-top) ::slotted(ion-label){margin-top:0;margin-bottom:6px}:host(.tab-layout-icon-bottom) ::slotted(ion-badge){top:8px}:host(.tab-layout-icon-bottom) ::slotted(ion-badge){inset-inline-start:70%}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:6px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:6px;margin-bottom:0}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){top:16px}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){inset-inline-start:80%}:host(.tab-layout-icon-start) ::slotted(ion-icon){-webkit-margin-end:6px;margin-inline-end:6px}:host(.tab-layout-icon-end) ::slotted(ion-icon){-webkit-margin-start:6px;margin-inline-start:6px}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){top:16px}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){inset-inline-start:70%}:host(.tab-layout-icon-hide) ::slotted(ion-label),:host(.tab-has-label-only) ::slotted(ion-label){margin-top:0;margin-bottom:0}:host(.tab-layout-label-hide) ::slotted(ion-badge),:host(.tab-has-icon-only) ::slotted(ion-badge){top:16px}:host(.tab-layout-label-hide) ::slotted(ion-icon),:host(.tab-has-icon-only) ::slotted(ion-icon){margin-top:0;margin-bottom:0;font-size:24px}';
const IonTabButtonMdStyle0 = tabButtonMdCss;
const TabButton = /* @__PURE__ */ proxyCustomElement$1(class TabButton2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionTabButtonClick = createEvent(this, "ionTabButtonClick", 7);
    this.inheritedAttributes = {};
    this.onKeyUp = (ev) => {
      if (ev.key === "Enter" || ev.key === " ") {
        this.selectTab(ev);
      }
    };
    this.onClick = (ev) => {
      this.selectTab(ev);
    };
    this.disabled = false;
    this.download = void 0;
    this.href = void 0;
    this.rel = void 0;
    this.layout = void 0;
    this.selected = false;
    this.tab = void 0;
    this.target = void 0;
  }
  onTabBarChanged(ev) {
    const dispatchedFrom = ev.target;
    const parent2 = this.el.parentElement;
    if (ev.composedPath().includes(parent2) || (dispatchedFrom === null || dispatchedFrom === void 0 ? void 0 : dispatchedFrom.contains(this.el))) {
      this.selected = this.tab === ev.detail.tab;
    }
  }
  componentWillLoad() {
    this.inheritedAttributes = Object.assign({}, inheritAttributes$2(this.el, ["aria-label"]));
    if (this.layout === void 0) {
      this.layout = config.get("tabButtonLayout", "icon-top");
    }
  }
  selectTab(ev) {
    if (this.tab !== void 0) {
      if (!this.disabled) {
        this.ionTabButtonClick.emit({
          tab: this.tab,
          href: this.href,
          selected: this.selected
        });
      }
      ev.preventDefault();
    }
  }
  get hasLabel() {
    return !!this.el.querySelector("ion-label");
  }
  get hasIcon() {
    return !!this.el.querySelector("ion-icon");
  }
  render() {
    const { disabled, hasIcon, hasLabel, href, rel, target, layout, selected, tab, inheritedAttributes } = this;
    const mode = getIonMode$2(this);
    const attrs = {
      download: this.download,
      href,
      rel,
      target
    };
    return h$1(Host$1, { key: "5976c45943ea7ea8e7c1a85fc9996de421439f08", onClick: this.onClick, onKeyup: this.onKeyUp, id: tab !== void 0 ? "tab-button-".concat(tab) : null, class: {
      [mode]: true,
      "tab-selected": selected,
      "tab-disabled": disabled,
      "tab-has-label": hasLabel,
      "tab-has-icon": hasIcon,
      "tab-has-label-only": hasLabel && !hasIcon,
      "tab-has-icon-only": hasIcon && !hasLabel,
      ["tab-layout-".concat(layout)]: true,
      "ion-activatable": true,
      "ion-selectable": true,
      "ion-focusable": true
    } }, h$1("a", Object.assign({ key: "1db09d861b67ff292018fb4b0dc7b85bd4677eb8" }, attrs, { class: "button-native", part: "native", role: "tab", "aria-selected": selected ? "true" : null, "aria-disabled": disabled ? "true" : null, tabindex: disabled ? "-1" : void 0 }, inheritedAttributes), h$1("span", { key: "4381eafcb27e8c7bb0d86d4f115ceb0caf03b9b4", class: "button-inner" }, h$1("slot", { key: "1981135f6fbb88376c1bd923c55c70fe8b5c5159" })), mode === "md" && h$1("ion-ripple-effect", { key: "0509bc7155d055d1ed710600e9cf4df135881491", type: "unbounded" })));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: IonTabButtonIosStyle0,
      md: IonTabButtonMdStyle0
    };
  }
}, [33, "ion-tab-button", {
  "disabled": [4],
  "download": [1],
  "href": [1],
  "rel": [1],
  "layout": [1025],
  "selected": [1028],
  "tab": [1],
  "target": [1]
}, [[8, "ionTabBarChanged", "onTabBarChanged"]]]);
function defineCustomElement$1$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-tab-button", "ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-tab-button":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, TabButton);
        }
        break;
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          defineCustomElement$u();
        }
        break;
    }
  });
}
const defineCustomElement$3 = defineCustomElement$1$1;
var BUILD = {
  allRenderFn: false,
  cmpDidLoad: true,
  cmpDidUnload: false,
  cmpDidUpdate: true,
  cmpDidRender: true,
  cmpWillLoad: true,
  cmpWillUpdate: true,
  cmpWillRender: true,
  connectedCallback: true,
  disconnectedCallback: true,
  element: true,
  event: true,
  hasRenderFn: true,
  lifecycle: true,
  hostListener: true,
  hostListenerTargetWindow: true,
  hostListenerTargetDocument: true,
  hostListenerTargetBody: true,
  hostListenerTargetParent: false,
  hostListenerTarget: true,
  member: true,
  method: true,
  mode: true,
  observeAttribute: true,
  prop: true,
  propMutable: true,
  reflect: true,
  scoped: true,
  shadowDom: true,
  slot: true,
  cssAnnotations: true,
  state: true,
  style: true,
  formAssociated: false,
  svg: true,
  updatable: true,
  vdomAttribute: true,
  vdomXlink: true,
  vdomClass: true,
  vdomFunctional: true,
  vdomKey: true,
  vdomListener: true,
  vdomRef: true,
  vdomPropOrAttr: true,
  vdomRender: true,
  vdomStyle: true,
  vdomText: true,
  watchCallback: true,
  taskQueue: true,
  hotModuleReplacement: false,
  isDebug: false,
  isDev: false,
  isTesting: false,
  hydrateServerSide: false,
  hydrateClientSide: false,
  lifecycleDOMEvents: false,
  lazyLoad: false,
  profile: false,
  slotRelocation: true,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: false,
  hydratedAttribute: false,
  hydratedClass: true,
  // TODO(STENCIL-1305): remove this option
  scriptDataOpts: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: false,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: false,
  invisiblePrehydration: true,
  propBoolean: true,
  propNumber: true,
  propString: true,
  constructableCSS: true,
  cmpShouldUpdate: true,
  devTools: false,
  shadowDelegatesFocus: true,
  initializeNextTick: false,
  asyncLoading: true,
  asyncQueue: false,
  transformTagName: false,
  attachStyles: true,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: false
};
var NAMESPACE = (
  /* default */
  "app"
);
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var hostRefs = /* @__PURE__ */ new WeakMap();
var getHostRef = (ref) => hostRefs.get(ref);
var registerHost = (hostElement, cmpMeta) => {
  const hostRef = {
    $flags$: 0,
    $hostElement$: hostElement,
    $cmpMeta$: cmpMeta,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  {
    hostRef.$onReadyPromise$ = new Promise((r2) => hostRef.$onReadyResolve$ = r2);
    hostElement["s-p"] = [];
    hostElement["s-rc"] = [];
  }
  return hostRefs.set(hostElement, hostRef);
};
var isMemberInElement = (elm, memberName) => memberName in elm;
var consoleError = (e2, el2) => (0, console.error)(e2, el2);
var styles = /* @__PURE__ */ new Map();
var modeResolutionChain = [];
var SLOT_FB_CSS = "slot-fb{display:contents}slot-fb[hidden]{display:none}";
var XLINK_NS = "http://www.w3.org/1999/xlink";
var win = typeof window !== "undefined" ? window : {};
var doc = win.document || { head: {} };
var H = win.HTMLElement || class {
};
var plt = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (h2) => h2(),
  raf: (h2) => requestAnimationFrame(h2),
  ael: (el2, eventName, listener, opts) => el2.addEventListener(eventName, listener, opts),
  rel: (el2, eventName, listener, opts) => el2.removeEventListener(eventName, listener, opts),
  ce: (eventName, opts) => new CustomEvent(eventName, opts)
};
var supportsListenerOptions = /* @__PURE__ */ (() => {
  let supportsListenerOptions2 = false;
  try {
    doc.addEventListener(
      "e",
      null,
      Object.defineProperty({}, "passive", {
        get() {
          supportsListenerOptions2 = true;
        }
      })
    );
  } catch (e2) {
  }
  return supportsListenerOptions2;
})();
var promiseResolve = (v2) => Promise.resolve(v2);
var supportsConstructableStylesheets = /* @__PURE__ */ (() => {
  try {
    new CSSStyleSheet();
    return typeof new CSSStyleSheet().replaceSync === "function";
  } catch (e2) {
  }
  return false;
})();
var queuePending = false;
var queueDomReads = [];
var queueDomWrites = [];
var queueTask = (queue, write) => (cb2) => {
  queue.push(cb2);
  if (!queuePending) {
    queuePending = true;
    if (write && plt.$flags$ & 4) {
      nextTick(flush);
    } else {
      plt.raf(flush);
    }
  }
};
var consume = (queue) => {
  for (let i2 = 0; i2 < queue.length; i2++) {
    try {
      queue[i2](performance.now());
    } catch (e2) {
      consoleError(e2);
    }
  }
  queue.length = 0;
};
var flush = () => {
  consume(queueDomReads);
  {
    consume(queueDomWrites);
    if (queuePending = queueDomReads.length > 0) {
      plt.raf(flush);
    }
  }
};
var nextTick = (cb2) => promiseResolve().then(cb2);
var writeTask = /* @__PURE__ */ queueTask(queueDomWrites, true);
var getAssetPath = (path) => {
  const assetUrl = new URL(path, plt.$resourcesUrl$);
  return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;
};
var EMPTY_OBJ = {};
var SVG_NS = "http://www.w3.org/2000/svg";
var HTML_NS = "http://www.w3.org/1999/xhtml";
var isDef = (v2) => v2 != null;
var isComplexType = (o) => {
  o = typeof o;
  return o === "object" || o === "function";
};
function queryNonceMetaTagContent(doc2) {
  var _a, _b, _c;
  return (_c = (_b = (_a = doc2.head) == null ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) == null ? void 0 : _b.getAttribute("content")) != null ? _c : void 0;
}
var result_exports = {};
__export(result_exports, {
  err: () => err,
  map: () => map,
  ok: () => ok,
  unwrap: () => unwrap,
  unwrapErr: () => unwrapErr
});
var ok = (value) => ({
  isOk: true,
  isErr: false,
  value
});
var err = (value) => ({
  isOk: false,
  isErr: true,
  value
});
function map(result, fn) {
  if (result.isOk) {
    const val = fn(result.value);
    if (val instanceof Promise) {
      return val.then((newVal) => ok(newVal));
    } else {
      return ok(val);
    }
  }
  if (result.isErr) {
    const value = result.value;
    return err(value);
  }
  throw "should never get here";
}
var unwrap = (result) => {
  if (result.isOk) {
    return result.value;
  } else {
    throw result.value;
  }
};
var unwrapErr = (result) => {
  if (result.isErr) {
    return result.value;
  } else {
    throw result.value;
  }
};
var createTime = (fnName, tagName = "") => {
  {
    return () => {
      return;
    };
  }
};
var h = (nodeName, vnodeData, ...children) => {
  let child = null;
  let key = null;
  let slotName = null;
  let simple = false;
  let lastSimple = false;
  const vNodeChildren = [];
  const walk = (c2) => {
    for (let i2 = 0; i2 < c2.length; i2++) {
      child = c2[i2];
      if (Array.isArray(child)) {
        walk(child);
      } else if (child != null && typeof child !== "boolean") {
        if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
          child = String(child);
        }
        if (simple && lastSimple) {
          vNodeChildren[vNodeChildren.length - 1].$text$ += child;
        } else {
          vNodeChildren.push(simple ? newVNode(null, child) : child);
        }
        lastSimple = simple;
      }
    }
  };
  walk(children);
  if (vnodeData) {
    if (vnodeData.key) {
      key = vnodeData.key;
    }
    if (vnodeData.name) {
      slotName = vnodeData.name;
    }
    {
      const classData = vnodeData.className || vnodeData.class;
      if (classData) {
        vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k2) => classData[k2]).join(" ");
      }
    }
  }
  if (typeof nodeName === "function") {
    return nodeName(
      vnodeData === null ? {} : vnodeData,
      vNodeChildren,
      vdomFnUtils
    );
  }
  const vnode = newVNode(nodeName, null);
  vnode.$attrs$ = vnodeData;
  if (vNodeChildren.length > 0) {
    vnode.$children$ = vNodeChildren;
  }
  {
    vnode.$key$ = key;
  }
  {
    vnode.$name$ = slotName;
  }
  return vnode;
};
var newVNode = (tag, text) => {
  const vnode = {
    $flags$: 0,
    $tag$: tag,
    $text$: text,
    $elm$: null,
    $children$: null
  };
  {
    vnode.$attrs$ = null;
  }
  {
    vnode.$key$ = null;
  }
  {
    vnode.$name$ = null;
  }
  return vnode;
};
var Host = {};
var isHost = (node) => node && node.$tag$ === Host;
var vdomFnUtils = {
  forEach: (children, cb2) => children.map(convertToPublic).forEach(cb2),
  map: (children, cb2) => children.map(convertToPublic).map(cb2).map(convertToPrivate)
};
var convertToPublic = (node) => ({
  vattrs: node.$attrs$,
  vchildren: node.$children$,
  vkey: node.$key$,
  vname: node.$name$,
  vtag: node.$tag$,
  vtext: node.$text$
});
var convertToPrivate = (node) => {
  if (typeof node.vtag === "function") {
    const vnodeData = { ...node.vattrs };
    if (node.vkey) {
      vnodeData.key = node.vkey;
    }
    if (node.vname) {
      vnodeData.name = node.vname;
    }
    return h(node.vtag, vnodeData, ...node.vchildren || []);
  }
  const vnode = newVNode(node.vtag, node.vtext);
  vnode.$attrs$ = node.vattrs;
  vnode.$children$ = node.vchildren;
  vnode.$key$ = node.vkey;
  vnode.$name$ = node.vname;
  return vnode;
};
var computeMode = (elm) => modeResolutionChain.map((h2) => h2(elm)).find((m2) => !!m2);
var parsePropertyValue = (propValue, propType) => {
  if (propValue != null && !isComplexType(propValue)) {
    if (propType & 4) {
      return propValue === "false" ? false : propValue === "" || !!propValue;
    }
    if (propType & 2) {
      return parseFloat(propValue);
    }
    if (propType & 1) {
      return String(propValue);
    }
    return propValue;
  }
  return propValue;
};
var emitEvent = (elm, name, opts) => {
  const ev = plt.ce(name, opts);
  elm.dispatchEvent(ev);
  return ev;
};
var rootAppliedStyles = /* @__PURE__ */ new WeakMap();
var registerStyle = (scopeId2, cssText, allowCS) => {
  let style = styles.get(scopeId2);
  if (supportsConstructableStylesheets && allowCS) {
    style = style || new CSSStyleSheet();
    if (typeof style === "string") {
      style = cssText;
    } else {
      style.replaceSync(cssText);
    }
  } else {
    style = cssText;
  }
  styles.set(scopeId2, style);
};
var addStyle = (styleContainerNode, cmpMeta, mode) => {
  var _a;
  const scopeId2 = getScopeId(cmpMeta, mode);
  const style = styles.get(scopeId2);
  styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : doc;
  if (style) {
    if (typeof style === "string") {
      styleContainerNode = styleContainerNode.head || styleContainerNode;
      let appliedStyles = rootAppliedStyles.get(styleContainerNode);
      let styleElm;
      if (!appliedStyles) {
        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
      }
      if (!appliedStyles.has(scopeId2)) {
        {
          styleElm = doc.createElement("style");
          styleElm.innerHTML = style;
          const nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(doc);
          if (nonce != null) {
            styleElm.setAttribute("nonce", nonce);
          }
          if (!(cmpMeta.$flags$ & 1)) {
            if (styleContainerNode.nodeName === "HEAD") {
              const preconnectLinks = styleContainerNode.querySelectorAll("link[rel=preconnect]");
              const referenceNode2 = preconnectLinks.length > 0 ? preconnectLinks[preconnectLinks.length - 1].nextSibling : styleContainerNode.querySelector("style");
              styleContainerNode.insertBefore(styleElm, referenceNode2);
            } else if ("host" in styleContainerNode) {
              if (supportsConstructableStylesheets) {
                const stylesheet = new CSSStyleSheet();
                stylesheet.replaceSync(style);
                styleContainerNode.adoptedStyleSheets = [stylesheet, ...styleContainerNode.adoptedStyleSheets];
              } else {
                const existingStyleContainer = styleContainerNode.querySelector("style");
                if (existingStyleContainer) {
                  existingStyleContainer.innerHTML = style + existingStyleContainer.innerHTML;
                } else {
                  styleContainerNode.prepend(styleElm);
                }
              }
            } else {
              styleContainerNode.append(styleElm);
            }
          }
          if (cmpMeta.$flags$ & 1 && styleContainerNode.nodeName !== "HEAD") {
            styleContainerNode.insertBefore(styleElm, null);
          }
        }
        if (cmpMeta.$flags$ & 4) {
          styleElm.innerHTML += SLOT_FB_CSS;
        }
        if (appliedStyles) {
          appliedStyles.add(scopeId2);
        }
      }
    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
      styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
    }
  }
  return scopeId2;
};
var attachStyles = (hostRef) => {
  const cmpMeta = hostRef.$cmpMeta$;
  const elm = hostRef.$hostElement$;
  const flags2 = cmpMeta.$flags$;
  const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
  const scopeId2 = addStyle(
    elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(),
    cmpMeta,
    hostRef.$modeName$
  );
  if (flags2 & 10 && flags2 & 2) {
    elm["s-sc"] = scopeId2;
    elm.classList.add(scopeId2 + "-h");
    if (flags2 & 2) {
      elm.classList.add(scopeId2 + "-s");
    }
  }
  endAttachStyles();
};
var getScopeId = (cmp, mode) => "sc-" + (mode && cmp.$flags$ & 32 ? cmp.$tagName$ + "-" + mode : cmp.$tagName$);
var setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags2) => {
  if (oldValue !== newValue) {
    let isProp = isMemberInElement(elm, memberName);
    let ln = memberName.toLowerCase();
    if (memberName === "class") {
      const classList = elm.classList;
      const oldClasses = parseClassList(oldValue);
      const newClasses = parseClassList(newValue);
      classList.remove(...oldClasses.filter((c2) => c2 && !newClasses.includes(c2)));
      classList.add(...newClasses.filter((c2) => c2 && !oldClasses.includes(c2)));
    } else if (memberName === "style") {
      {
        for (const prop in oldValue) {
          if (!newValue || newValue[prop] == null) {
            if (prop.includes("-")) {
              elm.style.removeProperty(prop);
            } else {
              elm.style[prop] = "";
            }
          }
        }
      }
      for (const prop in newValue) {
        if (!oldValue || newValue[prop] !== oldValue[prop]) {
          if (prop.includes("-")) {
            elm.style.setProperty(prop, newValue[prop]);
          } else {
            elm.style[prop] = newValue[prop];
          }
        }
      }
    } else if (memberName === "key")
      ;
    else if (memberName === "ref") {
      if (newValue) {
        newValue(elm);
      }
    } else if (!elm.__lookupSetter__(memberName) && memberName[0] === "o" && memberName[1] === "n") {
      if (memberName[2] === "-") {
        memberName = memberName.slice(3);
      } else if (isMemberInElement(win, ln)) {
        memberName = ln.slice(2);
      } else {
        memberName = ln[2] + memberName.slice(3);
      }
      if (oldValue || newValue) {
        const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);
        memberName = memberName.replace(CAPTURE_EVENT_REGEX, "");
        if (oldValue) {
          plt.rel(elm, memberName, oldValue, capture);
        }
        if (newValue) {
          plt.ael(elm, memberName, newValue, capture);
        }
      }
    } else {
      const isComplex = isComplexType(newValue);
      if ((isProp || isComplex && newValue !== null) && !isSvg) {
        try {
          if (!elm.tagName.includes("-")) {
            const n2 = newValue == null ? "" : newValue;
            if (memberName === "list") {
              isProp = false;
            } else if (oldValue == null || elm[memberName] != n2) {
              if (typeof elm.__lookupSetter__(memberName) === "function") {
                elm[memberName] = n2;
              } else {
                elm.setAttribute(memberName, n2);
              }
            }
          } else {
            elm[memberName] = newValue;
          }
        } catch (e2) {
        }
      }
      let xlink = false;
      {
        if (ln !== (ln = ln.replace(/^xlink\:?/, ""))) {
          memberName = ln;
          xlink = true;
        }
      }
      if (newValue == null || newValue === false) {
        if (newValue !== false || elm.getAttribute(memberName) === "") {
          if (xlink) {
            elm.removeAttributeNS(XLINK_NS, memberName);
          } else {
            elm.removeAttribute(memberName);
          }
        }
      } else if ((!isProp || flags2 & 4 || isSvg) && !isComplex) {
        newValue = newValue === true ? "" : newValue;
        if (xlink) {
          elm.setAttributeNS(XLINK_NS, memberName, newValue);
        } else {
          elm.setAttribute(memberName, newValue);
        }
      }
    }
  }
};
var parseClassListRegex = /\s/;
var parseClassList = (value) => !value ? [] : value.split(parseClassListRegex);
var CAPTURE_EVENT_SUFFIX = "Capture";
var CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + "$");
var updateElement = (oldVnode, newVnode, isSvgMode2) => {
  const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
  {
    for (const memberName of sortedAttrNames(Object.keys(oldVnodeAttrs))) {
      if (!(memberName in newVnodeAttrs)) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
      }
    }
  }
  for (const memberName of sortedAttrNames(Object.keys(newVnodeAttrs))) {
    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
  }
};
function sortedAttrNames(attrNames) {
  return attrNames.includes("ref") ? (
    // we need to sort these to ensure that `'ref'` is the last attr
    [...attrNames.filter((attr) => attr !== "ref"), "ref"]
  ) : (
    // no need to sort, return the original array
    attrNames
  );
}
var scopeId;
var contentRef;
var hostTagName;
var useNativeShadowDom = false;
var checkSlotFallbackVisibility = false;
var checkSlotRelocate = false;
var isSvgMode = false;
var createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
  var _a;
  const newVNode2 = newParentVNode.$children$[childIndex];
  let i2 = 0;
  let elm;
  let childNode;
  let oldVNode;
  if (!useNativeShadowDom) {
    checkSlotRelocate = true;
    if (newVNode2.$tag$ === "slot") {
      if (scopeId) {
        parentElm.classList.add(scopeId + "-s");
      }
      newVNode2.$flags$ |= newVNode2.$children$ ? (
        // slot element has fallback content
        // still create an element that "mocks" the slot element
        2
      ) : (
        // slot element does not have fallback content
        // create an html comment we'll use to always reference
        // where actual slot content should sit next to
        1
      );
    }
  }
  if (newVNode2.$text$ !== null) {
    elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);
  } else if (newVNode2.$flags$ & 1) {
    elm = newVNode2.$elm$ = doc.createTextNode("");
  } else {
    if (!isSvgMode) {
      isSvgMode = newVNode2.$tag$ === "svg";
    }
    elm = newVNode2.$elm$ = doc.createElementNS(
      isSvgMode ? SVG_NS : HTML_NS,
      !useNativeShadowDom && BUILD.slotRelocation && newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$
    );
    if (isSvgMode && newVNode2.$tag$ === "foreignObject") {
      isSvgMode = false;
    }
    {
      updateElement(null, newVNode2, isSvgMode);
    }
    const rootNode = elm.getRootNode();
    const isElementWithinShadowRoot = !rootNode.querySelector("body");
    if (!isElementWithinShadowRoot && BUILD.scoped && isDef(scopeId) && elm["s-si"] !== scopeId) {
      elm.classList.add(elm["s-si"] = scopeId);
    }
    {
      updateElementScopeIds(elm, parentElm);
    }
    if (newVNode2.$children$) {
      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {
        childNode = createElm(oldParentVNode, newVNode2, i2, elm);
        if (childNode) {
          elm.appendChild(childNode);
        }
      }
    }
    {
      if (newVNode2.$tag$ === "svg") {
        isSvgMode = false;
      } else if (elm.tagName === "foreignObject") {
        isSvgMode = true;
      }
    }
  }
  elm["s-hn"] = hostTagName;
  {
    if (newVNode2.$flags$ & (2 | 1)) {
      elm["s-sr"] = true;
      elm["s-cr"] = contentRef;
      elm["s-sn"] = newVNode2.$name$ || "";
      elm["s-rf"] = (_a = newVNode2.$attrs$) == null ? void 0 : _a.ref;
      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
      if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
        {
          putBackInOriginalLocation(oldParentVNode.$elm$, false);
        }
      }
    }
  }
  return elm;
};
var putBackInOriginalLocation = (parentElm, recursive) => {
  plt.$flags$ |= 1;
  const oldSlotChildNodes = Array.from(parentElm.childNodes);
  if (parentElm["s-sr"] && BUILD.experimentalSlotFixes) {
    let node = parentElm;
    while (node = node.nextSibling) {
      if (node && node["s-sn"] === parentElm["s-sn"] && node["s-sh"] === hostTagName) {
        oldSlotChildNodes.push(node);
      }
    }
  }
  for (let i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--) {
    const childNode = oldSlotChildNodes[i2];
    if (childNode["s-hn"] !== hostTagName && childNode["s-ol"]) {
      insertBefore(parentReferenceNode(childNode), childNode, referenceNode(childNode));
      childNode["s-ol"].remove();
      childNode["s-ol"] = void 0;
      childNode["s-sh"] = void 0;
      checkSlotRelocate = true;
    }
    if (recursive) {
      putBackInOriginalLocation(childNode, recursive);
    }
  }
  plt.$flags$ &= ~1;
};
var addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
  let containerElm = parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
  let childNode;
  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
    containerElm = containerElm.shadowRoot;
  }
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnodes[startIdx]) {
      childNode = createElm(null, parentVNode, startIdx, parentElm);
      if (childNode) {
        vnodes[startIdx].$elm$ = childNode;
        insertBefore(containerElm, childNode, referenceNode(before));
      }
    }
  }
};
var removeVnodes = (vnodes, startIdx, endIdx) => {
  for (let index = startIdx; index <= endIdx; ++index) {
    const vnode = vnodes[index];
    if (vnode) {
      const elm = vnode.$elm$;
      nullifyVNodeRefs(vnode);
      if (elm) {
        {
          checkSlotFallbackVisibility = true;
          if (elm["s-ol"]) {
            elm["s-ol"].remove();
          } else {
            putBackInOriginalLocation(elm, true);
          }
        }
        elm.remove();
      }
    }
  }
};
var updateChildren = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let idxInOld = 0;
  let i2 = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let node;
  let elmToMove;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {
      patch(oldStartVnode, newStartVnode, isInitialRender);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {
      patch(oldEndVnode, newEndVnode, isInitialRender);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
      }
      patch(oldStartVnode, newEndVnode, isInitialRender);
      insertBefore(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
      }
      patch(oldEndVnode, newStartVnode, isInitialRender);
      insertBefore(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      idxInOld = -1;
      {
        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {
          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {
            idxInOld = i2;
            break;
          }
        }
      }
      if (idxInOld >= 0) {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.$tag$ !== newStartVnode.$tag$) {
          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld, parentElm);
        } else {
          patch(elmToMove, newStartVnode, isInitialRender);
          oldCh[idxInOld] = void 0;
          node = elmToMove.$elm$;
        }
        newStartVnode = newCh[++newStartIdx];
      } else {
        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);
        newStartVnode = newCh[++newStartIdx];
      }
      if (node) {
        {
          insertBefore(parentReferenceNode(oldStartVnode.$elm$), node, referenceNode(oldStartVnode.$elm$));
        }
      }
    }
  }
  if (oldStartIdx > oldEndIdx) {
    addVnodes(
      parentElm,
      newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$,
      newVNode2,
      newCh,
      newStartIdx,
      newEndIdx
    );
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(oldCh, oldStartIdx, oldEndIdx);
  }
};
var isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {
  if (leftVNode.$tag$ === rightVNode.$tag$) {
    if (leftVNode.$tag$ === "slot") {
      if (
        // The component gets hydrated and no VDOM has been initialized.
        // Here the comparison can't happen as $name$ property is not set for `leftNode`.
        "$nodeId$" in leftVNode && isInitialRender && // `leftNode` is not from type HTMLComment which would cause many
        // hydration comments to be removed
        leftVNode.$elm$.nodeType !== 8
      ) {
        return false;
      }
      return leftVNode.$name$ === rightVNode.$name$;
    }
    if (!isInitialRender) {
      return leftVNode.$key$ === rightVNode.$key$;
    }
    return true;
  }
  return false;
};
var referenceNode = (node) => {
  return node && node["s-ol"] || node;
};
var parentReferenceNode = (node) => (node["s-ol"] ? node["s-ol"] : node).parentNode;
var patch = (oldVNode, newVNode2, isInitialRender = false) => {
  const elm = newVNode2.$elm$ = oldVNode.$elm$;
  const oldChildren = oldVNode.$children$;
  const newChildren = newVNode2.$children$;
  const tag = newVNode2.$tag$;
  const text = newVNode2.$text$;
  let defaultHolder;
  if (text === null) {
    {
      isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
    }
    {
      if (tag === "slot" && !useNativeShadowDom)
        ;
      else {
        updateElement(oldVNode, newVNode2, isSvgMode);
      }
    }
    if (oldChildren !== null && newChildren !== null) {
      updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);
    } else if (newChildren !== null) {
      if (oldVNode.$text$ !== null) {
        elm.textContent = "";
      }
      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
    } else if (
      // don't do this on initial render as it can cause non-hydrated content to be removed
      !isInitialRender && BUILD.updatable && oldChildren !== null
    ) {
      removeVnodes(oldChildren, 0, oldChildren.length - 1);
    }
    if (isSvgMode && tag === "svg") {
      isSvgMode = false;
    }
  } else if (defaultHolder = elm["s-cr"]) {
    defaultHolder.parentNode.textContent = text;
  } else if (oldVNode.$text$ !== text) {
    elm.data = text;
  }
};
var updateFallbackSlotVisibility = (elm) => {
  const childNodes = elm.childNodes;
  for (const childNode of childNodes) {
    if (childNode.nodeType === 1) {
      if (childNode["s-sr"]) {
        const slotName = childNode["s-sn"];
        childNode.hidden = false;
        for (const siblingNode of childNodes) {
          if (siblingNode !== childNode) {
            if (siblingNode["s-hn"] !== childNode["s-hn"] || slotName !== "") {
              if (siblingNode.nodeType === 1 && (slotName === siblingNode.getAttribute("slot") || slotName === siblingNode["s-sn"]) || siblingNode.nodeType === 3 && slotName === siblingNode["s-sn"]) {
                childNode.hidden = true;
                break;
              }
            } else {
              if (siblingNode.nodeType === 1 || siblingNode.nodeType === 3 && siblingNode.textContent.trim() !== "") {
                childNode.hidden = true;
                break;
              }
            }
          }
        }
      }
      updateFallbackSlotVisibility(childNode);
    }
  }
};
var relocateNodes = [];
var markSlotContentForRelocation = (elm) => {
  let node;
  let hostContentNodes;
  let j;
  for (const childNode of elm.childNodes) {
    if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
      hostContentNodes = node.parentNode.childNodes;
      const slotName = childNode["s-sn"];
      for (j = hostContentNodes.length - 1; j >= 0; j--) {
        node = hostContentNodes[j];
        if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"] && !BUILD.experimentalSlotFixes) {
          if (isNodeLocatedInSlot(node, slotName)) {
            let relocateNodeData = relocateNodes.find((r2) => r2.$nodeToRelocate$ === node);
            checkSlotFallbackVisibility = true;
            node["s-sn"] = node["s-sn"] || slotName;
            if (relocateNodeData) {
              relocateNodeData.$nodeToRelocate$["s-sh"] = childNode["s-hn"];
              relocateNodeData.$slotRefNode$ = childNode;
            } else {
              node["s-sh"] = childNode["s-hn"];
              relocateNodes.push({
                $slotRefNode$: childNode,
                $nodeToRelocate$: node
              });
            }
            if (node["s-sr"]) {
              relocateNodes.map((relocateNode) => {
                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                  relocateNodeData = relocateNodes.find((r2) => r2.$nodeToRelocate$ === node);
                  if (relocateNodeData && !relocateNode.$slotRefNode$) {
                    relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                  }
                }
              });
            }
          } else if (!relocateNodes.some((r2) => r2.$nodeToRelocate$ === node)) {
            relocateNodes.push({
              $nodeToRelocate$: node
            });
          }
        }
      }
    }
    if (childNode.nodeType === 1) {
      markSlotContentForRelocation(childNode);
    }
  }
};
var isNodeLocatedInSlot = (nodeToRelocate, slotName) => {
  if (nodeToRelocate.nodeType === 1) {
    if (nodeToRelocate.getAttribute("slot") === null && slotName === "") {
      return true;
    }
    if (nodeToRelocate.getAttribute("slot") === slotName) {
      return true;
    }
    return false;
  }
  if (nodeToRelocate["s-sn"] === slotName) {
    return true;
  }
  return slotName === "";
};
var nullifyVNodeRefs = (vNode) => {
  {
    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);
  }
};
var insertBefore = (parent2, newNode, reference) => {
  const inserted = parent2 == null ? void 0 : parent2.insertBefore(newNode, reference);
  {
    updateElementScopeIds(newNode, parent2);
  }
  return inserted;
};
var findScopeIds = (element) => {
  const scopeIds = [];
  if (element) {
    scopeIds.push(
      ...element["s-scs"] || [],
      element["s-si"],
      element["s-sc"],
      ...findScopeIds(element.parentElement)
    );
  }
  return scopeIds;
};
var updateElementScopeIds = (element, parent2, iterateChildNodes = false) => {
  var _a;
  if (element && parent2 && element.nodeType === 1) {
    const scopeIds = new Set(findScopeIds(parent2).filter(Boolean));
    if (scopeIds.size) {
      (_a = element.classList) == null ? void 0 : _a.add(...element["s-scs"] = [...scopeIds]);
      if (element["s-ol"] || iterateChildNodes) {
        for (const childNode of Array.from(element.childNodes)) {
          updateElementScopeIds(childNode, element, true);
        }
      }
    }
  }
};
var renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {
  var _a, _b, _c, _d, _e;
  const hostElm = hostRef.$hostElement$;
  const cmpMeta = hostRef.$cmpMeta$;
  const oldVNode = hostRef.$vnode$ || newVNode(null, null);
  const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
  hostTagName = hostElm.tagName;
  if (cmpMeta.$attrsToReflect$) {
    rootVnode.$attrs$ = rootVnode.$attrs$ || {};
    cmpMeta.$attrsToReflect$.map(
      ([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]
    );
  }
  if (isInitialLoad && rootVnode.$attrs$) {
    for (const key of Object.keys(rootVnode.$attrs$)) {
      if (hostElm.hasAttribute(key) && !["key", "ref", "style", "class"].includes(key)) {
        rootVnode.$attrs$[key] = hostElm[key];
      }
    }
  }
  rootVnode.$tag$ = null;
  rootVnode.$flags$ |= 4;
  hostRef.$vnode$ = rootVnode;
  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
  {
    scopeId = hostElm["s-sc"];
  }
  useNativeShadowDom = (cmpMeta.$flags$ & 1) !== 0;
  {
    contentRef = hostElm["s-cr"];
    checkSlotFallbackVisibility = false;
  }
  patch(oldVNode, rootVnode, isInitialLoad);
  {
    plt.$flags$ |= 1;
    if (checkSlotRelocate) {
      markSlotContentForRelocation(rootVnode.$elm$);
      for (const relocateData of relocateNodes) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        if (!nodeToRelocate["s-ol"]) {
          const orgLocationNode = doc.createTextNode("");
          orgLocationNode["s-nr"] = nodeToRelocate;
          insertBefore(nodeToRelocate.parentNode, nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
        }
      }
      for (const relocateData of relocateNodes) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        const slotRefNode = relocateData.$slotRefNode$;
        if (slotRefNode) {
          const parentNodeRef = slotRefNode.parentNode;
          let insertBeforeNode = slotRefNode.nextSibling;
          {
            let orgLocationNode = (_a = nodeToRelocate["s-ol"]) == null ? void 0 : _a.previousSibling;
            while (orgLocationNode) {
              let refNode = (_b = orgLocationNode["s-nr"]) != null ? _b : null;
              if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === refNode.parentNode) {
                refNode = refNode.nextSibling;
                while (refNode === nodeToRelocate || (refNode == null ? void 0 : refNode["s-sr"])) {
                  refNode = refNode == null ? void 0 : refNode.nextSibling;
                }
                if (!refNode || !refNode["s-nr"]) {
                  insertBeforeNode = refNode;
                  break;
                }
              }
              orgLocationNode = orgLocationNode.previousSibling;
            }
          }
          if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {
            if (nodeToRelocate !== insertBeforeNode) {
              if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
              }
              insertBefore(parentNodeRef, nodeToRelocate, insertBeforeNode);
              if (nodeToRelocate.nodeType === 1) {
                nodeToRelocate.hidden = (_c = nodeToRelocate["s-ih"]) != null ? _c : false;
              }
            }
          }
          nodeToRelocate && typeof slotRefNode["s-rf"] === "function" && slotRefNode["s-rf"](nodeToRelocate);
        } else {
          if (nodeToRelocate.nodeType === 1) {
            if (isInitialLoad) {
              nodeToRelocate["s-ih"] = (_d = nodeToRelocate.hidden) != null ? _d : false;
            }
            nodeToRelocate.hidden = true;
          }
        }
      }
    }
    if (checkSlotFallbackVisibility) {
      updateFallbackSlotVisibility(rootVnode.$elm$);
    }
    plt.$flags$ &= ~1;
    relocateNodes.length = 0;
  }
  if (BUILD.experimentalScopedSlotChanges && cmpMeta.$flags$ & 2) {
    for (const childNode of rootVnode.$elm$.childNodes) {
      if (childNode["s-hn"] !== hostTagName && !childNode["s-sh"]) {
        if (isInitialLoad && childNode["s-ih"] == null) {
          childNode["s-ih"] = (_e = childNode.hidden) != null ? _e : false;
        }
        childNode.hidden = true;
      }
    }
  }
  contentRef = void 0;
};
var attachToAncestor = (hostRef, ancestorComponent) => {
  if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent["s-p"]) {
    ancestorComponent["s-p"].push(new Promise((r2) => hostRef.$onRenderResolve$ = r2));
  }
};
var scheduleUpdate = (hostRef, isInitialLoad) => {
  {
    hostRef.$flags$ |= 16;
  }
  if (hostRef.$flags$ & 4) {
    hostRef.$flags$ |= 512;
    return;
  }
  attachToAncestor(hostRef, hostRef.$ancestorComponent$);
  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
  return writeTask(dispatch);
};
var dispatchHooks = (hostRef, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
  const instance = elm;
  if (!instance) {
    throw new Error(
      "Can't render component <".concat(elm.tagName.toLowerCase(), " /> with invalid Stencil runtime! Make sure this imported component is compiled with a `externalRuntime: true` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime")
    );
  }
  let maybePromise;
  if (isInitialLoad) {
    {
      maybePromise = safeCall(instance, "componentWillLoad");
    }
  } else {
    {
      maybePromise = safeCall(instance, "componentWillUpdate");
    }
  }
  {
    maybePromise = enqueue(maybePromise, () => safeCall(instance, "componentWillRender"));
  }
  endSchedule();
  return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));
};
var enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn).catch((err2) => {
  console.error(err2);
  fn();
}) : fn();
var isPromisey = (maybePromise) => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === "function";
var updateComponent = async (hostRef, instance, isInitialLoad) => {
  var _a;
  const elm = hostRef.$hostElement$;
  const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
  const rc2 = elm["s-rc"];
  if (isInitialLoad) {
    attachStyles(hostRef);
  }
  const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
  {
    callRender(hostRef, instance, elm, isInitialLoad);
  }
  if (rc2) {
    rc2.map((cb2) => cb2());
    elm["s-rc"] = void 0;
  }
  endRender();
  endUpdate();
  {
    const childrenPromises = (_a = elm["s-p"]) != null ? _a : [];
    const postUpdate = () => postUpdateComponent(hostRef);
    if (childrenPromises.length === 0) {
      postUpdate();
    } else {
      Promise.all(childrenPromises).then(postUpdate);
      hostRef.$flags$ |= 4;
      childrenPromises.length = 0;
    }
  }
};
var renderingRef = null;
var callRender = (hostRef, instance, elm, isInitialLoad) => {
  const allRenderFn = false;
  const lazyLoad = false;
  const taskQueue = true;
  const updatable = true;
  try {
    renderingRef = instance;
    instance = allRenderFn ? instance.render() : instance.render && instance.render();
    if (updatable && taskQueue) {
      hostRef.$flags$ &= ~16;
    }
    if (updatable || lazyLoad) {
      hostRef.$flags$ |= 2;
    }
    if (BUILD.hasRenderFn || BUILD.reflect) {
      if (BUILD.vdomRender || BUILD.reflect) {
        if (BUILD.hydrateServerSide)
          ;
        else {
          renderVdom(hostRef, instance, isInitialLoad);
        }
      }
    }
  } catch (e2) {
    consoleError(e2, hostRef.$hostElement$);
  }
  renderingRef = null;
  return null;
};
var postUpdateComponent = (hostRef) => {
  const tagName = hostRef.$cmpMeta$.$tagName$;
  const elm = hostRef.$hostElement$;
  const endPostUpdate = createTime("postUpdate", tagName);
  const instance = elm;
  const ancestorComponent = hostRef.$ancestorComponent$;
  {
    safeCall(instance, "componentDidRender");
  }
  if (!(hostRef.$flags$ & 64)) {
    hostRef.$flags$ |= 64;
    {
      addHydratedFlag(elm);
    }
    {
      safeCall(instance, "componentDidLoad");
    }
    endPostUpdate();
    {
      hostRef.$onReadyResolve$(elm);
      if (!ancestorComponent) {
        appDidLoad();
      }
    }
  } else {
    {
      safeCall(instance, "componentDidUpdate");
    }
    endPostUpdate();
  }
  {
    if (hostRef.$onRenderResolve$) {
      hostRef.$onRenderResolve$();
      hostRef.$onRenderResolve$ = void 0;
    }
    if (hostRef.$flags$ & 512) {
      nextTick(() => scheduleUpdate(hostRef, false));
    }
    hostRef.$flags$ &= ~(4 | 512);
  }
};
var appDidLoad = (who) => {
  {
    addHydratedFlag(doc.documentElement);
  }
  nextTick(() => emitEvent(win, "appload", { detail: { namespace: NAMESPACE } }));
};
var safeCall = (instance, method, arg) => {
  if (instance && instance[method]) {
    try {
      return instance[method](arg);
    } catch (e2) {
      consoleError(e2);
    }
  }
  return void 0;
};
var addHydratedFlag = (elm) => {
  var _a;
  return elm.classList.add((_a = BUILD.hydratedSelectorName) != null ? _a : "hydrated");
};
var getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
var setValue = (ref, propName, newVal, cmpMeta) => {
  const hostRef = getHostRef(ref);
  const elm = ref;
  const oldVal = hostRef.$instanceValues$.get(propName);
  const flags2 = hostRef.$flags$;
  const instance = elm;
  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
  const didValueChange = newVal !== oldVal && !areBothNaN;
  if (didValueChange) {
    hostRef.$instanceValues$.set(propName, newVal);
    {
      if (cmpMeta.$watchers$ && flags2 & 128) {
        const watchMethods = cmpMeta.$watchers$[propName];
        if (watchMethods) {
          watchMethods.map((watchMethodName) => {
            try {
              instance[watchMethodName](newVal, oldVal, propName);
            } catch (e2) {
              consoleError(e2, elm);
            }
          });
        }
      }
      if ((flags2 & (2 | 16)) === 2) {
        if (instance.componentShouldUpdate) {
          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
            return;
          }
        }
        scheduleUpdate(hostRef, false);
      }
    }
  }
};
var proxyComponent = (Cstr, cmpMeta, flags2) => {
  var _a, _b;
  const prototype = Cstr.prototype;
  if (cmpMeta.$members$ || (cmpMeta.$watchers$ || Cstr.watchers)) {
    if (Cstr.watchers && !cmpMeta.$watchers$) {
      cmpMeta.$watchers$ = Cstr.watchers;
    }
    const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});
    members.map(([memberName, [memberFlags]]) => {
      if (memberFlags & 31 || memberFlags & 32) {
        Object.defineProperty(prototype, memberName, {
          get() {
            return getValue(this, memberName);
          },
          set(newValue) {
            setValue(this, memberName, newValue, cmpMeta);
          },
          configurable: true,
          enumerable: true
        });
      }
    });
    {
      const attrNameToPropName = /* @__PURE__ */ new Map();
      prototype.attributeChangedCallback = function(attrName, oldValue, newValue) {
        plt.jmp(() => {
          var _a2;
          const propName = attrNameToPropName.get(attrName);
          if (this.hasOwnProperty(propName)) {
            newValue = this[propName];
            delete this[propName];
          } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && // cast type to number to avoid TS compiler issues
          this[propName] == newValue) {
            return;
          } else if (propName == null) {
            const hostRef = getHostRef(this);
            const flags22 = hostRef == null ? void 0 : hostRef.$flags$;
            if (flags22 && !(flags22 & 8) && flags22 & 128 && newValue !== oldValue) {
              const elm = this;
              const instance = elm;
              const entry = (_a2 = cmpMeta.$watchers$) == null ? void 0 : _a2[attrName];
              entry == null ? void 0 : entry.forEach((callbackName) => {
                if (instance[callbackName] != null) {
                  instance[callbackName].call(instance, newValue, oldValue, attrName);
                }
              });
            }
            return;
          }
          this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
        });
      };
      Cstr.observedAttributes = Array.from(
        /* @__PURE__ */ new Set([
          ...Object.keys((_b = cmpMeta.$watchers$) != null ? _b : {}),
          ...members.filter(
            ([_, m2]) => m2[0] & 15
            /* HasAttribute */
          ).map(([propName, m2]) => {
            var _a2;
            const attrName = m2[1] || propName;
            attrNameToPropName.set(attrName, propName);
            if (m2[0] & 512) {
              (_a2 = cmpMeta.$attrsToReflect$) == null ? void 0 : _a2.push([propName, attrName]);
            }
            return attrName;
          })
        ])
      );
    }
  }
  return Cstr;
};
var initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {
  let Cstr;
  if ((hostRef.$flags$ & 32) === 0) {
    hostRef.$flags$ |= 32;
    cmpMeta.$lazyBundleId$;
    {
      Cstr = elm.constructor;
      const cmpTag = elm.localName;
      customElements.whenDefined(cmpTag).then(
        () => hostRef.$flags$ |= 128
        /* isWatchReady */
      );
    }
    if (Cstr && Cstr.style) {
      let style;
      if (typeof Cstr.style === "string") {
        style = Cstr.style;
      } else if (typeof Cstr.style !== "string") {
        hostRef.$modeName$ = computeMode(elm);
        if (hostRef.$modeName$) {
          style = Cstr.style[hostRef.$modeName$];
        }
      }
      const scopeId2 = getScopeId(cmpMeta, hostRef.$modeName$);
      if (!styles.has(scopeId2)) {
        const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
        registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1));
        endRegisterStyles();
      }
    }
  }
  const ancestorComponent = hostRef.$ancestorComponent$;
  const schedule = () => scheduleUpdate(hostRef, true);
  if (ancestorComponent && ancestorComponent["s-rc"]) {
    ancestorComponent["s-rc"].push(schedule);
  } else {
    schedule();
  }
};
var fireConnectedCallback = (instance) => {
};
var connectedCallback = (elm) => {
  if ((plt.$flags$ & 1) === 0) {
    const hostRef = getHostRef(elm);
    const cmpMeta = hostRef.$cmpMeta$;
    const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
    if (!(hostRef.$flags$ & 1)) {
      hostRef.$flags$ |= 1;
      {
        if (
          // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
          cmpMeta.$flags$ & (4 | 8)
        ) {
          setContentReference(elm);
        }
      }
      {
        let ancestorComponent = elm;
        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
          if (ancestorComponent["s-p"]) {
            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
            break;
          }
        }
      }
      if (cmpMeta.$members$) {
        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
          if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
            const value = elm[memberName];
            delete elm[memberName];
            elm[memberName] = value;
          }
        });
      }
      {
        initializeComponent(elm, hostRef, cmpMeta);
      }
    } else {
      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
      if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {
        fireConnectedCallback(hostRef.$lazyInstance$);
      } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {
        hostRef.$onReadyPromise$.then(() => fireConnectedCallback(hostRef.$lazyInstance$));
      }
    }
    endConnected();
  }
};
var setContentReference = (elm) => {
  const contentRefElm = elm["s-cr"] = doc.createComment(
    ""
  );
  contentRefElm["s-cn"] = true;
  insertBefore(elm, contentRefElm, elm.firstChild);
};
var disconnectedCallback = async (elm) => {
  if ((plt.$flags$ & 1) === 0) {
    const hostRef = getHostRef(elm);
    {
      if (hostRef.$rmListeners$) {
        hostRef.$rmListeners$.map((rmListener) => rmListener());
        hostRef.$rmListeners$ = void 0;
      }
    }
  }
};
var proxyCustomElement = (Cstr, compactMeta) => {
  const cmpMeta = {
    $flags$: compactMeta[0],
    $tagName$: compactMeta[1]
  };
  {
    cmpMeta.$members$ = compactMeta[2];
  }
  {
    cmpMeta.$listeners$ = compactMeta[3];
  }
  {
    cmpMeta.$watchers$ = Cstr.$watchers$;
  }
  {
    cmpMeta.$attrsToReflect$ = [];
  }
  const originalConnectedCallback = Cstr.prototype.connectedCallback;
  const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
  Object.assign(Cstr.prototype, {
    __registerHost() {
      registerHost(this, cmpMeta);
    },
    connectedCallback() {
      const hostRef = getHostRef(this);
      addHostEventListeners(this, hostRef, cmpMeta.$listeners$);
      connectedCallback(this);
      if (originalConnectedCallback) {
        originalConnectedCallback.call(this);
      }
    },
    disconnectedCallback() {
      disconnectedCallback(this);
      if (originalDisconnectedCallback) {
        originalDisconnectedCallback.call(this);
      }
    },
    __attachShadow() {
      {
        if (!this.shadowRoot) {
          {
            this.attachShadow({
              mode: "open",
              delegatesFocus: !!(cmpMeta.$flags$ & 16)
            });
          }
        } else {
          if (this.shadowRoot.mode !== "open") {
            throw new Error(
              "Unable to re-use existing shadow root for ".concat(cmpMeta.$tagName$, "! Mode is set to ").concat(this.shadowRoot.mode, " but Stencil only supports open shadow roots.")
            );
          }
        }
      }
    }
  });
  Cstr.is = cmpMeta.$tagName$;
  return proxyComponent(Cstr, cmpMeta);
};
var addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
  if (listeners) {
    listeners.map(([flags2, name, method]) => {
      const target = getHostListenerTarget(elm, flags2);
      const handler = hostListenerProxy(hostRef, method);
      const opts = hostListenerOpts(flags2);
      plt.ael(target, name, handler, opts);
      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
    });
  }
};
var hostListenerProxy = (hostRef, methodName) => (ev) => {
  var _a;
  try {
    if (BUILD.lazyLoad)
      ;
    else {
      hostRef.$hostElement$[methodName](ev);
    }
  } catch (e2) {
    consoleError(e2);
  }
};
var getHostListenerTarget = (elm, flags2) => {
  if (flags2 & 4)
    return doc;
  if (flags2 & 8)
    return win;
  if (flags2 & 16)
    return doc.body;
  return elm;
};
var hostListenerOpts = (flags2) => supportsListenerOptions ? {
  passive: (flags2 & 1) !== 0,
  capture: (flags2 & 2) !== 0
} : (flags2 & 2) !== 0;
let CACHED_MAP;
const getIconMap = () => {
  if (typeof window === "undefined") {
    return /* @__PURE__ */ new Map();
  } else {
    if (!CACHED_MAP) {
      const win2 = window;
      win2.Ionicons = win2.Ionicons || {};
      CACHED_MAP = win2.Ionicons.map = win2.Ionicons.map || /* @__PURE__ */ new Map();
    }
    return CACHED_MAP;
  }
};
const getUrl = (i) => {
  let url = getSrc(i.src);
  if (url) {
    return url;
  }
  url = getName(i.name, i.icon, i.mode, i.ios, i.md);
  if (url) {
    return getNamedUrl(url, i);
  }
  if (i.icon) {
    url = getSrc(i.icon);
    if (url) {
      return url;
    }
    url = getSrc(i.icon[i.mode]);
    if (url) {
      return url;
    }
  }
  return null;
};
const getNamedUrl = (iconName, iconEl) => {
  const url = getIconMap().get(iconName);
  if (url) {
    return url;
  }
  try {
    return getAssetPath("svg/".concat(iconName, ".svg"));
  } catch (e2) {
    console.warn('[Ionicons Warning]: Could not load icon with name "'.concat(iconName, '". Ensure that the icon is registered using addIcons or that the icon SVG data is passed directly to the icon component.'), iconEl);
  }
};
const getName = (iconName, icon, mode, ios, md2) => {
  mode = (mode && toLower(mode)) === "ios" ? "ios" : "md";
  if (ios && mode === "ios") {
    iconName = toLower(ios);
  } else if (md2 && mode === "md") {
    iconName = toLower(md2);
  } else {
    if (!iconName && icon && !isSrc(icon)) {
      iconName = icon;
    }
    if (isStr(iconName)) {
      iconName = toLower(iconName);
    }
  }
  if (!isStr(iconName) || iconName.trim() === "") {
    return null;
  }
  const invalidChars = iconName.replace(/[a-z]|-|\d/gi, "");
  if (invalidChars !== "") {
    return null;
  }
  return iconName;
};
const getSrc = (src) => {
  if (isStr(src)) {
    src = src.trim();
    if (isSrc(src)) {
      return src;
    }
  }
  return null;
};
const isSrc = (str) => str.length > 0 && /(\/|\.)/.test(str);
const isStr = (val) => typeof val === "string";
const toLower = (val) => val.toLowerCase();
const inheritAttributes = (el2, attributes = []) => {
  const attributeObject = {};
  attributes.forEach((attr) => {
    if (el2.hasAttribute(attr)) {
      const value = el2.getAttribute(attr);
      if (value !== null) {
        attributeObject[attr] = el2.getAttribute(attr);
      }
      el2.removeAttribute(attr);
    }
  });
  return attributeObject;
};
const isRTL = (hostEl) => {
  if (hostEl) {
    if (hostEl.dir !== "") {
      return hostEl.dir.toLowerCase() === "rtl";
    }
  }
  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === "rtl";
};
const validateContent = (svgContent) => {
  const div = document.createElement("div");
  div.innerHTML = svgContent;
  for (let i = div.childNodes.length - 1; i >= 0; i--) {
    if (div.childNodes[i].nodeName.toLowerCase() !== "svg") {
      div.removeChild(div.childNodes[i]);
    }
  }
  const svgElm = div.firstElementChild;
  if (svgElm && svgElm.nodeName.toLowerCase() === "svg") {
    const svgClass = svgElm.getAttribute("class") || "";
    svgElm.setAttribute("class", (svgClass + " s-ion-icon").trim());
    if (isValid(svgElm)) {
      return div.innerHTML;
    }
  }
  return "";
};
const isValid = (elm) => {
  if (elm.nodeType === 1) {
    if (elm.nodeName.toLowerCase() === "script") {
      return false;
    }
    for (let i = 0; i < elm.attributes.length; i++) {
      const name = elm.attributes[i].name;
      if (isStr(name) && name.toLowerCase().indexOf("on") === 0) {
        return false;
      }
    }
    for (let i = 0; i < elm.childNodes.length; i++) {
      if (!isValid(elm.childNodes[i])) {
        return false;
      }
    }
  }
  return true;
};
const isSvgDataUrl = (url) => url.startsWith("data:image/svg+xml");
const isEncodedDataUrl = (url) => url.indexOf(";utf8,") !== -1;
const ioniconContent = /* @__PURE__ */ new Map();
const requests = /* @__PURE__ */ new Map();
let parser;
const getSvgContent = (url, sanitize) => {
  let req = requests.get(url);
  if (!req) {
    if (typeof fetch !== "undefined" && typeof document !== "undefined") {
      if (isSvgDataUrl(url) && isEncodedDataUrl(url)) {
        if (!parser) {
          parser = new DOMParser();
        }
        const doc2 = parser.parseFromString(url, "text/html");
        const svg = doc2.querySelector("svg");
        if (svg) {
          ioniconContent.set(url, svg.outerHTML);
        }
        return Promise.resolve();
      } else {
        req = fetch(url).then((rsp) => {
          if (rsp.ok) {
            return rsp.text().then((svgContent) => {
              if (svgContent && sanitize !== false) {
                svgContent = validateContent(svgContent);
              }
              ioniconContent.set(url, svgContent || "");
            });
          }
          ioniconContent.set(url, "");
        });
        requests.set(url, req);
      }
    } else {
      ioniconContent.set(url, "");
      return Promise.resolve();
    }
  }
  return req;
};
const iconCss = ":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}@supports (background: -webkit-named-image(i)){:host(.icon-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}}@supports not selector(:dir(rtl)) and selector(:host-context([dir='rtl'])){:host(.icon-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}}:host(.flip-rtl):host-context([dir='rtl']) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}@supports selector(:dir(rtl)){:host(.flip-rtl:dir(rtl)) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.flip-rtl:dir(ltr)) .icon-inner{-webkit-transform:scaleX(1);transform:scaleX(1)}}:host(.icon-small){font-size:1.125rem !important}:host(.icon-large){font-size:2rem !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}";
const Icon2 = /* @__PURE__ */ proxyCustomElement(class Icon3 extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.iconName = null;
    this.inheritedAttributes = {};
    this.didLoadIcon = false;
    this.svgContent = void 0;
    this.isVisible = false;
    this.mode = getIonMode();
    this.color = void 0;
    this.ios = void 0;
    this.md = void 0;
    this.flipRtl = void 0;
    this.name = void 0;
    this.src = void 0;
    this.icon = void 0;
    this.size = void 0;
    this.lazy = false;
    this.sanitize = true;
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAttributes(this.el, ["aria-label"]);
  }
  connectedCallback() {
    this.waitUntilVisible(this.el, "50px", () => {
      this.isVisible = true;
      this.loadIcon();
    });
  }
  componentDidLoad() {
    if (!this.didLoadIcon) {
      this.loadIcon();
    }
  }
  disconnectedCallback() {
    if (this.io) {
      this.io.disconnect();
      this.io = void 0;
    }
  }
  waitUntilVisible(el2, rootMargin, cb2) {
    if (this.lazy && typeof window !== "undefined" && window.IntersectionObserver) {
      const io = this.io = new window.IntersectionObserver((data) => {
        if (data[0].isIntersecting) {
          io.disconnect();
          this.io = void 0;
          cb2();
        }
      }, { rootMargin });
      io.observe(el2);
    } else {
      cb2();
    }
  }
  loadIcon() {
    if (this.isVisible) {
      const url = getUrl(this);
      if (url) {
        if (ioniconContent.has(url)) {
          this.svgContent = ioniconContent.get(url);
        } else {
          getSvgContent(url, this.sanitize).then(() => this.svgContent = ioniconContent.get(url));
        }
        this.didLoadIcon = true;
      }
    }
    this.iconName = getName(this.name, this.icon, this.mode, this.ios, this.md);
  }
  render() {
    const { flipRtl, iconName, inheritedAttributes, el: el2 } = this;
    const mode = this.mode || "md";
    const shouldAutoFlip = iconName ? (iconName.includes("arrow") || iconName.includes("chevron")) && flipRtl !== false : false;
    const shouldBeFlippable = flipRtl || shouldAutoFlip;
    return h(Host, Object.assign({ role: "img", class: Object.assign(Object.assign({ [mode]: true }, createColorClasses(this.color)), { ["icon-".concat(this.size)]: !!this.size, "flip-rtl": shouldBeFlippable, "icon-rtl": shouldBeFlippable && isRTL(el2) }) }, inheritedAttributes), this.svgContent ? h("div", { class: "icon-inner", innerHTML: this.svgContent }) : h("div", { class: "icon-inner" }));
  }
  static get assetsDirs() {
    return ["svg"];
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "name": ["loadIcon"],
      "src": ["loadIcon"],
      "icon": ["loadIcon"],
      "ios": ["loadIcon"],
      "md": ["loadIcon"]
    };
  }
  static get style() {
    return iconCss;
  }
}, [1, "ion-icon", {
  "mode": [1025],
  "color": [1],
  "ios": [1],
  "md": [1],
  "flipRtl": [4, "flip-rtl"],
  "name": [513],
  "src": [1],
  "icon": [8],
  "size": [1],
  "lazy": [4],
  "sanitize": [4],
  "svgContent": [32],
  "isVisible": [32]
}]);
const getIonMode = () => typeof document !== "undefined" && document.documentElement.getAttribute("mode") || "md";
const createColorClasses = (color) => {
  return color ? {
    "ion-color": true,
    ["ion-color-".concat(color)]: true
  } : null;
};
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-icon":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Icon2);
        }
        break;
    }
  });
}
const defineCustomElement$2 = defineCustomElement$1;
const IonLifeCycleContext = /* @__PURE__ */ React.createContext({
  onIonViewWillEnter: () => {
    return;
  },
  ionViewWillEnter: () => {
    return;
  },
  onIonViewDidEnter: () => {
    return;
  },
  ionViewDidEnter: () => {
    return;
  },
  onIonViewWillLeave: () => {
    return;
  },
  ionViewWillLeave: () => {
    return;
  },
  onIonViewDidLeave: () => {
    return;
  },
  ionViewDidLeave: () => {
    return;
  },
  cleanupIonViewWillEnter: () => {
    return;
  },
  cleanupIonViewDidEnter: () => {
    return;
  },
  cleanupIonViewWillLeave: () => {
    return;
  },
  cleanupIonViewDidLeave: () => {
    return;
  }
});
const DefaultIonLifeCycleContext = class {
  constructor() {
    this.ionViewWillEnterCallbacks = [];
    this.ionViewDidEnterCallbacks = [];
    this.ionViewWillLeaveCallbacks = [];
    this.ionViewDidLeaveCallbacks = [];
    this.ionViewWillEnterDestructorCallbacks = [];
    this.ionViewDidEnterDestructorCallbacks = [];
    this.ionViewWillLeaveDestructorCallbacks = [];
    this.ionViewDidLeaveDestructorCallbacks = [];
  }
  onIonViewWillEnter(callback) {
    if (callback.id) {
      const index = this.ionViewWillEnterCallbacks.findIndex((x2) => x2.id === callback.id);
      if (index > -1) {
        this.ionViewWillEnterCallbacks[index] = callback;
      } else {
        this.ionViewWillEnterCallbacks.push(callback);
      }
    } else {
      this.ionViewWillEnterCallbacks.push(callback);
    }
  }
  teardownCallback(callback, callbacks) {
    const matches2 = callbacks.filter((x2) => x2.id === callback.id);
    if (matches2.length !== 0) {
      matches2.forEach((match) => {
        if (match && typeof match.destructor === "function") {
          match.destructor();
        }
      });
      callbacks = callbacks.filter((x2) => x2.id !== callback.id);
    }
  }
  /**
   * Tears down the user-provided ionViewWillEnter lifecycle callback.
   * This is the same behavior as React's useEffect hook. The callback
   * is invoked when the component is unmounted.
   */
  cleanupIonViewWillEnter(callback) {
    this.teardownCallback(callback, this.ionViewWillEnterDestructorCallbacks);
  }
  /**
   * Tears down the user-provided ionViewDidEnter lifecycle callback.
   * This is the same behavior as React's useEffect hook. The callback
   * is invoked when the component is unmounted.
   */
  cleanupIonViewDidEnter(callback) {
    this.teardownCallback(callback, this.ionViewDidEnterDestructorCallbacks);
  }
  /**
   * Tears down the user-provided ionViewWillLeave lifecycle callback.
   * This is the same behavior as React's useEffect hook. The callback
   * is invoked when the component is unmounted.
   */
  cleanupIonViewWillLeave(callback) {
    this.teardownCallback(callback, this.ionViewWillLeaveDestructorCallbacks);
  }
  /**
   * Tears down the user-provided ionViewDidLeave lifecycle callback.
   * This is the same behavior as React's useEffect hook. The callback
   * is invoked when the component is unmounted.
   */
  cleanupIonViewDidLeave(callback) {
    this.teardownCallback(callback, this.ionViewDidLeaveDestructorCallbacks);
  }
  ionViewWillEnter() {
    this.ionViewWillEnterCallbacks.forEach((cb2) => {
      const destructor = cb2();
      if (cb2.id) {
        this.ionViewWillEnterDestructorCallbacks.push({ id: cb2.id, destructor });
      }
    });
  }
  onIonViewDidEnter(callback) {
    if (callback.id) {
      const index = this.ionViewDidEnterCallbacks.findIndex((x2) => x2.id === callback.id);
      if (index > -1) {
        this.ionViewDidEnterCallbacks[index] = callback;
      } else {
        this.ionViewDidEnterCallbacks.push(callback);
      }
    } else {
      this.ionViewDidEnterCallbacks.push(callback);
    }
  }
  ionViewDidEnter() {
    this.ionViewDidEnterCallbacks.forEach((cb2) => {
      const destructor = cb2();
      if (cb2.id) {
        this.ionViewDidEnterDestructorCallbacks.push({ id: cb2.id, destructor });
      }
    });
  }
  onIonViewWillLeave(callback) {
    if (callback.id) {
      const index = this.ionViewWillLeaveCallbacks.findIndex((x2) => x2.id === callback.id);
      if (index > -1) {
        this.ionViewWillLeaveCallbacks[index] = callback;
      } else {
        this.ionViewWillLeaveCallbacks.push(callback);
      }
    } else {
      this.ionViewWillLeaveCallbacks.push(callback);
    }
  }
  ionViewWillLeave() {
    this.ionViewWillLeaveCallbacks.forEach((cb2) => {
      const destructor = cb2();
      if (cb2.id) {
        this.ionViewWillLeaveDestructorCallbacks.push({ id: cb2.id, destructor });
      }
    });
  }
  onIonViewDidLeave(callback) {
    if (callback.id) {
      const index = this.ionViewDidLeaveCallbacks.findIndex((x2) => x2.id === callback.id);
      if (index > -1) {
        this.ionViewDidLeaveCallbacks[index] = callback;
      } else {
        this.ionViewDidLeaveCallbacks.push(callback);
      }
    } else {
      this.ionViewDidLeaveCallbacks.push(callback);
    }
  }
  ionViewDidLeave() {
    this.ionViewDidLeaveCallbacks.forEach((cb2) => {
      const destructor = cb2();
      if (cb2.id) {
        this.ionViewDidLeaveDestructorCallbacks.push({ id: cb2.id, destructor });
      }
    });
    this.componentCanBeDestroyed();
  }
  onComponentCanBeDestroyed(callback) {
    this.componentCanBeDestroyedCallback = callback;
  }
  componentCanBeDestroyed() {
    if (this.componentCanBeDestroyedCallback) {
      this.componentCanBeDestroyedCallback();
    }
  }
};
const NavContext = /* @__PURE__ */ React.createContext({
  getIonRedirect: () => void 0,
  getIonRoute: () => void 0,
  getPageManager: () => void 0,
  getStackManager: () => void 0,
  goBack: (route) => {
    if (typeof window !== "undefined") {
      if (typeof route === "string") {
        window.location.pathname = route;
      } else {
        window.history.back();
      }
    }
  },
  navigate: (path) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path;
    }
  },
  hasIonicRouter: () => false,
  routeInfo: void 0,
  setCurrentTab: () => void 0,
  changeTab: (_tab, path) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path;
    }
  },
  resetTab: (_tab, path) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path;
    }
  }
});
const dashToPascalCase = (str) => str.toLowerCase().split("-").map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1)).join("");
const camelToDashCase = (str) => str.replace(/([A-Z])/g, (m2) => "-".concat(m2[0].toLowerCase()));
const attachProps = (node, newProps, oldProps = {}) => {
  if (node instanceof Element) {
    const className = getClassName(node.classList, newProps, oldProps);
    if (className !== "") {
      node.className = className;
    }
    Object.keys(newProps).forEach((name) => {
      if (name === "children" || name === "style" || name === "ref" || name === "class" || name === "className" || name === "forwardedRef") {
        return;
      }
      if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
        const eventName = name.substring(2);
        const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
        if (!isCoveredByReact(eventNameLc)) {
          syncEvent(node, eventNameLc, newProps[name]);
        }
      } else {
        node[name] = newProps[name];
        const propType = typeof newProps[name];
        if (propType === "string") {
          node.setAttribute(camelToDashCase(name), newProps[name]);
        }
      }
    });
  }
};
const getClassName = (classList, newProps, oldProps) => {
  const newClassProp = newProps.className || newProps.class;
  const oldClassProp = oldProps.className || oldProps.class;
  const currentClasses = arrayToMap(classList);
  const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(" ") : []);
  const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(" ") : []);
  const finalClassNames = [];
  currentClasses.forEach((currentClass) => {
    if (incomingPropClasses.has(currentClass)) {
      finalClassNames.push(currentClass);
      incomingPropClasses.delete(currentClass);
    } else if (!oldPropClasses.has(currentClass)) {
      finalClassNames.push(currentClass);
    }
  });
  incomingPropClasses.forEach((s) => finalClassNames.push(s));
  return finalClassNames.join(" ");
};
const transformReactEventName = (eventNameSuffix) => {
  switch (eventNameSuffix) {
    case "doubleclick":
      return "dblclick";
  }
  return eventNameSuffix;
};
/**
 * Checks if an event is supported in the current execution environment.
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
const isCoveredByReact = (eventNameSuffix) => {
  if (typeof document === "undefined") {
    return true;
  } else {
    const eventName = "on" + transformReactEventName(eventNameSuffix);
    let isSupported = eventName in document;
    if (!isSupported) {
      const element = document.createElement("div");
      element.setAttribute(eventName, "return;");
      isSupported = typeof element[eventName] === "function";
    }
    return isSupported;
  }
};
const syncEvent = (node, eventName, newEventHandler) => {
  const eventStore = node.__events || (node.__events = {});
  const oldEventHandler = eventStore[eventName];
  if (oldEventHandler) {
    node.removeEventListener(eventName, oldEventHandler);
  }
  node.addEventListener(eventName, eventStore[eventName] = function handler(e2) {
    if (newEventHandler) {
      newEventHandler.call(this, e2);
    }
  });
};
const arrayToMap = (arr) => {
  const map2 = /* @__PURE__ */ new Map();
  arr.forEach((s) => map2.set(s, s));
  return map2;
};
const setRef = (ref, value) => {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref != null) {
    ref.current = value;
  }
};
const mergeRefs = (...refs) => {
  return (value) => {
    refs.forEach((ref) => {
      setRef(ref, value);
    });
  };
};
const createForwardRef$1 = (ReactComponent, displayName) => {
  const forwardRef = (props, ref) => {
    return React.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));
  };
  forwardRef.displayName = displayName;
  return React.forwardRef(forwardRef);
};
const defineCustomElement = (tagName, customElement) => {
  if (customElement !== void 0 && typeof customElements !== "undefined" && !customElements.get(tagName)) {
    customElements.define(tagName, customElement);
  }
};
const createReactComponent = (tagName, ReactComponentContext, manipulatePropsFunction, defineCustomElement2) => {
  if (defineCustomElement2 !== void 0) {
    defineCustomElement2();
  }
  const displayName = dashToPascalCase(tagName);
  const ReactComponent = class extends React.Component {
    constructor(props) {
      super(props);
      this.setComponentElRef = (element) => {
        this.componentEl = element;
      };
    }
    componentDidMount() {
      this.componentDidUpdate(this.props);
    }
    componentDidUpdate(prevProps) {
      attachProps(this.componentEl, this.props, prevProps);
    }
    render() {
      const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = __rest(_a, ["children", "forwardedRef", "style", "className", "ref"]);
      let propsToPass = Object.keys(cProps).reduce((acc, name) => {
        const value = cProps[name];
        if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
          const eventName = name.substring(2).toLowerCase();
          if (typeof document !== "undefined" && isCoveredByReact(eventName)) {
            acc[name] = value;
          }
        } else {
          const type = typeof value;
          if (type === "string" || type === "boolean" || type === "number") {
            acc[camelToDashCase(name)] = value;
          }
        }
        return acc;
      }, {});
      const newProps = Object.assign(Object.assign({}, propsToPass), { ref: mergeRefs(forwardedRef, this.setComponentElRef), style });
      return reactExports.createElement(tagName, newProps, children);
    }
    static get displayName() {
      return displayName;
    }
  };
  return createForwardRef$1(ReactComponent, displayName);
};
const IonButtons = /* @__PURE__ */ createReactComponent("ion-buttons", void 0, void 0, defineCustomElement$x);
const IonCheckbox = /* @__PURE__ */ createReactComponent("ion-checkbox", void 0, void 0, defineCustomElement$v);
const IonCol = /* @__PURE__ */ createReactComponent("ion-col", void 0, void 0, defineCustomElement$t);
const IonContent = /* @__PURE__ */ createReactComponent("ion-content", void 0, void 0, defineCustomElement$r);
const IonHeader = /* @__PURE__ */ createReactComponent("ion-header", void 0, void 0, defineCustomElement$p);
const IonImg = /* @__PURE__ */ createReactComponent("ion-img", void 0, void 0, defineCustomElement$o);
const IonInput = /* @__PURE__ */ createReactComponent("ion-input", void 0, void 0, defineCustomElement$m);
const IonLabel = /* @__PURE__ */ createReactComponent("ion-label", void 0, void 0, defineCustomElement$k);
const IonList = /* @__PURE__ */ createReactComponent("ion-list", void 0, void 0, defineCustomElement$i);
const IonRow = /* @__PURE__ */ createReactComponent("ion-row", void 0, void 0, defineCustomElement$g);
const IonSearchbar = /* @__PURE__ */ createReactComponent("ion-searchbar", void 0, void 0, defineCustomElement$f);
const IonSpinner = /* @__PURE__ */ createReactComponent("ion-spinner", void 0, void 0, defineCustomElement$b);
const IonTextarea = /* @__PURE__ */ createReactComponent("ion-textarea", void 0, void 0, defineCustomElement$a);
const IonTitle = /* @__PURE__ */ createReactComponent("ion-title", void 0, void 0, defineCustomElement$9);
const IonToolbar = /* @__PURE__ */ createReactComponent("ion-toolbar", void 0, void 0, defineCustomElement$8);
const createForwardRef = (ReactComponent, displayName) => {
  const forwardRef = (props, ref) => {
    return React.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));
  };
  forwardRef.displayName = displayName;
  return React.forwardRef(forwardRef);
};
const getConfig = () => {
  if (typeof window !== "undefined") {
    const Ionic = window.Ionic;
    if (Ionic && Ionic.config) {
      return Ionic.config;
    }
  }
  return null;
};
const createRoutingComponent = (tagName, customElement) => {
  defineCustomElement(tagName, customElement);
  const displayName = dashToPascalCase(tagName);
  const ReactComponent = class extends React.Component {
    constructor(props) {
      super(props);
      this.handleClick = (e2) => {
        const { routerLink, routerDirection, routerOptions, routerAnimation } = this.props;
        if (routerLink !== void 0) {
          e2.preventDefault();
          this.context.navigate(routerLink, routerDirection, void 0, routerAnimation, routerOptions);
        }
      };
      this.ref = React.createRef();
      this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);
    }
    componentDidMount() {
      this.componentDidUpdate(this.props);
    }
    componentDidUpdate(prevProps) {
      const node = this.ref.current;
      attachProps(node, this.props, prevProps);
    }
    render() {
      const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = __rest(_a, ["children", "forwardedRef", "style", "className", "ref"]);
      const propsToPass = Object.keys(cProps).reduce((acc, name) => {
        if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
          const eventName = name.substring(2).toLowerCase();
          if (isCoveredByReact(eventName)) {
            acc[name] = cProps[name];
          }
        } else if (["string", "boolean", "number"].includes(typeof cProps[name])) {
          acc[camelToDashCase(name)] = cProps[name];
        }
        return acc;
      }, {});
      const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });
      if (this.props.routerLink && !this.props.href) {
        newProps.href = this.props.routerLink;
      }
      if (newProps.onClick) {
        const oldClick = newProps.onClick;
        newProps.onClick = (e2) => {
          oldClick(e2);
          if (!e2.defaultPrevented) {
            this.handleClick(e2);
          }
        };
      } else {
        newProps.onClick = this.handleClick;
      }
      return reactExports.createElement(tagName, newProps, children);
    }
    static get displayName() {
      return displayName;
    }
    static get contextType() {
      return NavContext;
    }
  };
  return createForwardRef(ReactComponent, displayName);
};
const IonButton = /* @__PURE__ */ createRoutingComponent("ion-button", IonButton$1);
const IonItem = /* @__PURE__ */ createRoutingComponent("ion-item", IonItem$1);
const detachProps = (node, props) => {
  if (node instanceof Element) {
    Object.keys(props).forEach((name) => {
      if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
        const eventName = name.substring(2);
        const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
        if (!isCoveredByReact(eventNameLc)) {
          detachEvent(node, eventNameLc);
        }
      }
    });
  }
};
const detachEvent = (node, eventName) => {
  const eventStore = node.__events || (node.__events = {});
  const eventHandler = eventStore[eventName];
  if (eventHandler) {
    node.removeEventListener(eventName, eventHandler);
    eventStore[eventName] = void 0;
  }
};
const createInlineOverlayComponent = (tagName, defineCustomElement2, hasDelegateHost) => {
  if (defineCustomElement2) {
    defineCustomElement2();
  }
  const displayName = dashToPascalCase(tagName);
  const ReactComponent = class extends React.Component {
    constructor(props) {
      super(props);
      this.handleIonMount = () => {
        this.setState({ isOpen: true });
      };
      this.handleWillPresent = (evt) => {
        this.setState({ isOpen: true });
        this.props.onWillPresent && this.props.onWillPresent(evt);
      };
      this.handleDidDismiss = (evt) => {
        const wrapper = this.wrapperRef.current;
        const el2 = this.ref.current;
        if (wrapper && el2) {
          el2.append(wrapper);
          this.setState({ isOpen: false });
        }
        this.props.onDidDismiss && this.props.onDidDismiss(evt);
      };
      this.ref = React.createRef();
      this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);
      this.state = { isOpen: false };
      this.wrapperRef = React.createRef();
    }
    componentDidMount() {
      var _a, _b, _c;
      this.componentDidUpdate(this.props);
      (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener("ionMount", this.handleIonMount);
      (_b = this.ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener("willPresent", this.handleWillPresent);
      (_c = this.ref.current) === null || _c === void 0 ? void 0 : _c.addEventListener("didDismiss", this.handleDidDismiss);
    }
    componentDidUpdate(prevProps) {
      const node = this.ref.current;
      const _a = this.props, cProps = __rest(_a, ["onDidDismiss", "onWillPresent"]);
      attachProps(node, cProps, prevProps);
    }
    componentWillUnmount() {
      const node = this.ref.current;
      if (node && this.state.isOpen) {
        node.removeEventListener("didDismiss", this.handleDidDismiss);
        node.remove();
        detachProps(node, this.props);
      }
    }
    render() {
      const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = __rest(_a, ["children", "forwardedRef", "style", "className", "ref"]);
      const propsToPass = Object.keys(cProps).reduce((acc, name) => {
        if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
          const eventName = name.substring(2).toLowerCase();
          if (isCoveredByReact(eventName)) {
            acc[name] = cProps[name];
          }
        } else if (["string", "boolean", "number"].includes(typeof cProps[name])) {
          acc[camelToDashCase(name)] = cProps[name];
        }
        return acc;
      }, {});
      const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });
      const getWrapperClasses = () => {
        if (hasDelegateHost) {
          return "".concat(DELEGATE_HOST, " ion-page");
        }
        return DELEGATE_HOST;
      };
      return reactExports.createElement("template", {}, reactExports.createElement(
        tagName,
        newProps,
        /**
         * We only want the inner component
         * to be mounted if the overlay is open,
         * so conditionally render the component
         * based on the isOpen state.
         */
        this.state.isOpen || this.props.keepContentsMounted ? reactExports.createElement("div", {
          ref: this.wrapperRef,
          className: getWrapperClasses()
        }, children) : null
      ));
    }
    static get displayName() {
      return displayName;
    }
  };
  return createForwardRef(ReactComponent, displayName);
};
const DELEGATE_HOST = "ion-delegate-host";
const IonModal = /* @__PURE__ */ createInlineOverlayComponent("ion-modal", defineCustomElement$7, true);
const IonContext = React.createContext({
  addOverlay: () => {
    return;
  },
  removeOverlay: () => {
    return;
  }
});
const IonOverlayManager = ({ onAddOverlay, onRemoveOverlay }) => {
  const [overlays, setOverlays] = reactExports.useState({});
  const overlaysRef = reactExports.useRef({});
  reactExports.useEffect(() => {
    onAddOverlay(addOverlay);
    onRemoveOverlay(removeOverlay);
  }, []);
  const addOverlay = (id2, component, containerElement) => {
    const newOverlays = Object.assign({}, overlaysRef.current);
    newOverlays[id2] = { component, containerElement };
    overlaysRef.current = newOverlays;
    setOverlays(newOverlays);
  };
  const removeOverlay = (id2) => {
    const newOverlays = Object.assign({}, overlaysRef.current);
    delete newOverlays[id2];
    overlaysRef.current = newOverlays;
    setOverlays(newOverlays);
  };
  const overlayKeys = Object.keys(overlays);
  return React.createElement(React.Fragment, null, overlayKeys.map((key) => {
    const overlay = overlays[key];
    return ReactDOM.createPortal(overlay.component, overlay.containerElement, "overlay-".concat(key));
  }));
};
const IonTabButtonInner = /* @__PURE__ */ createReactComponent("ion-tab-button", void 0, void 0, defineCustomElement$3);
const IonTabBarInner = /* @__PURE__ */ createReactComponent("ion-tab-bar", void 0, void 0, defineCustomElement$4);
const IonRouterOutletInner = /* @__PURE__ */ createReactComponent("ion-router-outlet", void 0, void 0, defineCustomElement$5);
const IonAppInner = /* @__PURE__ */ createReactComponent("ion-app", void 0, void 0, defineCustomElement$6);
const IonIconInner = /* @__PURE__ */ createReactComponent("ion-icon", void 0, void 0, defineCustomElement$2);
const IonApp = /* @__PURE__ */ (() => class extends React.Component {
  constructor(props) {
    super(props);
    this.ionContext = {
      addOverlay: (id2, overlay, containerElement) => {
        if (this.addOverlayCallback) {
          this.addOverlayCallback(id2, overlay, containerElement);
        }
      },
      removeOverlay: (id2) => {
        if (this.removeOverlayCallback) {
          this.removeOverlayCallback(id2);
        }
      }
    };
  }
  render() {
    return React.createElement(
      IonContext.Provider,
      { value: this.ionContext },
      React.createElement(IonAppInner, Object.assign({}, this.props), this.props.children),
      React.createElement(IonOverlayManager, { onAddOverlay: (callback) => {
        this.addOverlayCallback = callback;
      }, onRemoveOverlay: (callback) => {
        this.removeOverlayCallback = callback;
      } })
    );
  }
  static get displayName() {
    return "IonApp";
  }
})();
const StackContext = React.createContext({
  registerIonPage: () => void 0,
  isInOutlet: () => false
});
class PageManager extends React.PureComponent {
  constructor(props) {
    super(props);
    this.ionPageElementRef = React.createRef();
    this.stableMergedRefs = mergeRefs(this.ionPageElementRef, this.props.forwardedRef);
    this.ionViewWillEnterHandler = this.ionViewWillEnterHandler.bind(this);
    this.ionViewDidEnterHandler = this.ionViewDidEnterHandler.bind(this);
    this.ionViewWillLeaveHandler = this.ionViewWillLeaveHandler.bind(this);
    this.ionViewDidLeaveHandler = this.ionViewDidLeaveHandler.bind(this);
  }
  componentDidMount() {
    if (this.ionPageElementRef.current) {
      if (this.context.isInOutlet()) {
        this.ionPageElementRef.current.classList.add("ion-page-invisible");
      }
      this.context.registerIonPage(this.ionPageElementRef.current, this.props.routeInfo);
      this.ionPageElementRef.current.addEventListener("ionViewWillEnter", this.ionViewWillEnterHandler);
      this.ionPageElementRef.current.addEventListener("ionViewDidEnter", this.ionViewDidEnterHandler);
      this.ionPageElementRef.current.addEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler);
      this.ionPageElementRef.current.addEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler);
    }
  }
  componentWillUnmount() {
    if (this.ionPageElementRef.current) {
      this.ionPageElementRef.current.removeEventListener("ionViewWillEnter", this.ionViewWillEnterHandler);
      this.ionPageElementRef.current.removeEventListener("ionViewDidEnter", this.ionViewDidEnterHandler);
      this.ionPageElementRef.current.removeEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler);
    }
  }
  ionViewWillEnterHandler() {
    this.ionLifeCycleContext.ionViewWillEnter();
  }
  ionViewDidEnterHandler() {
    this.ionLifeCycleContext.ionViewDidEnter();
  }
  ionViewWillLeaveHandler() {
    this.ionLifeCycleContext.ionViewWillLeave();
  }
  ionViewDidLeaveHandler() {
    this.ionLifeCycleContext.ionViewDidLeave();
  }
  render() {
    const _a = this.props, { className, children, routeInfo, forwardedRef } = _a, props = __rest(_a, ["className", "children", "routeInfo", "forwardedRef"]);
    return React.createElement(IonLifeCycleContext.Consumer, null, (context2) => {
      this.ionLifeCycleContext = context2;
      return React.createElement("div", Object.assign({ className: className ? "".concat(className, " ion-page") : "ion-page", ref: this.stableMergedRefs }, props), children);
    });
  }
  static get contextType() {
    return StackContext;
  }
}
class IonPageInternal extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    const _a = this.props, { className, children, forwardedRef } = _a, props = __rest(_a, ["className", "children", "forwardedRef"]);
    return this.context.hasIonicRouter() ? React.createElement(PageManager, Object.assign({ className: className ? "".concat(className) : "", routeInfo: this.context.routeInfo, forwardedRef }, props), children) : React.createElement("div", Object.assign({ className: className ? "ion-page ".concat(className) : "ion-page", ref: forwardedRef }, props), children);
  }
  static get displayName() {
    return "IonPage";
  }
  static get contextType() {
    return NavContext;
  }
}
const IonPage = createForwardRef(IonPageInternal, "IonPage");
const ids = { main: 0 };
const generateId = (type = "main") => {
  var _a;
  const id2 = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;
  ids[type] = id2;
  return id2.toString();
};
const ReactDelegate = (addView, removeView) => {
  const refMap = /* @__PURE__ */ new WeakMap();
  const reactDelegateId = "react-delegate-".concat(generateId());
  let id2 = 0;
  const attachViewToDom = async (parentElement, component, propsOrDataObj, cssClasses) => {
    const div = document.createElement("div");
    cssClasses && div.classList.add(...cssClasses);
    parentElement.appendChild(div);
    const componentWithProps = component(propsOrDataObj);
    const key = "".concat(reactDelegateId, "-").concat(id2++);
    const hostComponent = reactDomExports.createPortal(componentWithProps, div, key);
    refMap.set(div, hostComponent);
    addView(hostComponent);
    return Promise.resolve(div);
  };
  const removeViewFromDom = (_container, component) => {
    const hostComponent = refMap.get(component);
    hostComponent && removeView(hostComponent);
    component.remove();
    return Promise.resolve();
  };
  return {
    attachViewToDom,
    removeViewFromDom
  };
};
const IonNavInner = createReactComponent("ion-nav", void 0, void 0, defineCustomElement$h);
const IonNavInternal = (_a) => {
  var { children, forwardedRef } = _a, restOfProps = __rest(_a, ["children", "forwardedRef"]);
  const [views, setViews] = reactExports.useState([]);
  const addView = (view) => setViews((existingViews) => [...existingViews, view]);
  const removeView = (view) => setViews((existingViews) => existingViews.filter((v2) => v2 !== view));
  const delegate = reactExports.useMemo(() => ReactDelegate(addView, removeView), []);
  return React.createElement(IonNavInner, Object.assign({ delegate, ref: forwardedRef }, restOfProps), views);
};
createForwardRef(IonNavInternal, "IonNav");
const IonTabsContext = React.createContext({
  activeTab: void 0,
  selectTab: () => false,
  hasRouterOutlet: false,
  tabBarProps: { ref: React.createRef() }
});
const HTMLElementSSR = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class OutletPageManager extends React.Component {
  constructor(props) {
    super(props);
    this.outletIsReady = false;
    this.ionViewWillEnterHandler = this.ionViewWillEnterHandler.bind(this);
    this.ionViewDidEnterHandler = this.ionViewDidEnterHandler.bind(this);
    this.ionViewWillLeaveHandler = this.ionViewWillLeaveHandler.bind(this);
    this.ionViewDidLeaveHandler = this.ionViewDidLeaveHandler.bind(this);
  }
  componentDidMount() {
    if (this.ionRouterOutlet) {
      if (!this.outletIsReady) {
        componentOnReady(this.ionRouterOutlet, () => {
          this.outletIsReady = true;
          this.context.registerIonPage(this.ionRouterOutlet, this.props.routeInfo);
        });
      }
      this.ionRouterOutlet.addEventListener("ionViewWillEnter", this.ionViewWillEnterHandler);
      this.ionRouterOutlet.addEventListener("ionViewDidEnter", this.ionViewDidEnterHandler);
      this.ionRouterOutlet.addEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler);
      this.ionRouterOutlet.addEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler);
    }
  }
  componentWillUnmount() {
    if (this.ionRouterOutlet) {
      this.ionRouterOutlet.removeEventListener("ionViewWillEnter", this.ionViewWillEnterHandler);
      this.ionRouterOutlet.removeEventListener("ionViewDidEnter", this.ionViewDidEnterHandler);
      this.ionRouterOutlet.removeEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler);
      this.ionRouterOutlet.removeEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler);
    }
  }
  ionViewWillEnterHandler() {
    this.ionLifeCycleContext.ionViewWillEnter();
  }
  ionViewDidEnterHandler() {
    this.ionLifeCycleContext.ionViewDidEnter();
  }
  ionViewWillLeaveHandler() {
    this.ionLifeCycleContext.ionViewWillLeave();
  }
  ionViewDidLeaveHandler() {
    this.ionLifeCycleContext.ionViewDidLeave();
  }
  render() {
    const _a = this.props, { StackManager: StackManager2, children, routeInfo } = _a, props = __rest(_a, ["StackManager", "children", "routeInfo"]);
    return React.createElement(IonLifeCycleContext.Consumer, null, (context2) => {
      this.ionLifeCycleContext = context2;
      return React.createElement(
        StackManager2,
        { routeInfo },
        React.createElement(IonRouterOutletInner, Object.assign({ setRef: (val) => this.ionRouterOutlet = val }, props), children)
      );
    });
  }
  static get contextType() {
    return StackContext;
  }
}
class IonRouterOutletContainer extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    const StackManager2 = this.context.getStackManager();
    const _a = this.props, { children, forwardedRef } = _a, props = __rest(_a, ["children", "forwardedRef"]);
    return this.context.hasIonicRouter() ? props.ionPage ? React.createElement(OutletPageManager, Object.assign({ StackManager: StackManager2, routeInfo: this.context.routeInfo }, props), children) : React.createElement(
      StackManager2,
      { routeInfo: this.context.routeInfo },
      React.createElement(IonRouterOutletInner, Object.assign({}, props, { forwardedRef }), children)
    ) : React.createElement(IonRouterOutletInner, Object.assign({ ref: forwardedRef }, this.props), this.props.children);
  }
  static get contextType() {
    return NavContext;
  }
}
const IonRouterOutlet = createForwardRef(IonRouterOutletContainer, "IonRouterOutlet");
class IonTabsElement extends HTMLElementSSR {
  constructor() {
    super();
  }
}
if (typeof window !== "undefined" && window.customElements) {
  const element = window.customElements.get("ion-tabs");
  if (!element) {
    window.customElements.define("ion-tabs", IonTabsElement);
  }
}
const IonTabButton = /* @__PURE__ */ (() => class extends React.Component {
  constructor(props) {
    super(props);
    this.handleIonTabButtonClick = this.handleIonTabButtonClick.bind(this);
  }
  handleIonTabButtonClick() {
    if (this.props.onClick) {
      this.props.onClick(new CustomEvent("ionTabButtonClick", {
        detail: {
          tab: this.props.tab,
          href: this.props.href,
          routeOptions: this.props.routerOptions
        }
      }));
    }
  }
  render() {
    const _a = this.props, rest = __rest(_a, ["onClick"]);
    return React.createElement(IonTabButtonInner, Object.assign({ onIonTabButtonClick: this.handleIonTabButtonClick }, rest));
  }
  static get displayName() {
    return "IonTabButton";
  }
})();
class IonTabBarUnwrapped extends React.PureComponent {
  constructor(props) {
    super(props);
    this.setActiveTabOnContext = (_tab) => {
    };
    const tabs = {};
    React.Children.forEach(props.children, (child) => {
      var _a, _b, _c, _d;
      if (child != null && typeof child === "object" && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        tabs[child.props.tab] = {
          originalHref: child.props.href,
          currentHref: child.props.href,
          originalRouteOptions: child.props.href === ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) ? (_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : void 0,
          currentRouteOptions: child.props.href === ((_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.pathname) ? (_d = props.routeInfo) === null || _d === void 0 ? void 0 : _d.routeOptions : void 0
        };
      }
    });
    this.state = {
      tabs
    };
    this.onTabButtonClick = this.onTabButtonClick.bind(this);
    this.renderTabButton = this.renderTabButton.bind(this);
    this.setActiveTabOnContext = this.setActiveTabOnContext.bind(this);
    this.selectTab = this.selectTab.bind(this);
  }
  componentDidMount() {
    const tabs = this.state.tabs;
    const tabKeys = Object.keys(tabs);
    const activeTab = tabKeys.find((key) => {
      const href = tabs[key].originalHref;
      return this.props.routeInfo.pathname.startsWith(href);
    });
    if (activeTab) {
      this.setState({
        activeTab
      });
    }
  }
  componentDidUpdate() {
    if (this.state.activeTab) {
      this.setActiveTabOnContext(this.state.activeTab);
    }
  }
  selectTab(tab) {
    const tabUrl = this.state.tabs[tab];
    if (tabUrl) {
      this.onTabButtonClick(new CustomEvent("ionTabButtonClick", {
        detail: {
          href: tabUrl.currentHref,
          tab,
          selected: tab === this.state.activeTab,
          routeOptions: void 0
        }
      }));
      return true;
    }
    return false;
  }
  static getDerivedStateFromProps(props, state) {
    var _a, _b, _c;
    const tabs = Object.assign({}, state.tabs);
    const tabKeys = Object.keys(state.tabs);
    const activeTab = tabKeys.find((key) => {
      const href = state.tabs[key].originalHref;
      return props.routeInfo.pathname.startsWith(href);
    });
    React.Children.forEach(props.children, (child) => {
      if (child != null && typeof child === "object" && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        const tab = tabs[child.props.tab];
        if (!tab || tab.originalHref !== child.props.href) {
          tabs[child.props.tab] = {
            originalHref: child.props.href,
            currentHref: child.props.href,
            originalRouteOptions: child.props.routeOptions,
            currentRouteOptions: child.props.routeOptions
          };
        }
      }
    });
    const { activeTab: prevActiveTab } = state;
    if (activeTab && prevActiveTab) {
      const prevHref = state.tabs[prevActiveTab].currentHref;
      const prevRouteOptions = state.tabs[prevActiveTab].currentRouteOptions;
      if (activeTab !== prevActiveTab || prevHref !== ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) || prevRouteOptions !== ((_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions)) {
        tabs[activeTab] = {
          originalHref: tabs[activeTab].originalHref,
          currentHref: props.routeInfo.pathname + (props.routeInfo.search || ""),
          originalRouteOptions: tabs[activeTab].originalRouteOptions,
          currentRouteOptions: (_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.routeOptions
        };
        if (props.routeInfo.routeAction === "pop" && activeTab !== prevActiveTab) {
          tabs[prevActiveTab] = {
            originalHref: tabs[prevActiveTab].originalHref,
            currentHref: tabs[prevActiveTab].originalHref,
            originalRouteOptions: tabs[prevActiveTab].originalRouteOptions,
            currentRouteOptions: tabs[prevActiveTab].currentRouteOptions
          };
        }
      }
    }
    activeTab && props.onSetCurrentTab(activeTab, props.routeInfo);
    return {
      activeTab,
      tabs
    };
  }
  onTabButtonClick(e2, onClickFn) {
    var _a;
    const tappedTab = this.state.tabs[e2.detail.tab];
    const originalHref = tappedTab.originalHref;
    const hasRouterOutlet = (_a = this.props.tabsContext) === null || _a === void 0 ? void 0 : _a.hasRouterOutlet;
    const currentHref = hasRouterOutlet ? e2.detail.href : "";
    const { activeTab: prevActiveTab } = this.state;
    if (onClickFn) {
      onClickFn(e2);
    }
    if (prevActiveTab === e2.detail.tab) {
      if (originalHref !== currentHref) {
        this.context.resetTab(e2.detail.tab, originalHref, tappedTab.originalRouteOptions);
      }
    } else {
      if (this.props.onIonTabsWillChange) {
        this.props.onIonTabsWillChange(new CustomEvent("ionTabWillChange", { detail: { tab: e2.detail.tab } }));
      }
      if (this.props.onIonTabsDidChange) {
        this.props.onIonTabsDidChange(new CustomEvent("ionTabDidChange", { detail: { tab: e2.detail.tab } }));
      }
      if (hasRouterOutlet) {
        this.setActiveTabOnContext(e2.detail.tab);
        this.context.changeTab(e2.detail.tab, currentHref, e2.detail.routeOptions);
      }
    }
  }
  renderTabButton(activeTab) {
    return (child) => {
      var _a, _b;
      if (child != null && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        const href = child.props.tab === activeTab ? (_a = this.props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname : this.state.tabs[child.props.tab].currentHref;
        const routeOptions = child.props.tab === activeTab ? (_b = this.props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : this.state.tabs[child.props.tab].currentRouteOptions;
        return React.cloneElement(child, {
          href,
          routeOptions,
          onClick: (ev) => this.onTabButtonClick(ev, child.props.onClick)
        });
      }
      return null;
    };
  }
  render() {
    const { activeTab } = this.state;
    return React.createElement(IonTabBarInner, Object.assign({}, this.props, { selectedTab: activeTab }), React.Children.map(this.props.children, this.renderTabButton(activeTab)));
  }
  static get contextType() {
    return NavContext;
  }
}
const IonTabBarContainer = React.memo((_a) => {
  var { forwardedRef } = _a, props = __rest(_a, ["forwardedRef"]);
  const context2 = reactExports.useContext(NavContext);
  const tabsContext = reactExports.useContext(IonTabsContext);
  const tabBarRef = forwardedRef || tabsContext.tabBarProps.ref;
  const updatedTabBarProps = Object.assign(Object.assign({}, tabsContext.tabBarProps), { ref: tabBarRef });
  return React.createElement(IonTabBarUnwrapped, Object.assign({ ref: tabBarRef }, props, {
    routeInfo: props.routeInfo || context2.routeInfo || { pathname: window.location.pathname },
    onSetCurrentTab: context2.setCurrentTab,
    /**
     * Tab bar can be used as a standalone component,
     * so it cannot be modified directly through
     * IonTabs. Instead, props will be passed through
     * the context.
     */
    tabsContext: Object.assign(Object.assign({}, tabsContext), { tabBarProps: updatedTabBarProps })
  }), props.children);
});
createForwardRef(IonTabBarContainer, "IonTabBar");
class IonIconContainer extends React.PureComponent {
  constructor(props) {
    super(props);
    if (this.props.name) {
      console.warn('In Ionic React, you import icons from "ionicons/icons" and set the icon you imported to the "icon" property. Setting the "name" property has no effect.');
    }
  }
  render() {
    var _a, _b;
    const _c = this.props, { icon, ios, md: md2, mode } = _c, rest = __rest(_c, ["icon", "ios", "md", "mode"]);
    let iconToUse;
    const config2 = getConfig();
    const iconMode = mode || (config2 === null || config2 === void 0 ? void 0 : config2.get("mode"));
    if (ios || md2) {
      if (iconMode === "ios") {
        iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md2) !== null && _a !== void 0 ? _a : icon;
      } else {
        iconToUse = (_b = md2 !== null && md2 !== void 0 ? md2 : ios) !== null && _b !== void 0 ? _b : icon;
      }
    } else {
      iconToUse = icon;
    }
    return React.createElement(IonIconInner, Object.assign({ ref: this.props.forwardedRef, icon: iconToUse }, rest), this.props.children);
  }
  static get contextType() {
    return NavContext;
  }
}
const IonIcon = createForwardRef(IonIconContainer, "IonIcon");
class IonRoute extends React.PureComponent {
  render() {
    const IonRouteInner2 = this.context.getIonRoute();
    if (!this.context.hasIonicRouter() || !IonRoute) {
      console.error("You either do not have an Ionic Router package, or your router does not support using <IonRoute>");
      return null;
    }
    return React.createElement(IonRouteInner2, Object.assign({}, this.props));
  }
  static get contextType() {
    return NavContext;
  }
}
class IonRedirect extends React.PureComponent {
  render() {
    const IonRedirectInner = this.context.getIonRedirect();
    if (!this.context.hasIonicRouter() || !IonRedirect) {
      console.error("You either do not have an Ionic Router package, or your router does not support using <IonRedirect>");
      return null;
    }
    return React.createElement(IonRedirectInner, Object.assign({}, this.props));
  }
  static get contextType() {
    return NavContext;
  }
}
const IonRouterContext = React.createContext({
  routeInfo: void 0,
  // TODO(FW-2959): type
  push: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  back: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  canGoBack: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  nativeBack: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  }
});
class CreateAnimation extends React.PureComponent {
  constructor(props) {
    super(props);
    this.nodes = /* @__PURE__ */ new Map();
    this.animation = createAnimation(props.id);
  }
  setupAnimation(props) {
    const animation2 = this.animation;
    if (this.nodes.size > 0) {
      animation2.addElement(Array.from(this.nodes.values()));
    }
    checkConfig(animation2, props);
    checkPlayback(animation2, props);
  }
  componentDidMount() {
    const props = this.props;
    this.setupAnimation(props);
  }
  componentDidUpdate(prevProps) {
    const animation2 = this.animation;
    const props = this.props;
    checkConfig(animation2, props, prevProps);
    checkProgress(animation2, props, prevProps);
    checkPlayback(animation2, props, prevProps);
  }
  render() {
    const { children } = this.props;
    return React.createElement(React.Fragment, null, React.Children.map(children, (child, id2) => React.cloneElement(child, { ref: (el2) => this.nodes.set(id2, el2) })));
  }
}
const checkConfig = (animation2, currentProps = {}, prevProps = {}) => {
  const reservedProps = [
    "children",
    "progressStart",
    "progressStep",
    "progressEnd",
    "pause",
    "stop",
    "destroy",
    "play",
    "from",
    "to",
    "fromTo",
    "onFinish"
  ];
  for (const key in currentProps) {
    if (
      // eslint-disable-next-line no-prototype-builtins
      currentProps.hasOwnProperty(key) && !reservedProps.includes(key) && currentProps[key] !== prevProps[key]
    ) {
      animation2[key](currentProps[key]);
    }
  }
  const fromValues = currentProps.from;
  if (fromValues && fromValues !== prevProps.from) {
    const values = Array.isArray(fromValues) ? fromValues : [fromValues];
    values.forEach((val) => animation2.from(val.property, val.value));
  }
  const toValues = currentProps.to;
  if (toValues && toValues !== prevProps.to) {
    const values = Array.isArray(toValues) ? toValues : [toValues];
    values.forEach((val) => animation2.to(val.property, val.value));
  }
  const fromToValues = currentProps.fromTo;
  if (fromToValues && fromToValues !== prevProps.fromTo) {
    const values = Array.isArray(fromToValues) ? fromToValues : [fromToValues];
    values.forEach((val) => animation2.fromTo(val.property, val.fromValue, val.toValue));
  }
  const onFinishValues = currentProps.onFinish;
  if (onFinishValues && onFinishValues !== prevProps.onFinish) {
    const values = Array.isArray(onFinishValues) ? onFinishValues : [onFinishValues];
    values.forEach((val) => animation2.onFinish(val.callback, val.opts));
  }
};
const checkProgress = (animation2, currentProps = {}, prevProps = {}) => {
  var _a, _b, _c, _d, _e;
  const { progressStart, progressStep, progressEnd } = currentProps;
  if (progressStart && (((_a = prevProps.progressStart) === null || _a === void 0 ? void 0 : _a.forceLinearEasing) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.forceLinearEasing) || ((_b = prevProps.progressStart) === null || _b === void 0 ? void 0 : _b.step) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.step))) {
    animation2.progressStart(progressStart.forceLinearEasing, progressStart.step);
  }
  if (progressStep && ((_c = prevProps.progressStep) === null || _c === void 0 ? void 0 : _c.step) !== (progressStep === null || progressStep === void 0 ? void 0 : progressStep.step)) {
    animation2.progressStep(progressStep.step);
  }
  if (progressEnd && (((_d = prevProps.progressEnd) === null || _d === void 0 ? void 0 : _d.playTo) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.playTo) || ((_e = prevProps.progressEnd) === null || _e === void 0 ? void 0 : _e.step) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.step) || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.dur) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.dur))) {
    animation2.progressEnd(progressEnd.playTo, progressEnd.step, progressEnd.dur);
  }
};
const checkPlayback = (animation2, currentProps = {}, prevProps = {}) => {
  if (!prevProps.play && currentProps.play) {
    animation2.play();
  }
  if (!prevProps.pause && currentProps.pause) {
    animation2.pause();
  }
  if (!prevProps.stop && currentProps.stop) {
    animation2.stop();
  }
  if (!prevProps.destroy && currentProps.destroy) {
    animation2.destroy();
  }
};
const setupIonicReact = (config2 = {}) => {
  if (typeof document !== "undefined") {
    document.documentElement.classList.add("ion-ce");
  }
  initialize(Object.assign({}, config2));
};
const RouteManagerContext = /* @__PURE__ */ React.createContext({
  addViewItem: () => void 0,
  canGoBack: () => void 0,
  clearOutlet: () => void 0,
  createViewItem: () => void 0,
  findViewItemByPathname: () => void 0,
  findLeavingViewItemByRouteInfo: () => void 0,
  findViewItemByRouteInfo: () => void 0,
  getChildrenToRender: () => void 0,
  goBack: () => void 0,
  unMountViewItem: () => void 0
});
class ViewLifeCycleManager extends React.Component {
  constructor(props) {
    super(props);
    this.ionLifeCycleContext = new DefaultIonLifeCycleContext();
    this._isMounted = false;
    this.ionLifeCycleContext.onComponentCanBeDestroyed(() => {
      if (!this.props.mount) {
        if (this._isMounted) {
          this.setState({
            show: false
          }, () => this.props.removeView());
        }
      }
    });
    this.state = {
      show: true
    };
  }
  componentDidMount() {
    this._isMounted = true;
  }
  componentWillUnmount() {
    this._isMounted = false;
  }
  render() {
    const { show } = this.state;
    return React.createElement(IonLifeCycleContext.Provider, { value: this.ionLifeCycleContext }, show && this.props.children);
  }
}
class LocationHistory {
  constructor() {
    this.locationHistory = [];
    this.tabHistory = {};
  }
  add(routeInfo) {
    if (routeInfo.routeAction === "push" || routeInfo.routeAction == null) {
      this._add(routeInfo);
    } else if (routeInfo.routeAction === "pop") {
      this._pop(routeInfo);
    } else if (routeInfo.routeAction === "replace") {
      this._replace(routeInfo);
    }
    if (routeInfo.routeDirection === "root") {
      this._clear();
      this._add(routeInfo);
    }
  }
  clearTabStack(tab) {
    const routeInfos = this._getRouteInfosByKey(tab);
    if (routeInfos) {
      routeInfos.forEach((ri2) => {
        this.locationHistory = this.locationHistory.filter((x2) => x2.id !== ri2.id);
      });
      this.tabHistory[tab] = [];
    }
  }
  update(routeInfo) {
    const locationIndex = this.locationHistory.findIndex((x2) => x2.id === routeInfo.id);
    if (locationIndex > -1) {
      this.locationHistory.splice(locationIndex, 1, routeInfo);
    }
    const tabArray = this.tabHistory[routeInfo.tab || ""];
    if (tabArray) {
      const tabIndex = tabArray.findIndex((x2) => x2.id === routeInfo.id);
      if (tabIndex > -1) {
        tabArray.splice(tabIndex, 1, routeInfo);
      } else {
        tabArray.push(routeInfo);
      }
    } else if (routeInfo.tab) {
      this.tabHistory[routeInfo.tab] = [routeInfo];
    }
  }
  _add(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    if (routeInfos) {
      if (this._areRoutesEqual(routeInfos[routeInfos.length - 1], routeInfo)) {
        routeInfos.pop();
      }
      routeInfos.push(routeInfo);
    }
    this.locationHistory.push(routeInfo);
  }
  _areRoutesEqual(route1, route2) {
    if (!route1 || !route2) {
      return false;
    }
    return route1.pathname === route2.pathname && route1.search === route2.search;
  }
  _pop(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    if (routeInfos) {
      routeInfos.pop();
      routeInfos.pop();
      routeInfos.push(routeInfo);
    }
    this.locationHistory.pop();
    this.locationHistory.pop();
    this.locationHistory.push(routeInfo);
  }
  _replace(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    routeInfos && routeInfos.pop();
    this.locationHistory.pop();
    this._add(routeInfo);
  }
  _clear() {
    const keys = Object.keys(this.tabHistory);
    keys.forEach((k2) => this.tabHistory[k2] = []);
    this.locationHistory = [];
  }
  _getRouteInfosByKey(key) {
    let routeInfos;
    if (key) {
      routeInfos = this.tabHistory[key];
      if (!routeInfos) {
        routeInfos = this.tabHistory[key] = [];
      }
    }
    return routeInfos;
  }
  getFirstRouteInfoForTab(tab) {
    const routeInfos = this._getRouteInfosByKey(tab);
    if (routeInfos) {
      return routeInfos[0];
    }
    return void 0;
  }
  getCurrentRouteInfoForTab(tab) {
    const routeInfos = this._getRouteInfosByKey(tab);
    if (routeInfos) {
      return routeInfos[routeInfos.length - 1];
    }
    return void 0;
  }
  findLastLocation(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    if (routeInfos) {
      for (let i = routeInfos.length - 2; i >= 0; i--) {
        const ri2 = routeInfos[i];
        if (ri2) {
          if (ri2.pathname === routeInfo.pushedByRoute) {
            return ri2;
          }
        }
      }
    }
    for (let i = this.locationHistory.length - 2; i >= 0; i--) {
      const ri2 = this.locationHistory[i];
      if (ri2) {
        if (ri2.pathname === routeInfo.pushedByRoute) {
          return ri2;
        }
      }
    }
    return void 0;
  }
  previous() {
    return this.locationHistory[this.locationHistory.length - 2] || this.locationHistory[this.locationHistory.length - 1];
  }
  current() {
    return this.locationHistory[this.locationHistory.length - 1];
  }
  canGoBack() {
    return this.locationHistory.length > 1;
  }
}
class NavManager extends React.PureComponent {
  constructor(props) {
    super(props);
    this.ionRouterContextValue = {
      push: (pathname, routerDirection, routeAction, routerOptions, animationBuilder) => {
        this.navigate(pathname, routerDirection, routeAction, animationBuilder, routerOptions);
      },
      back: (animationBuilder) => {
        this.goBack(void 0, animationBuilder);
      },
      canGoBack: () => this.props.locationHistory.canGoBack(),
      nativeBack: () => this.props.onNativeBack(),
      routeInfo: this.props.routeInfo
    };
    this.state = {
      goBack: this.goBack.bind(this),
      hasIonicRouter: () => true,
      navigate: this.navigate.bind(this),
      getIonRedirect: this.getIonRedirect.bind(this),
      getIonRoute: this.getIonRoute.bind(this),
      getStackManager: this.getStackManager.bind(this),
      getPageManager: this.getPageManager.bind(this),
      routeInfo: this.props.routeInfo,
      setCurrentTab: this.props.onSetCurrentTab,
      changeTab: this.props.onChangeTab,
      resetTab: this.props.onResetTab
    };
  }
  componentDidMount() {
    if (typeof document !== "undefined") {
      this.handleHardwareBackButton = this.handleHardwareBackButton.bind(this);
      document.addEventListener("ionBackButton", this.handleHardwareBackButton);
    }
  }
  componentWillUnmount() {
    if (typeof document !== "undefined") {
      document.removeEventListener("ionBackButton", this.handleHardwareBackButton);
    }
  }
  handleHardwareBackButton(e2) {
    e2.detail.register(0, (processNextHandler) => {
      this.nativeGoBack();
      processNextHandler();
    });
  }
  goBack(route, animationBuilder) {
    this.props.onNavigateBack(route, animationBuilder);
  }
  nativeGoBack() {
    this.props.onNativeBack();
  }
  navigate(path, direction = "forward", action = "push", animationBuilder, options, tab) {
    this.props.onNavigate(path, action, direction, animationBuilder, options, tab);
  }
  getPageManager() {
    return PageManager;
  }
  getIonRedirect() {
    return this.props.ionRedirect;
  }
  getIonRoute() {
    return this.props.ionRoute;
  }
  getStackManager() {
    return this.props.stackManager;
  }
  render() {
    return React.createElement(
      NavContext.Provider,
      { value: Object.assign(Object.assign({}, this.state), { routeInfo: this.props.routeInfo }) },
      React.createElement(IonRouterContext.Provider, { value: Object.assign(Object.assign({}, this.ionRouterContextValue), { routeInfo: this.props.routeInfo }) }, this.props.children)
    );
  }
}
class ViewStacks {
  constructor() {
    this.viewStacks = {};
    this.add = this.add.bind(this);
    this.clear = this.clear.bind(this);
    this.getViewItemsForOutlet = this.getViewItemsForOutlet.bind(this);
    this.remove = this.remove.bind(this);
  }
  add(viewItem) {
    const { outletId } = viewItem;
    if (!this.viewStacks[outletId]) {
      this.viewStacks[outletId] = [viewItem];
    } else {
      this.viewStacks[outletId].push(viewItem);
    }
  }
  clear(outletId) {
    return setTimeout(() => {
      delete this.viewStacks[outletId];
    }, 500);
  }
  getViewItemsForOutlet(outletId) {
    return this.viewStacks[outletId] || [];
  }
  remove(viewItem) {
    const { outletId } = viewItem;
    const viewStack = this.viewStacks[outletId];
    if (viewStack) {
      const viewItemToRemove = viewStack.find((x2) => x2.id === viewItem.id);
      if (viewItemToRemove) {
        viewItemToRemove.mount = false;
        this.viewStacks[outletId] = viewStack.filter((x2) => x2.id !== viewItemToRemove.id);
      }
    }
  }
  getStackIds() {
    return Object.keys(this.viewStacks);
  }
  getAllViewItems() {
    const keys = this.getStackIds();
    const viewItems = [];
    keys.forEach((k2) => {
      viewItems.push(...this.viewStacks[k2]);
    });
    return viewItems;
  }
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
var readOnly = function(obj) {
  return obj;
};
var BeforeUnloadEventType = "beforeunload";
var HashChangeEventType = "hashchange";
var PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$window = _options.window, window2 = _options$window === void 0 ? document.defaultView : _options$window;
  var globalHistory = window2.history;
  function getIndexAndLocation() {
    var _window$location = window2.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;
    var state = globalHistory.state || {};
    return [state.idx, readOnly({
      pathname,
      search,
      hash,
      state: state.usr || null,
      key: state.key || "default"
    })];
  }
  var blockedPopTx = null;
  function handlePop() {
    if (blockedPopTx) {
      blockers.call(blockedPopTx);
      blockedPopTx = null;
    } else {
      var nextAction = Action.Pop;
      var _getIndexAndLocation = getIndexAndLocation(), nextIndex = _getIndexAndLocation[0], nextLocation = _getIndexAndLocation[1];
      if (blockers.length) {
        if (nextIndex != null) {
          var delta = index - nextIndex;
          if (delta) {
            blockedPopTx = {
              action: nextAction,
              location: nextLocation,
              retry: function retry() {
                go(delta * -1);
              }
            };
            go(delta);
          }
        }
      } else {
        applyTx(nextAction);
      }
    }
  }
  window2.addEventListener(PopStateEventType, handlePop);
  var action = Action.Pop;
  var _getIndexAndLocation2 = getIndexAndLocation(), index = _getIndexAndLocation2[0], location2 = _getIndexAndLocation2[1];
  var listeners = createEvents();
  var blockers = createEvents();
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function createHref(to) {
    return typeof to === "string" ? to : createPath(to);
  }
  function getNextLocation(to, state) {
    if (state === void 0) {
      state = null;
    }
    return readOnly(_extends({
      pathname: location2.pathname,
      hash: "",
      search: ""
    }, typeof to === "string" ? parsePath(to) : to, {
      state,
      key: createKey()
    }));
  }
  function getHistoryStateAndUrl(nextLocation, index2) {
    return [{
      usr: nextLocation.state,
      key: nextLocation.key,
      idx: index2
    }, createHref(nextLocation)];
  }
  function allowTx(action2, location22, retry) {
    return !blockers.length || (blockers.call({
      action: action2,
      location: location22,
      retry
    }), false);
  }
  function applyTx(nextAction) {
    action = nextAction;
    var _getIndexAndLocation3 = getIndexAndLocation();
    index = _getIndexAndLocation3[0];
    location2 = _getIndexAndLocation3[1];
    listeners.call({
      action,
      location: location2
    });
  }
  function push(to, state) {
    var nextAction = Action.Push;
    var nextLocation = getNextLocation(to, state);
    function retry() {
      push(to, state);
    }
    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr[0], url = _getHistoryStateAndUr[1];
      try {
        globalHistory.pushState(historyState, "", url);
      } catch (error) {
        window2.location.assign(url);
      }
      applyTx(nextAction);
    }
  }
  function replace(to, state) {
    var nextAction = Action.Replace;
    var nextLocation = getNextLocation(to, state);
    function retry() {
      replace(to, state);
    }
    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr2[0], url = _getHistoryStateAndUr2[1];
      globalHistory.replaceState(historyState, "", url);
      applyTx(nextAction);
    }
  }
  function go(delta) {
    globalHistory.go(delta);
  }
  var history2 = {
    get action() {
      return action;
    },
    get location() {
      return location2;
    },
    createHref,
    push,
    replace,
    go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      var unblock = blockers.push(blocker);
      if (blockers.length === 1) {
        window2.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
      }
      return function() {
        unblock();
        if (!blockers.length) {
          window2.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }
      };
    }
  };
  return history2;
}
function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  var _options2 = options, _options2$window = _options2.window, window2 = _options2$window === void 0 ? document.defaultView : _options2$window;
  var globalHistory = window2.history;
  function getIndexAndLocation() {
    var _parsePath = parsePath(window2.location.hash.substr(1)), _parsePath$pathname = _parsePath.pathname, pathname = _parsePath$pathname === void 0 ? "/" : _parsePath$pathname, _parsePath$search = _parsePath.search, search = _parsePath$search === void 0 ? "" : _parsePath$search, _parsePath$hash = _parsePath.hash, hash = _parsePath$hash === void 0 ? "" : _parsePath$hash;
    var state = globalHistory.state || {};
    return [state.idx, readOnly({
      pathname,
      search,
      hash,
      state: state.usr || null,
      key: state.key || "default"
    })];
  }
  var blockedPopTx = null;
  function handlePop() {
    if (blockedPopTx) {
      blockers.call(blockedPopTx);
      blockedPopTx = null;
    } else {
      var nextAction = Action.Pop;
      var _getIndexAndLocation4 = getIndexAndLocation(), nextIndex = _getIndexAndLocation4[0], nextLocation = _getIndexAndLocation4[1];
      if (blockers.length) {
        if (nextIndex != null) {
          var delta = index - nextIndex;
          if (delta) {
            blockedPopTx = {
              action: nextAction,
              location: nextLocation,
              retry: function retry() {
                go(delta * -1);
              }
            };
            go(delta);
          }
        }
      } else {
        applyTx(nextAction);
      }
    }
  }
  window2.addEventListener(PopStateEventType, handlePop);
  window2.addEventListener(HashChangeEventType, function() {
    var _getIndexAndLocation5 = getIndexAndLocation(), nextLocation = _getIndexAndLocation5[1];
    if (createPath(nextLocation) !== createPath(location2)) {
      handlePop();
    }
  });
  var action = Action.Pop;
  var _getIndexAndLocation6 = getIndexAndLocation(), index = _getIndexAndLocation6[0], location2 = _getIndexAndLocation6[1];
  var listeners = createEvents();
  var blockers = createEvents();
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getBaseHref() {
    var base = document.querySelector("base");
    var href = "";
    if (base && base.getAttribute("href")) {
      var url = window2.location.href;
      var hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href;
  }
  function createHref(to) {
    return getBaseHref() + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function getNextLocation(to, state) {
    if (state === void 0) {
      state = null;
    }
    return readOnly(_extends({
      pathname: location2.pathname,
      hash: "",
      search: ""
    }, typeof to === "string" ? parsePath(to) : to, {
      state,
      key: createKey()
    }));
  }
  function getHistoryStateAndUrl(nextLocation, index2) {
    return [{
      usr: nextLocation.state,
      key: nextLocation.key,
      idx: index2
    }, createHref(nextLocation)];
  }
  function allowTx(action2, location22, retry) {
    return !blockers.length || (blockers.call({
      action: action2,
      location: location22,
      retry
    }), false);
  }
  function applyTx(nextAction) {
    action = nextAction;
    var _getIndexAndLocation7 = getIndexAndLocation();
    index = _getIndexAndLocation7[0];
    location2 = _getIndexAndLocation7[1];
    listeners.call({
      action,
      location: location2
    });
  }
  function push(to, state) {
    var nextAction = Action.Push;
    var nextLocation = getNextLocation(to, state);
    function retry() {
      push(to, state);
    }
    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr3[0], url = _getHistoryStateAndUr3[1];
      try {
        globalHistory.pushState(historyState, "", url);
      } catch (error) {
        window2.location.assign(url);
      }
      applyTx(nextAction);
    }
  }
  function replace(to, state) {
    var nextAction = Action.Replace;
    var nextLocation = getNextLocation(to, state);
    function retry() {
      replace(to, state);
    }
    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr4[0], url = _getHistoryStateAndUr4[1];
      globalHistory.replaceState(historyState, "", url);
      applyTx(nextAction);
    }
  }
  function go(delta) {
    globalHistory.go(delta);
  }
  var history2 = {
    get action() {
      return action;
    },
    get location() {
      return location2;
    },
    createHref,
    push,
    replace,
    go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      var unblock = blockers.push(blocker);
      if (blockers.length === 1) {
        window2.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
      }
      return function() {
        unblock();
        if (!blockers.length) {
          window2.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }
      };
    }
  };
  return history2;
}
function promptBeforeUnload(event) {
  event.preventDefault();
  event.returnValue = "";
}
function createEvents() {
  var handlers = [];
  return {
    get length() {
      return handlers.length;
    },
    push: function push(fn) {
      handlers.push(fn);
      return function() {
        handlers = handlers.filter(function(handler) {
          return handler !== fn;
        });
      };
    },
    call: function call(arg) {
      handlers.forEach(function(fn) {
        return fn && fn(arg);
      });
    }
  };
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function createPath(_ref) {
  var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? "/" : _ref$pathname, _ref$search = _ref.search, search = _ref$search === void 0 ? "" : _ref$search, _ref$hash = _ref.hash, hash = _ref$hash === void 0 ? "" : _ref$hash;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  var parsedPath = {};
  if (path) {
    var hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    var searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
class IonRouteInner extends React.PureComponent {
  render() {
    return React.createElement(Route, Object.assign({ path: this.props.path, exact: this.props.exact, render: this.props.render }, this.props.computedMatch !== void 0 ? {
      computedMatch: this.props.computedMatch
    } : {}));
  }
}
const matchPath = ({ pathname, componentProps }) => {
  const { exact, component } = componentProps;
  const path = componentProps.path || componentProps.from;
  const matchProps = {
    exact,
    path,
    component
  };
  const match = matchPath$1(pathname, matchProps);
  if (!match) {
    return false;
  }
  return match;
};
class ReactRouterViewStack extends ViewStacks {
  constructor() {
    super();
    this.createViewItem = this.createViewItem.bind(this);
    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);
    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);
    this.getChildrenToRender = this.getChildrenToRender.bind(this);
    this.findViewItemByPathname = this.findViewItemByPathname.bind(this);
  }
  createViewItem(outletId, reactElement, routeInfo, page) {
    const viewItem = {
      id: generateId("viewItem"),
      outletId,
      ionPageElement: page,
      reactElement,
      mount: true,
      ionRoute: false
    };
    if (reactElement.type === IonRoute) {
      viewItem.ionRoute = true;
      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;
    }
    viewItem.routeData = {
      match: matchPath({
        pathname: routeInfo.pathname,
        componentProps: reactElement.props
      }),
      childProps: reactElement.props
    };
    return viewItem;
  }
  getChildrenToRender(outletId, ionRouterOutlet, routeInfo) {
    const viewItems = this.getViewItemsForOutlet(outletId);
    React.Children.forEach(ionRouterOutlet.props.children, (child) => {
      const viewItem = viewItems.find((v2) => {
        return matchComponent$1(child, v2.routeData.childProps.path || v2.routeData.childProps.from);
      });
      if (viewItem) {
        viewItem.reactElement = child;
      }
    });
    const children = viewItems.map((viewItem) => {
      let clonedChild;
      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {
        clonedChild = React.createElement(ViewLifeCycleManager, { key: "view-".concat(viewItem.id), mount: viewItem.mount, removeView: () => this.remove(viewItem) }, React.cloneElement(viewItem.reactElement, {
          computedMatch: viewItem.routeData.match
        }));
      } else {
        const match = matchComponent$1(viewItem.reactElement, routeInfo.pathname);
        clonedChild = React.createElement(ViewLifeCycleManager, { key: "view-".concat(viewItem.id), mount: viewItem.mount, removeView: () => this.remove(viewItem) }, React.cloneElement(viewItem.reactElement, {
          computedMatch: viewItem.routeData.match
        }));
        if (!match && viewItem.routeData.match) {
          viewItem.routeData.match = void 0;
          viewItem.mount = false;
        }
      }
      return clonedChild;
    });
    return children;
  }
  findViewItemByRouteInfo(routeInfo, outletId, updateMatch) {
    const { viewItem, match } = this.findViewItemByPath(routeInfo.pathname, outletId);
    const shouldUpdateMatch = updateMatch === void 0 || updateMatch === true;
    if (shouldUpdateMatch && viewItem && match) {
      viewItem.routeData.match = match;
    }
    return viewItem;
  }
  findLeavingViewItemByRouteInfo(routeInfo, outletId, mustBeIonRoute = true) {
    const { viewItem } = this.findViewItemByPath(routeInfo.lastPathname, outletId, mustBeIonRoute);
    return viewItem;
  }
  findViewItemByPathname(pathname, outletId) {
    const { viewItem } = this.findViewItemByPath(pathname, outletId);
    return viewItem;
  }
  /**
   * Returns the matching view item and the match result for a given pathname.
   */
  findViewItemByPath(pathname, outletId, mustBeIonRoute) {
    let viewItem;
    let match;
    let viewStack;
    if (outletId) {
      viewStack = this.getViewItemsForOutlet(outletId);
      viewStack.some(matchView);
      if (!viewItem) {
        viewStack.some(matchDefaultRoute);
      }
    } else {
      const viewItems = this.getAllViewItems();
      viewItems.some(matchView);
      if (!viewItem) {
        viewItems.some(matchDefaultRoute);
      }
    }
    return { viewItem, match };
    function matchView(v2) {
      var _a, _b;
      if (mustBeIonRoute && !v2.ionRoute) {
        return false;
      }
      match = matchPath({
        pathname,
        componentProps: v2.routeData.childProps
      });
      if (match) {
        const hasParameter = match.path.includes(":");
        if (!hasParameter || hasParameter && match.url === ((_b = (_a = v2.routeData) === null || _a === void 0 ? void 0 : _a.match) === null || _b === void 0 ? void 0 : _b.url)) {
          viewItem = v2;
          return true;
        }
      }
      return false;
    }
    function matchDefaultRoute(v2) {
      if (!v2.routeData.childProps.path && !v2.routeData.childProps.from) {
        match = {
          path: pathname,
          url: pathname,
          isExact: true,
          params: {}
        };
        viewItem = v2;
        return true;
      }
      return false;
    }
  }
}
function matchComponent$1(node, pathname) {
  return matchPath({
    pathname,
    componentProps: node.props
  });
}
function clonePageElement(leavingViewHtml) {
  let html;
  if (typeof leavingViewHtml === "string") {
    html = leavingViewHtml;
  } else {
    html = leavingViewHtml.outerHTML;
  }
  if (document) {
    const newEl = document.createElement("div");
    newEl.innerHTML = html;
    newEl.style.zIndex = "";
    const ionBackButton = newEl.getElementsByTagName("ion-back-button");
    if (ionBackButton[0]) {
      ionBackButton[0].remove();
    }
    return newEl.firstChild;
  }
  return void 0;
}
const isViewVisible = (el2) => !el2.classList.contains("ion-page-invisible") && !el2.classList.contains("ion-page-hidden");
class StackManager extends React.PureComponent {
  constructor(props) {
    super(props);
    this.stackContextValue = {
      registerIonPage: this.registerIonPage.bind(this),
      isInOutlet: () => true
    };
    this.pendingPageTransition = false;
    this.registerIonPage = this.registerIonPage.bind(this);
    this.transitionPage = this.transitionPage.bind(this);
    this.handlePageTransition = this.handlePageTransition.bind(this);
    this.id = generateId("routerOutlet");
    this.prevProps = void 0;
    this.skipTransition = false;
  }
  componentDidMount() {
    if (this.clearOutletTimeout) {
      clearTimeout(this.clearOutletTimeout);
    }
    if (this.routerOutletElement) {
      this.setupRouterOutlet(this.routerOutletElement);
      this.handlePageTransition(this.props.routeInfo);
    }
  }
  componentDidUpdate(prevProps) {
    const { pathname } = this.props.routeInfo;
    const { pathname: prevPathname } = prevProps.routeInfo;
    if (pathname !== prevPathname) {
      this.prevProps = prevProps;
      this.handlePageTransition(this.props.routeInfo);
    } else if (this.pendingPageTransition) {
      this.handlePageTransition(this.props.routeInfo);
      this.pendingPageTransition = false;
    }
  }
  componentWillUnmount() {
    this.clearOutletTimeout = this.context.clearOutlet(this.id);
  }
  async handlePageTransition(routeInfo) {
    var _a, _b;
    if (!this.routerOutletElement || !this.routerOutletElement.commit) {
      this.pendingPageTransition = true;
    } else {
      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);
      let leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);
      if (!leavingViewItem && routeInfo.prevRouteLastPathname) {
        leavingViewItem = this.context.findViewItemByPathname(routeInfo.prevRouteLastPathname, this.id);
      }
      if (leavingViewItem) {
        if (routeInfo.routeAction === "replace") {
          leavingViewItem.mount = false;
        } else if (!(routeInfo.routeAction === "push" && routeInfo.routeDirection === "forward")) {
          if (routeInfo.routeDirection !== "none" && enteringViewItem !== leavingViewItem) {
            leavingViewItem.mount = false;
          }
        } else if ((_a = routeInfo.routeOptions) === null || _a === void 0 ? void 0 : _a.unmount) {
          leavingViewItem.mount = false;
        }
      }
      const enteringRoute = matchRoute((_b = this.ionRouterOutlet) === null || _b === void 0 ? void 0 : _b.props.children, routeInfo);
      if (enteringViewItem) {
        enteringViewItem.reactElement = enteringRoute;
      } else if (enteringRoute) {
        enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);
        this.context.addViewItem(enteringViewItem);
      }
      if (enteringViewItem && enteringViewItem.ionPageElement) {
        if (enteringViewItem === leavingViewItem) {
          if (enteringViewItem.routeData.match.url !== routeInfo.pathname) {
            return;
          }
        }
        if (!leavingViewItem && this.props.routeInfo.prevRouteLastPathname) {
          leavingViewItem = this.context.findViewItemByPathname(this.props.routeInfo.prevRouteLastPathname, this.id);
        }
        if (isViewVisible(enteringViewItem.ionPageElement) && leavingViewItem !== void 0 && !isViewVisible(leavingViewItem.ionPageElement)) {
          return;
        }
        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);
      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {
        if (leavingViewItem.ionPageElement) {
          leavingViewItem.ionPageElement.classList.add("ion-page-hidden");
          leavingViewItem.ionPageElement.setAttribute("aria-hidden", "true");
        }
      }
      this.forceUpdate();
    }
  }
  registerIonPage(page, routeInfo) {
    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);
    if (foundView) {
      const oldPageElement = foundView.ionPageElement;
      foundView.ionPageElement = page;
      foundView.ionRoute = true;
      if (oldPageElement === page) {
        return;
      }
    }
    this.handlePageTransition(routeInfo);
  }
  async setupRouterOutlet(routerOutlet) {
    const canStart = () => {
      const config2 = getConfig();
      const swipeEnabled = config2 && config2.get("swipeBackEnabled", routerOutlet.mode === "ios");
      if (!swipeEnabled) {
        return false;
      }
      const { routeInfo } = this.props;
      const propsToUse = this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? this.prevProps.routeInfo : { pathname: routeInfo.pushedByRoute || "" };
      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);
      return !!enteringViewItem && /**
       * The root url '/' is treated as
       * the first view item (but is never mounted),
       * so we do not want to swipe back to the
       * root url.
       */
      enteringViewItem.mount && /**
       * When on the first page (whatever view
       * you land on after the root url) it
       * is possible for findViewItemByRouteInfo to
       * return the exact same view you are currently on.
       * Make sure that we are not swiping back to the same
       * instances of a view.
       */
      enteringViewItem.routeData.match.path !== routeInfo.pathname;
    };
    const onStart = async () => {
      const { routeInfo } = this.props;
      const propsToUse = this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? this.prevProps.routeInfo : { pathname: routeInfo.pushedByRoute || "" };
      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);
      const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);
      if (enteringViewItem && leavingViewItem) {
        await this.transitionPage(routeInfo, enteringViewItem, leavingViewItem, "back", true);
      }
      return Promise.resolve();
    };
    const onEnd = (shouldContinue) => {
      if (shouldContinue) {
        this.skipTransition = true;
        this.context.goBack();
      } else {
        const { routeInfo } = this.props;
        const propsToUse = this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? this.prevProps.routeInfo : { pathname: routeInfo.pushedByRoute || "" };
        const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);
        const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);
        if (enteringViewItem !== leavingViewItem && (enteringViewItem === null || enteringViewItem === void 0 ? void 0 : enteringViewItem.ionPageElement) !== void 0) {
          const { ionPageElement } = enteringViewItem;
          ionPageElement.setAttribute("aria-hidden", "true");
          ionPageElement.classList.add("ion-page-hidden");
        }
      }
    };
    routerOutlet.swipeHandler = {
      canStart,
      onStart,
      onEnd
    };
  }
  async transitionPage(routeInfo, enteringViewItem, leavingViewItem, direction, progressAnimation = false) {
    const runCommit = async (enteringEl, leavingEl) => {
      const skipTransition = this.skipTransition;
      if (skipTransition) {
        this.skipTransition = false;
      } else {
        enteringEl.classList.add("ion-page");
        enteringEl.classList.add("ion-page-invisible");
      }
      await routerOutlet.commit(enteringEl, leavingEl, {
        duration: skipTransition || directionToUse === void 0 ? 0 : void 0,
        direction: directionToUse,
        showGoBack: !!routeInfo.pushedByRoute,
        progressAnimation,
        animationBuilder: routeInfo.routeAnimation
      });
    };
    const routerOutlet = this.routerOutletElement;
    const routeInfoFallbackDirection = routeInfo.routeDirection === "none" || routeInfo.routeDirection === "root" ? void 0 : routeInfo.routeDirection;
    const directionToUse = direction !== null && direction !== void 0 ? direction : routeInfoFallbackDirection;
    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {
      if (leavingViewItem && leavingViewItem.ionPageElement && enteringViewItem === leavingViewItem) {
        const match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);
        if (match) {
          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);
          if (newLeavingElement) {
            this.routerOutletElement.appendChild(newLeavingElement);
            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);
            this.routerOutletElement.removeChild(newLeavingElement);
          }
        } else {
          await runCommit(enteringViewItem.ionPageElement, void 0);
        }
      } else {
        await runCommit(enteringViewItem.ionPageElement, leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement);
        if (leavingViewItem && leavingViewItem.ionPageElement && !progressAnimation) {
          leavingViewItem.ionPageElement.classList.add("ion-page-hidden");
          leavingViewItem.ionPageElement.setAttribute("aria-hidden", "true");
        }
      }
    }
  }
  render() {
    const { children } = this.props;
    const ionRouterOutlet = React.Children.only(children);
    this.ionRouterOutlet = ionRouterOutlet;
    const components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, () => {
      this.forceUpdate();
    });
    return React.createElement(StackContext.Provider, { value: this.stackContextValue }, React.cloneElement(ionRouterOutlet, {
      ref: (node) => {
        if (ionRouterOutlet.props.setRef) {
          ionRouterOutlet.props.setRef(node);
        }
        if (ionRouterOutlet.props.forwardedRef) {
          ionRouterOutlet.props.forwardedRef.current = node;
        }
        this.routerOutletElement = node;
        const { ref } = ionRouterOutlet;
        if (typeof ref === "function") {
          ref(node);
        }
      }
    }, components));
  }
  static get contextType() {
    return RouteManagerContext;
  }
}
function matchRoute(node, routeInfo) {
  let matchedNode;
  React.Children.forEach(node, (child) => {
    const match = matchPath({
      pathname: routeInfo.pathname,
      componentProps: child.props
    });
    if (match) {
      matchedNode = child;
    }
  });
  if (matchedNode) {
    return matchedNode;
  }
  React.Children.forEach(node, (child) => {
    if (!(child.props.path || child.props.from)) {
      matchedNode = child;
    }
  });
  return matchedNode;
}
function matchComponent(node, pathname, forceExact) {
  return matchPath({
    pathname,
    componentProps: Object.assign(Object.assign({}, node.props), { exact: forceExact })
  });
}
class IonRouterInner extends React.PureComponent {
  constructor(props) {
    super(props);
    this.exitViewFromOtherOutletHandlers = [];
    this.locationHistory = new LocationHistory();
    this.viewStack = new ReactRouterViewStack();
    this.routeMangerContextState = {
      canGoBack: () => this.locationHistory.canGoBack(),
      clearOutlet: this.viewStack.clear,
      findViewItemByPathname: this.viewStack.findViewItemByPathname,
      getChildrenToRender: this.viewStack.getChildrenToRender,
      goBack: () => this.handleNavigateBack(),
      createViewItem: this.viewStack.createViewItem,
      findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,
      findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,
      addViewItem: this.viewStack.add,
      unMountViewItem: this.viewStack.remove
    };
    const routeInfo = {
      id: generateId("routeInfo"),
      pathname: this.props.location.pathname,
      search: this.props.location.search
    };
    this.locationHistory.add(routeInfo);
    this.handleChangeTab = this.handleChangeTab.bind(this);
    this.handleResetTab = this.handleResetTab.bind(this);
    this.handleNativeBack = this.handleNativeBack.bind(this);
    this.handleNavigate = this.handleNavigate.bind(this);
    this.handleNavigateBack = this.handleNavigateBack.bind(this);
    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));
    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);
    this.state = {
      routeInfo
    };
  }
  handleChangeTab(tab, path, routeOptions) {
    if (!path) {
      return;
    }
    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);
    const [pathname, search] = path.split("?");
    if (routeInfo) {
      this.incomingRouteParams = Object.assign(Object.assign({}, routeInfo), { routeAction: "push", routeDirection: "none" });
      if (routeInfo.pathname === pathname) {
        this.incomingRouteParams.routeOptions = routeOptions;
        this.props.history.push(routeInfo.pathname + (routeInfo.search || ""));
      } else {
        this.incomingRouteParams.pathname = pathname;
        this.incomingRouteParams.search = search ? "?" + search : void 0;
        this.incomingRouteParams.routeOptions = routeOptions;
        this.props.history.push(pathname + (search ? "?" + search : ""));
      }
    } else {
      this.handleNavigate(pathname, "push", "none", void 0, routeOptions, tab);
    }
  }
  handleHistoryChange(location2, action) {
    var _a, _b, _c;
    let leavingLocationInfo;
    if (this.incomingRouteParams) {
      if (this.incomingRouteParams.routeAction === "replace") {
        leavingLocationInfo = this.locationHistory.previous();
      } else {
        leavingLocationInfo = this.locationHistory.current();
      }
    } else {
      leavingLocationInfo = this.locationHistory.current();
    }
    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;
    if (leavingUrl !== location2.pathname) {
      if (!this.incomingRouteParams) {
        if (action === "REPLACE") {
          this.incomingRouteParams = {
            routeAction: "replace",
            routeDirection: "none",
            tab: this.currentTab
          };
        }
        if (action === "POP") {
          const currentRoute = this.locationHistory.current();
          if (currentRoute && currentRoute.pushedByRoute) {
            const prevInfo = this.locationHistory.findLastLocation(currentRoute);
            this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routeAction: "pop", routeDirection: "back" });
          } else {
            this.incomingRouteParams = {
              routeAction: "pop",
              routeDirection: "none",
              tab: this.currentTab
            };
          }
        }
        if (!this.incomingRouteParams) {
          this.incomingRouteParams = {
            routeAction: "push",
            routeDirection: ((_a = location2.state) === null || _a === void 0 ? void 0 : _a.direction) || "forward",
            routeOptions: (_b = location2.state) === null || _b === void 0 ? void 0 : _b.routerOptions,
            tab: this.currentTab
          };
        }
      }
      let routeInfo;
      if ((_c = this.incomingRouteParams) === null || _c === void 0 ? void 0 : _c.id) {
        routeInfo = Object.assign(Object.assign({}, this.incomingRouteParams), { lastPathname: leavingLocationInfo.pathname });
        this.locationHistory.add(routeInfo);
      } else {
        const isPushed = this.incomingRouteParams.routeAction === "push" && this.incomingRouteParams.routeDirection === "forward";
        routeInfo = Object.assign(Object.assign({ id: generateId("routeInfo") }, this.incomingRouteParams), { lastPathname: leavingLocationInfo.pathname, pathname: location2.pathname, search: location2.search, params: this.props.match.params, prevRouteLastPathname: leavingLocationInfo.lastPathname });
        if (isPushed) {
          routeInfo.tab = leavingLocationInfo.tab;
          routeInfo.pushedByRoute = leavingLocationInfo.pathname;
        } else if (routeInfo.routeAction === "pop") {
          const r2 = this.locationHistory.findLastLocation(routeInfo);
          routeInfo.pushedByRoute = r2 === null || r2 === void 0 ? void 0 : r2.pushedByRoute;
        } else if (routeInfo.routeAction === "push" && routeInfo.tab !== leavingLocationInfo.tab) {
          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);
          routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;
        } else if (routeInfo.routeAction === "replace") {
          const currentRouteInfo = this.locationHistory.current();
          const currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;
          const pushedByRoute = currentPushedBy !== void 0 && currentPushedBy !== routeInfo.pathname ? currentPushedBy : routeInfo.pushedByRoute;
          routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;
          routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;
          routeInfo.pushedByRoute = pushedByRoute;
          routeInfo.routeDirection = routeInfo.routeDirection || (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeDirection);
          routeInfo.routeAnimation = routeInfo.routeAnimation || (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeAnimation);
        }
        this.locationHistory.add(routeInfo);
      }
      this.setState({
        routeInfo
      });
    }
    this.incomingRouteParams = void 0;
  }
  /**
   * history@4.x uses goBack(), history@5.x uses back()
   * TODO: If support for React Router <=5 is dropped
   * this logic is no longer needed. We can just
   * assume back() is available.
   */
  handleNativeBack() {
    const history2 = this.props.history;
    const goBack = history2.goBack || history2.back;
    goBack();
  }
  handleNavigate(path, routeAction, routeDirection, routeAnimation, routeOptions, tab) {
    this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {
      routeAction,
      routeDirection,
      routeOptions,
      routeAnimation,
      tab
    });
    if (routeAction === "push") {
      this.props.history.push(path);
    } else {
      this.props.history.replace(path);
    }
  }
  handleNavigateBack(defaultHref = "/", routeAnimation) {
    const config2 = getConfig();
    defaultHref = defaultHref ? defaultHref : config2 && config2.get("backButtonDefaultHref");
    const routeInfo = this.locationHistory.current();
    if (routeInfo && routeInfo.pushedByRoute) {
      const prevInfo = this.locationHistory.findLastLocation(routeInfo);
      if (prevInfo) {
        const incomingAnimation = routeAnimation || routeInfo.routeAnimation;
        this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routeAction: "pop", routeDirection: "back", routeAnimation: incomingAnimation });
        if (routeInfo.lastPathname === routeInfo.pushedByRoute || /**
         * We need to exclude tab switches/tab
         * context changes here because tabbed
         * navigation is not linear, but router.back()
         * will go back in a linear fashion.
         */
        prevInfo.pathname === routeInfo.pushedByRoute && routeInfo.tab === "" && prevInfo.tab === "") {
          const history2 = this.props.history;
          const goBack = history2.goBack || history2.back;
          goBack();
        } else {
          this.handleNavigate(prevInfo.pathname + (prevInfo.search || ""), "pop", "back", incomingAnimation);
        }
      } else {
        this.handleNavigate(defaultHref, "pop", "back", routeAnimation);
      }
    } else {
      this.handleNavigate(defaultHref, "pop", "back", routeAnimation);
    }
  }
  handleResetTab(tab, originalHref, originalRouteOptions) {
    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);
    if (routeInfo) {
      const newRouteInfo = Object.assign({}, routeInfo);
      newRouteInfo.pathname = originalHref;
      newRouteInfo.routeOptions = originalRouteOptions;
      this.incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), { routeAction: "pop", routeDirection: "back" });
      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ""));
    }
  }
  handleSetCurrentTab(tab) {
    this.currentTab = tab;
    const ri2 = Object.assign({}, this.locationHistory.current());
    if (ri2.tab !== tab) {
      ri2.tab = tab;
      this.locationHistory.update(ri2);
    }
  }
  render() {
    return React.createElement(
      RouteManagerContext.Provider,
      { value: this.routeMangerContextState },
      React.createElement(NavManager, { ionRoute: IonRouteInner, ionRedirect: {}, stackManager: StackManager, routeInfo: this.state.routeInfo, onNativeBack: this.handleNativeBack, onNavigateBack: this.handleNavigateBack, onNavigate: this.handleNavigate, onSetCurrentTab: this.handleSetCurrentTab, onChangeTab: this.handleChangeTab, onResetTab: this.handleResetTab, locationHistory: this.locationHistory }, this.props.children)
    );
  }
}
const IonRouter = withRouter(IonRouterInner);
IonRouter.displayName = "IonRouter";
class IonReactRouter extends React.Component {
  constructor(props) {
    super(props);
    const { history: history2 } = props, rest = __rest(props, ["history"]);
    this.history = history2 || createBrowserHistory(rest);
    this.history.listen(this.handleHistoryChange.bind(this));
    this.registerHistoryListener = this.registerHistoryListener.bind(this);
  }
  /**
   * history@4.x passes separate location and action
   * params. history@5.x passes location and action
   * together as a single object.
   * TODO: If support for React Router <=5 is dropped
   * this logic is no longer needed. We can just assume
   * a single object with both location and action.
   */
  handleHistoryChange(location2, action) {
    const locationValue = location2.location || location2;
    const actionValue = location2.action || action;
    if (this.historyListenHandler) {
      this.historyListenHandler(locationValue, actionValue);
    }
  }
  registerHistoryListener(cb2) {
    this.historyListenHandler = cb2;
  }
  render() {
    const _a = this.props, { children } = _a, props = __rest(_a, ["children"]);
    return React.createElement(
      Router,
      Object.assign({ history: this.history }, props),
      React.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children)
    );
  }
}
class IonReactMemoryRouter extends React.Component {
  constructor(props) {
    super(props);
    this.history = props.history;
    this.history.listen(this.handleHistoryChange.bind(this));
    this.registerHistoryListener = this.registerHistoryListener.bind(this);
  }
  /**
   * history@4.x passes separate location and action
   * params. history@5.x passes location and action
   * together as a single object.
   * TODO: If support for React Router <=5 is dropped
   * this logic is no longer needed. We can just assume
   * a single object with both location and action.
   */
  handleHistoryChange(location2, action) {
    const locationValue = location2.location || location2;
    const actionValue = location2.action || action;
    if (this.historyListenHandler) {
      this.historyListenHandler(locationValue, actionValue);
    }
  }
  registerHistoryListener(cb2) {
    this.historyListenHandler = cb2;
  }
  render() {
    const _a = this.props, { children } = _a, props = __rest(_a, ["children"]);
    return React.createElement(
      Router,
      Object.assign({}, props),
      React.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children)
    );
  }
}
class IonReactHashRouter extends React.Component {
  constructor(props) {
    super(props);
    const { history: history2 } = props, rest = __rest(props, ["history"]);
    this.history = history2 || createHashHistory(rest);
    this.history.listen(this.handleHistoryChange.bind(this));
    this.registerHistoryListener = this.registerHistoryListener.bind(this);
  }
  /**
   * history@4.x passes separate location and action
   * params. history@5.x passes location and action
   * together as a single object.
   * TODO: If support for React Router <=5 is dropped
   * this logic is no longer needed. We can just assume
   * a single object with both location and action.
   */
  handleHistoryChange(location2, action) {
    const locationValue = location2.location || location2;
    const actionValue = location2.action || action;
    if (this.historyListenHandler) {
      this.historyListenHandler(locationValue, actionValue);
    }
  }
  registerHistoryListener(cb2) {
    this.historyListenHandler = cb2;
  }
  render() {
    const _a = this.props, { children } = _a, props = __rest(_a, ["children"]);
    return React.createElement(
      Router,
      Object.assign({ history: this.history }, props),
      React.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children)
    );
  }
}
const MapboxContext = reactExports.createContext(void 0);
const useMapbox = () => {
  const context2 = reactExports.useContext(MapboxContext);
  if (context2 === void 0) {
    throw new Error("useMapbox must be used within a MapboxProvider");
  }
  return context2;
};
const Menu = ({
  disabled,
  paragraphText,
  headline,
  onClick,
  children,
  buttonText,
  className,
  onDismiss
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "form",
    {
      onSubmit: (e2) => {
        e2.preventDefault();
        if (onClick)
          onClick();
      },
      className,
      children: [
        headline && paragraphText && /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { style: { padding: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonButtons,
            {
              slot: "start",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { color: "medium", onClick: onDismiss, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { src: "/assets/icons/close.svg" }) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(IonTitle, { children: [
            headline,
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: paragraphText })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { type: "submit", fill: "clear", disabled, children: buttonText }) })
        ] }) }),
        React.isValidElement(children) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "menu-wrapper", children })
      ]
    }
  );
};
const MenuItem = ({ item, showSelectedIcon, onClick }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "add-location-menu-item", onClick, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "add-location-menu-item-label", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IonIcon,
        {
          "aria-hidden": "true",
          src: "/assets/icons/".concat(item.type, ".svg")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(IonLabel, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { style: { fontSize: "16px" }, children: item.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: item.description })
      ] })
    ] }),
    showSelectedIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IonIcon,
      {
        src: "/assets/icons/check.svg"
      }
    )
  ] });
};
var LocationTypes = /* @__PURE__ */ ((LocationTypes2) => {
  LocationTypes2["RESTAURANT"] = "restaurant";
  LocationTypes2["TOURISTIC"] = "touristic";
  LocationTypes2["PUBLIC_FACILITY"] = "public_facility";
  LocationTypes2["EVENT_VENUE"] = "event";
  LocationTypes2["CUSTOM"] = "custom";
  return LocationTypes2;
})(LocationTypes || {});
const MENU_ITEMS = [
  { id: "1", type: LocationTypes.RESTAURANT, title: "Restaurant", description: "Add restaurants, cafes and others." },
  { id: "2", type: LocationTypes.TOURISTIC, title: "Touristic Attraction", description: "Any touristic place" },
  { id: "3", type: LocationTypes.PUBLIC_FACILITY, title: "Public Facility", description: "Any public place" },
  { id: "4", type: LocationTypes.EVENT_VENUE, title: "Event Venue", description: "Event locations can be marked here" },
  { id: "5", type: LocationTypes.CUSTOM, title: "Custom Event", description: "Your custom event" }
];
const FilterMenu = ({
  onDismiss,
  showMenu,
  filterOptions,
  handleConfirm,
  handleCheckboxChange,
  activeFilters
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    IonModal,
    {
      mode: "ios",
      backdropDismiss: true,
      breakpoints: [0, 0.45],
      initialBreakpoint: 0.45,
      isOpen: showMenu,
      onIonModalDidDismiss: onDismiss,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonButtons,
            {
              slot: "start",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { color: "medium", onClick: onDismiss, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { src: "/assets/icons/close.svg" }) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: "Filter" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonButton,
            {
              onClick: handleConfirm,
              strong: true,
              children: "Confirm"
            }
          ) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { class: "ion-padding", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonList, { lines: "full", children: filterOptions.map((option, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(IonItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { src: "/assets/icons/".concat(option.type, ".svg") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IonCheckbox,
            {
              justify: "space-between",
              checked: activeFilters.includes(option.type),
              onIonChange: () => handleCheckboxChange(option.type),
              children: option.title
            }
          )
        ] }, index)) }) })
      ]
    }
  );
};
const FilterMenuContainer = ({ onDismiss, showMenu, onApplyFilter, activeFilters }) => {
  const [selectedFilters, setSelectedFilters] = reactExports.useState([...activeFilters]);
  const handleCheckboxChange = (locationType) => {
    setSelectedFilters(
      (prevFilters) => prevFilters.includes(locationType) ? prevFilters.filter((filter) => filter !== locationType) : [...prevFilters, locationType]
      // Add if not selected
    );
  };
  const handleConfirm = () => {
    onApplyFilter(selectedFilters);
    onDismiss();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    FilterMenu,
    {
      onDismiss,
      showMenu,
      filterOptions: MENU_ITEMS,
      handleCheckboxChange,
      handleConfirm,
      activeFilters: selectedFilters
    }
  );
};
const SearchLocation = ({
  results,
  handleInput,
  isPopoverOpen,
  setIsPopoverOpen,
  flyToLocation,
  showFilterMenu,
  setShowFilterMenu,
  handleFilterApply,
  activeFilters
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonToolbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRow, { className: "row", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonCol, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IonSearchbar,
          {
            style: { padding: 0 },
            animated: true,
            placeholder: "Search for location",
            onIonInput: handleInput,
            id: "searchbar",
            onIonCancel: () => setIsPopoverOpen(false)
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { fill: "clear", onClick: () => setShowFilterMenu(true), children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { src: "/assets/icons/filter.svg" }) }) })
      ] }) }),
      isPopoverOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Menu,
        {
          disabled: false,
          className: "menu",
          children: results.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "search-location-list", children: results.map((result) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            MenuItem,
            {
              item: {
                type: result.type,
                title: result.name,
                description: result.description
              },
              onClick: () => {
                flyToLocation(result);
              }
            },
            result.id
          )) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "info-text", children: "We could not find any location that fits your query." })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FilterMenuContainer,
      {
        onDismiss: () => {
          setShowFilterMenu(false);
        },
        showMenu: showFilterMenu,
        onApplyFilter: handleFilterApply,
        activeFilters
      }
    )
  ] });
};
const SearchLocationContainer = () => {
  const { setActiveFilters, activeFilters, mapRef, locations } = useMapbox();
  const [results, setResults] = reactExports.useState([]);
  const [isPopoverOpen, setIsPopoverOpen] = reactExports.useState(false);
  const [showFilterMenu, setShowFilterMenu] = reactExports.useState(false);
  const handleInput = (ev) => {
    let query = "";
    const target = ev.target;
    if (target)
      query = target.value.toLowerCase();
    if (query === "") {
      setResults([]);
      setIsPopoverOpen(false);
      return;
    }
    setResults(locations.filter((location2) => location2.name.toLowerCase().indexOf(query) > -1));
    setIsPopoverOpen(true);
  };
  const flyToLocation = (location2) => {
    if (mapRef.current) {
      mapRef.current.flyTo({
        center: [location2.longitude, location2.latitude]
      });
      setIsPopoverOpen(false);
    }
  };
  const handleFilterApply = (selectedFilters) => {
    setActiveFilters(selectedFilters);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SearchLocation,
    {
      results,
      handleInput,
      isPopoverOpen,
      setIsPopoverOpen,
      flyToLocation,
      setShowFilterMenu,
      showFilterMenu,
      activeFilters,
      handleFilterApply
    }
  );
};
/*! Capacitor: https://capacitorjs.com/ - MIT License */
const createCapacitorPlatforms = (win2) => {
  const defaultPlatformMap = /* @__PURE__ */ new Map();
  defaultPlatformMap.set("web", { name: "web" });
  const capPlatforms = win2.CapacitorPlatforms || {
    currentPlatform: { name: "web" },
    platforms: defaultPlatformMap
  };
  const addPlatform = (name, platform) => {
    capPlatforms.platforms.set(name, platform);
  };
  const setPlatform = (name) => {
    if (capPlatforms.platforms.has(name)) {
      capPlatforms.currentPlatform = capPlatforms.platforms.get(name);
    }
  };
  capPlatforms.addPlatform = addPlatform;
  capPlatforms.setPlatform = setPlatform;
  return capPlatforms;
};
const initPlatforms = (win2) => win2.CapacitorPlatforms = createCapacitorPlatforms(win2);
const CapacitorPlatforms = /* @__PURE__ */ initPlatforms(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
CapacitorPlatforms.addPlatform;
CapacitorPlatforms.setPlatform;
var ExceptionCode;
(function(ExceptionCode2) {
  ExceptionCode2["Unimplemented"] = "UNIMPLEMENTED";
  ExceptionCode2["Unavailable"] = "UNAVAILABLE";
})(ExceptionCode || (ExceptionCode = {}));
class CapacitorException extends Error {
  constructor(message, code, data) {
    super(message);
    this.message = message;
    this.code = code;
    this.data = data;
  }
}
const getPlatformId = (win2) => {
  var _a, _b;
  if (win2 === null || win2 === void 0 ? void 0 : win2.androidBridge) {
    return "android";
  } else if ((_b = (_a = win2 === null || win2 === void 0 ? void 0 : win2.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {
    return "ios";
  } else {
    return "web";
  }
};
const createCapacitor = (win2) => {
  var _a, _b, _c, _d, _e;
  const capCustomPlatform = win2.CapacitorCustomPlatform || null;
  const cap = win2.Capacitor || {};
  const Plugins = cap.Plugins = cap.Plugins || {};
  const capPlatforms = win2.CapacitorPlatforms;
  const defaultGetPlatform = () => {
    return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win2);
  };
  const getPlatform = ((_a = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _a === void 0 ? void 0 : _a.getPlatform) || defaultGetPlatform;
  const defaultIsNativePlatform = () => getPlatform() !== "web";
  const isNativePlatform = ((_b = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _b === void 0 ? void 0 : _b.isNativePlatform) || defaultIsNativePlatform;
  const defaultIsPluginAvailable = (pluginName) => {
    const plugin = registeredPlugins.get(pluginName);
    if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {
      return true;
    }
    if (getPluginHeader(pluginName)) {
      return true;
    }
    return false;
  };
  const isPluginAvailable = ((_c = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _c === void 0 ? void 0 : _c.isPluginAvailable) || defaultIsPluginAvailable;
  const defaultGetPluginHeader = (pluginName) => {
    var _a2;
    return (_a2 = cap.PluginHeaders) === null || _a2 === void 0 ? void 0 : _a2.find((h2) => h2.name === pluginName);
  };
  const getPluginHeader = ((_d = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _d === void 0 ? void 0 : _d.getPluginHeader) || defaultGetPluginHeader;
  const handleError = (err2) => win2.console.error(err2);
  const pluginMethodNoop = (_target, prop, pluginName) => {
    return Promise.reject("".concat(pluginName, ' does not have an implementation of "').concat(prop, '".'));
  };
  const registeredPlugins = /* @__PURE__ */ new Map();
  const defaultRegisterPlugin = (pluginName, jsImplementations = {}) => {
    const registeredPlugin = registeredPlugins.get(pluginName);
    if (registeredPlugin) {
      console.warn('Capacitor plugin "'.concat(pluginName, '" already registered. Cannot register plugins twice.'));
      return registeredPlugin.proxy;
    }
    const platform = getPlatform();
    const pluginHeader = getPluginHeader(pluginName);
    let jsImplementation;
    const loadPluginImplementation = async () => {
      if (!jsImplementation && platform in jsImplementations) {
        jsImplementation = typeof jsImplementations[platform] === "function" ? jsImplementation = await jsImplementations[platform]() : jsImplementation = jsImplementations[platform];
      } else if (capCustomPlatform !== null && !jsImplementation && "web" in jsImplementations) {
        jsImplementation = typeof jsImplementations["web"] === "function" ? jsImplementation = await jsImplementations["web"]() : jsImplementation = jsImplementations["web"];
      }
      return jsImplementation;
    };
    const createPluginMethod = (impl, prop) => {
      var _a2, _b2;
      if (pluginHeader) {
        const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m2) => prop === m2.name);
        if (methodHeader) {
          if (methodHeader.rtype === "promise") {
            return (options) => cap.nativePromise(pluginName, prop.toString(), options);
          } else {
            return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);
          }
        } else if (impl) {
          return (_a2 = impl[prop]) === null || _a2 === void 0 ? void 0 : _a2.bind(impl);
        }
      } else if (impl) {
        return (_b2 = impl[prop]) === null || _b2 === void 0 ? void 0 : _b2.bind(impl);
      } else {
        throw new CapacitorException('"'.concat(pluginName, '" plugin is not implemented on ').concat(platform), ExceptionCode.Unimplemented);
      }
    };
    const createPluginMethodWrapper = (prop) => {
      let remove;
      const wrapper = (...args) => {
        const p2 = loadPluginImplementation().then((impl) => {
          const fn = createPluginMethod(impl, prop);
          if (fn) {
            const p3 = fn(...args);
            remove = p3 === null || p3 === void 0 ? void 0 : p3.remove;
            return p3;
          } else {
            throw new CapacitorException('"'.concat(pluginName, ".").concat(prop, '()" is not implemented on ').concat(platform), ExceptionCode.Unimplemented);
          }
        });
        if (prop === "addListener") {
          p2.remove = async () => remove();
        }
        return p2;
      };
      wrapper.toString = () => "".concat(prop.toString(), "() { [capacitor code] }");
      Object.defineProperty(wrapper, "name", {
        value: prop,
        writable: false,
        configurable: false
      });
      return wrapper;
    };
    const addListener = createPluginMethodWrapper("addListener");
    const removeListener = createPluginMethodWrapper("removeListener");
    const addListenerNative = (eventName, callback) => {
      const call = addListener({ eventName }, callback);
      const remove = async () => {
        const callbackId = await call;
        removeListener({
          eventName,
          callbackId
        }, callback);
      };
      const p2 = new Promise((resolve) => call.then(() => resolve({ remove })));
      p2.remove = async () => {
        console.warn("Using addListener() without 'await' is deprecated.");
        await remove();
      };
      return p2;
    };
    const proxy = new Proxy({}, {
      get(_, prop) {
        switch (prop) {
          case "$$typeof":
            return void 0;
          case "toJSON":
            return () => ({});
          case "addListener":
            return pluginHeader ? addListenerNative : addListener;
          case "removeListener":
            return removeListener;
          default:
            return createPluginMethodWrapper(prop);
        }
      }
    });
    Plugins[pluginName] = proxy;
    registeredPlugins.set(pluginName, {
      name: pluginName,
      proxy,
      platforms: /* @__PURE__ */ new Set([
        ...Object.keys(jsImplementations),
        ...pluginHeader ? [platform] : []
      ])
    });
    return proxy;
  };
  const registerPlugin2 = ((_e = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _e === void 0 ? void 0 : _e.registerPlugin) || defaultRegisterPlugin;
  if (!cap.convertFileSrc) {
    cap.convertFileSrc = (filePath) => filePath;
  }
  cap.getPlatform = getPlatform;
  cap.handleError = handleError;
  cap.isNativePlatform = isNativePlatform;
  cap.isPluginAvailable = isPluginAvailable;
  cap.pluginMethodNoop = pluginMethodNoop;
  cap.registerPlugin = registerPlugin2;
  cap.Exception = CapacitorException;
  cap.DEBUG = !!cap.DEBUG;
  cap.isLoggingEnabled = !!cap.isLoggingEnabled;
  cap.platform = cap.getPlatform();
  cap.isNative = cap.isNativePlatform();
  return cap;
};
const initCapacitorGlobal = (win2) => win2.Capacitor = createCapacitor(win2);
const Capacitor = /* @__PURE__ */ initCapacitorGlobal(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
const registerPlugin = Capacitor.registerPlugin;
Capacitor.Plugins;
class WebPlugin {
  constructor(config2) {
    this.listeners = {};
    this.retainedEventArguments = {};
    this.windowListeners = {};
    if (config2) {
      console.warn('Capacitor WebPlugin "'.concat(config2.name, '" config object was deprecated in v3 and will be removed in v4.'));
      this.config = config2;
    }
  }
  addListener(eventName, listenerFunc) {
    let firstListener = false;
    const listeners = this.listeners[eventName];
    if (!listeners) {
      this.listeners[eventName] = [];
      firstListener = true;
    }
    this.listeners[eventName].push(listenerFunc);
    const windowListener = this.windowListeners[eventName];
    if (windowListener && !windowListener.registered) {
      this.addWindowListener(windowListener);
    }
    if (firstListener) {
      this.sendRetainedArgumentsForEvent(eventName);
    }
    const remove = async () => this.removeListener(eventName, listenerFunc);
    const p2 = Promise.resolve({ remove });
    return p2;
  }
  async removeAllListeners() {
    this.listeners = {};
    for (const listener in this.windowListeners) {
      this.removeWindowListener(this.windowListeners[listener]);
    }
    this.windowListeners = {};
  }
  notifyListeners(eventName, data, retainUntilConsumed) {
    const listeners = this.listeners[eventName];
    if (!listeners) {
      if (retainUntilConsumed) {
        let args = this.retainedEventArguments[eventName];
        if (!args) {
          args = [];
        }
        args.push(data);
        this.retainedEventArguments[eventName] = args;
      }
      return;
    }
    listeners.forEach((listener) => listener(data));
  }
  hasListeners(eventName) {
    return !!this.listeners[eventName].length;
  }
  registerWindowListener(windowEventName, pluginEventName) {
    this.windowListeners[pluginEventName] = {
      registered: false,
      windowEventName,
      pluginEventName,
      handler: (event) => {
        this.notifyListeners(pluginEventName, event);
      }
    };
  }
  unimplemented(msg = "not implemented") {
    return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);
  }
  unavailable(msg = "not available") {
    return new Capacitor.Exception(msg, ExceptionCode.Unavailable);
  }
  async removeListener(eventName, listenerFunc) {
    const listeners = this.listeners[eventName];
    if (!listeners) {
      return;
    }
    const index = listeners.indexOf(listenerFunc);
    this.listeners[eventName].splice(index, 1);
    if (!this.listeners[eventName].length) {
      this.removeWindowListener(this.windowListeners[eventName]);
    }
  }
  addWindowListener(handle) {
    window.addEventListener(handle.windowEventName, handle.handler);
    handle.registered = true;
  }
  removeWindowListener(handle) {
    if (!handle) {
      return;
    }
    window.removeEventListener(handle.windowEventName, handle.handler);
    handle.registered = false;
  }
  sendRetainedArgumentsForEvent(eventName) {
    const args = this.retainedEventArguments[eventName];
    if (!args) {
      return;
    }
    delete this.retainedEventArguments[eventName];
    args.forEach((arg) => {
      this.notifyListeners(eventName, arg);
    });
  }
}
const encode = (str) => encodeURIComponent(str).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
const decode = (str) => str.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
class CapacitorCookiesPluginWeb extends WebPlugin {
  async getCookies() {
    const cookies = document.cookie;
    const cookieMap = {};
    cookies.split(";").forEach((cookie) => {
      if (cookie.length <= 0)
        return;
      let [key, value] = cookie.replace(/=/, "CAP_COOKIE").split("CAP_COOKIE");
      key = decode(key).trim();
      value = decode(value).trim();
      cookieMap[key] = value;
    });
    return cookieMap;
  }
  async setCookie(options) {
    try {
      const encodedKey = encode(options.key);
      const encodedValue = encode(options.value);
      const expires = "; expires=".concat((options.expires || "").replace("expires=", ""));
      const path = (options.path || "/").replace("path=", "");
      const domain = options.url != null && options.url.length > 0 ? "domain=".concat(options.url) : "";
      document.cookie = "".concat(encodedKey, "=").concat(encodedValue || "").concat(expires, "; path=").concat(path, "; ").concat(domain, ";");
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async deleteCookie(options) {
    try {
      document.cookie = "".concat(options.key, "=; Max-Age=0");
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async clearCookies() {
    try {
      const cookies = document.cookie.split(";") || [];
      for (const cookie of cookies) {
        document.cookie = cookie.replace(/^ +/, "").replace(/=.*/, "=;expires=".concat((/* @__PURE__ */ new Date()).toUTCString(), ";path=/"));
      }
    } catch (error) {
      return Promise.reject(error);
    }
  }
  async clearAllCookies() {
    try {
      await this.clearCookies();
    } catch (error) {
      return Promise.reject(error);
    }
  }
}
registerPlugin("CapacitorCookies", {
  web: () => new CapacitorCookiesPluginWeb()
});
const readBlobAsBase64 = async (blob) => new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = () => {
    const base64String = reader.result;
    resolve(base64String.indexOf(",") >= 0 ? base64String.split(",")[1] : base64String);
  };
  reader.onerror = (error) => reject(error);
  reader.readAsDataURL(blob);
});
const normalizeHttpHeaders = (headers = {}) => {
  const originalKeys = Object.keys(headers);
  const loweredKeys = Object.keys(headers).map((k2) => k2.toLocaleLowerCase());
  const normalized = loweredKeys.reduce((acc, key, index) => {
    acc[key] = headers[originalKeys[index]];
    return acc;
  }, {});
  return normalized;
};
const buildUrlParams = (params, shouldEncode = true) => {
  if (!params)
    return null;
  const output = Object.entries(params).reduce((accumulator, entry) => {
    const [key, value] = entry;
    let encodedValue;
    let item;
    if (Array.isArray(value)) {
      item = "";
      value.forEach((str) => {
        encodedValue = shouldEncode ? encodeURIComponent(str) : str;
        item += "".concat(key, "=").concat(encodedValue, "&");
      });
      item.slice(0, -1);
    } else {
      encodedValue = shouldEncode ? encodeURIComponent(value) : value;
      item = "".concat(key, "=").concat(encodedValue);
    }
    return "".concat(accumulator, "&").concat(item);
  }, "");
  return output.substr(1);
};
const buildRequestInit = (options, extra = {}) => {
  const output = Object.assign({ method: options.method || "GET", headers: options.headers }, extra);
  const headers = normalizeHttpHeaders(options.headers);
  const type = headers["content-type"] || "";
  if (typeof options.data === "string") {
    output.body = options.data;
  } else if (type.includes("application/x-www-form-urlencoded")) {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(options.data || {})) {
      params.set(key, value);
    }
    output.body = params.toString();
  } else if (type.includes("multipart/form-data") || options.data instanceof FormData) {
    const form = new FormData();
    if (options.data instanceof FormData) {
      options.data.forEach((value, key) => {
        form.append(key, value);
      });
    } else {
      for (const key of Object.keys(options.data)) {
        form.append(key, options.data[key]);
      }
    }
    output.body = form;
    const headers2 = new Headers(output.headers);
    headers2.delete("content-type");
    output.headers = headers2;
  } else if (type.includes("application/json") || typeof options.data === "object") {
    output.body = JSON.stringify(options.data);
  }
  return output;
};
class CapacitorHttpPluginWeb extends WebPlugin {
  /**
   * Perform an Http request given a set of options
   * @param options Options to build the HTTP request
   */
  async request(options) {
    const requestInit = buildRequestInit(options, options.webFetchExtra);
    const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);
    const url = urlParams ? "".concat(options.url, "?").concat(urlParams) : options.url;
    const response = await fetch(url, requestInit);
    const contentType = response.headers.get("content-type") || "";
    let { responseType = "text" } = response.ok ? options : {};
    if (contentType.includes("application/json")) {
      responseType = "json";
    }
    let data;
    let blob;
    switch (responseType) {
      case "arraybuffer":
      case "blob":
        blob = await response.blob();
        data = await readBlobAsBase64(blob);
        break;
      case "json":
        data = await response.json();
        break;
      case "document":
      case "text":
      default:
        data = await response.text();
    }
    const headers = {};
    response.headers.forEach((value, key) => {
      headers[key] = value;
    });
    return {
      data,
      headers,
      status: response.status,
      url: response.url
    };
  }
  /**
   * Perform an Http GET request given a set of options
   * @param options Options to build the HTTP request
   */
  async get(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "GET" }));
  }
  /**
   * Perform an Http POST request given a set of options
   * @param options Options to build the HTTP request
   */
  async post(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "POST" }));
  }
  /**
   * Perform an Http PUT request given a set of options
   * @param options Options to build the HTTP request
   */
  async put(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "PUT" }));
  }
  /**
   * Perform an Http PATCH request given a set of options
   * @param options Options to build the HTTP request
   */
  async patch(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "PATCH" }));
  }
  /**
   * Perform an Http DELETE request given a set of options
   * @param options Options to build the HTTP request
   */
  async delete(options) {
    return this.request(Object.assign(Object.assign({}, options), { method: "DELETE" }));
  }
}
registerPlugin("CapacitorHttp", {
  web: () => new CapacitorHttpPluginWeb()
});
const Preferences = registerPlugin("Preferences", {
  web: () => __vitePreload(() => import("./web-CvhkMMnK.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url).then((m2) => new m2.PreferencesWeb())
});
const getAllLocations = async () => {
  const { value: mapDataString } = await Preferences.get({ key: "mapData" });
  return mapDataString ? JSON.parse(mapDataString) : { locations: [] };
};
const deleteLocation = async (locationId) => {
  const mapData = await getAllLocations();
  const updatedLocations = mapData.locations.filter(
    (location2) => location2.id !== locationId
  );
  await Preferences.set({
    key: "mapData",
    value: JSON.stringify({ locations: updatedLocations })
  });
};
const updateLocation = async (updatedLocation) => {
  const mapData = await getAllLocations();
  const updatedLocations = mapData.locations.map(
    (location2) => location2.id === updatedLocation.id ? updatedLocation : location2
  );
  await Preferences.set({
    key: "mapData",
    value: JSON.stringify({ locations: updatedLocations })
  });
};
const storeLocation = async (location2) => {
  const mapData = await getAllLocations();
  mapData.locations.push(location2);
  await Preferences.set({
    key: "mapData",
    value: JSON.stringify(mapData)
  });
};
const initializeStorage = async () => {
  const { value: isInitialized } = await Preferences.get({ key: "isInitialized" });
  if (!isInitialized) {
    const response = await fetch("./src/data/locations.json");
    const initialData = await response.json();
    await Preferences.set({
      key: "mapData",
      value: JSON.stringify(initialData)
    });
    await Preferences.set({
      key: "isInitialized",
      value: "true"
    });
  }
};
var mapboxGl = { exports: {} };
(function(module, exports) {
  var define_process_env_default = {};
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal$1, function() {
    var shared, worker, mapboxgl2;
    function define2(_, chunk) {
      if (!shared) {
        shared = chunk;
      } else if (!worker) {
        worker = chunk;
      } else {
        var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
        var sharedChunk = {};
        shared(sharedChunk);
        mapboxgl2 = chunk(sharedChunk);
        if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
          mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
        }
      }
    }
    define2(["exports"], function(t2) {
      function e2(t22) {
        return t22 && t22.__esModule && Object.prototype.hasOwnProperty.call(t22, "default") ? t22.default : t22;
      }
      var r2, n2 = {}, i = {};
      function s() {
        if (r2)
          return i;
        r2 = 1, Object.defineProperty(i, "__esModule", { value: true }), i.setMatrixArrayType = function(t3) {
          i.ARRAY_TYPE = e22 = t3;
        }, i.toRadian = function(t3) {
          return t3 * s2;
        }, i.equals = function(e3, r22) {
          return Math.abs(e3 - r22) <= t22 * Math.max(1, Math.abs(e3), Math.abs(r22));
        }, i.RANDOM = i.ARRAY_TYPE = i.EPSILON = void 0;
        var t22 = 1e-6;
        i.EPSILON = t22;
        var e22 = "undefined" != typeof Float32Array ? Float32Array : Array;
        i.ARRAY_TYPE = e22;
        var n22 = Math.random;
        i.RANDOM = n22;
        var s2 = Math.PI / 180;
        return Math.hypot || (Math.hypot = function() {
          for (var t3 = 0, e3 = arguments.length; e3--; )
            t3 += arguments[e3] * arguments[e3];
          return Math.sqrt(t3);
        }), i;
      }
      var a, o = {};
      function l2() {
        if (a)
          return o;
        function t22(e3) {
          return t22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          }, t22(e3);
        }
        a = 1, Object.defineProperty(o, "__esModule", { value: true }), o.create = function() {
          var t3 = new e22.ARRAY_TYPE(4);
          return e22.ARRAY_TYPE != Float32Array && (t3[1] = 0, t3[2] = 0), t3[0] = 1, t3[3] = 1, t3;
        }, o.clone = function(t3) {
          var r3 = new e22.ARRAY_TYPE(4);
          return r3[0] = t3[0], r3[1] = t3[1], r3[2] = t3[2], r3[3] = t3[3], r3;
        }, o.copy = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3;
        }, o.identity = function(t3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3;
        }, o.fromValues = function(t3, r3, n3, i3) {
          var s2 = new e22.ARRAY_TYPE(4);
          return s2[0] = t3, s2[1] = r3, s2[2] = n3, s2[3] = i3, s2;
        }, o.set = function(t3, e3, r3, n3, i3) {
          return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3[3] = i3, t3;
        }, o.transpose = function(t3, e3) {
          if (t3 === e3) {
            var r3 = e3[1];
            t3[1] = e3[2], t3[2] = r3;
          } else
            t3[0] = e3[0], t3[1] = e3[2], t3[2] = e3[1], t3[3] = e3[3];
          return t3;
        }, o.invert = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = r3 * s2 - i3 * n3;
          return a2 ? (t3[0] = s2 * (a2 = 1 / a2), t3[1] = -n3 * a2, t3[2] = -i3 * a2, t3[3] = r3 * a2, t3) : null;
        }, o.adjoint = function(t3, e3) {
          var r3 = e3[0];
          return t3[0] = e3[3], t3[1] = -e3[1], t3[2] = -e3[2], t3[3] = r3, t3;
        }, o.determinant = function(t3) {
          return t3[0] * t3[3] - t3[2] * t3[1];
        }, o.multiply = n22, o.rotate = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = Math.sin(r3), l22 = Math.cos(r3);
          return t3[0] = n3 * l22 + s2 * o2, t3[1] = i3 * l22 + a2 * o2, t3[2] = n3 * -o2 + s2 * l22, t3[3] = i3 * -o2 + a2 * l22, t3;
        }, o.scale = function(t3, e3, r3) {
          var n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = r3[0], o2 = r3[1];
          return t3[0] = e3[0] * a2, t3[1] = n3 * a2, t3[2] = i3 * o2, t3[3] = s2 * o2, t3;
        }, o.fromRotation = function(t3, e3) {
          var r3 = Math.sin(e3), n3 = Math.cos(e3);
          return t3[0] = n3, t3[1] = r3, t3[2] = -r3, t3[3] = n3, t3;
        }, o.fromScaling = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = 0, t3[2] = 0, t3[3] = e3[1], t3;
        }, o.str = function(t3) {
          return "mat2(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ")";
        }, o.frob = function(t3) {
          return Math.hypot(t3[0], t3[1], t3[2], t3[3]);
        }, o.LDU = function(t3, e3, r3, n3) {
          return t3[2] = n3[2] / n3[0], r3[0] = n3[0], r3[1] = n3[1], r3[3] = n3[3] - t3[2] * r3[1], [t3, e3, r3];
        }, o.add = function(t3, e3, r3) {
          return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3[3] = e3[3] + r3[3], t3;
        }, o.subtract = i2, o.exactEquals = function(t3, e3) {
          return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3];
        }, o.equals = function(t3, r3) {
          var n3 = t3[0], i3 = t3[1], s2 = t3[2], a2 = t3[3], o2 = r3[0], l22 = r3[1], u22 = r3[2], c22 = r3[3];
          return Math.abs(n3 - o2) <= e22.EPSILON * Math.max(1, Math.abs(n3), Math.abs(o2)) && Math.abs(i3 - l22) <= e22.EPSILON * Math.max(1, Math.abs(i3), Math.abs(l22)) && Math.abs(s2 - u22) <= e22.EPSILON * Math.max(1, Math.abs(s2), Math.abs(u22)) && Math.abs(a2 - c22) <= e22.EPSILON * Math.max(1, Math.abs(a2), Math.abs(c22));
        }, o.multiplyScalar = function(t3, e3, r3) {
          return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3[3] = e3[3] * r3, t3;
        }, o.multiplyScalarAndAdd = function(t3, e3, r3, n3) {
          return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3[2] = e3[2] + r3[2] * n3, t3[3] = e3[3] + r3[3] * n3, t3;
        }, o.sub = o.mul = void 0;
        var e22 = function(e3, n3) {
          if (e3 && e3.__esModule)
            return e3;
          if (null === e3 || "object" !== t22(e3) && "function" != typeof e3)
            return { default: e3 };
          var i3 = r22(void 0);
          if (i3 && i3.has(e3))
            return i3.get(e3);
          var s2 = {}, a2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var o2 in e3)
            if ("default" !== o2 && Object.prototype.hasOwnProperty.call(e3, o2)) {
              var l22 = a2 ? Object.getOwnPropertyDescriptor(e3, o2) : null;
              l22 && (l22.get || l22.set) ? Object.defineProperty(s2, o2, l22) : s2[o2] = e3[o2];
            }
          return s2.default = e3, i3 && i3.set(e3, s2), s2;
        }(s());
        function r22(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
          return (r22 = function(t4) {
            return t4 ? n3 : e3;
          })(t3);
        }
        function n22(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = r3[0], l22 = r3[1], u22 = r3[2], c22 = r3[3];
          return t3[0] = n3 * o2 + s2 * l22, t3[1] = i3 * o2 + a2 * l22, t3[2] = n3 * u22 + s2 * c22, t3[3] = i3 * u22 + a2 * c22, t3;
        }
        function i2(t3, e3, r3) {
          return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3[2] = e3[2] - r3[2], t3[3] = e3[3] - r3[3], t3;
        }
        return o.mul = n22, o.sub = i2, o;
      }
      var u2, c2 = {};
      function h2() {
        if (u2)
          return c2;
        function t22(e3) {
          return t22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          }, t22(e3);
        }
        u2 = 1, Object.defineProperty(c2, "__esModule", { value: true }), c2.create = function() {
          var t3 = new e22.ARRAY_TYPE(6);
          return e22.ARRAY_TYPE != Float32Array && (t3[1] = 0, t3[2] = 0, t3[4] = 0, t3[5] = 0), t3[0] = 1, t3[3] = 1, t3;
        }, c2.clone = function(t3) {
          var r3 = new e22.ARRAY_TYPE(6);
          return r3[0] = t3[0], r3[1] = t3[1], r3[2] = t3[2], r3[3] = t3[3], r3[4] = t3[4], r3[5] = t3[5], r3;
        }, c2.copy = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[4] = e3[4], t3[5] = e3[5], t3;
        }, c2.identity = function(t3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3[4] = 0, t3[5] = 0, t3;
        }, c2.fromValues = function(t3, r3, n3, i3, s2, a2) {
          var o2 = new e22.ARRAY_TYPE(6);
          return o2[0] = t3, o2[1] = r3, o2[2] = n3, o2[3] = i3, o2[4] = s2, o2[5] = a2, o2;
        }, c2.set = function(t3, e3, r3, n3, i3, s2, a2) {
          return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3[3] = i3, t3[4] = s2, t3[5] = a2, t3;
        }, c2.invert = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = e3[4], o2 = e3[5], l22 = r3 * s2 - n3 * i3;
          return l22 ? (t3[0] = s2 * (l22 = 1 / l22), t3[1] = -n3 * l22, t3[2] = -i3 * l22, t3[3] = r3 * l22, t3[4] = (i3 * o2 - s2 * a2) * l22, t3[5] = (n3 * a2 - r3 * o2) * l22, t3) : null;
        }, c2.determinant = function(t3) {
          return t3[0] * t3[3] - t3[1] * t3[2];
        }, c2.multiply = n22, c2.rotate = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = e3[4], l22 = e3[5], u22 = Math.sin(r3), c22 = Math.cos(r3);
          return t3[0] = n3 * c22 + s2 * u22, t3[1] = i3 * c22 + a2 * u22, t3[2] = n3 * -u22 + s2 * c22, t3[3] = i3 * -u22 + a2 * c22, t3[4] = o2, t3[5] = l22, t3;
        }, c2.scale = function(t3, e3, r3) {
          var n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = e3[4], o2 = e3[5], l22 = r3[0], u22 = r3[1];
          return t3[0] = e3[0] * l22, t3[1] = n3 * l22, t3[2] = i3 * u22, t3[3] = s2 * u22, t3[4] = a2, t3[5] = o2, t3;
        }, c2.translate = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = e3[4], l22 = e3[5], u22 = r3[0], c22 = r3[1];
          return t3[0] = n3, t3[1] = i3, t3[2] = s2, t3[3] = a2, t3[4] = n3 * u22 + s2 * c22 + o2, t3[5] = i3 * u22 + a2 * c22 + l22, t3;
        }, c2.fromRotation = function(t3, e3) {
          var r3 = Math.sin(e3), n3 = Math.cos(e3);
          return t3[0] = n3, t3[1] = r3, t3[2] = -r3, t3[3] = n3, t3[4] = 0, t3[5] = 0, t3;
        }, c2.fromScaling = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = 0, t3[2] = 0, t3[3] = e3[1], t3[4] = 0, t3[5] = 0, t3;
        }, c2.fromTranslation = function(t3, e3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3[4] = e3[0], t3[5] = e3[1], t3;
        }, c2.str = function(t3) {
          return "mat2d(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ", " + t3[4] + ", " + t3[5] + ")";
        }, c2.frob = function(t3) {
          return Math.hypot(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5], 1);
        }, c2.add = function(t3, e3, r3) {
          return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3[3] = e3[3] + r3[3], t3[4] = e3[4] + r3[4], t3[5] = e3[5] + r3[5], t3;
        }, c2.subtract = i2, c2.multiplyScalar = function(t3, e3, r3) {
          return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3[3] = e3[3] * r3, t3[4] = e3[4] * r3, t3[5] = e3[5] * r3, t3;
        }, c2.multiplyScalarAndAdd = function(t3, e3, r3, n3) {
          return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3[2] = e3[2] + r3[2] * n3, t3[3] = e3[3] + r3[3] * n3, t3[4] = e3[4] + r3[4] * n3, t3[5] = e3[5] + r3[5] * n3, t3;
        }, c2.exactEquals = function(t3, e3) {
          return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3] && t3[4] === e3[4] && t3[5] === e3[5];
        }, c2.equals = function(t3, r3) {
          var n3 = t3[0], i3 = t3[1], s2 = t3[2], a2 = t3[3], o2 = t3[4], l22 = t3[5], u22 = r3[0], c22 = r3[1], h22 = r3[2], p22 = r3[3], f22 = r3[4], d22 = r3[5];
          return Math.abs(n3 - u22) <= e22.EPSILON * Math.max(1, Math.abs(n3), Math.abs(u22)) && Math.abs(i3 - c22) <= e22.EPSILON * Math.max(1, Math.abs(i3), Math.abs(c22)) && Math.abs(s2 - h22) <= e22.EPSILON * Math.max(1, Math.abs(s2), Math.abs(h22)) && Math.abs(a2 - p22) <= e22.EPSILON * Math.max(1, Math.abs(a2), Math.abs(p22)) && Math.abs(o2 - f22) <= e22.EPSILON * Math.max(1, Math.abs(o2), Math.abs(f22)) && Math.abs(l22 - d22) <= e22.EPSILON * Math.max(1, Math.abs(l22), Math.abs(d22));
        }, c2.sub = c2.mul = void 0;
        var e22 = function(e3, n3) {
          if (e3 && e3.__esModule)
            return e3;
          if (null === e3 || "object" !== t22(e3) && "function" != typeof e3)
            return { default: e3 };
          var i3 = r22(void 0);
          if (i3 && i3.has(e3))
            return i3.get(e3);
          var s2 = {}, a2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var o2 in e3)
            if ("default" !== o2 && Object.prototype.hasOwnProperty.call(e3, o2)) {
              var l22 = a2 ? Object.getOwnPropertyDescriptor(e3, o2) : null;
              l22 && (l22.get || l22.set) ? Object.defineProperty(s2, o2, l22) : s2[o2] = e3[o2];
            }
          return s2.default = e3, i3 && i3.set(e3, s2), s2;
        }(s());
        function r22(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
          return (r22 = function(t4) {
            return t4 ? n3 : e3;
          })(t3);
        }
        function n22(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = e3[4], l22 = e3[5], u22 = r3[0], c22 = r3[1], h22 = r3[2], p22 = r3[3], f22 = r3[4], d22 = r3[5];
          return t3[0] = n3 * u22 + s2 * c22, t3[1] = i3 * u22 + a2 * c22, t3[2] = n3 * h22 + s2 * p22, t3[3] = i3 * h22 + a2 * p22, t3[4] = n3 * f22 + s2 * d22 + o2, t3[5] = i3 * f22 + a2 * d22 + l22, t3;
        }
        function i2(t3, e3, r3) {
          return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3[2] = e3[2] - r3[2], t3[3] = e3[3] - r3[3], t3[4] = e3[4] - r3[4], t3[5] = e3[5] - r3[5], t3;
        }
        return c2.mul = n22, c2.sub = i2, c2;
      }
      var p2, f2 = {};
      function d2() {
        if (p2)
          return f2;
        function t22(e3) {
          return t22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          }, t22(e3);
        }
        p2 = 1, Object.defineProperty(f2, "__esModule", { value: true }), f2.create = function() {
          var t3 = new e22.ARRAY_TYPE(9);
          return e22.ARRAY_TYPE != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0), t3[0] = 1, t3[4] = 1, t3[8] = 1, t3;
        }, f2.fromMat4 = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[4], t3[4] = e3[5], t3[5] = e3[6], t3[6] = e3[8], t3[7] = e3[9], t3[8] = e3[10], t3;
        }, f2.clone = function(t3) {
          var r3 = new e22.ARRAY_TYPE(9);
          return r3[0] = t3[0], r3[1] = t3[1], r3[2] = t3[2], r3[3] = t3[3], r3[4] = t3[4], r3[5] = t3[5], r3[6] = t3[6], r3[7] = t3[7], r3[8] = t3[8], r3;
        }, f2.copy = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[4] = e3[4], t3[5] = e3[5], t3[6] = e3[6], t3[7] = e3[7], t3[8] = e3[8], t3;
        }, f2.fromValues = function(t3, r3, n3, i3, s2, a2, o2, l22, u22) {
          var c22 = new e22.ARRAY_TYPE(9);
          return c22[0] = t3, c22[1] = r3, c22[2] = n3, c22[3] = i3, c22[4] = s2, c22[5] = a2, c22[6] = o2, c22[7] = l22, c22[8] = u22, c22;
        }, f2.set = function(t3, e3, r3, n3, i3, s2, a2, o2, l22, u22) {
          return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3[3] = i3, t3[4] = s2, t3[5] = a2, t3[6] = o2, t3[7] = l22, t3[8] = u22, t3;
        }, f2.identity = function(t3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 1, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1, t3;
        }, f2.transpose = function(t3, e3) {
          if (t3 === e3) {
            var r3 = e3[1], n3 = e3[2], i3 = e3[5];
            t3[1] = e3[3], t3[2] = e3[6], t3[3] = r3, t3[5] = e3[7], t3[6] = n3, t3[7] = i3;
          } else
            t3[0] = e3[0], t3[1] = e3[3], t3[2] = e3[6], t3[3] = e3[1], t3[4] = e3[4], t3[5] = e3[7], t3[6] = e3[2], t3[7] = e3[5], t3[8] = e3[8];
          return t3;
        }, f2.invert = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = e3[4], o2 = e3[5], l22 = e3[6], u22 = e3[7], c22 = e3[8], h22 = c22 * a2 - o2 * u22, p22 = -c22 * s2 + o2 * l22, f22 = u22 * s2 - a2 * l22, d22 = r3 * h22 + n3 * p22 + i3 * f22;
          return d22 ? (t3[0] = h22 * (d22 = 1 / d22), t3[1] = (-c22 * n3 + i3 * u22) * d22, t3[2] = (o2 * n3 - i3 * a2) * d22, t3[3] = p22 * d22, t3[4] = (c22 * r3 - i3 * l22) * d22, t3[5] = (-o2 * r3 + i3 * s2) * d22, t3[6] = f22 * d22, t3[7] = (-u22 * r3 + n3 * l22) * d22, t3[8] = (a2 * r3 - n3 * s2) * d22, t3) : null;
        }, f2.adjoint = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = e3[4], o2 = e3[5], l22 = e3[6], u22 = e3[7], c22 = e3[8];
          return t3[0] = a2 * c22 - o2 * u22, t3[1] = i3 * u22 - n3 * c22, t3[2] = n3 * o2 - i3 * a2, t3[3] = o2 * l22 - s2 * c22, t3[4] = r3 * c22 - i3 * l22, t3[5] = i3 * s2 - r3 * o2, t3[6] = s2 * u22 - a2 * l22, t3[7] = n3 * l22 - r3 * u22, t3[8] = r3 * a2 - n3 * s2, t3;
        }, f2.determinant = function(t3) {
          var e3 = t3[3], r3 = t3[4], n3 = t3[5], i3 = t3[6], s2 = t3[7], a2 = t3[8];
          return t3[0] * (a2 * r3 - n3 * s2) + t3[1] * (-a2 * e3 + n3 * i3) + t3[2] * (s2 * e3 - r3 * i3);
        }, f2.multiply = n22, f2.translate = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = e3[4], l22 = e3[5], u22 = e3[6], c22 = e3[7], h22 = e3[8], p22 = r3[0], f22 = r3[1];
          return t3[0] = n3, t3[1] = i3, t3[2] = s2, t3[3] = a2, t3[4] = o2, t3[5] = l22, t3[6] = p22 * n3 + f22 * a2 + u22, t3[7] = p22 * i3 + f22 * o2 + c22, t3[8] = p22 * s2 + f22 * l22 + h22, t3;
        }, f2.rotate = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = e3[4], l22 = e3[5], u22 = e3[6], c22 = e3[7], h22 = e3[8], p22 = Math.sin(r3), f22 = Math.cos(r3);
          return t3[0] = f22 * n3 + p22 * a2, t3[1] = f22 * i3 + p22 * o2, t3[2] = f22 * s2 + p22 * l22, t3[3] = f22 * a2 - p22 * n3, t3[4] = f22 * o2 - p22 * i3, t3[5] = f22 * l22 - p22 * s2, t3[6] = u22, t3[7] = c22, t3[8] = h22, t3;
        }, f2.scale = function(t3, e3, r3) {
          var n3 = r3[0], i3 = r3[1];
          return t3[0] = n3 * e3[0], t3[1] = n3 * e3[1], t3[2] = n3 * e3[2], t3[3] = i3 * e3[3], t3[4] = i3 * e3[4], t3[5] = i3 * e3[5], t3[6] = e3[6], t3[7] = e3[7], t3[8] = e3[8], t3;
        }, f2.fromTranslation = function(t3, e3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 1, t3[5] = 0, t3[6] = e3[0], t3[7] = e3[1], t3[8] = 1, t3;
        }, f2.fromRotation = function(t3, e3) {
          var r3 = Math.sin(e3), n3 = Math.cos(e3);
          return t3[0] = n3, t3[1] = r3, t3[2] = 0, t3[3] = -r3, t3[4] = n3, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1, t3;
        }, f2.fromScaling = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = e3[1], t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1, t3;
        }, f2.fromMat2d = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = e3[1], t3[2] = 0, t3[3] = e3[2], t3[4] = e3[3], t3[5] = 0, t3[6] = e3[4], t3[7] = e3[5], t3[8] = 1, t3;
        }, f2.fromQuat = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = r3 + r3, o2 = n3 + n3, l22 = i3 + i3, u22 = r3 * a2, c22 = n3 * a2, h22 = n3 * o2, p22 = i3 * a2, f22 = i3 * o2, d22 = i3 * l22, m22 = s2 * a2, y22 = s2 * o2, g22 = s2 * l22;
          return t3[0] = 1 - h22 - d22, t3[3] = c22 - g22, t3[6] = p22 + y22, t3[1] = c22 + g22, t3[4] = 1 - u22 - d22, t3[7] = f22 - m22, t3[2] = p22 - y22, t3[5] = f22 + m22, t3[8] = 1 - u22 - h22, t3;
        }, f2.normalFromMat4 = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = e3[4], o2 = e3[5], l22 = e3[6], u22 = e3[7], c22 = e3[8], h22 = e3[9], p22 = e3[10], f22 = e3[11], d22 = e3[12], m22 = e3[13], y22 = e3[14], g22 = e3[15], x22 = r3 * o2 - n3 * a2, b22 = r3 * l22 - i3 * a2, v22 = r3 * u22 - s2 * a2, w22 = n3 * l22 - i3 * o2, _2 = n3 * u22 - s2 * o2, M22 = i3 * u22 - s2 * l22, A22 = c22 * m22 - h22 * d22, S22 = c22 * y22 - p22 * d22, I22 = c22 * g22 - f22 * d22, P22 = h22 * y22 - p22 * m22, z22 = h22 * g22 - f22 * m22, k22 = p22 * g22 - f22 * y22, T22 = x22 * k22 - b22 * z22 + v22 * P22 + w22 * I22 - _2 * S22 + M22 * A22;
          return T22 ? (t3[0] = (o2 * k22 - l22 * z22 + u22 * P22) * (T22 = 1 / T22), t3[1] = (l22 * I22 - a2 * k22 - u22 * S22) * T22, t3[2] = (a2 * z22 - o2 * I22 + u22 * A22) * T22, t3[3] = (i3 * z22 - n3 * k22 - s2 * P22) * T22, t3[4] = (r3 * k22 - i3 * I22 + s2 * S22) * T22, t3[5] = (n3 * I22 - r3 * z22 - s2 * A22) * T22, t3[6] = (m22 * M22 - y22 * _2 + g22 * w22) * T22, t3[7] = (y22 * v22 - d22 * M22 - g22 * b22) * T22, t3[8] = (d22 * _2 - m22 * v22 + g22 * x22) * T22, t3) : null;
        }, f2.projection = function(t3, e3, r3) {
          return t3[0] = 2 / e3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = -2 / r3, t3[5] = 0, t3[6] = -1, t3[7] = 1, t3[8] = 1, t3;
        }, f2.str = function(t3) {
          return "mat3(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ", " + t3[4] + ", " + t3[5] + ", " + t3[6] + ", " + t3[7] + ", " + t3[8] + ")";
        }, f2.frob = function(t3) {
          return Math.hypot(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5], t3[6], t3[7], t3[8]);
        }, f2.add = function(t3, e3, r3) {
          return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3[3] = e3[3] + r3[3], t3[4] = e3[4] + r3[4], t3[5] = e3[5] + r3[5], t3[6] = e3[6] + r3[6], t3[7] = e3[7] + r3[7], t3[8] = e3[8] + r3[8], t3;
        }, f2.subtract = i2, f2.multiplyScalar = function(t3, e3, r3) {
          return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3[3] = e3[3] * r3, t3[4] = e3[4] * r3, t3[5] = e3[5] * r3, t3[6] = e3[6] * r3, t3[7] = e3[7] * r3, t3[8] = e3[8] * r3, t3;
        }, f2.multiplyScalarAndAdd = function(t3, e3, r3, n3) {
          return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3[2] = e3[2] + r3[2] * n3, t3[3] = e3[3] + r3[3] * n3, t3[4] = e3[4] + r3[4] * n3, t3[5] = e3[5] + r3[5] * n3, t3[6] = e3[6] + r3[6] * n3, t3[7] = e3[7] + r3[7] * n3, t3[8] = e3[8] + r3[8] * n3, t3;
        }, f2.exactEquals = function(t3, e3) {
          return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3] && t3[4] === e3[4] && t3[5] === e3[5] && t3[6] === e3[6] && t3[7] === e3[7] && t3[8] === e3[8];
        }, f2.equals = function(t3, r3) {
          var n3 = t3[0], i3 = t3[1], s2 = t3[2], a2 = t3[3], o2 = t3[4], l22 = t3[5], u22 = t3[6], c22 = t3[7], h22 = t3[8], p22 = r3[0], f22 = r3[1], d22 = r3[2], m22 = r3[3], y22 = r3[4], g22 = r3[5], x22 = r3[6], b22 = r3[7], v22 = r3[8];
          return Math.abs(n3 - p22) <= e22.EPSILON * Math.max(1, Math.abs(n3), Math.abs(p22)) && Math.abs(i3 - f22) <= e22.EPSILON * Math.max(1, Math.abs(i3), Math.abs(f22)) && Math.abs(s2 - d22) <= e22.EPSILON * Math.max(1, Math.abs(s2), Math.abs(d22)) && Math.abs(a2 - m22) <= e22.EPSILON * Math.max(1, Math.abs(a2), Math.abs(m22)) && Math.abs(o2 - y22) <= e22.EPSILON * Math.max(1, Math.abs(o2), Math.abs(y22)) && Math.abs(l22 - g22) <= e22.EPSILON * Math.max(1, Math.abs(l22), Math.abs(g22)) && Math.abs(u22 - x22) <= e22.EPSILON * Math.max(1, Math.abs(u22), Math.abs(x22)) && Math.abs(c22 - b22) <= e22.EPSILON * Math.max(1, Math.abs(c22), Math.abs(b22)) && Math.abs(h22 - v22) <= e22.EPSILON * Math.max(1, Math.abs(h22), Math.abs(v22));
        }, f2.sub = f2.mul = void 0;
        var e22 = function(e3, n3) {
          if (e3 && e3.__esModule)
            return e3;
          if (null === e3 || "object" !== t22(e3) && "function" != typeof e3)
            return { default: e3 };
          var i3 = r22(void 0);
          if (i3 && i3.has(e3))
            return i3.get(e3);
          var s2 = {}, a2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var o2 in e3)
            if ("default" !== o2 && Object.prototype.hasOwnProperty.call(e3, o2)) {
              var l22 = a2 ? Object.getOwnPropertyDescriptor(e3, o2) : null;
              l22 && (l22.get || l22.set) ? Object.defineProperty(s2, o2, l22) : s2[o2] = e3[o2];
            }
          return s2.default = e3, i3 && i3.set(e3, s2), s2;
        }(s());
        function r22(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
          return (r22 = function(t4) {
            return t4 ? n3 : e3;
          })(t3);
        }
        function n22(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = e3[4], l22 = e3[5], u22 = e3[6], c22 = e3[7], h22 = e3[8], p22 = r3[0], f22 = r3[1], d22 = r3[2], m22 = r3[3], y22 = r3[4], g22 = r3[5], x22 = r3[6], b22 = r3[7], v22 = r3[8];
          return t3[0] = p22 * n3 + f22 * a2 + d22 * u22, t3[1] = p22 * i3 + f22 * o2 + d22 * c22, t3[2] = p22 * s2 + f22 * l22 + d22 * h22, t3[3] = m22 * n3 + y22 * a2 + g22 * u22, t3[4] = m22 * i3 + y22 * o2 + g22 * c22, t3[5] = m22 * s2 + y22 * l22 + g22 * h22, t3[6] = x22 * n3 + b22 * a2 + v22 * u22, t3[7] = x22 * i3 + b22 * o2 + v22 * c22, t3[8] = x22 * s2 + b22 * l22 + v22 * h22, t3;
        }
        function i2(t3, e3, r3) {
          return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3[2] = e3[2] - r3[2], t3[3] = e3[3] - r3[3], t3[4] = e3[4] - r3[4], t3[5] = e3[5] - r3[5], t3[6] = e3[6] - r3[6], t3[7] = e3[7] - r3[7], t3[8] = e3[8] - r3[8], t3;
        }
        return f2.mul = n22, f2.sub = i2, f2;
      }
      var m2, y2 = {};
      function g2() {
        if (m2)
          return y2;
        function t22(e3) {
          return t22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          }, t22(e3);
        }
        m2 = 1, Object.defineProperty(y2, "__esModule", { value: true }), y2.create = function() {
          var t3 = new e22.ARRAY_TYPE(16);
          return e22.ARRAY_TYPE != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0), t3[0] = 1, t3[5] = 1, t3[10] = 1, t3[15] = 1, t3;
        }, y2.clone = function(t3) {
          var r3 = new e22.ARRAY_TYPE(16);
          return r3[0] = t3[0], r3[1] = t3[1], r3[2] = t3[2], r3[3] = t3[3], r3[4] = t3[4], r3[5] = t3[5], r3[6] = t3[6], r3[7] = t3[7], r3[8] = t3[8], r3[9] = t3[9], r3[10] = t3[10], r3[11] = t3[11], r3[12] = t3[12], r3[13] = t3[13], r3[14] = t3[14], r3[15] = t3[15], r3;
        }, y2.copy = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[4] = e3[4], t3[5] = e3[5], t3[6] = e3[6], t3[7] = e3[7], t3[8] = e3[8], t3[9] = e3[9], t3[10] = e3[10], t3[11] = e3[11], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15], t3;
        }, y2.fromValues = function(t3, r3, n3, i3, s2, a3, o3, l3, u3, c3, h22, p22, f22, d22, m22, y22) {
          var g22 = new e22.ARRAY_TYPE(16);
          return g22[0] = t3, g22[1] = r3, g22[2] = n3, g22[3] = i3, g22[4] = s2, g22[5] = a3, g22[6] = o3, g22[7] = l3, g22[8] = u3, g22[9] = c3, g22[10] = h22, g22[11] = p22, g22[12] = f22, g22[13] = d22, g22[14] = m22, g22[15] = y22, g22;
        }, y2.set = function(t3, e3, r3, n3, i3, s2, a3, o3, l3, u3, c3, h22, p22, f22, d22, m22, y22) {
          return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3[3] = i3, t3[4] = s2, t3[5] = a3, t3[6] = o3, t3[7] = l3, t3[8] = u3, t3[9] = c3, t3[10] = h22, t3[11] = p22, t3[12] = f22, t3[13] = d22, t3[14] = m22, t3[15] = y22, t3;
        }, y2.identity = n22, y2.transpose = function(t3, e3) {
          if (t3 === e3) {
            var r3 = e3[1], n3 = e3[2], i3 = e3[3], s2 = e3[6], a3 = e3[7], o3 = e3[11];
            t3[1] = e3[4], t3[2] = e3[8], t3[3] = e3[12], t3[4] = r3, t3[6] = e3[9], t3[7] = e3[13], t3[8] = n3, t3[9] = s2, t3[11] = e3[14], t3[12] = i3, t3[13] = a3, t3[14] = o3;
          } else
            t3[0] = e3[0], t3[1] = e3[4], t3[2] = e3[8], t3[3] = e3[12], t3[4] = e3[1], t3[5] = e3[5], t3[6] = e3[9], t3[7] = e3[13], t3[8] = e3[2], t3[9] = e3[6], t3[10] = e3[10], t3[11] = e3[14], t3[12] = e3[3], t3[13] = e3[7], t3[14] = e3[11], t3[15] = e3[15];
          return t3;
        }, y2.invert = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a3 = e3[4], o3 = e3[5], l3 = e3[6], u3 = e3[7], c3 = e3[8], h22 = e3[9], p22 = e3[10], f22 = e3[11], d22 = e3[12], m22 = e3[13], y22 = e3[14], g22 = e3[15], x22 = r3 * o3 - n3 * a3, b22 = r3 * l3 - i3 * a3, v22 = r3 * u3 - s2 * a3, w22 = n3 * l3 - i3 * o3, _2 = n3 * u3 - s2 * o3, M22 = i3 * u3 - s2 * l3, A22 = c3 * m22 - h22 * d22, S22 = c3 * y22 - p22 * d22, I22 = c3 * g22 - f22 * d22, P22 = h22 * y22 - p22 * m22, z22 = h22 * g22 - f22 * m22, k22 = p22 * g22 - f22 * y22, T22 = x22 * k22 - b22 * z22 + v22 * P22 + w22 * I22 - _2 * S22 + M22 * A22;
          return T22 ? (t3[0] = (o3 * k22 - l3 * z22 + u3 * P22) * (T22 = 1 / T22), t3[1] = (i3 * z22 - n3 * k22 - s2 * P22) * T22, t3[2] = (m22 * M22 - y22 * _2 + g22 * w22) * T22, t3[3] = (p22 * _2 - h22 * M22 - f22 * w22) * T22, t3[4] = (l3 * I22 - a3 * k22 - u3 * S22) * T22, t3[5] = (r3 * k22 - i3 * I22 + s2 * S22) * T22, t3[6] = (y22 * v22 - d22 * M22 - g22 * b22) * T22, t3[7] = (c3 * M22 - p22 * v22 + f22 * b22) * T22, t3[8] = (a3 * z22 - o3 * I22 + u3 * A22) * T22, t3[9] = (n3 * I22 - r3 * z22 - s2 * A22) * T22, t3[10] = (d22 * _2 - m22 * v22 + g22 * x22) * T22, t3[11] = (h22 * v22 - c3 * _2 - f22 * x22) * T22, t3[12] = (o3 * S22 - a3 * P22 - l3 * A22) * T22, t3[13] = (r3 * P22 - n3 * S22 + i3 * A22) * T22, t3[14] = (m22 * b22 - d22 * w22 - y22 * x22) * T22, t3[15] = (c3 * w22 - h22 * b22 + p22 * x22) * T22, t3) : null;
        }, y2.adjoint = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a3 = e3[4], o3 = e3[5], l3 = e3[6], u3 = e3[7], c3 = e3[8], h22 = e3[9], p22 = e3[10], f22 = e3[11], d22 = e3[12], m22 = e3[13], y22 = e3[14], g22 = e3[15];
          return t3[0] = o3 * (p22 * g22 - f22 * y22) - h22 * (l3 * g22 - u3 * y22) + m22 * (l3 * f22 - u3 * p22), t3[1] = -(n3 * (p22 * g22 - f22 * y22) - h22 * (i3 * g22 - s2 * y22) + m22 * (i3 * f22 - s2 * p22)), t3[2] = n3 * (l3 * g22 - u3 * y22) - o3 * (i3 * g22 - s2 * y22) + m22 * (i3 * u3 - s2 * l3), t3[3] = -(n3 * (l3 * f22 - u3 * p22) - o3 * (i3 * f22 - s2 * p22) + h22 * (i3 * u3 - s2 * l3)), t3[4] = -(a3 * (p22 * g22 - f22 * y22) - c3 * (l3 * g22 - u3 * y22) + d22 * (l3 * f22 - u3 * p22)), t3[5] = r3 * (p22 * g22 - f22 * y22) - c3 * (i3 * g22 - s2 * y22) + d22 * (i3 * f22 - s2 * p22), t3[6] = -(r3 * (l3 * g22 - u3 * y22) - a3 * (i3 * g22 - s2 * y22) + d22 * (i3 * u3 - s2 * l3)), t3[7] = r3 * (l3 * f22 - u3 * p22) - a3 * (i3 * f22 - s2 * p22) + c3 * (i3 * u3 - s2 * l3), t3[8] = a3 * (h22 * g22 - f22 * m22) - c3 * (o3 * g22 - u3 * m22) + d22 * (o3 * f22 - u3 * h22), t3[9] = -(r3 * (h22 * g22 - f22 * m22) - c3 * (n3 * g22 - s2 * m22) + d22 * (n3 * f22 - s2 * h22)), t3[10] = r3 * (o3 * g22 - u3 * m22) - a3 * (n3 * g22 - s2 * m22) + d22 * (n3 * u3 - s2 * o3), t3[11] = -(r3 * (o3 * f22 - u3 * h22) - a3 * (n3 * f22 - s2 * h22) + c3 * (n3 * u3 - s2 * o3)), t3[12] = -(a3 * (h22 * y22 - p22 * m22) - c3 * (o3 * y22 - l3 * m22) + d22 * (o3 * p22 - l3 * h22)), t3[13] = r3 * (h22 * y22 - p22 * m22) - c3 * (n3 * y22 - i3 * m22) + d22 * (n3 * p22 - i3 * h22), t3[14] = -(r3 * (o3 * y22 - l3 * m22) - a3 * (n3 * y22 - i3 * m22) + d22 * (n3 * l3 - i3 * o3)), t3[15] = r3 * (o3 * p22 - l3 * h22) - a3 * (n3 * p22 - i3 * h22) + c3 * (n3 * l3 - i3 * o3), t3;
        }, y2.determinant = function(t3) {
          var e3 = t3[0], r3 = t3[1], n3 = t3[2], i3 = t3[3], s2 = t3[4], a3 = t3[5], o3 = t3[6], l3 = t3[7], u3 = t3[8], c3 = t3[9], h22 = t3[10], p22 = t3[11], f22 = t3[12], d22 = t3[13], m22 = t3[14], y22 = t3[15];
          return (e3 * a3 - r3 * s2) * (h22 * y22 - p22 * m22) - (e3 * o3 - n3 * s2) * (c3 * y22 - p22 * d22) + (e3 * l3 - i3 * s2) * (c3 * m22 - h22 * d22) + (r3 * o3 - n3 * a3) * (u3 * y22 - p22 * f22) - (r3 * l3 - i3 * a3) * (u3 * m22 - h22 * f22) + (n3 * l3 - i3 * o3) * (u3 * d22 - c3 * f22);
        }, y2.multiply = i2, y2.translate = function(t3, e3, r3) {
          var n3, i3, s2, a3, o3, l3, u3, c3, h22, p22, f22, d22, m22 = r3[0], y22 = r3[1], g22 = r3[2];
          return e3 === t3 ? (t3[12] = e3[0] * m22 + e3[4] * y22 + e3[8] * g22 + e3[12], t3[13] = e3[1] * m22 + e3[5] * y22 + e3[9] * g22 + e3[13], t3[14] = e3[2] * m22 + e3[6] * y22 + e3[10] * g22 + e3[14], t3[15] = e3[3] * m22 + e3[7] * y22 + e3[11] * g22 + e3[15]) : (i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = e3[4], l3 = e3[5], u3 = e3[6], c3 = e3[7], h22 = e3[8], p22 = e3[9], f22 = e3[10], d22 = e3[11], t3[0] = n3 = e3[0], t3[1] = i3, t3[2] = s2, t3[3] = a3, t3[4] = o3, t3[5] = l3, t3[6] = u3, t3[7] = c3, t3[8] = h22, t3[9] = p22, t3[10] = f22, t3[11] = d22, t3[12] = n3 * m22 + o3 * y22 + h22 * g22 + e3[12], t3[13] = i3 * m22 + l3 * y22 + p22 * g22 + e3[13], t3[14] = s2 * m22 + u3 * y22 + f22 * g22 + e3[14], t3[15] = a3 * m22 + c3 * y22 + d22 * g22 + e3[15]), t3;
        }, y2.scale = function(t3, e3, r3) {
          var n3 = r3[0], i3 = r3[1], s2 = r3[2];
          return t3[0] = e3[0] * n3, t3[1] = e3[1] * n3, t3[2] = e3[2] * n3, t3[3] = e3[3] * n3, t3[4] = e3[4] * i3, t3[5] = e3[5] * i3, t3[6] = e3[6] * i3, t3[7] = e3[7] * i3, t3[8] = e3[8] * s2, t3[9] = e3[9] * s2, t3[10] = e3[10] * s2, t3[11] = e3[11] * s2, t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15], t3;
        }, y2.rotate = function(t3, r3, n3, i3) {
          var s2, a3, o3, l3, u3, c3, h22, p22, f22, d22, m22, y22, g22, x22, b22, v22, w22, _2, M22, A22, S22, I22, P22, z22, k22 = i3[0], T22 = i3[1], E22 = i3[2], B22 = Math.hypot(k22, T22, E22);
          return B22 < e22.EPSILON ? null : (k22 *= B22 = 1 / B22, T22 *= B22, E22 *= B22, s2 = Math.sin(n3), a3 = Math.cos(n3), u3 = r3[1], c3 = r3[2], h22 = r3[3], f22 = r3[5], d22 = r3[6], m22 = r3[7], g22 = r3[9], x22 = r3[10], b22 = r3[11], v22 = k22 * k22 * (o3 = 1 - a3) + a3, M22 = k22 * T22 * o3 - E22 * s2, A22 = T22 * T22 * o3 + a3, S22 = E22 * T22 * o3 + k22 * s2, I22 = k22 * E22 * o3 + T22 * s2, P22 = T22 * E22 * o3 - k22 * s2, z22 = E22 * E22 * o3 + a3, t3[0] = (l3 = r3[0]) * v22 + (p22 = r3[4]) * (w22 = T22 * k22 * o3 + E22 * s2) + (y22 = r3[8]) * (_2 = E22 * k22 * o3 - T22 * s2), t3[1] = u3 * v22 + f22 * w22 + g22 * _2, t3[2] = c3 * v22 + d22 * w22 + x22 * _2, t3[3] = h22 * v22 + m22 * w22 + b22 * _2, t3[4] = l3 * M22 + p22 * A22 + y22 * S22, t3[5] = u3 * M22 + f22 * A22 + g22 * S22, t3[6] = c3 * M22 + d22 * A22 + x22 * S22, t3[7] = h22 * M22 + m22 * A22 + b22 * S22, t3[8] = l3 * I22 + p22 * P22 + y22 * z22, t3[9] = u3 * I22 + f22 * P22 + g22 * z22, t3[10] = c3 * I22 + d22 * P22 + x22 * z22, t3[11] = h22 * I22 + m22 * P22 + b22 * z22, r3 !== t3 && (t3[12] = r3[12], t3[13] = r3[13], t3[14] = r3[14], t3[15] = r3[15]), t3);
        }, y2.rotateX = function(t3, e3, r3) {
          var n3 = Math.sin(r3), i3 = Math.cos(r3), s2 = e3[4], a3 = e3[5], o3 = e3[6], l3 = e3[7], u3 = e3[8], c3 = e3[9], h22 = e3[10], p22 = e3[11];
          return e3 !== t3 && (t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]), t3[4] = s2 * i3 + u3 * n3, t3[5] = a3 * i3 + c3 * n3, t3[6] = o3 * i3 + h22 * n3, t3[7] = l3 * i3 + p22 * n3, t3[8] = u3 * i3 - s2 * n3, t3[9] = c3 * i3 - a3 * n3, t3[10] = h22 * i3 - o3 * n3, t3[11] = p22 * i3 - l3 * n3, t3;
        }, y2.rotateY = function(t3, e3, r3) {
          var n3 = Math.sin(r3), i3 = Math.cos(r3), s2 = e3[0], a3 = e3[1], o3 = e3[2], l3 = e3[3], u3 = e3[8], c3 = e3[9], h22 = e3[10], p22 = e3[11];
          return e3 !== t3 && (t3[4] = e3[4], t3[5] = e3[5], t3[6] = e3[6], t3[7] = e3[7], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]), t3[0] = s2 * i3 - u3 * n3, t3[1] = a3 * i3 - c3 * n3, t3[2] = o3 * i3 - h22 * n3, t3[3] = l3 * i3 - p22 * n3, t3[8] = s2 * n3 + u3 * i3, t3[9] = a3 * n3 + c3 * i3, t3[10] = o3 * n3 + h22 * i3, t3[11] = l3 * n3 + p22 * i3, t3;
        }, y2.rotateZ = function(t3, e3, r3) {
          var n3 = Math.sin(r3), i3 = Math.cos(r3), s2 = e3[0], a3 = e3[1], o3 = e3[2], l3 = e3[3], u3 = e3[4], c3 = e3[5], h22 = e3[6], p22 = e3[7];
          return e3 !== t3 && (t3[8] = e3[8], t3[9] = e3[9], t3[10] = e3[10], t3[11] = e3[11], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]), t3[0] = s2 * i3 + u3 * n3, t3[1] = a3 * i3 + c3 * n3, t3[2] = o3 * i3 + h22 * n3, t3[3] = l3 * i3 + p22 * n3, t3[4] = u3 * i3 - s2 * n3, t3[5] = c3 * i3 - a3 * n3, t3[6] = h22 * i3 - o3 * n3, t3[7] = p22 * i3 - l3 * n3, t3;
        }, y2.fromTranslation = function(t3, e3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = e3[0], t3[13] = e3[1], t3[14] = e3[2], t3[15] = 1, t3;
        }, y2.fromScaling = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = e3[1], t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = e3[2], t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, y2.fromRotation = function(t3, r3, n3) {
          var i3, s2, a3, o3 = n3[0], l3 = n3[1], u3 = n3[2], c3 = Math.hypot(o3, l3, u3);
          return c3 < e22.EPSILON ? null : (o3 *= c3 = 1 / c3, l3 *= c3, u3 *= c3, i3 = Math.sin(r3), s2 = Math.cos(r3), t3[0] = o3 * o3 * (a3 = 1 - s2) + s2, t3[1] = l3 * o3 * a3 + u3 * i3, t3[2] = u3 * o3 * a3 - l3 * i3, t3[3] = 0, t3[4] = o3 * l3 * a3 - u3 * i3, t3[5] = l3 * l3 * a3 + s2, t3[6] = u3 * l3 * a3 + o3 * i3, t3[7] = 0, t3[8] = o3 * u3 * a3 + l3 * i3, t3[9] = l3 * u3 * a3 - o3 * i3, t3[10] = u3 * u3 * a3 + s2, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3);
        }, y2.fromXRotation = function(t3, e3) {
          var r3 = Math.sin(e3), n3 = Math.cos(e3);
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = n3, t3[6] = r3, t3[7] = 0, t3[8] = 0, t3[9] = -r3, t3[10] = n3, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, y2.fromYRotation = function(t3, e3) {
          var r3 = Math.sin(e3), n3 = Math.cos(e3);
          return t3[0] = n3, t3[1] = 0, t3[2] = -r3, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = r3, t3[9] = 0, t3[10] = n3, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, y2.fromZRotation = function(t3, e3) {
          var r3 = Math.sin(e3), n3 = Math.cos(e3);
          return t3[0] = n3, t3[1] = r3, t3[2] = 0, t3[3] = 0, t3[4] = -r3, t3[5] = n3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, y2.fromRotationTranslation = a2, y2.fromQuat2 = function(t3, r3) {
          var n3 = new e22.ARRAY_TYPE(3), i3 = -r3[0], s2 = -r3[1], o3 = -r3[2], l3 = r3[3], u3 = r3[4], c3 = r3[5], h22 = r3[6], p22 = r3[7], f22 = i3 * i3 + s2 * s2 + o3 * o3 + l3 * l3;
          return f22 > 0 ? (n3[0] = 2 * (u3 * l3 + p22 * i3 + c3 * o3 - h22 * s2) / f22, n3[1] = 2 * (c3 * l3 + p22 * s2 + h22 * i3 - u3 * o3) / f22, n3[2] = 2 * (h22 * l3 + p22 * o3 + u3 * s2 - c3 * i3) / f22) : (n3[0] = 2 * (u3 * l3 + p22 * i3 + c3 * o3 - h22 * s2), n3[1] = 2 * (c3 * l3 + p22 * s2 + h22 * i3 - u3 * o3), n3[2] = 2 * (h22 * l3 + p22 * o3 + u3 * s2 - c3 * i3)), a2(t3, r3, n3), t3;
        }, y2.getTranslation = function(t3, e3) {
          return t3[0] = e3[12], t3[1] = e3[13], t3[2] = e3[14], t3;
        }, y2.getScaling = o2, y2.getRotation = function(t3, r3) {
          var n3 = new e22.ARRAY_TYPE(3);
          o2(n3, r3);
          var i3 = 1 / n3[0], s2 = 1 / n3[1], a3 = 1 / n3[2], l3 = r3[0] * i3, u3 = r3[1] * s2, c3 = r3[2] * a3, h22 = r3[4] * i3, p22 = r3[5] * s2, f22 = r3[6] * a3, d22 = r3[8] * i3, m22 = r3[9] * s2, y22 = r3[10] * a3, g22 = l3 + p22 + y22, x22 = 0;
          return g22 > 0 ? (x22 = 2 * Math.sqrt(g22 + 1), t3[3] = 0.25 * x22, t3[0] = (f22 - m22) / x22, t3[1] = (d22 - c3) / x22, t3[2] = (u3 - h22) / x22) : l3 > p22 && l3 > y22 ? (x22 = 2 * Math.sqrt(1 + l3 - p22 - y22), t3[3] = (f22 - m22) / x22, t3[0] = 0.25 * x22, t3[1] = (u3 + h22) / x22, t3[2] = (d22 + c3) / x22) : p22 > y22 ? (x22 = 2 * Math.sqrt(1 + p22 - l3 - y22), t3[3] = (d22 - c3) / x22, t3[0] = (u3 + h22) / x22, t3[1] = 0.25 * x22, t3[2] = (f22 + m22) / x22) : (x22 = 2 * Math.sqrt(1 + y22 - l3 - p22), t3[3] = (u3 - h22) / x22, t3[0] = (d22 + c3) / x22, t3[1] = (f22 + m22) / x22, t3[2] = 0.25 * x22), t3;
        }, y2.fromRotationTranslationScale = function(t3, e3, r3, n3) {
          var i3 = e3[0], s2 = e3[1], a3 = e3[2], o3 = e3[3], l3 = i3 + i3, u3 = s2 + s2, c3 = a3 + a3, h22 = i3 * l3, p22 = i3 * u3, f22 = i3 * c3, d22 = s2 * u3, m22 = s2 * c3, y22 = a3 * c3, g22 = o3 * l3, x22 = o3 * u3, b22 = o3 * c3, v22 = n3[0], w22 = n3[1], _2 = n3[2];
          return t3[0] = (1 - (d22 + y22)) * v22, t3[1] = (p22 + b22) * v22, t3[2] = (f22 - x22) * v22, t3[3] = 0, t3[4] = (p22 - b22) * w22, t3[5] = (1 - (h22 + y22)) * w22, t3[6] = (m22 + g22) * w22, t3[7] = 0, t3[8] = (f22 + x22) * _2, t3[9] = (m22 - g22) * _2, t3[10] = (1 - (h22 + d22)) * _2, t3[11] = 0, t3[12] = r3[0], t3[13] = r3[1], t3[14] = r3[2], t3[15] = 1, t3;
        }, y2.fromRotationTranslationScaleOrigin = function(t3, e3, r3, n3, i3) {
          var s2 = e3[0], a3 = e3[1], o3 = e3[2], l3 = e3[3], u3 = s2 + s2, c3 = a3 + a3, h22 = o3 + o3, p22 = s2 * u3, f22 = s2 * c3, d22 = s2 * h22, m22 = a3 * c3, y22 = a3 * h22, g22 = o3 * h22, x22 = l3 * u3, b22 = l3 * c3, v22 = l3 * h22, w22 = n3[0], _2 = n3[1], M22 = n3[2], A22 = i3[0], S22 = i3[1], I22 = i3[2], P22 = (1 - (m22 + g22)) * w22, z22 = (f22 + v22) * w22, k22 = (d22 - b22) * w22, T22 = (f22 - v22) * _2, E22 = (1 - (p22 + g22)) * _2, B22 = (y22 + x22) * _2, V22 = (d22 + b22) * M22, C22 = (y22 - x22) * M22, R22 = (1 - (p22 + m22)) * M22;
          return t3[0] = P22, t3[1] = z22, t3[2] = k22, t3[3] = 0, t3[4] = T22, t3[5] = E22, t3[6] = B22, t3[7] = 0, t3[8] = V22, t3[9] = C22, t3[10] = R22, t3[11] = 0, t3[12] = r3[0] + A22 - (P22 * A22 + T22 * S22 + V22 * I22), t3[13] = r3[1] + S22 - (z22 * A22 + E22 * S22 + C22 * I22), t3[14] = r3[2] + I22 - (k22 * A22 + B22 * S22 + R22 * I22), t3[15] = 1, t3;
        }, y2.fromQuat = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a3 = r3 + r3, o3 = n3 + n3, l3 = i3 + i3, u3 = r3 * a3, c3 = n3 * a3, h22 = n3 * o3, p22 = i3 * a3, f22 = i3 * o3, d22 = i3 * l3, m22 = s2 * a3, y22 = s2 * o3, g22 = s2 * l3;
          return t3[0] = 1 - h22 - d22, t3[1] = c3 + g22, t3[2] = p22 - y22, t3[3] = 0, t3[4] = c3 - g22, t3[5] = 1 - u3 - d22, t3[6] = f22 + m22, t3[7] = 0, t3[8] = p22 + y22, t3[9] = f22 - m22, t3[10] = 1 - u3 - h22, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, y2.frustum = function(t3, e3, r3, n3, i3, s2, a3) {
          var o3 = 1 / (r3 - e3), l3 = 1 / (i3 - n3), u3 = 1 / (s2 - a3);
          return t3[0] = 2 * s2 * o3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 2 * s2 * l3, t3[6] = 0, t3[7] = 0, t3[8] = (r3 + e3) * o3, t3[9] = (i3 + n3) * l3, t3[10] = (a3 + s2) * u3, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[14] = a3 * s2 * 2 * u3, t3[15] = 0, t3;
        }, y2.perspectiveNO = l22, y2.perspectiveZO = function(t3, e3, r3, n3, i3) {
          var s2, a3 = 1 / Math.tan(e3 / 2);
          return t3[0] = a3 / r3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = a3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[15] = 0, null != i3 && i3 !== 1 / 0 ? (t3[10] = i3 * (s2 = 1 / (n3 - i3)), t3[14] = i3 * n3 * s2) : (t3[10] = -1, t3[14] = -n3), t3;
        }, y2.perspectiveFromFieldOfView = function(t3, e3, r3, n3) {
          var i3 = Math.tan(e3.upDegrees * Math.PI / 180), s2 = Math.tan(e3.downDegrees * Math.PI / 180), a3 = Math.tan(e3.leftDegrees * Math.PI / 180), o3 = Math.tan(e3.rightDegrees * Math.PI / 180), l3 = 2 / (a3 + o3), u3 = 2 / (i3 + s2);
          return t3[0] = l3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = u3, t3[6] = 0, t3[7] = 0, t3[8] = -(a3 - o3) * l3 * 0.5, t3[9] = (i3 - s2) * u3 * 0.5, t3[10] = n3 / (r3 - n3), t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[14] = n3 * r3 / (r3 - n3), t3[15] = 0, t3;
        }, y2.orthoNO = u22, y2.orthoZO = function(t3, e3, r3, n3, i3, s2, a3) {
          var o3 = 1 / (e3 - r3), l3 = 1 / (n3 - i3), u3 = 1 / (s2 - a3);
          return t3[0] = -2 * o3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * l3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = u3, t3[11] = 0, t3[12] = (e3 + r3) * o3, t3[13] = (i3 + n3) * l3, t3[14] = s2 * u3, t3[15] = 1, t3;
        }, y2.lookAt = function(t3, r3, i3, s2) {
          var a3, o3, l3, u3, c3, h22, p22, f22, d22, m22, y22 = r3[0], g22 = r3[1], x22 = r3[2], b22 = s2[0], v22 = s2[1], w22 = s2[2], _2 = i3[0], M22 = i3[1], A22 = i3[2];
          return Math.abs(y22 - _2) < e22.EPSILON && Math.abs(g22 - M22) < e22.EPSILON && Math.abs(x22 - A22) < e22.EPSILON ? n22(t3) : (p22 = y22 - _2, f22 = g22 - M22, d22 = x22 - A22, a3 = v22 * (d22 *= m22 = 1 / Math.hypot(p22, f22, d22)) - w22 * (f22 *= m22), o3 = w22 * (p22 *= m22) - b22 * d22, l3 = b22 * f22 - v22 * p22, (m22 = Math.hypot(a3, o3, l3)) ? (a3 *= m22 = 1 / m22, o3 *= m22, l3 *= m22) : (a3 = 0, o3 = 0, l3 = 0), u3 = f22 * l3 - d22 * o3, c3 = d22 * a3 - p22 * l3, h22 = p22 * o3 - f22 * a3, (m22 = Math.hypot(u3, c3, h22)) ? (u3 *= m22 = 1 / m22, c3 *= m22, h22 *= m22) : (u3 = 0, c3 = 0, h22 = 0), t3[0] = a3, t3[1] = u3, t3[2] = p22, t3[3] = 0, t3[4] = o3, t3[5] = c3, t3[6] = f22, t3[7] = 0, t3[8] = l3, t3[9] = h22, t3[10] = d22, t3[11] = 0, t3[12] = -(a3 * y22 + o3 * g22 + l3 * x22), t3[13] = -(u3 * y22 + c3 * g22 + h22 * x22), t3[14] = -(p22 * y22 + f22 * g22 + d22 * x22), t3[15] = 1, t3);
        }, y2.targetTo = function(t3, e3, r3, n3) {
          var i3 = e3[0], s2 = e3[1], a3 = e3[2], o3 = n3[0], l3 = n3[1], u3 = n3[2], c3 = i3 - r3[0], h22 = s2 - r3[1], p22 = a3 - r3[2], f22 = c3 * c3 + h22 * h22 + p22 * p22;
          f22 > 0 && (c3 *= f22 = 1 / Math.sqrt(f22), h22 *= f22, p22 *= f22);
          var d22 = l3 * p22 - u3 * h22, m22 = u3 * c3 - o3 * p22, y22 = o3 * h22 - l3 * c3;
          return (f22 = d22 * d22 + m22 * m22 + y22 * y22) > 0 && (d22 *= f22 = 1 / Math.sqrt(f22), m22 *= f22, y22 *= f22), t3[0] = d22, t3[1] = m22, t3[2] = y22, t3[3] = 0, t3[4] = h22 * y22 - p22 * m22, t3[5] = p22 * d22 - c3 * y22, t3[6] = c3 * m22 - h22 * d22, t3[7] = 0, t3[8] = c3, t3[9] = h22, t3[10] = p22, t3[11] = 0, t3[12] = i3, t3[13] = s2, t3[14] = a3, t3[15] = 1, t3;
        }, y2.str = function(t3) {
          return "mat4(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ", " + t3[4] + ", " + t3[5] + ", " + t3[6] + ", " + t3[7] + ", " + t3[8] + ", " + t3[9] + ", " + t3[10] + ", " + t3[11] + ", " + t3[12] + ", " + t3[13] + ", " + t3[14] + ", " + t3[15] + ")";
        }, y2.frob = function(t3) {
          return Math.hypot(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5], t3[6], t3[7], t3[8], t3[9], t3[10], t3[11], t3[12], t3[13], t3[14], t3[15]);
        }, y2.add = function(t3, e3, r3) {
          return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3[3] = e3[3] + r3[3], t3[4] = e3[4] + r3[4], t3[5] = e3[5] + r3[5], t3[6] = e3[6] + r3[6], t3[7] = e3[7] + r3[7], t3[8] = e3[8] + r3[8], t3[9] = e3[9] + r3[9], t3[10] = e3[10] + r3[10], t3[11] = e3[11] + r3[11], t3[12] = e3[12] + r3[12], t3[13] = e3[13] + r3[13], t3[14] = e3[14] + r3[14], t3[15] = e3[15] + r3[15], t3;
        }, y2.subtract = c22, y2.multiplyScalar = function(t3, e3, r3) {
          return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3[3] = e3[3] * r3, t3[4] = e3[4] * r3, t3[5] = e3[5] * r3, t3[6] = e3[6] * r3, t3[7] = e3[7] * r3, t3[8] = e3[8] * r3, t3[9] = e3[9] * r3, t3[10] = e3[10] * r3, t3[11] = e3[11] * r3, t3[12] = e3[12] * r3, t3[13] = e3[13] * r3, t3[14] = e3[14] * r3, t3[15] = e3[15] * r3, t3;
        }, y2.multiplyScalarAndAdd = function(t3, e3, r3, n3) {
          return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3[2] = e3[2] + r3[2] * n3, t3[3] = e3[3] + r3[3] * n3, t3[4] = e3[4] + r3[4] * n3, t3[5] = e3[5] + r3[5] * n3, t3[6] = e3[6] + r3[6] * n3, t3[7] = e3[7] + r3[7] * n3, t3[8] = e3[8] + r3[8] * n3, t3[9] = e3[9] + r3[9] * n3, t3[10] = e3[10] + r3[10] * n3, t3[11] = e3[11] + r3[11] * n3, t3[12] = e3[12] + r3[12] * n3, t3[13] = e3[13] + r3[13] * n3, t3[14] = e3[14] + r3[14] * n3, t3[15] = e3[15] + r3[15] * n3, t3;
        }, y2.exactEquals = function(t3, e3) {
          return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3] && t3[4] === e3[4] && t3[5] === e3[5] && t3[6] === e3[6] && t3[7] === e3[7] && t3[8] === e3[8] && t3[9] === e3[9] && t3[10] === e3[10] && t3[11] === e3[11] && t3[12] === e3[12] && t3[13] === e3[13] && t3[14] === e3[14] && t3[15] === e3[15];
        }, y2.equals = function(t3, r3) {
          var n3 = t3[0], i3 = t3[1], s2 = t3[2], a3 = t3[3], o3 = t3[4], l3 = t3[5], u3 = t3[6], c3 = t3[7], h22 = t3[8], p22 = t3[9], f22 = t3[10], d22 = t3[11], m22 = t3[12], y22 = t3[13], g22 = t3[14], x22 = t3[15], b22 = r3[0], v22 = r3[1], w22 = r3[2], _2 = r3[3], M22 = r3[4], A22 = r3[5], S22 = r3[6], I22 = r3[7], P22 = r3[8], z22 = r3[9], k22 = r3[10], T22 = r3[11], E22 = r3[12], B22 = r3[13], V22 = r3[14], C22 = r3[15];
          return Math.abs(n3 - b22) <= e22.EPSILON * Math.max(1, Math.abs(n3), Math.abs(b22)) && Math.abs(i3 - v22) <= e22.EPSILON * Math.max(1, Math.abs(i3), Math.abs(v22)) && Math.abs(s2 - w22) <= e22.EPSILON * Math.max(1, Math.abs(s2), Math.abs(w22)) && Math.abs(a3 - _2) <= e22.EPSILON * Math.max(1, Math.abs(a3), Math.abs(_2)) && Math.abs(o3 - M22) <= e22.EPSILON * Math.max(1, Math.abs(o3), Math.abs(M22)) && Math.abs(l3 - A22) <= e22.EPSILON * Math.max(1, Math.abs(l3), Math.abs(A22)) && Math.abs(u3 - S22) <= e22.EPSILON * Math.max(1, Math.abs(u3), Math.abs(S22)) && Math.abs(c3 - I22) <= e22.EPSILON * Math.max(1, Math.abs(c3), Math.abs(I22)) && Math.abs(h22 - P22) <= e22.EPSILON * Math.max(1, Math.abs(h22), Math.abs(P22)) && Math.abs(p22 - z22) <= e22.EPSILON * Math.max(1, Math.abs(p22), Math.abs(z22)) && Math.abs(f22 - k22) <= e22.EPSILON * Math.max(1, Math.abs(f22), Math.abs(k22)) && Math.abs(d22 - T22) <= e22.EPSILON * Math.max(1, Math.abs(d22), Math.abs(T22)) && Math.abs(m22 - E22) <= e22.EPSILON * Math.max(1, Math.abs(m22), Math.abs(E22)) && Math.abs(y22 - B22) <= e22.EPSILON * Math.max(1, Math.abs(y22), Math.abs(B22)) && Math.abs(g22 - V22) <= e22.EPSILON * Math.max(1, Math.abs(g22), Math.abs(V22)) && Math.abs(x22 - C22) <= e22.EPSILON * Math.max(1, Math.abs(x22), Math.abs(C22));
        }, y2.sub = y2.mul = y2.ortho = y2.perspective = void 0;
        var e22 = function(e3, n3) {
          if (e3 && e3.__esModule)
            return e3;
          if (null === e3 || "object" !== t22(e3) && "function" != typeof e3)
            return { default: e3 };
          var i3 = r22(void 0);
          if (i3 && i3.has(e3))
            return i3.get(e3);
          var s2 = {}, a3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var o3 in e3)
            if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e3, o3)) {
              var l3 = a3 ? Object.getOwnPropertyDescriptor(e3, o3) : null;
              l3 && (l3.get || l3.set) ? Object.defineProperty(s2, o3, l3) : s2[o3] = e3[o3];
            }
          return s2.default = e3, i3 && i3.set(e3, s2), s2;
        }(s());
        function r22(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
          return (r22 = function(t4) {
            return t4 ? n3 : e3;
          })(t3);
        }
        function n22(t3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }
        function i2(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = e3[4], l3 = e3[5], u3 = e3[6], c3 = e3[7], h22 = e3[8], p22 = e3[9], f22 = e3[10], d22 = e3[11], m22 = e3[12], y22 = e3[13], g22 = e3[14], x22 = e3[15], b22 = r3[0], v22 = r3[1], w22 = r3[2], _2 = r3[3];
          return t3[0] = b22 * n3 + v22 * o3 + w22 * h22 + _2 * m22, t3[1] = b22 * i3 + v22 * l3 + w22 * p22 + _2 * y22, t3[2] = b22 * s2 + v22 * u3 + w22 * f22 + _2 * g22, t3[3] = b22 * a3 + v22 * c3 + w22 * d22 + _2 * x22, t3[4] = (b22 = r3[4]) * n3 + (v22 = r3[5]) * o3 + (w22 = r3[6]) * h22 + (_2 = r3[7]) * m22, t3[5] = b22 * i3 + v22 * l3 + w22 * p22 + _2 * y22, t3[6] = b22 * s2 + v22 * u3 + w22 * f22 + _2 * g22, t3[7] = b22 * a3 + v22 * c3 + w22 * d22 + _2 * x22, t3[8] = (b22 = r3[8]) * n3 + (v22 = r3[9]) * o3 + (w22 = r3[10]) * h22 + (_2 = r3[11]) * m22, t3[9] = b22 * i3 + v22 * l3 + w22 * p22 + _2 * y22, t3[10] = b22 * s2 + v22 * u3 + w22 * f22 + _2 * g22, t3[11] = b22 * a3 + v22 * c3 + w22 * d22 + _2 * x22, t3[12] = (b22 = r3[12]) * n3 + (v22 = r3[13]) * o3 + (w22 = r3[14]) * h22 + (_2 = r3[15]) * m22, t3[13] = b22 * i3 + v22 * l3 + w22 * p22 + _2 * y22, t3[14] = b22 * s2 + v22 * u3 + w22 * f22 + _2 * g22, t3[15] = b22 * a3 + v22 * c3 + w22 * d22 + _2 * x22, t3;
        }
        function a2(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = n3 + n3, l3 = i3 + i3, u3 = s2 + s2, c3 = n3 * o3, h22 = n3 * l3, p22 = n3 * u3, f22 = i3 * l3, d22 = i3 * u3, m22 = s2 * u3, y22 = a3 * o3, g22 = a3 * l3, x22 = a3 * u3;
          return t3[0] = 1 - (f22 + m22), t3[1] = h22 + x22, t3[2] = p22 - g22, t3[3] = 0, t3[4] = h22 - x22, t3[5] = 1 - (c3 + m22), t3[6] = d22 + y22, t3[7] = 0, t3[8] = p22 + g22, t3[9] = d22 - y22, t3[10] = 1 - (c3 + f22), t3[11] = 0, t3[12] = r3[0], t3[13] = r3[1], t3[14] = r3[2], t3[15] = 1, t3;
        }
        function o2(t3, e3) {
          var r3 = e3[4], n3 = e3[5], i3 = e3[6], s2 = e3[8], a3 = e3[9], o3 = e3[10];
          return t3[0] = Math.hypot(e3[0], e3[1], e3[2]), t3[1] = Math.hypot(r3, n3, i3), t3[2] = Math.hypot(s2, a3, o3), t3;
        }
        function l22(t3, e3, r3, n3, i3) {
          var s2, a3 = 1 / Math.tan(e3 / 2);
          return t3[0] = a3 / r3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = a3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[15] = 0, null != i3 && i3 !== 1 / 0 ? (t3[10] = (i3 + n3) * (s2 = 1 / (n3 - i3)), t3[14] = 2 * i3 * n3 * s2) : (t3[10] = -1, t3[14] = -2 * n3), t3;
        }
        function u22(t3, e3, r3, n3, i3, s2, a3) {
          var o3 = 1 / (e3 - r3), l3 = 1 / (n3 - i3), u3 = 1 / (s2 - a3);
          return t3[0] = -2 * o3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * l3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 2 * u3, t3[11] = 0, t3[12] = (e3 + r3) * o3, t3[13] = (i3 + n3) * l3, t3[14] = (a3 + s2) * u3, t3[15] = 1, t3;
        }
        function c22(t3, e3, r3) {
          return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3[2] = e3[2] - r3[2], t3[3] = e3[3] - r3[3], t3[4] = e3[4] - r3[4], t3[5] = e3[5] - r3[5], t3[6] = e3[6] - r3[6], t3[7] = e3[7] - r3[7], t3[8] = e3[8] - r3[8], t3[9] = e3[9] - r3[9], t3[10] = e3[10] - r3[10], t3[11] = e3[11] - r3[11], t3[12] = e3[12] - r3[12], t3[13] = e3[13] - r3[13], t3[14] = e3[14] - r3[14], t3[15] = e3[15] - r3[15], t3;
        }
        return y2.perspective = l22, y2.ortho = u22, y2.mul = i2, y2.sub = c22, y2;
      }
      var x2, b2 = {}, v2 = {};
      function w2() {
        if (x2)
          return v2;
        function t22(e3) {
          return t22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          }, t22(e3);
        }
        x2 = 1, Object.defineProperty(v2, "__esModule", { value: true }), v2.create = n22, v2.clone = function(t3) {
          var r3 = new e22.ARRAY_TYPE(3);
          return r3[0] = t3[0], r3[1] = t3[1], r3[2] = t3[2], r3;
        }, v2.length = i2, v2.fromValues = function(t3, r3, n3) {
          var i3 = new e22.ARRAY_TYPE(3);
          return i3[0] = t3, i3[1] = r3, i3[2] = n3, i3;
        }, v2.copy = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3;
        }, v2.set = function(t3, e3, r3, n3) {
          return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3;
        }, v2.add = function(t3, e3, r3) {
          return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3;
        }, v2.subtract = a2, v2.multiply = o2, v2.divide = l22, v2.ceil = function(t3, e3) {
          return t3[0] = Math.ceil(e3[0]), t3[1] = Math.ceil(e3[1]), t3[2] = Math.ceil(e3[2]), t3;
        }, v2.floor = function(t3, e3) {
          return t3[0] = Math.floor(e3[0]), t3[1] = Math.floor(e3[1]), t3[2] = Math.floor(e3[2]), t3;
        }, v2.min = function(t3, e3, r3) {
          return t3[0] = Math.min(e3[0], r3[0]), t3[1] = Math.min(e3[1], r3[1]), t3[2] = Math.min(e3[2], r3[2]), t3;
        }, v2.max = function(t3, e3, r3) {
          return t3[0] = Math.max(e3[0], r3[0]), t3[1] = Math.max(e3[1], r3[1]), t3[2] = Math.max(e3[2], r3[2]), t3;
        }, v2.round = function(t3, e3) {
          return t3[0] = Math.round(e3[0]), t3[1] = Math.round(e3[1]), t3[2] = Math.round(e3[2]), t3;
        }, v2.scale = function(t3, e3, r3) {
          return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3;
        }, v2.scaleAndAdd = function(t3, e3, r3, n3) {
          return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3[2] = e3[2] + r3[2] * n3, t3;
        }, v2.distance = u22, v2.squaredDistance = c22, v2.squaredLength = h22, v2.negate = function(t3, e3) {
          return t3[0] = -e3[0], t3[1] = -e3[1], t3[2] = -e3[2], t3;
        }, v2.inverse = function(t3, e3) {
          return t3[0] = 1 / e3[0], t3[1] = 1 / e3[1], t3[2] = 1 / e3[2], t3;
        }, v2.normalize = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = r3 * r3 + n3 * n3 + i3 * i3;
          return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t3[0] = e3[0] * s2, t3[1] = e3[1] * s2, t3[2] = e3[2] * s2, t3;
        }, v2.dot = p22, v2.cross = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = r3[0], o3 = r3[1], l3 = r3[2];
          return t3[0] = i3 * l3 - s2 * o3, t3[1] = s2 * a3 - n3 * l3, t3[2] = n3 * o3 - i3 * a3, t3;
        }, v2.lerp = function(t3, e3, r3, n3) {
          var i3 = e3[0], s2 = e3[1], a3 = e3[2];
          return t3[0] = i3 + n3 * (r3[0] - i3), t3[1] = s2 + n3 * (r3[1] - s2), t3[2] = a3 + n3 * (r3[2] - a3), t3;
        }, v2.hermite = function(t3, e3, r3, n3, i3, s2) {
          var a3 = s2 * s2, o3 = a3 * (2 * s2 - 3) + 1, l3 = a3 * (s2 - 2) + s2, u3 = a3 * (s2 - 1), c3 = a3 * (3 - 2 * s2);
          return t3[0] = e3[0] * o3 + r3[0] * l3 + n3[0] * u3 + i3[0] * c3, t3[1] = e3[1] * o3 + r3[1] * l3 + n3[1] * u3 + i3[1] * c3, t3[2] = e3[2] * o3 + r3[2] * l3 + n3[2] * u3 + i3[2] * c3, t3;
        }, v2.bezier = function(t3, e3, r3, n3, i3, s2) {
          var a3 = 1 - s2, o3 = a3 * a3, l3 = s2 * s2, u3 = o3 * a3, c3 = 3 * s2 * o3, h3 = 3 * l3 * a3, p3 = l3 * s2;
          return t3[0] = e3[0] * u3 + r3[0] * c3 + n3[0] * h3 + i3[0] * p3, t3[1] = e3[1] * u3 + r3[1] * c3 + n3[1] * h3 + i3[1] * p3, t3[2] = e3[2] * u3 + r3[2] * c3 + n3[2] * h3 + i3[2] * p3, t3;
        }, v2.random = function(t3, r3) {
          r3 = r3 || 1;
          var n3 = 2 * e22.RANDOM() * Math.PI, i3 = 2 * e22.RANDOM() - 1, s2 = Math.sqrt(1 - i3 * i3) * r3;
          return t3[0] = Math.cos(n3) * s2, t3[1] = Math.sin(n3) * s2, t3[2] = i3 * r3, t3;
        }, v2.transformMat4 = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = r3[3] * n3 + r3[7] * i3 + r3[11] * s2 + r3[15];
          return t3[0] = (r3[0] * n3 + r3[4] * i3 + r3[8] * s2 + r3[12]) / (a3 = a3 || 1), t3[1] = (r3[1] * n3 + r3[5] * i3 + r3[9] * s2 + r3[13]) / a3, t3[2] = (r3[2] * n3 + r3[6] * i3 + r3[10] * s2 + r3[14]) / a3, t3;
        }, v2.transformMat3 = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2];
          return t3[0] = n3 * r3[0] + i3 * r3[3] + s2 * r3[6], t3[1] = n3 * r3[1] + i3 * r3[4] + s2 * r3[7], t3[2] = n3 * r3[2] + i3 * r3[5] + s2 * r3[8], t3;
        }, v2.transformQuat = function(t3, e3, r3) {
          var n3 = r3[0], i3 = r3[1], s2 = r3[2], a3 = e3[0], o3 = e3[1], l3 = e3[2], u3 = i3 * l3 - s2 * o3, c3 = s2 * a3 - n3 * l3, h3 = n3 * o3 - i3 * a3, p3 = i3 * h3 - s2 * c3, f3 = s2 * u3 - n3 * h3, d3 = n3 * c3 - i3 * u3, m22 = 2 * r3[3];
          return c3 *= m22, h3 *= m22, f3 *= 2, d3 *= 2, t3[0] = a3 + (u3 *= m22) + (p3 *= 2), t3[1] = o3 + c3 + f3, t3[2] = l3 + h3 + d3, t3;
        }, v2.rotateX = function(t3, e3, r3, n3) {
          var i3 = [], s2 = [];
          return i3[0] = e3[0] - r3[0], i3[1] = e3[1] - r3[1], i3[2] = e3[2] - r3[2], s2[0] = i3[0], s2[1] = i3[1] * Math.cos(n3) - i3[2] * Math.sin(n3), s2[2] = i3[1] * Math.sin(n3) + i3[2] * Math.cos(n3), t3[0] = s2[0] + r3[0], t3[1] = s2[1] + r3[1], t3[2] = s2[2] + r3[2], t3;
        }, v2.rotateY = function(t3, e3, r3, n3) {
          var i3 = [], s2 = [];
          return i3[0] = e3[0] - r3[0], i3[1] = e3[1] - r3[1], i3[2] = e3[2] - r3[2], s2[0] = i3[2] * Math.sin(n3) + i3[0] * Math.cos(n3), s2[1] = i3[1], s2[2] = i3[2] * Math.cos(n3) - i3[0] * Math.sin(n3), t3[0] = s2[0] + r3[0], t3[1] = s2[1] + r3[1], t3[2] = s2[2] + r3[2], t3;
        }, v2.rotateZ = function(t3, e3, r3, n3) {
          var i3 = [], s2 = [];
          return i3[0] = e3[0] - r3[0], i3[1] = e3[1] - r3[1], i3[2] = e3[2] - r3[2], s2[0] = i3[0] * Math.cos(n3) - i3[1] * Math.sin(n3), s2[1] = i3[0] * Math.sin(n3) + i3[1] * Math.cos(n3), s2[2] = i3[2], t3[0] = s2[0] + r3[0], t3[1] = s2[1] + r3[1], t3[2] = s2[2] + r3[2], t3;
        }, v2.angle = function(t3, e3) {
          var r3 = t3[0], n3 = t3[1], i3 = t3[2], s2 = e3[0], a3 = e3[1], o3 = e3[2], l3 = Math.sqrt(r3 * r3 + n3 * n3 + i3 * i3) * Math.sqrt(s2 * s2 + a3 * a3 + o3 * o3), u3 = l3 && p22(t3, e3) / l3;
          return Math.acos(Math.min(Math.max(u3, -1), 1));
        }, v2.zero = function(t3) {
          return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3;
        }, v2.str = function(t3) {
          return "vec3(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ")";
        }, v2.exactEquals = function(t3, e3) {
          return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2];
        }, v2.equals = function(t3, r3) {
          var n3 = t3[0], i3 = t3[1], s2 = t3[2], a3 = r3[0], o3 = r3[1], l3 = r3[2];
          return Math.abs(n3 - a3) <= e22.EPSILON * Math.max(1, Math.abs(n3), Math.abs(a3)) && Math.abs(i3 - o3) <= e22.EPSILON * Math.max(1, Math.abs(i3), Math.abs(o3)) && Math.abs(s2 - l3) <= e22.EPSILON * Math.max(1, Math.abs(s2), Math.abs(l3));
        }, v2.forEach = v2.sqrLen = v2.len = v2.sqrDist = v2.dist = v2.div = v2.mul = v2.sub = void 0;
        var e22 = function(e3, n3) {
          if (e3 && e3.__esModule)
            return e3;
          if (null === e3 || "object" !== t22(e3) && "function" != typeof e3)
            return { default: e3 };
          var i3 = r22(void 0);
          if (i3 && i3.has(e3))
            return i3.get(e3);
          var s2 = {}, a3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var o3 in e3)
            if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e3, o3)) {
              var l3 = a3 ? Object.getOwnPropertyDescriptor(e3, o3) : null;
              l3 && (l3.get || l3.set) ? Object.defineProperty(s2, o3, l3) : s2[o3] = e3[o3];
            }
          return s2.default = e3, i3 && i3.set(e3, s2), s2;
        }(s());
        function r22(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
          return (r22 = function(t4) {
            return t4 ? n3 : e3;
          })(t3);
        }
        function n22() {
          var t3 = new e22.ARRAY_TYPE(3);
          return e22.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0), t3;
        }
        function i2(t3) {
          return Math.hypot(t3[0], t3[1], t3[2]);
        }
        function a2(t3, e3, r3) {
          return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3[2] = e3[2] - r3[2], t3;
        }
        function o2(t3, e3, r3) {
          return t3[0] = e3[0] * r3[0], t3[1] = e3[1] * r3[1], t3[2] = e3[2] * r3[2], t3;
        }
        function l22(t3, e3, r3) {
          return t3[0] = e3[0] / r3[0], t3[1] = e3[1] / r3[1], t3[2] = e3[2] / r3[2], t3;
        }
        function u22(t3, e3) {
          return Math.hypot(e3[0] - t3[0], e3[1] - t3[1], e3[2] - t3[2]);
        }
        function c22(t3, e3) {
          var r3 = e3[0] - t3[0], n3 = e3[1] - t3[1], i3 = e3[2] - t3[2];
          return r3 * r3 + n3 * n3 + i3 * i3;
        }
        function h22(t3) {
          var e3 = t3[0], r3 = t3[1], n3 = t3[2];
          return e3 * e3 + r3 * r3 + n3 * n3;
        }
        function p22(t3, e3) {
          return t3[0] * e3[0] + t3[1] * e3[1] + t3[2] * e3[2];
        }
        v2.sub = a2, v2.mul = o2, v2.div = l22, v2.dist = u22, v2.sqrDist = c22, v2.len = i2, v2.sqrLen = h22;
        var f22, d22 = (f22 = n22(), function(t3, e3, r3, n3, i3, s2) {
          var a3, o3;
          for (e3 || (e3 = 3), r3 || (r3 = 0), o3 = n3 ? Math.min(n3 * e3 + r3, t3.length) : t3.length, a3 = r3; a3 < o3; a3 += e3)
            f22[0] = t3[a3], f22[1] = t3[a3 + 1], f22[2] = t3[a3 + 2], i3(f22, f22, s2), t3[a3] = f22[0], t3[a3 + 1] = f22[1], t3[a3 + 2] = f22[2];
          return t3;
        });
        return v2.forEach = d22, v2;
      }
      var _, M2, A2 = {};
      function S2() {
        if (_)
          return A2;
        function t22(e3) {
          return t22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          }, t22(e3);
        }
        _ = 1, Object.defineProperty(A2, "__esModule", { value: true }), A2.create = n22, A2.clone = function(t3) {
          var r3 = new e22.ARRAY_TYPE(4);
          return r3[0] = t3[0], r3[1] = t3[1], r3[2] = t3[2], r3[3] = t3[3], r3;
        }, A2.fromValues = function(t3, r3, n3, i3) {
          var s2 = new e22.ARRAY_TYPE(4);
          return s2[0] = t3, s2[1] = r3, s2[2] = n3, s2[3] = i3, s2;
        }, A2.copy = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3;
        }, A2.set = function(t3, e3, r3, n3, i3) {
          return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3[3] = i3, t3;
        }, A2.add = function(t3, e3, r3) {
          return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3[3] = e3[3] + r3[3], t3;
        }, A2.subtract = i2, A2.multiply = a2, A2.divide = o2, A2.ceil = function(t3, e3) {
          return t3[0] = Math.ceil(e3[0]), t3[1] = Math.ceil(e3[1]), t3[2] = Math.ceil(e3[2]), t3[3] = Math.ceil(e3[3]), t3;
        }, A2.floor = function(t3, e3) {
          return t3[0] = Math.floor(e3[0]), t3[1] = Math.floor(e3[1]), t3[2] = Math.floor(e3[2]), t3[3] = Math.floor(e3[3]), t3;
        }, A2.min = function(t3, e3, r3) {
          return t3[0] = Math.min(e3[0], r3[0]), t3[1] = Math.min(e3[1], r3[1]), t3[2] = Math.min(e3[2], r3[2]), t3[3] = Math.min(e3[3], r3[3]), t3;
        }, A2.max = function(t3, e3, r3) {
          return t3[0] = Math.max(e3[0], r3[0]), t3[1] = Math.max(e3[1], r3[1]), t3[2] = Math.max(e3[2], r3[2]), t3[3] = Math.max(e3[3], r3[3]), t3;
        }, A2.round = function(t3, e3) {
          return t3[0] = Math.round(e3[0]), t3[1] = Math.round(e3[1]), t3[2] = Math.round(e3[2]), t3[3] = Math.round(e3[3]), t3;
        }, A2.scale = function(t3, e3, r3) {
          return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3[3] = e3[3] * r3, t3;
        }, A2.scaleAndAdd = function(t3, e3, r3, n3) {
          return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3[2] = e3[2] + r3[2] * n3, t3[3] = e3[3] + r3[3] * n3, t3;
        }, A2.distance = l22, A2.squaredDistance = u22, A2.length = c22, A2.squaredLength = h22, A2.negate = function(t3, e3) {
          return t3[0] = -e3[0], t3[1] = -e3[1], t3[2] = -e3[2], t3[3] = -e3[3], t3;
        }, A2.inverse = function(t3, e3) {
          return t3[0] = 1 / e3[0], t3[1] = 1 / e3[1], t3[2] = 1 / e3[2], t3[3] = 1 / e3[3], t3;
        }, A2.normalize = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a3 = r3 * r3 + n3 * n3 + i3 * i3 + s2 * s2;
          return a3 > 0 && (a3 = 1 / Math.sqrt(a3)), t3[0] = r3 * a3, t3[1] = n3 * a3, t3[2] = i3 * a3, t3[3] = s2 * a3, t3;
        }, A2.dot = function(t3, e3) {
          return t3[0] * e3[0] + t3[1] * e3[1] + t3[2] * e3[2] + t3[3] * e3[3];
        }, A2.cross = function(t3, e3, r3, n3) {
          var i3 = r3[0] * n3[1] - r3[1] * n3[0], s2 = r3[0] * n3[2] - r3[2] * n3[0], a3 = r3[0] * n3[3] - r3[3] * n3[0], o3 = r3[1] * n3[2] - r3[2] * n3[1], l3 = r3[1] * n3[3] - r3[3] * n3[1], u3 = r3[2] * n3[3] - r3[3] * n3[2], c3 = e3[0], h3 = e3[1], p3 = e3[2], f3 = e3[3];
          return t3[0] = h3 * u3 - p3 * l3 + f3 * o3, t3[1] = -c3 * u3 + p3 * a3 - f3 * s2, t3[2] = c3 * l3 - h3 * a3 + f3 * i3, t3[3] = -c3 * o3 + h3 * s2 - p3 * i3, t3;
        }, A2.lerp = function(t3, e3, r3, n3) {
          var i3 = e3[0], s2 = e3[1], a3 = e3[2], o3 = e3[3];
          return t3[0] = i3 + n3 * (r3[0] - i3), t3[1] = s2 + n3 * (r3[1] - s2), t3[2] = a3 + n3 * (r3[2] - a3), t3[3] = o3 + n3 * (r3[3] - o3), t3;
        }, A2.random = function(t3, r3) {
          var n3, i3, s2, a3, o3, l3;
          r3 = r3 || 1;
          do {
            o3 = (n3 = 2 * e22.RANDOM() - 1) * n3 + (i3 = 2 * e22.RANDOM() - 1) * i3;
          } while (o3 >= 1);
          do {
            l3 = (s2 = 2 * e22.RANDOM() - 1) * s2 + (a3 = 2 * e22.RANDOM() - 1) * a3;
          } while (l3 >= 1);
          var u3 = Math.sqrt((1 - o3) / l3);
          return t3[0] = r3 * n3, t3[1] = r3 * i3, t3[2] = r3 * s2 * u3, t3[3] = r3 * a3 * u3, t3;
        }, A2.transformMat4 = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3];
          return t3[0] = r3[0] * n3 + r3[4] * i3 + r3[8] * s2 + r3[12] * a3, t3[1] = r3[1] * n3 + r3[5] * i3 + r3[9] * s2 + r3[13] * a3, t3[2] = r3[2] * n3 + r3[6] * i3 + r3[10] * s2 + r3[14] * a3, t3[3] = r3[3] * n3 + r3[7] * i3 + r3[11] * s2 + r3[15] * a3, t3;
        }, A2.transformQuat = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = r3[0], o3 = r3[1], l3 = r3[2], u3 = r3[3], c3 = u3 * n3 + o3 * s2 - l3 * i3, h3 = u3 * i3 + l3 * n3 - a3 * s2, p3 = u3 * s2 + a3 * i3 - o3 * n3, f3 = -a3 * n3 - o3 * i3 - l3 * s2;
          return t3[0] = c3 * u3 + f3 * -a3 + h3 * -l3 - p3 * -o3, t3[1] = h3 * u3 + f3 * -o3 + p3 * -a3 - c3 * -l3, t3[2] = p3 * u3 + f3 * -l3 + c3 * -o3 - h3 * -a3, t3[3] = e3[3], t3;
        }, A2.zero = function(t3) {
          return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3;
        }, A2.str = function(t3) {
          return "vec4(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ")";
        }, A2.exactEquals = function(t3, e3) {
          return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3];
        }, A2.equals = function(t3, r3) {
          var n3 = t3[0], i3 = t3[1], s2 = t3[2], a3 = t3[3], o3 = r3[0], l3 = r3[1], u3 = r3[2], c3 = r3[3];
          return Math.abs(n3 - o3) <= e22.EPSILON * Math.max(1, Math.abs(n3), Math.abs(o3)) && Math.abs(i3 - l3) <= e22.EPSILON * Math.max(1, Math.abs(i3), Math.abs(l3)) && Math.abs(s2 - u3) <= e22.EPSILON * Math.max(1, Math.abs(s2), Math.abs(u3)) && Math.abs(a3 - c3) <= e22.EPSILON * Math.max(1, Math.abs(a3), Math.abs(c3));
        }, A2.forEach = A2.sqrLen = A2.len = A2.sqrDist = A2.dist = A2.div = A2.mul = A2.sub = void 0;
        var e22 = function(e3, n3) {
          if (e3 && e3.__esModule)
            return e3;
          if (null === e3 || "object" !== t22(e3) && "function" != typeof e3)
            return { default: e3 };
          var i3 = r22(void 0);
          if (i3 && i3.has(e3))
            return i3.get(e3);
          var s2 = {}, a3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var o3 in e3)
            if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e3, o3)) {
              var l3 = a3 ? Object.getOwnPropertyDescriptor(e3, o3) : null;
              l3 && (l3.get || l3.set) ? Object.defineProperty(s2, o3, l3) : s2[o3] = e3[o3];
            }
          return s2.default = e3, i3 && i3.set(e3, s2), s2;
        }(s());
        function r22(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
          return (r22 = function(t4) {
            return t4 ? n3 : e3;
          })(t3);
        }
        function n22() {
          var t3 = new e22.ARRAY_TYPE(4);
          return e22.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 0), t3;
        }
        function i2(t3, e3, r3) {
          return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3[2] = e3[2] - r3[2], t3[3] = e3[3] - r3[3], t3;
        }
        function a2(t3, e3, r3) {
          return t3[0] = e3[0] * r3[0], t3[1] = e3[1] * r3[1], t3[2] = e3[2] * r3[2], t3[3] = e3[3] * r3[3], t3;
        }
        function o2(t3, e3, r3) {
          return t3[0] = e3[0] / r3[0], t3[1] = e3[1] / r3[1], t3[2] = e3[2] / r3[2], t3[3] = e3[3] / r3[3], t3;
        }
        function l22(t3, e3) {
          return Math.hypot(e3[0] - t3[0], e3[1] - t3[1], e3[2] - t3[2], e3[3] - t3[3]);
        }
        function u22(t3, e3) {
          var r3 = e3[0] - t3[0], n3 = e3[1] - t3[1], i3 = e3[2] - t3[2], s2 = e3[3] - t3[3];
          return r3 * r3 + n3 * n3 + i3 * i3 + s2 * s2;
        }
        function c22(t3) {
          return Math.hypot(t3[0], t3[1], t3[2], t3[3]);
        }
        function h22(t3) {
          var e3 = t3[0], r3 = t3[1], n3 = t3[2], i3 = t3[3];
          return e3 * e3 + r3 * r3 + n3 * n3 + i3 * i3;
        }
        A2.sub = i2, A2.mul = a2, A2.div = o2, A2.dist = l22, A2.sqrDist = u22, A2.len = c22, A2.sqrLen = h22;
        var p22, f22 = (p22 = n22(), function(t3, e3, r3, n3, i3, s2) {
          var a3, o3;
          for (e3 || (e3 = 4), r3 || (r3 = 0), o3 = n3 ? Math.min(n3 * e3 + r3, t3.length) : t3.length, a3 = r3; a3 < o3; a3 += e3)
            p22[0] = t3[a3], p22[1] = t3[a3 + 1], p22[2] = t3[a3 + 2], p22[3] = t3[a3 + 3], i3(p22, p22, s2), t3[a3] = p22[0], t3[a3 + 1] = p22[1], t3[a3 + 2] = p22[2], t3[a3 + 3] = p22[3];
          return t3;
        });
        return A2.forEach = f22, A2;
      }
      function I2() {
        if (M2)
          return b2;
        function t22(e3) {
          return t22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          }, t22(e3);
        }
        M2 = 1, Object.defineProperty(b2, "__esModule", { value: true }), b2.create = l22, b2.identity = function(t3) {
          return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3;
        }, b2.setAxisAngle = u22, b2.getAxisAngle = function(t3, r3) {
          var n3 = 2 * Math.acos(r3[3]), i3 = Math.sin(n3 / 2);
          return i3 > e22.EPSILON ? (t3[0] = r3[0] / i3, t3[1] = r3[1] / i3, t3[2] = r3[2] / i3) : (t3[0] = 1, t3[1] = 0, t3[2] = 0), n3;
        }, b2.getAngle = function(t3, e3) {
          var r3 = g22(t3, e3);
          return Math.acos(2 * r3 * r3 - 1);
        }, b2.multiply = c22, b2.rotateX = function(t3, e3, r3) {
          r3 *= 0.5;
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = Math.sin(r3), l3 = Math.cos(r3);
          return t3[0] = n3 * l3 + a3 * o3, t3[1] = i3 * l3 + s2 * o3, t3[2] = s2 * l3 - i3 * o3, t3[3] = a3 * l3 - n3 * o3, t3;
        }, b2.rotateY = function(t3, e3, r3) {
          r3 *= 0.5;
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = Math.sin(r3), l3 = Math.cos(r3);
          return t3[0] = n3 * l3 - s2 * o3, t3[1] = i3 * l3 + a3 * o3, t3[2] = s2 * l3 + n3 * o3, t3[3] = a3 * l3 - i3 * o3, t3;
        }, b2.rotateZ = function(t3, e3, r3) {
          r3 *= 0.5;
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = Math.sin(r3), l3 = Math.cos(r3);
          return t3[0] = n3 * l3 + i3 * o3, t3[1] = i3 * l3 - n3 * o3, t3[2] = s2 * l3 + a3 * o3, t3[3] = a3 * l3 - s2 * o3, t3;
        }, b2.calculateW = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2];
          return t3[0] = r3, t3[1] = n3, t3[2] = i3, t3[3] = Math.sqrt(Math.abs(1 - r3 * r3 - n3 * n3 - i3 * i3)), t3;
        }, b2.exp = h22, b2.ln = p22, b2.pow = function(t3, e3, r3) {
          return p22(t3, e3), y22(t3, t3, r3), h22(t3, t3), t3;
        }, b2.slerp = f22, b2.random = function(t3) {
          var r3 = e22.RANDOM(), n3 = e22.RANDOM(), i3 = e22.RANDOM(), s2 = Math.sqrt(1 - r3), a3 = Math.sqrt(r3);
          return t3[0] = s2 * Math.sin(2 * Math.PI * n3), t3[1] = s2 * Math.cos(2 * Math.PI * n3), t3[2] = a3 * Math.sin(2 * Math.PI * i3), t3[3] = a3 * Math.cos(2 * Math.PI * i3), t3;
        }, b2.invert = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a3 = r3 * r3 + n3 * n3 + i3 * i3 + s2 * s2, o3 = a3 ? 1 / a3 : 0;
          return t3[0] = -r3 * o3, t3[1] = -n3 * o3, t3[2] = -i3 * o3, t3[3] = s2 * o3, t3;
        }, b2.conjugate = function(t3, e3) {
          return t3[0] = -e3[0], t3[1] = -e3[1], t3[2] = -e3[2], t3[3] = e3[3], t3;
        }, b2.fromMat3 = m22, b2.fromEuler = function(t3, e3, r3, n3) {
          var i3 = 0.5 * Math.PI / 180;
          e3 *= i3, r3 *= i3, n3 *= i3;
          var s2 = Math.sin(e3), a3 = Math.cos(e3), o3 = Math.sin(r3), l3 = Math.cos(r3), u3 = Math.sin(n3), c3 = Math.cos(n3);
          return t3[0] = s2 * l3 * c3 - a3 * o3 * u3, t3[1] = a3 * o3 * c3 + s2 * l3 * u3, t3[2] = a3 * l3 * u3 - s2 * o3 * c3, t3[3] = a3 * l3 * c3 + s2 * o3 * u3, t3;
        }, b2.str = function(t3) {
          return "quat(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ")";
        }, b2.setAxes = b2.sqlerp = b2.rotationTo = b2.equals = b2.exactEquals = b2.normalize = b2.sqrLen = b2.squaredLength = b2.len = b2.length = b2.lerp = b2.dot = b2.scale = b2.mul = b2.add = b2.set = b2.copy = b2.fromValues = b2.clone = void 0;
        var e22 = o2(s()), r22 = o2(d2()), n22 = o2(w2()), i2 = o2(S2());
        function a2(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e3 = /* @__PURE__ */ new WeakMap(), r3 = /* @__PURE__ */ new WeakMap();
          return (a2 = function(t4) {
            return t4 ? r3 : e3;
          })(t3);
        }
        function o2(e3, r3) {
          if (e3 && e3.__esModule)
            return e3;
          if (null === e3 || "object" !== t22(e3) && "function" != typeof e3)
            return { default: e3 };
          var n3 = a2(r3);
          if (n3 && n3.has(e3))
            return n3.get(e3);
          var i3 = {}, s2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var o3 in e3)
            if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e3, o3)) {
              var l3 = s2 ? Object.getOwnPropertyDescriptor(e3, o3) : null;
              l3 && (l3.get || l3.set) ? Object.defineProperty(i3, o3, l3) : i3[o3] = e3[o3];
            }
          return i3.default = e3, n3 && n3.set(e3, i3), i3;
        }
        function l22() {
          var t3 = new e22.ARRAY_TYPE(4);
          return e22.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0), t3[3] = 1, t3;
        }
        function u22(t3, e3, r3) {
          r3 *= 0.5;
          var n3 = Math.sin(r3);
          return t3[0] = n3 * e3[0], t3[1] = n3 * e3[1], t3[2] = n3 * e3[2], t3[3] = Math.cos(r3), t3;
        }
        function c22(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = r3[0], l3 = r3[1], u3 = r3[2], c3 = r3[3];
          return t3[0] = n3 * c3 + a3 * o3 + i3 * u3 - s2 * l3, t3[1] = i3 * c3 + a3 * l3 + s2 * o3 - n3 * u3, t3[2] = s2 * c3 + a3 * u3 + n3 * l3 - i3 * o3, t3[3] = a3 * c3 - n3 * o3 - i3 * l3 - s2 * u3, t3;
        }
        function h22(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a3 = Math.sqrt(r3 * r3 + n3 * n3 + i3 * i3), o3 = Math.exp(s2), l3 = a3 > 0 ? o3 * Math.sin(a3) / a3 : 0;
          return t3[0] = r3 * l3, t3[1] = n3 * l3, t3[2] = i3 * l3, t3[3] = o3 * Math.cos(a3), t3;
        }
        function p22(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a3 = Math.sqrt(r3 * r3 + n3 * n3 + i3 * i3), o3 = a3 > 0 ? Math.atan2(a3, s2) / a3 : 0;
          return t3[0] = r3 * o3, t3[1] = n3 * o3, t3[2] = i3 * o3, t3[3] = 0.5 * Math.log(r3 * r3 + n3 * n3 + i3 * i3 + s2 * s2), t3;
        }
        function f22(t3, r3, n3, i3) {
          var s2, a3, o3, l3, u3, c3 = r3[0], h3 = r3[1], p3 = r3[2], f3 = r3[3], d22 = n3[0], m3 = n3[1], y3 = n3[2], g3 = n3[3];
          return (a3 = c3 * d22 + h3 * m3 + p3 * y3 + f3 * g3) < 0 && (a3 = -a3, d22 = -d22, m3 = -m3, y3 = -y3, g3 = -g3), 1 - a3 > e22.EPSILON ? (s2 = Math.acos(a3), o3 = Math.sin(s2), l3 = Math.sin((1 - i3) * s2) / o3, u3 = Math.sin(i3 * s2) / o3) : (l3 = 1 - i3, u3 = i3), t3[0] = l3 * c3 + u3 * d22, t3[1] = l3 * h3 + u3 * m3, t3[2] = l3 * p3 + u3 * y3, t3[3] = l3 * f3 + u3 * g3, t3;
        }
        function m22(t3, e3) {
          var r3, n3 = e3[0] + e3[4] + e3[8];
          if (n3 > 0)
            r3 = Math.sqrt(n3 + 1), t3[3] = 0.5 * r3, t3[0] = (e3[5] - e3[7]) * (r3 = 0.5 / r3), t3[1] = (e3[6] - e3[2]) * r3, t3[2] = (e3[1] - e3[3]) * r3;
          else {
            var i3 = 0;
            e3[4] > e3[0] && (i3 = 1), e3[8] > e3[3 * i3 + i3] && (i3 = 2);
            var s2 = (i3 + 1) % 3, a3 = (i3 + 2) % 3;
            r3 = Math.sqrt(e3[3 * i3 + i3] - e3[3 * s2 + s2] - e3[3 * a3 + a3] + 1), t3[i3] = 0.5 * r3, t3[3] = (e3[3 * s2 + a3] - e3[3 * a3 + s2]) * (r3 = 0.5 / r3), t3[s2] = (e3[3 * s2 + i3] + e3[3 * i3 + s2]) * r3, t3[a3] = (e3[3 * a3 + i3] + e3[3 * i3 + a3]) * r3;
          }
          return t3;
        }
        b2.clone = i2.clone, b2.fromValues = i2.fromValues, b2.copy = i2.copy, b2.set = i2.set, b2.add = i2.add, b2.mul = c22;
        var y22 = i2.scale;
        b2.scale = y22;
        var g22 = i2.dot;
        b2.dot = g22, b2.lerp = i2.lerp;
        var x22 = i2.length;
        b2.length = x22, b2.len = x22;
        var v22 = i2.squaredLength;
        b2.squaredLength = v22, b2.sqrLen = v22;
        var _2 = i2.normalize;
        b2.normalize = _2, b2.exactEquals = i2.exactEquals, b2.equals = i2.equals;
        var A22, I22, P22, z22 = (A22 = n22.create(), I22 = n22.fromValues(1, 0, 0), P22 = n22.fromValues(0, 1, 0), function(t3, e3, r3) {
          var i3 = n22.dot(e3, r3);
          return i3 < -0.999999 ? (n22.cross(A22, I22, e3), n22.len(A22) < 1e-6 && n22.cross(A22, P22, e3), n22.normalize(A22, A22), u22(t3, A22, Math.PI), t3) : i3 > 0.999999 ? (t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3) : (n22.cross(A22, e3, r3), t3[0] = A22[0], t3[1] = A22[1], t3[2] = A22[2], t3[3] = 1 + i3, _2(t3, t3));
        });
        b2.rotationTo = z22;
        var k22, T22, E22 = (k22 = l22(), T22 = l22(), function(t3, e3, r3, n3, i3, s2) {
          return f22(k22, e3, i3, s2), f22(T22, r3, n3, s2), f22(t3, k22, T22, 2 * s2 * (1 - s2)), t3;
        });
        b2.sqlerp = E22;
        var B22, V22 = (B22 = r22.create(), function(t3, e3, r3, n3) {
          return B22[0] = r3[0], B22[3] = r3[1], B22[6] = r3[2], B22[1] = n3[0], B22[4] = n3[1], B22[7] = n3[2], B22[2] = -e3[0], B22[5] = -e3[1], B22[8] = -e3[2], _2(t3, m22(t3, B22));
        });
        return b2.setAxes = V22, b2;
      }
      var P2, z2 = {};
      function k2() {
        if (P2)
          return z2;
        function t22(e3) {
          return t22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          }, t22(e3);
        }
        P2 = 1, Object.defineProperty(z2, "__esModule", { value: true }), z2.create = function() {
          var t3 = new e22.ARRAY_TYPE(8);
          return e22.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[4] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0), t3[3] = 1, t3;
        }, z2.clone = function(t3) {
          var r3 = new e22.ARRAY_TYPE(8);
          return r3[0] = t3[0], r3[1] = t3[1], r3[2] = t3[2], r3[3] = t3[3], r3[4] = t3[4], r3[5] = t3[5], r3[6] = t3[6], r3[7] = t3[7], r3;
        }, z2.fromValues = function(t3, r3, n3, i3, s2, a3, o3, l3) {
          var u3 = new e22.ARRAY_TYPE(8);
          return u3[0] = t3, u3[1] = r3, u3[2] = n3, u3[3] = i3, u3[4] = s2, u3[5] = a3, u3[6] = o3, u3[7] = l3, u3;
        }, z2.fromRotationTranslationValues = function(t3, r3, n3, i3, s2, a3, o3) {
          var l3 = new e22.ARRAY_TYPE(8);
          l3[0] = t3, l3[1] = r3, l3[2] = n3, l3[3] = i3;
          var u3 = 0.5 * s2, c3 = 0.5 * a3, h3 = 0.5 * o3;
          return l3[4] = u3 * i3 + c3 * n3 - h3 * r3, l3[5] = c3 * i3 + h3 * t3 - u3 * n3, l3[6] = h3 * i3 + u3 * r3 - c3 * t3, l3[7] = -u3 * t3 - c3 * r3 - h3 * n3, l3;
        }, z2.fromRotationTranslation = o2, z2.fromTranslation = function(t3, e3) {
          return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3[4] = 0.5 * e3[0], t3[5] = 0.5 * e3[1], t3[6] = 0.5 * e3[2], t3[7] = 0, t3;
        }, z2.fromRotation = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[4] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3;
        }, z2.fromMat4 = function(t3, i3) {
          var s2 = r22.create();
          n22.getRotation(s2, i3);
          var a3 = new e22.ARRAY_TYPE(3);
          return n22.getTranslation(a3, i3), o2(t3, s2, a3), t3;
        }, z2.copy = l22, z2.identity = function(t3) {
          return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3[4] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3;
        }, z2.set = function(t3, e3, r3, n3, i3, s2, a3, o3, l3) {
          return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3[3] = i3, t3[4] = s2, t3[5] = a3, t3[6] = o3, t3[7] = l3, t3;
        }, z2.getDual = function(t3, e3) {
          return t3[0] = e3[4], t3[1] = e3[5], t3[2] = e3[6], t3[3] = e3[7], t3;
        }, z2.setDual = function(t3, e3) {
          return t3[4] = e3[0], t3[5] = e3[1], t3[6] = e3[2], t3[7] = e3[3], t3;
        }, z2.getTranslation = function(t3, e3) {
          var r3 = e3[4], n3 = e3[5], i3 = e3[6], s2 = e3[7], a3 = -e3[0], o3 = -e3[1], l3 = -e3[2], u3 = e3[3];
          return t3[0] = 2 * (r3 * u3 + s2 * a3 + n3 * l3 - i3 * o3), t3[1] = 2 * (n3 * u3 + s2 * o3 + i3 * a3 - r3 * l3), t3[2] = 2 * (i3 * u3 + s2 * l3 + r3 * o3 - n3 * a3), t3;
        }, z2.translate = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = 0.5 * r3[0], l3 = 0.5 * r3[1], u3 = 0.5 * r3[2], c3 = e3[4], h3 = e3[5], p3 = e3[6], f22 = e3[7];
          return t3[0] = n3, t3[1] = i3, t3[2] = s2, t3[3] = a3, t3[4] = a3 * o3 + i3 * u3 - s2 * l3 + c3, t3[5] = a3 * l3 + s2 * o3 - n3 * u3 + h3, t3[6] = a3 * u3 + n3 * l3 - i3 * o3 + p3, t3[7] = -n3 * o3 - i3 * l3 - s2 * u3 + f22, t3;
        }, z2.rotateX = function(t3, e3, n3) {
          var i3 = -e3[0], s2 = -e3[1], a3 = -e3[2], o3 = e3[3], l3 = e3[4], u3 = e3[5], c3 = e3[6], h3 = e3[7], p3 = l3 * o3 + h3 * i3 + u3 * a3 - c3 * s2, f22 = u3 * o3 + h3 * s2 + c3 * i3 - l3 * a3, d22 = c3 * o3 + h3 * a3 + l3 * s2 - u3 * i3, m22 = h3 * o3 - l3 * i3 - u3 * s2 - c3 * a3;
          return r22.rotateX(t3, e3, n3), t3[4] = p3 * (o3 = t3[3]) + m22 * (i3 = t3[0]) + f22 * (a3 = t3[2]) - d22 * (s2 = t3[1]), t3[5] = f22 * o3 + m22 * s2 + d22 * i3 - p3 * a3, t3[6] = d22 * o3 + m22 * a3 + p3 * s2 - f22 * i3, t3[7] = m22 * o3 - p3 * i3 - f22 * s2 - d22 * a3, t3;
        }, z2.rotateY = function(t3, e3, n3) {
          var i3 = -e3[0], s2 = -e3[1], a3 = -e3[2], o3 = e3[3], l3 = e3[4], u3 = e3[5], c3 = e3[6], h3 = e3[7], p3 = l3 * o3 + h3 * i3 + u3 * a3 - c3 * s2, f22 = u3 * o3 + h3 * s2 + c3 * i3 - l3 * a3, d22 = c3 * o3 + h3 * a3 + l3 * s2 - u3 * i3, m22 = h3 * o3 - l3 * i3 - u3 * s2 - c3 * a3;
          return r22.rotateY(t3, e3, n3), t3[4] = p3 * (o3 = t3[3]) + m22 * (i3 = t3[0]) + f22 * (a3 = t3[2]) - d22 * (s2 = t3[1]), t3[5] = f22 * o3 + m22 * s2 + d22 * i3 - p3 * a3, t3[6] = d22 * o3 + m22 * a3 + p3 * s2 - f22 * i3, t3[7] = m22 * o3 - p3 * i3 - f22 * s2 - d22 * a3, t3;
        }, z2.rotateZ = function(t3, e3, n3) {
          var i3 = -e3[0], s2 = -e3[1], a3 = -e3[2], o3 = e3[3], l3 = e3[4], u3 = e3[5], c3 = e3[6], h3 = e3[7], p3 = l3 * o3 + h3 * i3 + u3 * a3 - c3 * s2, f22 = u3 * o3 + h3 * s2 + c3 * i3 - l3 * a3, d22 = c3 * o3 + h3 * a3 + l3 * s2 - u3 * i3, m22 = h3 * o3 - l3 * i3 - u3 * s2 - c3 * a3;
          return r22.rotateZ(t3, e3, n3), t3[4] = p3 * (o3 = t3[3]) + m22 * (i3 = t3[0]) + f22 * (a3 = t3[2]) - d22 * (s2 = t3[1]), t3[5] = f22 * o3 + m22 * s2 + d22 * i3 - p3 * a3, t3[6] = d22 * o3 + m22 * a3 + p3 * s2 - f22 * i3, t3[7] = m22 * o3 - p3 * i3 - f22 * s2 - d22 * a3, t3;
        }, z2.rotateByQuatAppend = function(t3, e3, r3) {
          var n3 = r3[0], i3 = r3[1], s2 = r3[2], a3 = r3[3], o3 = e3[0], l3 = e3[1], u3 = e3[2], c3 = e3[3];
          return t3[0] = o3 * a3 + c3 * n3 + l3 * s2 - u3 * i3, t3[1] = l3 * a3 + c3 * i3 + u3 * n3 - o3 * s2, t3[2] = u3 * a3 + c3 * s2 + o3 * i3 - l3 * n3, t3[3] = c3 * a3 - o3 * n3 - l3 * i3 - u3 * s2, t3[4] = (o3 = e3[4]) * a3 + (c3 = e3[7]) * n3 + (l3 = e3[5]) * s2 - (u3 = e3[6]) * i3, t3[5] = l3 * a3 + c3 * i3 + u3 * n3 - o3 * s2, t3[6] = u3 * a3 + c3 * s2 + o3 * i3 - l3 * n3, t3[7] = c3 * a3 - o3 * n3 - l3 * i3 - u3 * s2, t3;
        }, z2.rotateByQuatPrepend = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = r3[0], l3 = r3[1], u3 = r3[2], c3 = r3[3];
          return t3[0] = n3 * c3 + a3 * o3 + i3 * u3 - s2 * l3, t3[1] = i3 * c3 + a3 * l3 + s2 * o3 - n3 * u3, t3[2] = s2 * c3 + a3 * u3 + n3 * l3 - i3 * o3, t3[3] = a3 * c3 - n3 * o3 - i3 * l3 - s2 * u3, t3[4] = n3 * (c3 = r3[7]) + a3 * (o3 = r3[4]) + i3 * (u3 = r3[6]) - s2 * (l3 = r3[5]), t3[5] = i3 * c3 + a3 * l3 + s2 * o3 - n3 * u3, t3[6] = s2 * c3 + a3 * u3 + n3 * l3 - i3 * o3, t3[7] = a3 * c3 - n3 * o3 - i3 * l3 - s2 * u3, t3;
        }, z2.rotateAroundAxis = function(t3, r3, n3, i3) {
          if (Math.abs(i3) < e22.EPSILON)
            return l22(t3, r3);
          var s2 = Math.hypot(n3[0], n3[1], n3[2]);
          i3 *= 0.5;
          var a3 = Math.sin(i3), o3 = a3 * n3[0] / s2, u3 = a3 * n3[1] / s2, c3 = a3 * n3[2] / s2, h3 = Math.cos(i3), p3 = r3[0], f22 = r3[1], d22 = r3[2], m22 = r3[3];
          t3[0] = p3 * h3 + m22 * o3 + f22 * c3 - d22 * u3, t3[1] = f22 * h3 + m22 * u3 + d22 * o3 - p3 * c3, t3[2] = d22 * h3 + m22 * c3 + p3 * u3 - f22 * o3, t3[3] = m22 * h3 - p3 * o3 - f22 * u3 - d22 * c3;
          var y22 = r3[4], g22 = r3[5], x22 = r3[6], b22 = r3[7];
          return t3[4] = y22 * h3 + b22 * o3 + g22 * c3 - x22 * u3, t3[5] = g22 * h3 + b22 * u3 + x22 * o3 - y22 * c3, t3[6] = x22 * h3 + b22 * c3 + y22 * u3 - g22 * o3, t3[7] = b22 * h3 - y22 * o3 - g22 * u3 - x22 * c3, t3;
        }, z2.add = function(t3, e3, r3) {
          return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3[3] = e3[3] + r3[3], t3[4] = e3[4] + r3[4], t3[5] = e3[5] + r3[5], t3[6] = e3[6] + r3[6], t3[7] = e3[7] + r3[7], t3;
        }, z2.multiply = u22, z2.scale = function(t3, e3, r3) {
          return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3[3] = e3[3] * r3, t3[4] = e3[4] * r3, t3[5] = e3[5] * r3, t3[6] = e3[6] * r3, t3[7] = e3[7] * r3, t3;
        }, z2.lerp = function(t3, e3, r3, n3) {
          var i3 = 1 - n3;
          return c22(e3, r3) < 0 && (n3 = -n3), t3[0] = e3[0] * i3 + r3[0] * n3, t3[1] = e3[1] * i3 + r3[1] * n3, t3[2] = e3[2] * i3 + r3[2] * n3, t3[3] = e3[3] * i3 + r3[3] * n3, t3[4] = e3[4] * i3 + r3[4] * n3, t3[5] = e3[5] * i3 + r3[5] * n3, t3[6] = e3[6] * i3 + r3[6] * n3, t3[7] = e3[7] * i3 + r3[7] * n3, t3;
        }, z2.invert = function(t3, e3) {
          var r3 = p22(e3);
          return t3[0] = -e3[0] / r3, t3[1] = -e3[1] / r3, t3[2] = -e3[2] / r3, t3[3] = e3[3] / r3, t3[4] = -e3[4] / r3, t3[5] = -e3[5] / r3, t3[6] = -e3[6] / r3, t3[7] = e3[7] / r3, t3;
        }, z2.conjugate = function(t3, e3) {
          return t3[0] = -e3[0], t3[1] = -e3[1], t3[2] = -e3[2], t3[3] = e3[3], t3[4] = -e3[4], t3[5] = -e3[5], t3[6] = -e3[6], t3[7] = e3[7], t3;
        }, z2.normalize = function(t3, e3) {
          var r3 = p22(e3);
          if (r3 > 0) {
            r3 = Math.sqrt(r3);
            var n3 = e3[0] / r3, i3 = e3[1] / r3, s2 = e3[2] / r3, a3 = e3[3] / r3, o3 = e3[4], l3 = e3[5], u3 = e3[6], c3 = e3[7], h3 = n3 * o3 + i3 * l3 + s2 * u3 + a3 * c3;
            t3[0] = n3, t3[1] = i3, t3[2] = s2, t3[3] = a3, t3[4] = (o3 - n3 * h3) / r3, t3[5] = (l3 - i3 * h3) / r3, t3[6] = (u3 - s2 * h3) / r3, t3[7] = (c3 - a3 * h3) / r3;
          }
          return t3;
        }, z2.str = function(t3) {
          return "quat2(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ", " + t3[4] + ", " + t3[5] + ", " + t3[6] + ", " + t3[7] + ")";
        }, z2.exactEquals = function(t3, e3) {
          return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3] && t3[4] === e3[4] && t3[5] === e3[5] && t3[6] === e3[6] && t3[7] === e3[7];
        }, z2.equals = function(t3, r3) {
          var n3 = t3[0], i3 = t3[1], s2 = t3[2], a3 = t3[3], o3 = t3[4], l3 = t3[5], u3 = t3[6], c3 = t3[7], h3 = r3[0], p3 = r3[1], f22 = r3[2], d22 = r3[3], m22 = r3[4], y22 = r3[5], g22 = r3[6], x22 = r3[7];
          return Math.abs(n3 - h3) <= e22.EPSILON * Math.max(1, Math.abs(n3), Math.abs(h3)) && Math.abs(i3 - p3) <= e22.EPSILON * Math.max(1, Math.abs(i3), Math.abs(p3)) && Math.abs(s2 - f22) <= e22.EPSILON * Math.max(1, Math.abs(s2), Math.abs(f22)) && Math.abs(a3 - d22) <= e22.EPSILON * Math.max(1, Math.abs(a3), Math.abs(d22)) && Math.abs(o3 - m22) <= e22.EPSILON * Math.max(1, Math.abs(o3), Math.abs(m22)) && Math.abs(l3 - y22) <= e22.EPSILON * Math.max(1, Math.abs(l3), Math.abs(y22)) && Math.abs(u3 - g22) <= e22.EPSILON * Math.max(1, Math.abs(u3), Math.abs(g22)) && Math.abs(c3 - x22) <= e22.EPSILON * Math.max(1, Math.abs(c3), Math.abs(x22));
        }, z2.sqrLen = z2.squaredLength = z2.len = z2.length = z2.dot = z2.mul = z2.setReal = z2.getReal = void 0;
        var e22 = a2(s()), r22 = a2(I2()), n22 = a2(g2());
        function i2(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e3 = /* @__PURE__ */ new WeakMap(), r3 = /* @__PURE__ */ new WeakMap();
          return (i2 = function(t4) {
            return t4 ? r3 : e3;
          })(t3);
        }
        function a2(e3, r3) {
          if (e3 && e3.__esModule)
            return e3;
          if (null === e3 || "object" !== t22(e3) && "function" != typeof e3)
            return { default: e3 };
          var n3 = i2(r3);
          if (n3 && n3.has(e3))
            return n3.get(e3);
          var s2 = {}, a3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var o3 in e3)
            if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e3, o3)) {
              var l3 = a3 ? Object.getOwnPropertyDescriptor(e3, o3) : null;
              l3 && (l3.get || l3.set) ? Object.defineProperty(s2, o3, l3) : s2[o3] = e3[o3];
            }
          return s2.default = e3, n3 && n3.set(e3, s2), s2;
        }
        function o2(t3, e3, r3) {
          var n3 = 0.5 * r3[0], i3 = 0.5 * r3[1], s2 = 0.5 * r3[2], a3 = e3[0], o3 = e3[1], l3 = e3[2], u3 = e3[3];
          return t3[0] = a3, t3[1] = o3, t3[2] = l3, t3[3] = u3, t3[4] = n3 * u3 + i3 * l3 - s2 * o3, t3[5] = i3 * u3 + s2 * a3 - n3 * l3, t3[6] = s2 * u3 + n3 * o3 - i3 * a3, t3[7] = -n3 * a3 - i3 * o3 - s2 * l3, t3;
        }
        function l22(t3, e3) {
          return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[4] = e3[4], t3[5] = e3[5], t3[6] = e3[6], t3[7] = e3[7], t3;
        }
        function u22(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = r3[4], l3 = r3[5], u3 = r3[6], c3 = r3[7], h3 = e3[4], p3 = e3[5], f22 = e3[6], d22 = e3[7], m22 = r3[0], y22 = r3[1], g22 = r3[2], x22 = r3[3];
          return t3[0] = n3 * x22 + a3 * m22 + i3 * g22 - s2 * y22, t3[1] = i3 * x22 + a3 * y22 + s2 * m22 - n3 * g22, t3[2] = s2 * x22 + a3 * g22 + n3 * y22 - i3 * m22, t3[3] = a3 * x22 - n3 * m22 - i3 * y22 - s2 * g22, t3[4] = n3 * c3 + a3 * o3 + i3 * u3 - s2 * l3 + h3 * x22 + d22 * m22 + p3 * g22 - f22 * y22, t3[5] = i3 * c3 + a3 * l3 + s2 * o3 - n3 * u3 + p3 * x22 + d22 * y22 + f22 * m22 - h3 * g22, t3[6] = s2 * c3 + a3 * u3 + n3 * l3 - i3 * o3 + f22 * x22 + d22 * g22 + h3 * y22 - p3 * m22, t3[7] = a3 * c3 - n3 * o3 - i3 * l3 - s2 * u3 + d22 * x22 - h3 * m22 - p3 * y22 - f22 * g22, t3;
        }
        z2.getReal = r22.copy, z2.setReal = r22.copy, z2.mul = u22;
        var c22 = r22.dot;
        z2.dot = c22;
        var h22 = r22.length;
        z2.length = h22, z2.len = h22;
        var p22 = r22.squaredLength;
        return z2.squaredLength = p22, z2.sqrLen = p22, z2;
      }
      var T2, E2, B2 = {};
      function V2() {
        if (T2)
          return B2;
        function t22(e3) {
          return t22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          }, t22(e3);
        }
        T2 = 1, Object.defineProperty(B2, "__esModule", { value: true }), B2.create = n22, B2.clone = function(t3) {
          var r3 = new e22.ARRAY_TYPE(2);
          return r3[0] = t3[0], r3[1] = t3[1], r3;
        }, B2.fromValues = function(t3, r3) {
          var n3 = new e22.ARRAY_TYPE(2);
          return n3[0] = t3, n3[1] = r3, n3;
        }, B2.copy = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = e3[1], t3;
        }, B2.set = function(t3, e3, r3) {
          return t3[0] = e3, t3[1] = r3, t3;
        }, B2.add = function(t3, e3, r3) {
          return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3;
        }, B2.subtract = i2, B2.multiply = a2, B2.divide = o2, B2.ceil = function(t3, e3) {
          return t3[0] = Math.ceil(e3[0]), t3[1] = Math.ceil(e3[1]), t3;
        }, B2.floor = function(t3, e3) {
          return t3[0] = Math.floor(e3[0]), t3[1] = Math.floor(e3[1]), t3;
        }, B2.min = function(t3, e3, r3) {
          return t3[0] = Math.min(e3[0], r3[0]), t3[1] = Math.min(e3[1], r3[1]), t3;
        }, B2.max = function(t3, e3, r3) {
          return t3[0] = Math.max(e3[0], r3[0]), t3[1] = Math.max(e3[1], r3[1]), t3;
        }, B2.round = function(t3, e3) {
          return t3[0] = Math.round(e3[0]), t3[1] = Math.round(e3[1]), t3;
        }, B2.scale = function(t3, e3, r3) {
          return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3;
        }, B2.scaleAndAdd = function(t3, e3, r3, n3) {
          return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3;
        }, B2.distance = l22, B2.squaredDistance = u22, B2.length = c22, B2.squaredLength = h22, B2.negate = function(t3, e3) {
          return t3[0] = -e3[0], t3[1] = -e3[1], t3;
        }, B2.inverse = function(t3, e3) {
          return t3[0] = 1 / e3[0], t3[1] = 1 / e3[1], t3;
        }, B2.normalize = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = r3 * r3 + n3 * n3;
          return i3 > 0 && (i3 = 1 / Math.sqrt(i3)), t3[0] = e3[0] * i3, t3[1] = e3[1] * i3, t3;
        }, B2.dot = function(t3, e3) {
          return t3[0] * e3[0] + t3[1] * e3[1];
        }, B2.cross = function(t3, e3, r3) {
          var n3 = e3[0] * r3[1] - e3[1] * r3[0];
          return t3[0] = t3[1] = 0, t3[2] = n3, t3;
        }, B2.lerp = function(t3, e3, r3, n3) {
          var i3 = e3[0], s2 = e3[1];
          return t3[0] = i3 + n3 * (r3[0] - i3), t3[1] = s2 + n3 * (r3[1] - s2), t3;
        }, B2.random = function(t3, r3) {
          r3 = r3 || 1;
          var n3 = 2 * e22.RANDOM() * Math.PI;
          return t3[0] = Math.cos(n3) * r3, t3[1] = Math.sin(n3) * r3, t3;
        }, B2.transformMat2 = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1];
          return t3[0] = r3[0] * n3 + r3[2] * i3, t3[1] = r3[1] * n3 + r3[3] * i3, t3;
        }, B2.transformMat2d = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1];
          return t3[0] = r3[0] * n3 + r3[2] * i3 + r3[4], t3[1] = r3[1] * n3 + r3[3] * i3 + r3[5], t3;
        }, B2.transformMat3 = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1];
          return t3[0] = r3[0] * n3 + r3[3] * i3 + r3[6], t3[1] = r3[1] * n3 + r3[4] * i3 + r3[7], t3;
        }, B2.transformMat4 = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1];
          return t3[0] = r3[0] * n3 + r3[4] * i3 + r3[12], t3[1] = r3[1] * n3 + r3[5] * i3 + r3[13], t3;
        }, B2.rotate = function(t3, e3, r3, n3) {
          var i3 = e3[0] - r3[0], s2 = e3[1] - r3[1], a3 = Math.sin(n3), o3 = Math.cos(n3);
          return t3[0] = i3 * o3 - s2 * a3 + r3[0], t3[1] = i3 * a3 + s2 * o3 + r3[1], t3;
        }, B2.angle = function(t3, e3) {
          var r3 = t3[0], n3 = t3[1], i3 = e3[0], s2 = e3[1], a3 = Math.sqrt(r3 * r3 + n3 * n3) * Math.sqrt(i3 * i3 + s2 * s2);
          return Math.acos(Math.min(Math.max(a3 && (r3 * i3 + n3 * s2) / a3, -1), 1));
        }, B2.zero = function(t3) {
          return t3[0] = 0, t3[1] = 0, t3;
        }, B2.str = function(t3) {
          return "vec2(" + t3[0] + ", " + t3[1] + ")";
        }, B2.exactEquals = function(t3, e3) {
          return t3[0] === e3[0] && t3[1] === e3[1];
        }, B2.equals = function(t3, r3) {
          var n3 = t3[0], i3 = t3[1], s2 = r3[0], a3 = r3[1];
          return Math.abs(n3 - s2) <= e22.EPSILON * Math.max(1, Math.abs(n3), Math.abs(s2)) && Math.abs(i3 - a3) <= e22.EPSILON * Math.max(1, Math.abs(i3), Math.abs(a3));
        }, B2.forEach = B2.sqrLen = B2.sqrDist = B2.dist = B2.div = B2.mul = B2.sub = B2.len = void 0;
        var e22 = function(e3, n3) {
          if (e3 && e3.__esModule)
            return e3;
          if (null === e3 || "object" !== t22(e3) && "function" != typeof e3)
            return { default: e3 };
          var i3 = r22(void 0);
          if (i3 && i3.has(e3))
            return i3.get(e3);
          var s2 = {}, a3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var o3 in e3)
            if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e3, o3)) {
              var l3 = a3 ? Object.getOwnPropertyDescriptor(e3, o3) : null;
              l3 && (l3.get || l3.set) ? Object.defineProperty(s2, o3, l3) : s2[o3] = e3[o3];
            }
          return s2.default = e3, i3 && i3.set(e3, s2), s2;
        }(s());
        function r22(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
          return (r22 = function(t4) {
            return t4 ? n3 : e3;
          })(t3);
        }
        function n22() {
          var t3 = new e22.ARRAY_TYPE(2);
          return e22.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0), t3;
        }
        function i2(t3, e3, r3) {
          return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3;
        }
        function a2(t3, e3, r3) {
          return t3[0] = e3[0] * r3[0], t3[1] = e3[1] * r3[1], t3;
        }
        function o2(t3, e3, r3) {
          return t3[0] = e3[0] / r3[0], t3[1] = e3[1] / r3[1], t3;
        }
        function l22(t3, e3) {
          return Math.hypot(e3[0] - t3[0], e3[1] - t3[1]);
        }
        function u22(t3, e3) {
          var r3 = e3[0] - t3[0], n3 = e3[1] - t3[1];
          return r3 * r3 + n3 * n3;
        }
        function c22(t3) {
          return Math.hypot(t3[0], t3[1]);
        }
        function h22(t3) {
          var e3 = t3[0], r3 = t3[1];
          return e3 * e3 + r3 * r3;
        }
        B2.len = c22, B2.sub = i2, B2.mul = a2, B2.div = o2, B2.dist = l22, B2.sqrDist = u22, B2.sqrLen = h22;
        var p22, f22 = (p22 = n22(), function(t3, e3, r3, n3, i3, s2) {
          var a3, o3;
          for (e3 || (e3 = 2), r3 || (r3 = 0), o3 = n3 ? Math.min(n3 * e3 + r3, t3.length) : t3.length, a3 = r3; a3 < o3; a3 += e3)
            p22[0] = t3[a3], p22[1] = t3[a3 + 1], i3(p22, p22, s2), t3[a3] = p22[0], t3[a3 + 1] = p22[1];
          return t3;
        });
        return B2.forEach = f22, B2;
      }
      function C2() {
        if (E2)
          return n2;
        function t22(e3) {
          return t22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          }, t22(e3);
        }
        E2 = 1, Object.defineProperty(n2, "__esModule", { value: true }), n2.vec4 = n2.vec3 = n2.vec2 = n2.quat2 = n2.quat = n2.mat4 = n2.mat3 = n2.mat2d = n2.mat2 = n2.glMatrix = void 0;
        var e22 = x22(s());
        n2.glMatrix = e22;
        var r22 = x22(l2());
        n2.mat2 = r22;
        var i2 = x22(h2());
        n2.mat2d = i2;
        var a2 = x22(d2());
        n2.mat3 = a2;
        var o2 = x22(g2());
        n2.mat4 = o2;
        var u22 = x22(I2());
        n2.quat = u22;
        var c22 = x22(k2());
        n2.quat2 = c22;
        var p22 = x22(V2());
        n2.vec2 = p22;
        var f22 = x22(w2());
        n2.vec3 = f22;
        var m22 = x22(S2());
        function y22(t3) {
          if ("function" != typeof WeakMap)
            return null;
          var e3 = /* @__PURE__ */ new WeakMap(), r3 = /* @__PURE__ */ new WeakMap();
          return (y22 = function(t4) {
            return t4 ? r3 : e3;
          })(t3);
        }
        function x22(e3, r3) {
          if (e3 && e3.__esModule)
            return e3;
          if (null === e3 || "object" !== t22(e3) && "function" != typeof e3)
            return { default: e3 };
          var n22 = y22(r3);
          if (n22 && n22.has(e3))
            return n22.get(e3);
          var i3 = {}, s2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var a3 in e3)
            if ("default" !== a3 && Object.prototype.hasOwnProperty.call(e3, a3)) {
              var o3 = s2 ? Object.getOwnPropertyDescriptor(e3, a3) : null;
              o3 && (o3.get || o3.set) ? Object.defineProperty(i3, a3, o3) : i3[a3] = e3[a3];
            }
          return i3.default = e3, n22 && n22.set(e3, i3), i3;
        }
        return n2.vec4 = m22, n2;
      }
      var R2, D2, L2, F2, O2 = C2(), U2 = function() {
        if (D2)
          return R2;
        function t22(t3, e22, r22, n22) {
          this.cx = 3 * t3, this.bx = 3 * (r22 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e22, this.by = 3 * (n22 - e22) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e22, this.p2x = r22, this.p2y = n22;
        }
        return D2 = 1, R2 = t22, t22.prototype = { sampleCurveX: function(t3) {
          return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
        }, sampleCurveY: function(t3) {
          return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
        }, sampleCurveDerivativeX: function(t3) {
          return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
        }, solveCurveX: function(t3, e22) {
          if (void 0 === e22 && (e22 = 1e-6), t3 < 0)
            return 0;
          if (t3 > 1)
            return 1;
          for (var r22 = t3, n22 = 0; n22 < 8; n22++) {
            var i2 = this.sampleCurveX(r22) - t3;
            if (Math.abs(i2) < e22)
              return r22;
            var s2 = this.sampleCurveDerivativeX(r22);
            if (Math.abs(s2) < 1e-6)
              break;
            r22 -= i2 / s2;
          }
          var a2 = 0, o2 = 1;
          for (r22 = t3, n22 = 0; n22 < 20 && (i2 = this.sampleCurveX(r22), !(Math.abs(i2 - t3) < e22)); n22++)
            t3 > i2 ? a2 = r22 : o2 = r22, r22 = 0.5 * (o2 - a2) + a2;
          return r22;
        }, solve: function(t3, e22) {
          return this.sampleCurveY(this.solveCurveX(t3, e22));
        } }, R2;
      }(), j = e2(U2);
      function N2() {
        if (F2)
          return L2;
        function t22(t3, e22) {
          this.x = t3, this.y = e22;
        }
        return F2 = 1, L2 = t22, t22.prototype = { clone: function() {
          return new t22(this.x, this.y);
        }, add: function(t3) {
          return this.clone()._add(t3);
        }, sub: function(t3) {
          return this.clone()._sub(t3);
        }, multByPoint: function(t3) {
          return this.clone()._multByPoint(t3);
        }, divByPoint: function(t3) {
          return this.clone()._divByPoint(t3);
        }, mult: function(t3) {
          return this.clone()._mult(t3);
        }, div: function(t3) {
          return this.clone()._div(t3);
        }, rotate: function(t3) {
          return this.clone()._rotate(t3);
        }, rotateAround: function(t3, e22) {
          return this.clone()._rotateAround(t3, e22);
        }, matMult: function(t3) {
          return this.clone()._matMult(t3);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t3) {
          return this.x === t3.x && this.y === t3.y;
        }, dist: function(t3) {
          return Math.sqrt(this.distSqr(t3));
        }, distSqr: function(t3) {
          var e22 = t3.x - this.x, r22 = t3.y - this.y;
          return e22 * e22 + r22 * r22;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t3) {
          return Math.atan2(this.y - t3.y, this.x - t3.x);
        }, angleWith: function(t3) {
          return this.angleWithSep(t3.x, t3.y);
        }, angleWithSep: function(t3, e22) {
          return Math.atan2(this.x * e22 - this.y * t3, this.x * t3 + this.y * e22);
        }, _matMult: function(t3) {
          var e22 = t3[2] * this.x + t3[3] * this.y;
          return this.x = t3[0] * this.x + t3[1] * this.y, this.y = e22, this;
        }, _add: function(t3) {
          return this.x += t3.x, this.y += t3.y, this;
        }, _sub: function(t3) {
          return this.x -= t3.x, this.y -= t3.y, this;
        }, _mult: function(t3) {
          return this.x *= t3, this.y *= t3, this;
        }, _div: function(t3) {
          return this.x /= t3, this.y /= t3, this;
        }, _multByPoint: function(t3) {
          return this.x *= t3.x, this.y *= t3.y, this;
        }, _divByPoint: function(t3) {
          return this.x /= t3.x, this.y /= t3.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t3 = this.y;
          return this.y = this.x, this.x = -t3, this;
        }, _rotate: function(t3) {
          var e22 = Math.cos(t3), r22 = Math.sin(t3), n22 = r22 * this.x + e22 * this.y;
          return this.x = e22 * this.x - r22 * this.y, this.y = n22, this;
        }, _rotateAround: function(t3, e22) {
          var r22 = Math.cos(t3), n22 = Math.sin(t3), i2 = e22.y + n22 * (this.x - e22.x) + r22 * (this.y - e22.y);
          return this.x = e22.x + r22 * (this.x - e22.x) - n22 * (this.y - e22.y), this.y = i2, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, t22.convert = function(e22) {
          return e22 instanceof t22 ? e22 : Array.isArray(e22) ? new t22(e22[0], e22[1]) : e22;
        }, L2;
      }
      var q2 = e2(N2());
      function $(t22, e22) {
        if (Array.isArray(t22)) {
          if (!Array.isArray(e22) || t22.length !== e22.length)
            return false;
          for (let r22 = 0; r22 < t22.length; r22++)
            if (!$(t22[r22], e22[r22]))
              return false;
          return true;
        }
        if ("object" == typeof t22 && null !== t22 && null !== e22) {
          if ("object" != typeof e22)
            return false;
          if (Object.keys(t22).length !== Object.keys(e22).length)
            return false;
          for (const r22 in t22)
            if (!$(t22[r22], e22[r22]))
              return false;
          return true;
        }
        return t22 === e22;
      }
      const G2 = Math.PI / 180, X2 = 180 / Math.PI;
      function Y2(t22) {
        return t22 * G2;
      }
      function Z2(t22) {
        return t22 * X2;
      }
      const W2 = [[0, 0], [1, 0], [1, 1], [0, 1]];
      function H2(t22) {
        if (t22 <= 0)
          return 0;
        if (t22 >= 1)
          return 1;
        const e22 = t22 * t22, r22 = e22 * t22;
        return 4 * (t22 < 0.5 ? r22 : 3 * (t22 - e22) + r22 - 0.75);
      }
      function K2(t22, e22, r22, n22) {
        const i2 = new j(t22, e22, r22, n22);
        return function(t3) {
          return i2.solve(t3);
        };
      }
      const J2 = K2(0.25, 0.1, 0.25, 1);
      function Q2(t22, e22, r22) {
        return Math.min(r22, Math.max(e22, t22));
      }
      function tt(t22, e22, r22) {
        return (r22 = Q2((r22 - t22) / (e22 - t22), 0, 1)) * r22 * (3 - 2 * r22);
      }
      function et(t22, e22, r22) {
        const n22 = r22 - e22, i2 = ((t22 - e22) % n22 + n22) % n22 + e22;
        return i2 === e22 ? r22 : i2;
      }
      function rt(t22, e22, r22) {
        if (!t22.length)
          return r22(null, []);
        let n22 = t22.length;
        const i2 = new Array(t22.length);
        let s2 = null;
        t22.forEach((t3, a2) => {
          e22(t3, (t4, e3) => {
            t4 && (s2 = t4), i2[a2] = e3, 0 == --n22 && r22(s2, i2);
          });
        });
      }
      function nt(t22, ...e22) {
        for (const r22 of e22)
          for (const e3 in r22)
            t22[e3] = r22[e3];
        return t22;
      }
      let it = 1;
      function st() {
        return it++;
      }
      function at(t22) {
        return t22 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t22) / Math.LN2));
      }
      function ot(t22, e22) {
        t22.forEach((t3) => {
          e22[t3] && (e22[t3] = e22[t3].bind(e22));
        });
      }
      function lt(t22, e22) {
        return -1 !== t22.indexOf(e22, t22.length - e22.length);
      }
      function ut(t22, e22, r22) {
        const n22 = {};
        for (const r3 in t22)
          n22[r3] = e22.call(this, t22[r3], r3, t22);
        return n22;
      }
      function ct(t22, e22, r22) {
        const n22 = {};
        for (const r3 in t22)
          e22.call(this, t22[r3], r3, t22) && (n22[r3] = t22[r3]);
        return n22;
      }
      function ht(t22) {
        return Array.isArray(t22) ? t22.map(ht) : "object" == typeof t22 && t22 ? ut(t22, ht) : t22;
      }
      const pt = {};
      function ft(t22) {
        pt[t22] || ("undefined" != typeof console && console.warn(t22), pt[t22] = true);
      }
      function dt(t22, e22, r22) {
        return (r22.y - t22.y) * (e22.x - t22.x) > (e22.y - t22.y) * (r22.x - t22.x);
      }
      function mt(t22) {
        let e22 = 0;
        for (let r22, n22, i2 = 0, s2 = t22.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
          r22 = t22[i2], n22 = t22[a2], e22 += (n22.x - r22.x) * (r22.y + n22.y);
        return e22;
      }
      function yt([t22, e22, r22]) {
        const n22 = Y2(e22 + 90), i2 = Y2(r22);
        return { x: t22 * Math.cos(n22) * Math.sin(i2), y: t22 * Math.sin(n22) * Math.sin(i2), z: t22 * Math.cos(i2), azimuthal: e22, polar: r22 };
      }
      function gt() {
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
      }
      function xt(t22) {
        const e22 = {};
        if (t22.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r22, n22, i2) => {
          const s2 = n22 || i2;
          return e22[r22] = !s2 || s2.toLowerCase(), "";
        }), e22["max-age"]) {
          const t3 = parseInt(e22["max-age"], 10);
          isNaN(t3) ? delete e22["max-age"] : e22["max-age"] = t3;
        }
        return e22;
      }
      let bt, vt = null;
      function wt(t22, e22) {
        return [t22[4 * e22], t22[4 * e22 + 1], t22[4 * e22 + 2], t22[4 * e22 + 3]];
      }
      function _t(t22, e22, r22, n22) {
        for (; e22 < r22; ) {
          const i2 = e22 + r22 >> 1;
          t22[i2] < n22 ? e22 = i2 + 1 : r22 = i2;
        }
        return e22;
      }
      function Mt(t22, e22, r22, n22) {
        for (; e22 < r22; ) {
          const i2 = e22 + r22 >> 1;
          t22[i2] <= n22 ? e22 = i2 + 1 : r22 = i2;
        }
        return e22;
      }
      function At(t22) {
        return t22 > 0 ? 1 / (1.001 - t22) : 1 + t22;
      }
      function St(t22) {
        return t22 > 0 ? 1 - 1 / (1.001 - t22) : -t22;
      }
      const It = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
        if (null == bt) {
          const t22 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
          try {
            bt = null != define_process_env_default.API_URL_REGEX ? new RegExp(define_process_env_default.API_URL_REGEX) : t22;
          } catch (e22) {
            bt = t22;
          }
        }
        return bt;
      }, get API_TILEJSON_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
      }, get API_SPRITE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
      }, get API_FONTS_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
      }, get API_STYLE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
      }, get API_CDN_URL_REGEX() {
        return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
      }, get EVENTS_URL() {
        if (!It.API_URL)
          return null;
        try {
          const t22 = new URL(It.API_URL);
          return "api.mapbox.cn" === t22.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t22.hostname ? "https://events.mapbox.com/events/v2" : null;
        } catch (t22) {
          return null;
        }
      }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", RASTERARRAYS_URL_PREFIX: "rasterarrays/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, DEFAULT_STYLE: "mapbox://styles/mapbox/standard", MAX_PARALLEL_IMAGE_REQUESTS: 16, DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm", MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm", MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm", GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf", TILES3D_URL_PREFIX: "3dtiles/v1" };
      function Pt(t22) {
        return It.API_URL_REGEX.test(t22);
      }
      function zt(t22) {
        return It.API_SPRITE_REGEX.test(t22);
      }
      let kt, Tt, Et, Bt, Vt, Ct;
      function Rt() {
        return null == kt && (kt = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof self.createImageBitmap), kt;
      }
      const Dt = { now: () => void 0 !== Bt ? Bt : performance.now(), setNow(t22) {
        Bt = t22;
      }, restoreNow() {
        Bt = void 0;
      }, frame(t22) {
        const e22 = requestAnimationFrame(t22);
        return { cancel: () => cancelAnimationFrame(e22) };
      }, getImageData(t22, e22 = 0) {
        const { width: r22, height: n22 } = t22;
        Vt || (Vt = document.createElement("canvas"));
        const i2 = Vt.getContext("2d", { willReadFrequently: true });
        if (!i2)
          throw new Error("failed to create canvas 2d context");
        return (r22 > Vt.width || n22 > Vt.height) && (Vt.width = r22, Vt.height = n22), i2.clearRect(-e22, -e22, r22 + 2 * e22, n22 + 2 * e22), i2.drawImage(t22, 0, 0, r22, n22), i2.getImageData(-e22, -e22, r22 + 2 * e22, n22 + 2 * e22);
      }, resolveURL: (t22) => (Tt || (Tt = document.createElement("a")), Tt.href = t22, Tt.href), get devicePixelRatio() {
        return window.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!window.matchMedia && (null == Et && (Et = window.matchMedia("(prefers-reduced-motion: reduce)")), Et.matches);
      }, hasCanvasFingerprintNoise() {
        if (void 0 !== Ct)
          return Ct;
        if (!Rt())
          return Ct = false, false;
        const t22 = new OffscreenCanvas(85, 1), e22 = t22.getContext("2d", { willReadFrequently: true });
        let r22 = 0;
        for (let n3 = 0; n3 < t22.width; ++n3)
          e22.fillStyle = "rgba(".concat(r22++, ",").concat(r22++, ",").concat(r22++, ", 255)"), e22.fillRect(n3, 0, 1, 1);
        const n22 = e22.getImageData(0, 0, t22.width, t22.height);
        r22 = 0;
        for (let t3 = 0; t3 < n22.data.length; ++t3)
          if (t3 % 4 != 3 && r22++ !== n22.data[t3])
            return Ct = true, true;
        return Ct = false, false;
      } };
      function Lt(t22, e22) {
        const r22 = t22.indexOf("?");
        if (r22 < 0)
          return "".concat(t22, "?").concat(new URLSearchParams(e22).toString());
        const n22 = new URLSearchParams(t22.slice(r22));
        for (const t3 in e22)
          n22.set(t3, e22[t3]);
        return "".concat(t22.slice(0, r22), "?").concat(n22.toString());
      }
      function Ft(t22, e22 = { persistentParams: [] }) {
        const r22 = t22.indexOf("?");
        if (r22 < 0)
          return t22;
        const n22 = new URLSearchParams(), i2 = new URLSearchParams(t22.slice(r22));
        for (const t3 of e22.persistentParams) {
          const e3 = i2.get(t3);
          e3 && n22.set(t3, e3);
        }
        const s2 = n22.toString();
        return "".concat(t22.slice(0, r22)).concat(s2.length > 0 ? "?".concat(s2) : "");
      }
      const Ot = "mapbox-tiles";
      let Ut = 500, jt = 50;
      const Nt = ["language", "worldview", "jobid"];
      let qt, $t;
      function Gt() {
        try {
          return caches;
        } catch (t22) {
        }
      }
      function Xt() {
        const t22 = Gt();
        t22 && null == qt && (qt = t22.open(Ot));
      }
      let Yt = 1 / 0;
      const Zt = { supported: false, testSupport: function(t22) {
        !Kt && Ht && (Jt ? te2(t22) : Wt = t22);
      } };
      let Wt, Ht, Kt = false, Jt = false;
      const Qt = "undefined" != typeof self ? self : {};
      function te2(t22) {
        const e22 = t22.createTexture();
        t22.bindTexture(t22.TEXTURE_2D, e22);
        try {
          if (t22.texImage2D(t22.TEXTURE_2D, 0, t22.RGBA, t22.RGBA, t22.UNSIGNED_BYTE, Ht), t22.isContextLost())
            return;
          Zt.supported = true;
        } catch (t3) {
        }
        t22.deleteTexture(e22), Kt = true;
      }
      Qt.document && (Ht = Qt.document.createElement("img"), Ht.onload = function() {
        Wt && te2(Wt), Wt = null, Jt = true;
      }, Ht.onerror = function() {
        Kt = true, Wt = null;
      }, Ht.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      const ee2 = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image", Model: "Model" };
      "function" == typeof Object.freeze && Object.freeze(ee2);
      class re2 extends Error {
        constructor(t22, e22, r22) {
          401 === e22 && Pt(r22) && (t22 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t22), this.status = e22, this.url = r22;
        }
        toString() {
          return "".concat(this.name, ": ").concat(this.message, " (").concat(this.status, "): ").concat(this.url);
        }
      }
      const ne2 = gt() ? () => self.worker && self.worker.referrer : () => ("blob:" === location.protocol ? parent : self).location.href;
      const ie2 = function(t22, e22) {
        if (!(/^file:/.test(r22 = t22.url) || /^file:/.test(ne2()) && !/^\w+:/.test(r22))) {
          if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal"))
            return function(t3, e3) {
              const r3 = new AbortController(), n22 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: ne2(), referrerPolicy: t3.referrerPolicy, signal: r3.signal });
              let i2 = false, s2 = false;
              const a2 = (o2 = n22.url).indexOf("sku=") > 0 && Pt(o2);
              var o2;
              "json" === t3.type && n22.headers.set("Accept", "application/json");
              const l22 = (r4, i3, o3) => {
                if (s2)
                  return;
                if (r4 && "SecurityError" !== r4.message && ft(r4.toString()), i3 && o3)
                  return u22(i3);
                const l3 = Date.now();
                fetch(n22).then((r5) => {
                  if (r5.ok) {
                    const t4 = a2 ? r5.clone() : null;
                    return u22(r5, t4, l3);
                  }
                  return e3(new re2(r5.statusText, r5.status, t3.url));
                }).catch((r5) => {
                  "AbortError" !== r5.name && e3(new Error("".concat(r5.message, " ").concat(t3.url)));
                });
              }, u22 = (r4, a3, o3) => {
                ("arrayBuffer" === t3.type ? r4.arrayBuffer() : "json" === t3.type ? r4.json() : r4.text()).then((t4) => {
                  s2 || (a3 && o3 && function(t5, e4, r5) {
                    if (Xt(), null == qt)
                      return;
                    const n3 = xt(e4.headers.get("Cache-Control") || "");
                    if (n3["no-store"])
                      return;
                    const i3 = { status: e4.status, statusText: e4.statusText, headers: new Headers() };
                    e4.headers.forEach((t6, e5) => i3.headers.set(e5, t6)), n3["max-age"] && i3.headers.set("Expires", new Date(r5 + 1e3 * n3["max-age"]).toUTCString());
                    const s3 = i3.headers.get("Expires");
                    if (!s3)
                      return;
                    if (new Date(s3).getTime() - r5 < 42e4)
                      return;
                    let a4 = Ft(t5.url, { persistentParams: Nt });
                    if (206 === e4.status) {
                      const e5 = t5.headers.get("Range");
                      if (!e5)
                        return;
                      i3.status = 200, a4 = Lt(a4, { range: e5 });
                    }
                    !function(t6, e5) {
                      if (void 0 === $t)
                        try {
                          new Response(new ReadableStream()), $t = true;
                        } catch (t7) {
                          $t = false;
                        }
                      $t ? e5(t6.body) : t6.blob().then(e5);
                    }(e4, (t6) => {
                      const r6 = new Response(200 !== (n4 = e4.status) && 404 !== n4 && [101, 103, 204, 205, 304].includes(n4) ? null : t6, i3);
                      var n4;
                      Xt(), null != qt && qt.then((t7) => t7.put(a4, r6)).catch((t7) => ft(t7.message));
                    });
                  }(n22, a3, o3), i2 = true, e3(null, t4, r4.headers.get("Cache-Control"), r4.headers.get("Expires")));
                }).catch((t4) => {
                  s2 || e3(new Error(t4.message));
                });
              };
              return a2 ? function(t4, e4) {
                if (Xt(), null == qt)
                  return e4(null);
                qt.then((r4) => {
                  let n3 = Ft(t4.url, { persistentParams: Nt });
                  const i3 = t4.headers.get("Range");
                  i3 && (n3 = Lt(n3, { range: i3 })), r4.match(n3).then((t5) => {
                    const i4 = function(t6) {
                      if (!t6)
                        return false;
                      const e5 = new Date(t6.headers.get("Expires") || 0), r5 = xt(t6.headers.get("Cache-Control") || "");
                      return e5 > Date.now() && !r5["no-cache"];
                    }(t5);
                    r4.delete(n3), i4 && r4.put(n3, t5.clone()), e4(null, t5, i4);
                  }).catch(e4);
                }).catch(e4);
              }(n22, l22) : l22(null, null), { cancel: () => {
                s2 = true, i2 || r3.abort();
              } };
            }(t22, e22);
          if (gt() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", t22, e22, void 0, true);
        }
        var r22;
        return function(t3, e3) {
          const r3 = new XMLHttpRequest();
          r3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (r3.responseType = "arraybuffer");
          for (const e4 in t3.headers)
            r3.setRequestHeader(e4, t3.headers[e4]);
          return "json" === t3.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t3.credentials, r3.onerror = () => {
            e3(new Error(r3.statusText));
          }, r3.onload = () => {
            if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
              let n22 = r3.response;
              if ("json" === t3.type)
                try {
                  n22 = JSON.parse(r3.response);
                } catch (t4) {
                  return e3(t4);
                }
              e3(null, n22, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
            } else
              e3(new re2(r3.statusText, r3.status, t3.url));
          }, r3.send(t3.body), { cancel: () => r3.abort() };
        }(t22, e22);
      }, se2 = function(t22, e22) {
        return ie2(nt(t22, { type: "arrayBuffer" }), e22);
      };
      function ae2(t22) {
        const e22 = document.createElement("a");
        return e22.href = t22, e22.protocol === location.protocol && e22.host === location.host;
      }
      const oe2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      let le2, ue2;
      le2 = [], ue2 = 0;
      const ce2 = function(t22, e22) {
        if (Zt.supported && (t22.headers || (t22.headers = {}), t22.headers.accept = "image/webp,*/*"), ue2 >= It.MAX_PARALLEL_IMAGE_REQUESTS) {
          const r3 = { requestParameters: t22, callback: e22, cancelled: false, cancel() {
            this.cancelled = true;
          } };
          return le2.push(r3), r3;
        }
        ue2++;
        let r22 = false;
        const n22 = () => {
          if (!r22)
            for (r22 = true, ue2--; le2.length && ue2 < It.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const t3 = le2.shift(), { requestParameters: e3, callback: r3, cancelled: n3 } = t3;
              n3 || (t3.cancel = ce2(e3, r3).cancel);
            }
        }, i2 = se2(t22, (t3, r3, i3, s2) => {
          n22(), t3 ? e22(t3) : r3 && (self.createImageBitmap ? function(t4, e3) {
            const r4 = new Blob([new Uint8Array(t4)], { type: "image/png" });
            createImageBitmap(r4).then((t5) => {
              e3(null, t5);
            }).catch((t5) => {
              e3(new Error("Could not load image because of ".concat(t5.message, ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")));
            });
          }(r3, (t4, r4) => e22(t4, r4, i3, s2)) : function(t4, e3) {
            const r4 = new Image();
            r4.onload = () => {
              e3(null, r4), URL.revokeObjectURL(r4.src), r4.onload = null, requestAnimationFrame(() => {
                r4.src = oe2;
              });
            }, r4.onerror = () => e3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const n3 = new Blob([new Uint8Array(t4)], { type: "image/png" });
            r4.src = t4.byteLength ? URL.createObjectURL(n3) : oe2;
          }(r3, (t4, r4) => e22(t4, r4, i3, s2)));
        });
        return { cancel: () => {
          i2.cancel(), n22();
        } };
      };
      var he2, pe2, fe2, de2 = { exports: {} }, me2 = { exports: {} }, ye = { exports: {} }, ge2 = function() {
        if (fe2)
          return de2.exports;
        fe2 = 1;
        var t22 = (he2 || (he2 = 1, me2.exports = function(t3, e3) {
          var r22, n22, i2, s2, a2, o2, l22, u22;
          for (n22 = t3.length - (r22 = 3 & t3.length), i2 = e3, a2 = 3432918353, o2 = 461845907, u22 = 0; u22 < n22; )
            l22 = 255 & t3.charCodeAt(u22) | (255 & t3.charCodeAt(++u22)) << 8 | (255 & t3.charCodeAt(++u22)) << 16 | (255 & t3.charCodeAt(++u22)) << 24, ++u22, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l22 = (65535 & (l22 = (l22 = (65535 & l22) * a2 + (((l22 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l22 >>> 17)) * o2 + (((l22 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
          switch (l22 = 0, r22) {
            case 3:
              l22 ^= (255 & t3.charCodeAt(u22 + 2)) << 16;
            case 2:
              l22 ^= (255 & t3.charCodeAt(u22 + 1)) << 8;
            case 1:
              i2 ^= l22 = (65535 & (l22 = (l22 = (65535 & (l22 ^= 255 & t3.charCodeAt(u22))) * a2 + (((l22 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l22 >>> 17)) * o2 + (((l22 >>> 16) * o2 & 65535) << 16) & 4294967295;
          }
          return i2 ^= t3.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
        }), me2.exports), e22 = (pe2 || (pe2 = 1, ye.exports = function(t3, e3) {
          for (var r22, n22 = t3.length, i2 = e3 ^ n22, s2 = 0; n22 >= 4; )
            r22 = 1540483477 * (65535 & (r22 = 255 & t3.charCodeAt(s2) | (255 & t3.charCodeAt(++s2)) << 8 | (255 & t3.charCodeAt(++s2)) << 16 | (255 & t3.charCodeAt(++s2)) << 24)) + ((1540483477 * (r22 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r22 = 1540483477 * (65535 & (r22 ^= r22 >>> 24)) + ((1540483477 * (r22 >>> 16) & 65535) << 16)), n22 -= 4, ++s2;
          switch (n22) {
            case 3:
              i2 ^= (255 & t3.charCodeAt(s2 + 2)) << 16;
            case 2:
              i2 ^= (255 & t3.charCodeAt(s2 + 1)) << 8;
            case 1:
              i2 = 1540483477 * (65535 & (i2 ^= 255 & t3.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
          }
          return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
        }), ye.exports);
        return de2.exports = t22, de2.exports.murmur3 = t22, de2.exports.murmur2 = e22, de2.exports;
      }(), xe = e2(ge2);
      class be2 {
        constructor(t22, ...e22) {
          nt(this, e22[0] || {}), this.type = t22;
        }
      }
      class ve2 extends be2 {
        constructor(t22, e22 = {}) {
          super("error", nt({ error: t22 }, e22));
        }
      }
      function we2(t22, e22, r22) {
        r22[t22] && -1 !== r22[t22].indexOf(e22) || (r22[t22] = r22[t22] || [], r22[t22].push(e22));
      }
      function _e(t22, e22, r22) {
        if (r22 && r22[t22]) {
          const n22 = r22[t22].indexOf(e22);
          -1 !== n22 && r22[t22].splice(n22, 1);
        }
      }
      class Me2 {
        on(t22, e22) {
          return this._listeners = this._listeners || {}, we2(t22, e22, this._listeners), this;
        }
        off(t22, e22) {
          return _e(t22, e22, this._listeners), _e(t22, e22, this._oneTimeListeners), this;
        }
        once(t22, e22) {
          return e22 ? (this._oneTimeListeners = this._oneTimeListeners || {}, we2(t22, e22, this._oneTimeListeners), this) : new Promise((e3) => this.once(t22, e3));
        }
        fire(t22, e22) {
          const r22 = "string" == typeof t22 ? new be2(t22, e22) : t22, n22 = r22.type;
          if (this.listens(n22)) {
            r22.target = this;
            const t3 = this._listeners && this._listeners[n22] ? this._listeners[n22].slice() : [];
            for (const e4 of t3)
              e4.call(this, r22);
            const e3 = this._oneTimeListeners && this._oneTimeListeners[n22] ? this._oneTimeListeners[n22].slice() : [];
            for (const t4 of e3)
              _e(n22, t4, this._oneTimeListeners), t4.call(this, r22);
            const i2 = this._eventedParent;
            i2 && (nt(r22, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(r22));
          } else
            r22 instanceof ve2 && console.error(r22.error);
          return this;
        }
        listens(t22) {
          return !!(this._listeners && this._listeners[t22] && this._listeners[t22].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t22] && this._oneTimeListeners[t22].length > 0 || this._eventedParent && this._eventedParent.listens(t22));
        }
        setEventedParent(t22, e22) {
          return this._eventedParent = t22, this._eventedParentData = e22, this;
        }
      }
      var Ae2, Se2 = {}, Ie2 = function() {
        if (Ae2)
          return Se2;
        Ae2 = 1;
        var t22 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function e22(t3) {
          return (t3 = Math.round(t3)) < 0 ? 0 : t3 > 255 ? 255 : t3;
        }
        function r22(t3) {
          return e22("%" === t3[t3.length - 1] ? parseFloat(t3) / 100 * 255 : parseInt(t3));
        }
        function n22(t3) {
          return (e3 = "%" === t3[t3.length - 1] ? parseFloat(t3) / 100 : parseFloat(t3)) < 0 ? 0 : e3 > 1 ? 1 : e3;
          var e3;
        }
        function i2(t3, e3, r3) {
          return r3 < 0 ? r3 += 1 : r3 > 1 && (r3 -= 1), 6 * r3 < 1 ? t3 + (e3 - t3) * r3 * 6 : 2 * r3 < 1 ? e3 : 3 * r3 < 2 ? t3 + (e3 - t3) * (2 / 3 - r3) * 6 : t3;
        }
        try {
          Se2.parseCSSColor = function(s2) {
            var a2, o2 = s2.replace(/ /g, "").toLowerCase();
            if (o2 in t22)
              return t22[o2].slice();
            if ("#" === o2[0])
              return 4 === o2.length ? (a2 = parseInt(o2.substr(1), 16)) >= 0 && a2 <= 4095 ? [(3840 & a2) >> 4 | (3840 & a2) >> 8, 240 & a2 | (240 & a2) >> 4, 15 & a2 | (15 & a2) << 4, 1] : null : 7 === o2.length && (a2 = parseInt(o2.substr(1), 16)) >= 0 && a2 <= 16777215 ? [(16711680 & a2) >> 16, (65280 & a2) >> 8, 255 & a2, 1] : null;
            var l22 = o2.indexOf("("), u22 = o2.indexOf(")");
            if (-1 !== l22 && u22 + 1 === o2.length) {
              var c22 = o2.substr(0, l22), h22 = o2.substr(l22 + 1, u22 - (l22 + 1)).split(","), p22 = 1;
              switch (c22) {
                case "rgba":
                  if (4 !== h22.length)
                    return null;
                  p22 = n22(h22.pop());
                case "rgb":
                  return 3 !== h22.length ? null : [r22(h22[0]), r22(h22[1]), r22(h22[2]), p22];
                case "hsla":
                  if (4 !== h22.length)
                    return null;
                  p22 = n22(h22.pop());
                case "hsl":
                  if (3 !== h22.length)
                    return null;
                  var f22 = (parseFloat(h22[0]) % 360 + 360) % 360 / 360, d22 = n22(h22[1]), m22 = n22(h22[2]), y22 = m22 <= 0.5 ? m22 * (d22 + 1) : m22 + d22 - m22 * d22, g22 = 2 * m22 - y22;
                  return [e22(255 * i2(g22, y22, f22 + 1 / 3)), e22(255 * i2(g22, y22, f22)), e22(255 * i2(g22, y22, f22 - 1 / 3)), p22];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch (t3) {
        }
        return Se2;
      }();
      class Pe2 {
        constructor(t22, e22, r22, n22 = 1) {
          this.r = t22, this.g = e22, this.b = r22, this.a = n22;
        }
        static parse(t22) {
          if (!t22)
            return;
          if (t22 instanceof Pe2)
            return t22;
          if ("string" != typeof t22)
            return;
          const e22 = Ie2.parseCSSColor(t22);
          return e22 ? new Pe2(e22[0] / 255 * e22[3], e22[1] / 255 * e22[3], e22[2] / 255 * e22[3], e22[3]) : void 0;
        }
        toString() {
          const [t22, e22, r22, n22] = 0 === this.a ? [0, 0, 0, 0] : [255 * this.r / this.a, 255 * this.g / this.a, 255 * this.b / this.a, this.a];
          return "rgba(".concat(Math.round(t22), ",").concat(Math.round(e22), ",").concat(Math.round(r22), ",").concat(n22, ")");
        }
        toRenderColor(t22) {
          const { r: e22, g: r22, b: n22, a: i2 } = this;
          return new ze(t22, e22, r22, n22, i2);
        }
      }
      class ze {
        constructor(t22, e22, r22, n22, i2) {
          if (t22) {
            const s2 = t22.image.height, a2 = s2 * s2;
            e22 = 0 === i2 ? 0 : e22 / i2 * (s2 - 1), r22 = 0 === i2 ? 0 : r22 / i2 * (s2 - 1), n22 = 0 === i2 ? 0 : n22 / i2 * (s2 - 1);
            const o2 = Math.floor(e22), l22 = Math.floor(r22), u22 = Math.floor(n22), c22 = Math.ceil(e22), h22 = Math.ceil(r22), p22 = Math.ceil(n22), f22 = e22 - o2, d22 = r22 - l22, m22 = n22 - u22, y22 = t22.image.data, g22 = 4 * (o2 + l22 * a2 + u22 * s2), x22 = 4 * (o2 + l22 * a2 + p22 * s2), b22 = 4 * (o2 + h22 * a2 + u22 * s2), v22 = 4 * (o2 + h22 * a2 + p22 * s2), w22 = 4 * (c22 + l22 * a2 + u22 * s2), _2 = 4 * (c22 + l22 * a2 + p22 * s2), M22 = 4 * (c22 + h22 * a2 + u22 * s2), A22 = 4 * (c22 + h22 * a2 + p22 * s2);
            if (g22 < 0 || A22 >= y22.length)
              throw new Error("out of range");
            this.r = ke2(ke2(ke2(y22[g22], y22[x22], m22), ke2(y22[b22], y22[v22], m22), d22), ke2(ke2(y22[w22], y22[_2], m22), ke2(y22[M22], y22[A22], m22), d22), f22) / 255 * i2, this.g = ke2(ke2(ke2(y22[g22 + 1], y22[x22 + 1], m22), ke2(y22[b22 + 1], y22[v22 + 1], m22), d22), ke2(ke2(y22[w22 + 1], y22[_2 + 1], m22), ke2(y22[M22 + 1], y22[A22 + 1], m22), d22), f22) / 255 * i2, this.b = ke2(ke2(ke2(y22[g22 + 2], y22[x22 + 2], m22), ke2(y22[b22 + 2], y22[v22 + 2], m22), d22), ke2(ke2(y22[w22 + 2], y22[_2 + 2], m22), ke2(y22[M22 + 2], y22[A22 + 2], m22), d22), f22) / 255 * i2, this.a = i2;
          } else
            this.r = e22, this.g = r22, this.b = n22, this.a = i2;
        }
        toArray() {
          const { r: t22, g: e22, b: r22, a: n22 } = this;
          return 0 === n22 ? [0, 0, 0, 0] : [255 * t22 / n22, 255 * e22 / n22, 255 * r22 / n22, n22];
        }
        toArray01() {
          const { r: t22, g: e22, b: r22, a: n22 } = this;
          return 0 === n22 ? [0, 0, 0, 0] : [t22 / n22, e22 / n22, r22 / n22, n22];
        }
        toArray01Scaled(t22) {
          const { r: e22, g: r22, b: n22, a: i2 } = this;
          return 0 === i2 ? [0, 0, 0] : [e22 / i2 * t22, r22 / i2 * t22, n22 / i2 * t22];
        }
        toArray01PremultipliedAlpha() {
          const { r: t22, g: e22, b: r22, a: n22 } = this;
          return [t22, e22, r22, n22];
        }
        toArray01Linear() {
          const { r: t22, g: e22, b: r22, a: n22 } = this;
          return 0 === n22 ? [0, 0, 0, 0] : [Math.pow(t22 / n22, 2.2), Math.pow(e22 / n22, 2.2), Math.pow(r22 / n22, 2.2), n22];
        }
      }
      function ke2(t22, e22, r22) {
        return t22 * (1 - r22) + e22 * r22;
      }
      function Te2(t22, e22, r22) {
        return t22.map((t3, n22) => ke2(t3, e22[n22], r22));
      }
      Pe2.black = new Pe2(0, 0, 0, 1), Pe2.white = new Pe2(1, 1, 1, 1), Pe2.transparent = new Pe2(0, 0, 0, 0), Pe2.red = new Pe2(1, 0, 0, 1), Pe2.blue = new Pe2(0, 0, 1, 1);
      var Ee2 = Object.freeze({ __proto__: null, array: Te2, color: function(t22, e22, r22) {
        return new Pe2(ke2(t22.r, e22.r, r22), ke2(t22.g, e22.g, r22), ke2(t22.b, e22.b, r22), ke2(t22.a, e22.a, r22));
      }, number: ke2 });
      function Be2(t22, ...e22) {
        for (const r22 of e22)
          for (const e3 in r22)
            t22[e3] = r22[e3];
        return t22;
      }
      class Ve2 extends Error {
        constructor(t22, e22) {
          super(e22), this.message = e22, this.key = t22;
        }
      }
      class Ce2 {
        constructor(t22, e22 = []) {
          this.parent = t22, this.bindings = {};
          for (const [t3, r22] of e22)
            this.bindings[t3] = r22;
        }
        concat(t22) {
          return new Ce2(this, t22);
        }
        get(t22) {
          if (this.bindings[t22])
            return this.bindings[t22];
          if (this.parent)
            return this.parent.get(t22);
          throw new Error("".concat(t22, " not found in scope."));
        }
        has(t22) {
          return !!this.bindings[t22] || !!this.parent && this.parent.has(t22);
        }
      }
      const Re2 = { kind: "null" }, De2 = { kind: "number" }, Le2 = { kind: "string" }, Fe2 = { kind: "boolean" }, Oe2 = { kind: "color" }, Ue2 = { kind: "object" }, je2 = { kind: "value" }, Ne2 = { kind: "collator" }, qe2 = { kind: "formatted" }, $e2 = { kind: "resolvedImage" };
      function Ge2(t22, e22) {
        return { kind: "array", itemType: t22, N: e22 };
      }
      function Xe2(t22) {
        if ("array" === t22.kind) {
          const e22 = Xe2(t22.itemType);
          return "number" == typeof t22.N ? "array<".concat(e22, ", ").concat(t22.N, ">") : "value" === t22.itemType.kind ? "array" : "array<".concat(e22, ">");
        }
        return t22.kind;
      }
      const Ye2 = [Re2, De2, Le2, Fe2, Oe2, qe2, Ue2, Ge2(je2), $e2];
      function Ze2(t22, e22) {
        if ("error" === e22.kind)
          return null;
        if ("array" === t22.kind) {
          if ("array" === e22.kind && (0 === e22.N && "value" === e22.itemType.kind || !Ze2(t22.itemType, e22.itemType)) && ("number" != typeof t22.N || t22.N === e22.N))
            return null;
        } else {
          if (t22.kind === e22.kind)
            return null;
          if ("value" === t22.kind) {
            for (const t3 of Ye2)
              if (!Ze2(t3, e22))
                return null;
          }
        }
        return "Expected ".concat(Xe2(t22), " but found ").concat(Xe2(e22), " instead.");
      }
      function We2(t22, e22) {
        return e22.some((e3) => e3.kind === t22.kind);
      }
      function He2(t22, e22) {
        return e22.some((e3) => "null" === e3 ? null === t22 : "array" === e3 ? Array.isArray(t22) : "object" === e3 ? t22 && !Array.isArray(t22) && "object" == typeof t22 : e3 === typeof t22);
      }
      class Ke2 {
        constructor(t22, e22, r22) {
          this.sensitivity = t22 ? e22 ? "variant" : "case" : e22 ? "accent" : "base", this.locale = r22, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(t22, e22) {
          return this.collator.compare(t22, e22);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class Je2 {
        constructor(t22, e22, r22, n22, i2) {
          this.text = t22.normalize ? t22.normalize() : t22, this.image = e22, this.scale = r22, this.fontStack = n22, this.textColor = i2;
        }
      }
      class Qe2 {
        constructor(t22) {
          this.sections = t22;
        }
        static fromString(t22) {
          return new Qe2([new Je2(t22, null, null, null, null)]);
        }
        isEmpty() {
          return 0 === this.sections.length || !this.sections.some((t22) => 0 !== t22.text.length || t22.image && 0 !== t22.image.namePrimary.length);
        }
        static factory(t22) {
          return t22 instanceof Qe2 ? t22 : Qe2.fromString(t22);
        }
        toString() {
          return 0 === this.sections.length ? "" : this.sections.map((t22) => t22.text).join("");
        }
        serialize() {
          const t22 = ["format"];
          for (const e22 of this.sections) {
            if (e22.image) {
              t22.push(["image", e22.image.namePrimary]);
              continue;
            }
            t22.push(e22.text);
            const r22 = {};
            e22.fontStack && (r22["text-font"] = ["literal", e22.fontStack.split(",")]), e22.scale && (r22["font-scale"] = e22.scale), e22.textColor && (r22["text-color"] = ["rgba"].concat(e22.textColor.toRenderColor(null).toArray())), t22.push(r22);
          }
          return t22;
        }
      }
      class tr {
        constructor(t22) {
          this.namePrimary = t22.namePrimary, t22.nameSecondary && (this.nameSecondary = t22.nameSecondary), this.available = t22.available;
        }
        toString() {
          return this.nameSecondary ? "[".concat(this.namePrimary, ",").concat(this.nameSecondary, "]") : this.namePrimary;
        }
        static fromString(t22, e22) {
          return t22 ? new tr({ namePrimary: t22, nameSecondary: e22, available: false }) : null;
        }
        serialize() {
          return this.nameSecondary ? ["image", this.namePrimary, this.nameSecondary] : ["image", this.namePrimary];
        }
      }
      function er(t22, e22, r22, n22) {
        return "number" == typeof t22 && t22 >= 0 && t22 <= 255 && "number" == typeof e22 && e22 >= 0 && e22 <= 255 && "number" == typeof r22 && r22 >= 0 && r22 <= 255 ? void 0 === n22 || "number" == typeof n22 && n22 >= 0 && n22 <= 1 ? null : "Invalid rgba value [".concat([t22, e22, r22, n22].join(", "), "]: 'a' must be between 0 and 1.") : "Invalid rgba value [".concat(("number" == typeof n22 ? [t22, e22, r22, n22] : [t22, e22, r22]).join(", "), "]: 'r', 'g', and 'b' must be between 0 and 255.");
      }
      function rr(t22) {
        if (null === t22)
          return true;
        if ("string" == typeof t22)
          return true;
        if ("boolean" == typeof t22)
          return true;
        if ("number" == typeof t22)
          return true;
        if (t22 instanceof Pe2)
          return true;
        if (t22 instanceof Ke2)
          return true;
        if (t22 instanceof Qe2)
          return true;
        if (t22 instanceof tr)
          return true;
        if (Array.isArray(t22)) {
          for (const e22 of t22)
            if (!rr(e22))
              return false;
          return true;
        }
        if ("object" == typeof t22) {
          for (const e22 in t22)
            if (!rr(t22[e22]))
              return false;
          return true;
        }
        return false;
      }
      function nr(t22) {
        if (null === t22)
          return Re2;
        if ("string" == typeof t22)
          return Le2;
        if ("boolean" == typeof t22)
          return Fe2;
        if ("number" == typeof t22)
          return De2;
        if (t22 instanceof Pe2)
          return Oe2;
        if (t22 instanceof Ke2)
          return Ne2;
        if (t22 instanceof Qe2)
          return qe2;
        if (t22 instanceof tr)
          return $e2;
        if (Array.isArray(t22)) {
          const e22 = t22.length;
          let r22;
          for (const e3 of t22) {
            const t3 = nr(e3);
            if (r22) {
              if (r22 === t3)
                continue;
              r22 = je2;
              break;
            }
            r22 = t3;
          }
          return Ge2(r22 || je2, e22);
        }
        return Ue2;
      }
      function ir(t22) {
        const e22 = typeof t22;
        return null === t22 ? "" : "string" === e22 || "number" === e22 || "boolean" === e22 ? String(t22) : t22 instanceof Pe2 || t22 instanceof Qe2 || t22 instanceof tr ? t22.toString() : JSON.stringify(t22);
      }
      class sr {
        constructor(t22, e22) {
          this.type = t22, this.value = e22;
        }
        static parse(t22, e22) {
          if (2 !== t22.length)
            return e22.error("'literal' expression requires exactly one argument, but found ".concat(t22.length - 1, " instead."));
          if (!rr(t22[1]))
            return e22.error("invalid value");
          const r22 = t22[1];
          let n22 = nr(r22);
          const i2 = e22.expectedType;
          return "array" !== n22.kind || 0 !== n22.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n22 = i2), new sr(n22, r22);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof Pe2 ? ["rgba"].concat(this.value.toRenderColor(null).toArray()) : this.value instanceof Qe2 ? this.value.serialize() : this.value;
        }
      }
      class ar {
        constructor(t22) {
          this.name = "ExpressionEvaluationError", this.message = t22;
        }
        toJSON() {
          return this.message;
        }
      }
      const or = { string: Le2, number: De2, boolean: Fe2, object: Ue2 };
      class lr {
        constructor(t22, e22) {
          this.type = t22, this.args = e22;
        }
        static parse(t22, e22) {
          if (t22.length < 2)
            return e22.error("Expected at least one argument.");
          let r22, n22 = 1;
          const i2 = t22[0];
          if ("array" === i2) {
            let i3, s3;
            if (t22.length > 2) {
              const r3 = t22[1];
              if ("string" != typeof r3 || !(r3 in or) || "object" === r3)
                return e22.error('The item type argument of "array" must be one of string, number, boolean', 1);
              i3 = or[r3], n22++;
            } else
              i3 = je2;
            if (t22.length > 3) {
              if (null !== t22[2] && ("number" != typeof t22[2] || t22[2] < 0 || t22[2] !== Math.floor(t22[2])))
                return e22.error('The length argument to "array" must be a positive integer literal', 2);
              s3 = t22[2], n22++;
            }
            r22 = Ge2(i3, s3);
          } else
            r22 = or[i2];
          const s2 = [];
          for (; n22 < t22.length; n22++) {
            const r3 = e22.parse(t22[n22], n22, je2);
            if (!r3)
              return null;
            s2.push(r3);
          }
          return new lr(r22, s2);
        }
        evaluate(t22) {
          for (let e22 = 0; e22 < this.args.length; e22++) {
            const r22 = this.args[e22].evaluate(t22);
            if (!Ze2(this.type, nr(r22)))
              return r22;
            if (e22 === this.args.length - 1)
              throw new ar("The expression ".concat(JSON.stringify(this.args[e22].serialize()), " evaluated to ").concat(Xe2(nr(r22)), " but was expected to be of type ").concat(Xe2(this.type), "."));
          }
          return null;
        }
        eachChild(t22) {
          this.args.forEach(t22);
        }
        outputDefined() {
          return this.args.every((t22) => t22.outputDefined());
        }
        serialize() {
          const t22 = this.type, e22 = [t22.kind];
          if ("array" === t22.kind) {
            const r22 = t22.itemType;
            if ("string" === r22.kind || "number" === r22.kind || "boolean" === r22.kind) {
              e22.push(r22.kind);
              const n22 = t22.N;
              ("number" == typeof n22 || this.args.length > 1) && e22.push(n22);
            }
          }
          return e22.concat(this.args.map((t3) => t3.serialize()));
        }
      }
      class ur {
        constructor(t22) {
          this.type = qe2, this.sections = t22;
        }
        static parse(t22, e22) {
          if (t22.length < 2)
            return e22.error("Expected at least one argument.");
          const r22 = t22[1];
          if (!Array.isArray(r22) && "object" == typeof r22)
            return e22.error("First argument must be an image or text section.");
          const n22 = [];
          let i2 = false;
          for (let r3 = 1; r3 <= t22.length - 1; ++r3) {
            const s2 = t22[r3];
            if (i2 && "object" == typeof s2 && !Array.isArray(s2)) {
              i2 = false;
              let t3 = null;
              if (s2["font-scale"] && (t3 = e22.parseObjectValue(s2["font-scale"], r3, "font-scale", De2), !t3))
                return null;
              let a2 = null;
              if (s2["text-font"] && (a2 = e22.parseObjectValue(s2["text-font"], r3, "text-font", Ge2(Le2)), !a2))
                return null;
              let o2 = null;
              if (s2["text-color"] && (o2 = e22.parseObjectValue(s2["text-color"], r3, "text-color", Oe2), !o2))
                return null;
              const l22 = n22[n22.length - 1];
              l22.scale = t3, l22.font = a2, l22.textColor = o2;
            } else {
              const s3 = e22.parse(t22[r3], r3, je2);
              if (!s3)
                return null;
              const a2 = s3.type.kind;
              if ("string" !== a2 && "value" !== a2 && "null" !== a2 && "resolvedImage" !== a2)
                return e22.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              i2 = true, n22.push({ content: s3, scale: null, font: null, textColor: null });
            }
          }
          return new ur(n22);
        }
        evaluate(t22) {
          return new Qe2(this.sections.map((e22) => {
            const r22 = e22.content.evaluate(t22);
            return nr(r22) === $e2 ? new Je2("", r22, null, null, null) : new Je2(ir(r22), null, e22.scale ? e22.scale.evaluate(t22) : null, e22.font ? e22.font.evaluate(t22).join(",") : null, e22.textColor ? e22.textColor.evaluate(t22) : null);
          }));
        }
        eachChild(t22) {
          for (const e22 of this.sections)
            t22(e22.content), e22.scale && t22(e22.scale), e22.font && t22(e22.font), e22.textColor && t22(e22.textColor);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t22 = ["format"];
          for (const e22 of this.sections) {
            t22.push(e22.content.serialize());
            const r22 = {};
            e22.scale && (r22["font-scale"] = e22.scale.serialize()), e22.font && (r22["text-font"] = e22.font.serialize()), e22.textColor && (r22["text-color"] = e22.textColor.serialize()), t22.push(r22);
          }
          return t22;
        }
      }
      class cr {
        constructor(t22, e22) {
          this.type = $e2, this.inputPrimary = t22, this.inputSecondary = e22;
        }
        static parse(t22, e22) {
          if (t22.length < 2)
            return e22.error("Expected two or more arguments.");
          const r22 = e22.parse(t22[1], 1, Le2);
          if (!r22)
            return e22.error("No image name provided.");
          if (2 === t22.length)
            return new cr(r22);
          const n22 = e22.parse(t22[2], 1, Le2);
          return n22 ? new cr(r22, n22) : e22.error("Secondary image variant is not a string.");
        }
        evaluate(t22) {
          const e22 = tr.fromString(this.inputPrimary.evaluate(t22), this.inputSecondary ? this.inputSecondary.evaluate(t22) : void 0);
          return e22 && t22.availableImages && (e22.available = t22.availableImages.indexOf(e22.namePrimary) > -1, e22.nameSecondary && e22.available && t22.availableImages && (e22.available = t22.availableImages.indexOf(e22.nameSecondary) > -1)), e22;
        }
        eachChild(t22) {
          t22(this.inputPrimary), this.inputSecondary && t22(this.inputSecondary);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return this.inputSecondary ? ["image", this.inputPrimary.serialize(), this.inputSecondary.serialize()] : ["image", this.inputPrimary.serialize()];
        }
      }
      function hr(t22) {
        return t22 instanceof Number ? "number" : t22 instanceof String ? "string" : t22 instanceof Boolean ? "boolean" : Array.isArray(t22) ? "array" : null === t22 ? "null" : typeof t22;
      }
      const pr = { "to-boolean": Fe2, "to-color": Oe2, "to-number": De2, "to-string": Le2 };
      class fr {
        constructor(t22, e22) {
          this.type = t22, this.args = e22;
        }
        static parse(t22, e22) {
          if (t22.length < 2)
            return e22.error("Expected at least one argument.");
          const r22 = t22[0], n22 = [];
          let i2 = Re2;
          if ("to-array" === r22) {
            if (!Array.isArray(t22[1]))
              return null;
            const r3 = t22[1].length;
            if (e22.expectedType) {
              if ("array" !== e22.expectedType.kind)
                return e22.error("Expected ".concat(e22.expectedType.kind, " but found array."));
              i2 = Ge2(e22.expectedType.itemType, r3);
            } else {
              if (!(r3 > 0 && rr(t22[1][0])))
                return null;
              i2 = Ge2(nr(t22[1][0]), r3);
            }
            for (let s2 = 0; s2 < r3; s2++) {
              const r4 = t22[1][s2];
              let a2;
              if ("array" === hr(r4))
                a2 = e22.parse(r4, void 0, i2.itemType);
              else {
                const t3 = hr(r4);
                if (t3 !== i2.itemType.kind)
                  return e22.error("Expected ".concat(i2.itemType.kind, " but found ").concat(t3, "."));
                a2 = e22.registry.literal.parse(["literal", void 0 === r4 ? null : r4], e22);
              }
              if (!a2)
                return null;
              n22.push(a2);
            }
          } else {
            if (("to-boolean" === r22 || "to-string" === r22) && 2 !== t22.length)
              return e22.error("Expected one argument.");
            i2 = pr[r22];
            for (let r3 = 1; r3 < t22.length; r3++) {
              const i3 = e22.parse(t22[r3], r3, je2);
              if (!i3)
                return null;
              n22.push(i3);
            }
          }
          return new fr(i2, n22);
        }
        evaluate(t22) {
          if ("boolean" === this.type.kind)
            return Boolean(this.args[0].evaluate(t22));
          if ("color" === this.type.kind) {
            let e22, r22;
            for (const n22 of this.args) {
              if (e22 = n22.evaluate(t22), r22 = null, e22 instanceof Pe2)
                return e22;
              if ("string" == typeof e22) {
                const r3 = t22.parseColor(e22);
                if (r3)
                  return r3;
              } else if (Array.isArray(e22) && (r22 = e22.length < 3 || e22.length > 4 ? "Invalid rbga value ".concat(JSON.stringify(e22), ": expected an array containing either three or four numeric values.") : er(e22[0], e22[1], e22[2], e22[3]), !r22))
                return new Pe2(e22[0] / 255, e22[1] / 255, e22[2] / 255, e22[3]);
            }
            throw new ar(r22 || "Could not parse color from value '".concat("string" == typeof e22 ? e22 : String(JSON.stringify(e22)), "'"));
          }
          if ("number" === this.type.kind) {
            let e22 = null;
            for (const r22 of this.args) {
              if (e22 = r22.evaluate(t22), null === e22)
                return 0;
              const n22 = Number(e22);
              if (!isNaN(n22))
                return n22;
            }
            throw new ar("Could not convert ".concat(JSON.stringify(e22), " to number."));
          }
          return "formatted" === this.type.kind ? Qe2.fromString(ir(this.args[0].evaluate(t22))) : "resolvedImage" === this.type.kind ? tr.fromString(ir(this.args[0].evaluate(t22))) : "array" === this.type.kind ? this.args.map((e22) => e22.evaluate(t22)) : ir(this.args[0].evaluate(t22));
        }
        eachChild(t22) {
          this.args.forEach(t22);
        }
        outputDefined() {
          return this.args.every((t22) => t22.outputDefined());
        }
        serialize() {
          if ("formatted" === this.type.kind)
            return new ur([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if ("resolvedImage" === this.type.kind)
            return new cr(this.args[0]).serialize();
          const t22 = "array" === this.type.kind ? [] : ["to-".concat(this.type.kind)];
          return this.eachChild((e22) => {
            t22.push(e22.serialize());
          }), t22;
        }
      }
      const dr = ["Unknown", "Point", "LineString", "Polygon"];
      class mr {
        constructor(t22, e22) {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t22, this.options = e22;
        }
        id() {
          return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? "number" == typeof this.feature.type ? dr[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        measureLight(t22) {
          return this.globals.brightness || 0;
        }
        distanceFromCenter() {
          if (this.featureTileCoord && this.featureDistanceData) {
            const t22 = this.featureDistanceData.center, e22 = this.featureDistanceData.scale, { x: r22, y: n22 } = this.featureTileCoord;
            return this.featureDistanceData.bearing[0] * (r22 * e22 - t22[0]) + this.featureDistanceData.bearing[1] * (n22 * e22 - t22[1]);
          }
          return 0;
        }
        parseColor(t22) {
          let e22 = this._parseColorCache[t22];
          return e22 || (e22 = this._parseColorCache[t22] = Pe2.parse(t22)), e22;
        }
        getConfig(t22) {
          return this.options ? this.options.get(t22) : null;
        }
      }
      class yr {
        constructor(t22, e22, r22, n22, i2) {
          this.name = t22, this.type = e22, this._evaluate = r22, this.args = n22, this._overloadIndex = i2;
        }
        evaluate(t22) {
          if (!this._evaluate) {
            const t3 = yr.definitions[this.name];
            this._evaluate = Array.isArray(t3) ? t3[2] : t3.overloads[this._overloadIndex][1];
          }
          return this._evaluate(t22, this.args);
        }
        eachChild(t22) {
          this.args.forEach(t22);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return [this.name].concat(this.args.map((t22) => t22.serialize()));
        }
        static parse(t22, e22) {
          const r22 = t22[0], n22 = yr.definitions[r22];
          if (!n22)
            return e22.error('Unknown expression "'.concat(r22, '". If you wanted a literal array, use ["literal", [...]].'), 0);
          const i2 = Array.isArray(n22) ? n22[0] : n22.type, s2 = Array.isArray(n22) ? [[n22[1], n22[2]]] : n22.overloads, a2 = [];
          let o2 = null, l22 = -1;
          for (const [n3, u22] of s2) {
            if (Array.isArray(n3) && n3.length !== t22.length - 1)
              continue;
            a2.push(n3), l22++, o2 = new Ln(e22.registry, e22.path, null, e22.scope, void 0, e22._scope, e22.options);
            const s3 = [];
            let c22 = false;
            for (let e3 = 1; e3 < t22.length; e3++) {
              const r3 = t22[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, a3 = o2.parse(r3, 1 + s3.length, i3);
              if (!a3) {
                c22 = true;
                break;
              }
              s3.push(a3);
            }
            if (!c22)
              if (Array.isArray(n3) && n3.length !== s3.length)
                o2.error("Expected ".concat(n3.length, " arguments, but found ").concat(s3.length, " instead."));
              else {
                for (let t3 = 0; t3 < s3.length; t3++) {
                  const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = s3[t3];
                  o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                }
                if (0 === o2.errors.length)
                  return new yr(r22, i2, u22, s3, l22);
              }
          }
          if (1 === a2.length)
            e22.errors.push(...o2.errors);
          else {
            const r3 = (a2.length ? a2 : s2.map(([t3]) => t3)).map(gr).join(" | "), n3 = [];
            for (let r4 = 1; r4 < t22.length; r4++) {
              const i3 = e22.parse(t22[r4], 1 + n3.length);
              if (!i3)
                return null;
              n3.push(Xe2(i3.type));
            }
            e22.error("Expected arguments of type ".concat(r3, ", but found (").concat(n3.join(", "), ") instead."));
          }
          return null;
        }
        static register(t22, e22) {
          yr.definitions = e22;
          for (const r22 in e22)
            t22[r22] = yr;
        }
      }
      function gr(t22) {
        return Array.isArray(t22) ? "(".concat(t22.map(Xe2).join(", "), ")") : "(".concat(Xe2(t22.type), "...)");
      }
      class xr {
        constructor(t22, e22, r22) {
          this.type = Ne2, this.locale = r22, this.caseSensitive = t22, this.diacriticSensitive = e22;
        }
        static parse(t22, e22) {
          if (2 !== t22.length)
            return e22.error("Expected one argument.");
          const r22 = t22[1];
          if ("object" != typeof r22 || Array.isArray(r22))
            return e22.error("Collator options argument must be an object.");
          const n22 = void 0 === r22["case-sensitive"] ? e22.parse(false, 1, Fe2) : e22.parseObjectValue(r22["case-sensitive"], 1, "case-sensitive", Fe2);
          if (!n22)
            return null;
          const i2 = void 0 === r22["diacritic-sensitive"] ? e22.parse(false, 1, Fe2) : e22.parseObjectValue(r22["diacritic-sensitive"], 1, "diacritic-sensitive", Fe2);
          if (!i2)
            return null;
          let s2 = null;
          return r22.locale && (s2 = e22.parseObjectValue(r22.locale, 1, "locale", Le2), !s2) ? null : new xr(n22, i2, s2);
        }
        evaluate(t22) {
          return new Ke2(this.caseSensitive.evaluate(t22), this.diacriticSensitive.evaluate(t22), this.locale ? this.locale.evaluate(t22) : null);
        }
        eachChild(t22) {
          t22(this.caseSensitive), t22(this.diacriticSensitive), this.locale && t22(this.locale);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t22 = {};
          return t22["case-sensitive"] = this.caseSensitive.serialize(), t22["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t22.locale = this.locale.serialize()), ["collator", t22];
        }
      }
      function br(t22, e22, r22 = 0, n22 = t22.length - 1, i2 = wr) {
        for (; n22 > r22; ) {
          if (n22 - r22 > 600) {
            const s3 = n22 - r22 + 1, a3 = e22 - r22 + 1, o3 = Math.log(s3), l22 = 0.5 * Math.exp(2 * o3 / 3), u22 = 0.5 * Math.sqrt(o3 * l22 * (s3 - l22) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
            br(t22, e22, Math.max(r22, Math.floor(e22 - a3 * l22 / s3 + u22)), Math.min(n22, Math.floor(e22 + (s3 - a3) * l22 / s3 + u22)), i2);
          }
          const s2 = t22[e22];
          let a2 = r22, o2 = n22;
          for (vr(t22, r22, e22), i2(t22[n22], s2) > 0 && vr(t22, r22, n22); a2 < o2; ) {
            for (vr(t22, a2, o2), a2++, o2--; i2(t22[a2], s2) < 0; )
              a2++;
            for (; i2(t22[o2], s2) > 0; )
              o2--;
          }
          0 === i2(t22[r22], s2) ? vr(t22, r22, o2) : (o2++, vr(t22, o2, n22)), o2 <= e22 && (r22 = o2 + 1), e22 <= o2 && (n22 = o2 - 1);
        }
      }
      function vr(t22, e22, r22) {
        const n22 = t22[e22];
        t22[e22] = t22[r22], t22[r22] = n22;
      }
      function wr(t22, e22) {
        return t22 < e22 ? -1 : t22 > e22 ? 1 : 0;
      }
      function _r(t22) {
        let e22 = 0;
        for (let r22, n22, i2 = 0, s2 = t22.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
          r22 = t22[i2], n22 = t22[a2], e22 += (n22.x - r22.x) * (r22.y + n22.y);
        return e22;
      }
      function Mr(t22, e22) {
        t22[0] = Math.min(t22[0], e22[0]), t22[1] = Math.min(t22[1], e22[1]), t22[2] = Math.max(t22[2], e22[0]), t22[3] = Math.max(t22[3], e22[1]);
      }
      function Ar(t22, e22) {
        return !(t22[0] <= e22[0] || t22[2] >= e22[2] || t22[1] <= e22[1] || t22[3] >= e22[3]);
      }
      function Sr(t22, e22, r22) {
        const n22 = t22[0] - e22[0], i2 = t22[1] - e22[1], s2 = t22[0] - r22[0], a2 = t22[1] - r22[1];
        return n22 * a2 - s2 * i2 == 0 && n22 * s2 <= 0 && i2 * a2 <= 0;
      }
      function Ir(t22, e22, r22 = false) {
        let n22 = false;
        for (let o2 = 0, l22 = e22.length; o2 < l22; o2++) {
          const l3 = e22[o2];
          for (let e3 = 0, o3 = l3.length, u22 = o3 - 1; e3 < o3; u22 = e3++) {
            const o4 = l3[u22], c22 = l3[e3];
            if (Sr(t22, o4, c22))
              return r22;
            (s2 = o4)[1] > (i2 = t22)[1] != (a2 = c22)[1] > i2[1] && i2[0] < (a2[0] - s2[0]) * (i2[1] - s2[1]) / (a2[1] - s2[1]) + s2[0] && (n22 = !n22);
          }
        }
        var i2, s2, a2;
        return n22;
      }
      function Pr(t22, e22, r22, n22) {
        const i2 = n22[0] - r22[0], s2 = n22[1] - r22[1], a2 = (t22[0] - r22[0]) * s2 - i2 * (t22[1] - r22[1]), o2 = (e22[0] - r22[0]) * s2 - i2 * (e22[1] - r22[1]);
        return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
      }
      function zr(t22, e22, r22, n22) {
        return 0 != (i2 = [n22[0] - r22[0], n22[1] - r22[1]])[0] * (s2 = [e22[0] - t22[0], e22[1] - t22[1]])[1] - i2[1] * s2[0] && !(!Pr(t22, e22, r22, n22) || !Pr(r22, n22, t22, e22));
        var i2, s2;
      }
      const kr = 8192;
      function Tr(t22, e22) {
        const r22 = (180 + t22[0]) / 360, n22 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t22[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e22.z);
        return [Math.round(r22 * i2 * kr), Math.round(n22 * i2 * kr)];
      }
      function Er(t22, e22) {
        for (let r22 = 0; r22 < e22.length; r22++)
          if (Ir(t22, e22[r22]))
            return true;
        return false;
      }
      function Br(t22, e22, r22) {
        for (const n22 of r22)
          for (let r3 = 0, i2 = n22.length, s2 = i2 - 1; r3 < i2; s2 = r3++)
            if (zr(t22, e22, n22[s2], n22[r3]))
              return true;
        return false;
      }
      function Vr(t22, e22) {
        for (let r22 = 0; r22 < t22.length; ++r22)
          if (!Ir(t22[r22], e22))
            return false;
        for (let r22 = 0; r22 < t22.length - 1; ++r22)
          if (Br(t22[r22], t22[r22 + 1], e22))
            return false;
        return true;
      }
      function Cr(t22, e22) {
        for (let r22 = 0; r22 < e22.length; r22++)
          if (Vr(t22, e22[r22]))
            return true;
        return false;
      }
      function Rr(t22, e22, r22) {
        const n22 = [];
        for (let i2 = 0; i2 < t22.length; i2++) {
          const s2 = [];
          for (let n3 = 0; n3 < t22[i2].length; n3++) {
            const a2 = Tr(t22[i2][n3], r22);
            Mr(e22, a2), s2.push(a2);
          }
          n22.push(s2);
        }
        return n22;
      }
      function Dr(t22, e22, r22) {
        const n22 = [];
        for (let i2 = 0; i2 < t22.length; i2++) {
          const s2 = Rr(t22[i2], e22, r22);
          n22.push(s2);
        }
        return n22;
      }
      function Lr(t22, e22, r22, n22) {
        if (t22[0] < r22[0] || t22[0] > r22[2]) {
          const e3 = 0.5 * n22;
          let i2 = t22[0] - r22[0] > e3 ? -n22 : r22[0] - t22[0] > e3 ? n22 : 0;
          0 === i2 && (i2 = t22[0] - r22[2] > e3 ? -n22 : r22[2] - t22[0] > e3 ? n22 : 0), t22[0] += i2;
        }
        Mr(e22, t22);
      }
      function Fr(t22, e22, r22, n22) {
        const i2 = Math.pow(2, n22.z) * kr, s2 = [n22.x * kr, n22.y * kr], a2 = [];
        if (!t22)
          return a2;
        for (const n3 of t22)
          for (const t3 of n3) {
            const n4 = [t3.x + s2[0], t3.y + s2[1]];
            Lr(n4, e22, r22, i2), a2.push(n4);
          }
        return a2;
      }
      function Or(t22, e22, r22, n22) {
        const i2 = Math.pow(2, n22.z) * kr, s2 = [n22.x * kr, n22.y * kr], a2 = [];
        if (!t22)
          return a2;
        for (const r3 of t22) {
          const t3 = [];
          for (const n3 of r3) {
            const r4 = [n3.x + s2[0], n3.y + s2[1]];
            Mr(e22, r4), t3.push(r4);
          }
          a2.push(t3);
        }
        if (e22[2] - e22[0] <= i2 / 2) {
          (o2 = e22)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
          for (const t3 of a2)
            for (const n3 of t3)
              Lr(n3, e22, r22, i2);
        }
        var o2;
        return a2;
      }
      class Ur {
        constructor(t22, e22) {
          this.type = Fe2, this.geojson = t22, this.geometries = e22;
        }
        static parse(t22, e22) {
          if (2 !== t22.length)
            return e22.error("'within' expression requires exactly one argument, but found ".concat(t22.length - 1, " instead."));
          if (rr(t22[1])) {
            const e3 = t22[1];
            if ("FeatureCollection" === e3.type)
              for (let t3 = 0; t3 < e3.features.length; ++t3) {
                const r22 = e3.features[t3].geometry.type;
                if ("Polygon" === r22 || "MultiPolygon" === r22)
                  return new Ur(e3, e3.features[t3].geometry);
              }
            else if ("Feature" === e3.type) {
              const t3 = e3.geometry.type;
              if ("Polygon" === t3 || "MultiPolygon" === t3)
                return new Ur(e3, e3.geometry);
            } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type)
              return new Ur(e3, e3);
          }
          return e22.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t22) {
          if (null != t22.geometry() && null != t22.canonicalID()) {
            if ("Point" === t22.geometryType())
              return function(t3, e22) {
                const r22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (!i2)
                  return false;
                if ("Polygon" === e22.type) {
                  const s2 = Rr(e22.coordinates, n22, i2), a2 = Fr(t3.geometry(), r22, n22, i2);
                  if (!Ar(r22, n22))
                    return false;
                  for (const t4 of a2)
                    if (!Ir(t4, s2))
                      return false;
                }
                if ("MultiPolygon" === e22.type) {
                  const s2 = Dr(e22.coordinates, n22, i2), a2 = Fr(t3.geometry(), r22, n22, i2);
                  if (!Ar(r22, n22))
                    return false;
                  for (const t4 of a2)
                    if (!Er(t4, s2))
                      return false;
                }
                return true;
              }(t22, this.geometries);
            if ("LineString" === t22.geometryType())
              return function(t3, e22) {
                const r22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (!i2)
                  return false;
                if ("Polygon" === e22.type) {
                  const s2 = Rr(e22.coordinates, n22, i2), a2 = Or(t3.geometry(), r22, n22, i2);
                  if (!Ar(r22, n22))
                    return false;
                  for (const t4 of a2)
                    if (!Vr(t4, s2))
                      return false;
                }
                if ("MultiPolygon" === e22.type) {
                  const s2 = Dr(e22.coordinates, n22, i2), a2 = Or(t3.geometry(), r22, n22, i2);
                  if (!Ar(r22, n22))
                    return false;
                  for (const t4 of a2)
                    if (!Cr(t4, s2))
                      return false;
                }
                return true;
              }(t22, this.geometries);
          }
          return false;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["within", this.geojson];
        }
      }
      const jr = { kilometers: 1, miles: 1e3 / 1609.344, nauticalmiles: 1e3 / 1852, meters: 1e3, metres: 1e3, yards: 1e3 / 0.9144, feet: 1e3 / 0.3048, inches: 1e3 / 0.0254 }, Nr = 1 / 298.257223563, qr = Nr * (2 - Nr), $r = Math.PI / 180;
      class Gr {
        static fromTile(t22, e22, r22) {
          const n22 = Math.PI * (1 - 2 * (t22 + 0.5) / Math.pow(2, e22)), i2 = Math.atan(0.5 * (Math.exp(n22) - Math.exp(-n22))) / $r;
          return new Gr(i2, r22);
        }
        static get units() {
          return jr;
        }
        constructor(t22, e22) {
          if (void 0 === t22)
            throw new Error("No latitude given.");
          if (e22 && !jr[e22])
            throw new Error("Unknown unit ".concat(e22, ". Use one of: ").concat(Object.keys(jr).join(", ")));
          const r22 = 6378.137 * $r * (e22 ? jr[e22] : 1), n22 = Math.cos(t22 * $r), i2 = 1 / (1 - qr * (1 - n22 * n22)), s2 = Math.sqrt(i2);
          this.kx = r22 * s2 * n22, this.ky = r22 * s2 * i2 * (1 - qr);
        }
        distance(t22, e22) {
          const r22 = Zr(t22[0] - e22[0]) * this.kx, n22 = (t22[1] - e22[1]) * this.ky;
          return Math.sqrt(r22 * r22 + n22 * n22);
        }
        bearing(t22, e22) {
          const r22 = Zr(e22[0] - t22[0]) * this.kx;
          return Math.atan2(r22, (e22[1] - t22[1]) * this.ky) / $r;
        }
        destination(t22, e22, r22) {
          const n22 = r22 * $r;
          return this.offset(t22, Math.sin(n22) * e22, Math.cos(n22) * e22);
        }
        offset(t22, e22, r22) {
          return [t22[0] + e22 / this.kx, t22[1] + r22 / this.ky];
        }
        lineDistance(t22) {
          let e22 = 0;
          for (let r22 = 0; r22 < t22.length - 1; r22++)
            e22 += this.distance(t22[r22], t22[r22 + 1]);
          return e22;
        }
        area(t22) {
          let e22 = 0;
          for (let r22 = 0; r22 < t22.length; r22++) {
            const n22 = t22[r22];
            for (let t3 = 0, i2 = n22.length, s2 = i2 - 1; t3 < i2; s2 = t3++)
              e22 += Zr(n22[t3][0] - n22[s2][0]) * (n22[t3][1] + n22[s2][1]) * (r22 ? -1 : 1);
          }
          return Math.abs(e22) / 2 * this.kx * this.ky;
        }
        along(t22, e22) {
          let r22 = 0;
          if (e22 <= 0)
            return t22[0];
          for (let n22 = 0; n22 < t22.length - 1; n22++) {
            const i2 = t22[n22], s2 = t22[n22 + 1], a2 = this.distance(i2, s2);
            if (r22 += a2, r22 > e22)
              return Yr(i2, s2, (e22 - (r22 - a2)) / a2);
          }
          return t22[t22.length - 1];
        }
        pointToSegmentDistance(t22, e22, r22) {
          let [n22, i2] = e22, s2 = Zr(r22[0] - n22) * this.kx, a2 = (r22[1] - i2) * this.ky;
          if (0 !== s2 || 0 !== a2) {
            const e3 = (Zr(t22[0] - n22) * this.kx * s2 + (t22[1] - i2) * this.ky * a2) / (s2 * s2 + a2 * a2);
            e3 > 1 ? (n22 = r22[0], i2 = r22[1]) : e3 > 0 && (n22 += s2 / this.kx * e3, i2 += a2 / this.ky * e3);
          }
          return s2 = Zr(t22[0] - n22) * this.kx, a2 = (t22[1] - i2) * this.ky, Math.sqrt(s2 * s2 + a2 * a2);
        }
        pointOnLine(t22, e22) {
          let r22 = 1 / 0, n22 = t22[0][0], i2 = t22[0][1], s2 = 0, a2 = 0;
          for (let o2 = 0; o2 < t22.length - 1; o2++) {
            let l22 = t22[o2][0], u22 = t22[o2][1], c22 = Zr(t22[o2 + 1][0] - l22) * this.kx, h22 = (t22[o2 + 1][1] - u22) * this.ky, p22 = 0;
            0 === c22 && 0 === h22 || (p22 = (Zr(e22[0] - l22) * this.kx * c22 + (e22[1] - u22) * this.ky * h22) / (c22 * c22 + h22 * h22), p22 > 1 ? (l22 = t22[o2 + 1][0], u22 = t22[o2 + 1][1]) : p22 > 0 && (l22 += c22 / this.kx * p22, u22 += h22 / this.ky * p22)), c22 = Zr(e22[0] - l22) * this.kx, h22 = (e22[1] - u22) * this.ky;
            const f22 = c22 * c22 + h22 * h22;
            f22 < r22 && (r22 = f22, n22 = l22, i2 = u22, s2 = o2, a2 = p22);
          }
          return { point: [n22, i2], index: s2, t: Math.max(0, Math.min(1, a2)) };
        }
        lineSlice(t22, e22, r22) {
          let n22 = this.pointOnLine(r22, t22), i2 = this.pointOnLine(r22, e22);
          if (n22.index > i2.index || n22.index === i2.index && n22.t > i2.t) {
            const t3 = n22;
            n22 = i2, i2 = t3;
          }
          const s2 = [n22.point], a2 = n22.index + 1, o2 = i2.index;
          !Xr(r22[a2], s2[0]) && a2 <= o2 && s2.push(r22[a2]);
          for (let t3 = a2 + 1; t3 <= o2; t3++)
            s2.push(r22[t3]);
          return Xr(r22[o2], i2.point) || s2.push(i2.point), s2;
        }
        lineSliceAlong(t22, e22, r22) {
          let n22 = 0;
          const i2 = [];
          for (let s2 = 0; s2 < r22.length - 1; s2++) {
            const a2 = r22[s2], o2 = r22[s2 + 1], l22 = this.distance(a2, o2);
            if (n22 += l22, n22 > t22 && 0 === i2.length && i2.push(Yr(a2, o2, (t22 - (n22 - l22)) / l22)), n22 >= e22)
              return i2.push(Yr(a2, o2, (e22 - (n22 - l22)) / l22)), i2;
            n22 > t22 && i2.push(o2);
          }
          return i2;
        }
        bufferPoint(t22, e22) {
          const r22 = e22 / this.ky, n22 = e22 / this.kx;
          return [t22[0] - n22, t22[1] - r22, t22[0] + n22, t22[1] + r22];
        }
        bufferBBox(t22, e22) {
          const r22 = e22 / this.ky, n22 = e22 / this.kx;
          return [t22[0] - n22, t22[1] - r22, t22[2] + n22, t22[3] + r22];
        }
        insideBBox(t22, e22) {
          return Zr(t22[0] - e22[0]) >= 0 && Zr(t22[0] - e22[2]) <= 0 && t22[1] >= e22[1] && t22[1] <= e22[3];
        }
      }
      function Xr(t22, e22) {
        return t22[0] === e22[0] && t22[1] === e22[1];
      }
      function Yr(t22, e22, r22) {
        const n22 = Zr(e22[0] - t22[0]);
        return [t22[0] + n22 * r22, t22[1] + (e22[1] - t22[1]) * r22];
      }
      function Zr(t22) {
        for (; t22 < -180; )
          t22 += 360;
        for (; t22 > 180; )
          t22 -= 360;
        return t22;
      }
      class Wr {
        constructor(t22 = [], e22 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
          if (this.data = t22, this.length = this.data.length, this.compare = e22, this.length > 0)
            for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--)
              this._down(t3);
        }
        push(t22) {
          this.data.push(t22), this._up(this.length++);
        }
        pop() {
          if (0 === this.length)
            return;
          const t22 = this.data[0], e22 = this.data.pop();
          return --this.length > 0 && (this.data[0] = e22, this._down(0)), t22;
        }
        peek() {
          return this.data[0];
        }
        _up(t22) {
          const { data: e22, compare: r22 } = this, n22 = e22[t22];
          for (; t22 > 0; ) {
            const i2 = t22 - 1 >> 1, s2 = e22[i2];
            if (r22(n22, s2) >= 0)
              break;
            e22[t22] = s2, t22 = i2;
          }
          e22[t22] = n22;
        }
        _down(t22) {
          const { data: e22, compare: r22 } = this, n22 = this.length >> 1, i2 = e22[t22];
          for (; t22 < n22; ) {
            let n3 = 1 + (t22 << 1);
            const s2 = n3 + 1;
            if (s2 < this.length && r22(e22[s2], e22[n3]) < 0 && (n3 = s2), r22(e22[n3], i2) >= 0)
              break;
            e22[t22] = e22[n3], t22 = n3;
          }
          e22[t22] = i2;
        }
      }
      var Hr = 8192;
      function Kr(t22, e22) {
        return e22.dist - t22.dist;
      }
      const Jr = 100, Qr = 50;
      function tn(t22) {
        const e22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        if (e22.length !== t22.length)
          return false;
        for (let r22 = 0; r22 < e22.length; r22++)
          if (e22[r22] !== t22[r22])
            return false;
        return true;
      }
      function en(t22) {
        return t22[1] - t22[0] + 1;
      }
      function rn(t22, e22) {
        const r22 = t22[1] >= t22[0] && t22[1] < e22;
        return r22 || console.warn("Distance Expression: Index is out of range"), r22;
      }
      function nn(t22, e22) {
        if (t22[0] > t22[1])
          return [null, null];
        const r22 = en(t22);
        if (e22) {
          if (2 === r22)
            return [t22, null];
          const e3 = Math.floor(r22 / 2);
          return [[t22[0], t22[0] + e3], [t22[0] + e3, t22[1]]];
        }
        {
          if (1 === r22)
            return [t22, null];
          const e3 = Math.floor(r22 / 2) - 1;
          return [[t22[0], t22[0] + e3], [t22[0] + e3 + 1, t22[1]]];
        }
      }
      function sn(t22, e22) {
        const r22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        if (!rn(e22, t22.length))
          return r22;
        for (let n22 = e22[0]; n22 <= e22[1]; ++n22)
          Mr(r22, t22[n22]);
        return r22;
      }
      function an(t22) {
        const e22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let r22 = 0; r22 < t22.length; ++r22)
          for (let n22 = 0; n22 < t22[r22].length; ++n22)
            Mr(e22, t22[r22][n22]);
        return e22;
      }
      function on(t22, e22, r22) {
        if (tn(t22) || tn(e22))
          return NaN;
        let n22 = 0, i2 = 0;
        return t22[2] < e22[0] && (n22 = e22[0] - t22[2]), t22[0] > e22[2] && (n22 = t22[0] - e22[2]), t22[1] > e22[3] && (i2 = t22[1] - e22[3]), t22[3] < e22[1] && (i2 = e22[1] - t22[3]), r22.distance([0, 0], [n22, i2]);
      }
      function ln(t22) {
        return 360 * t22 - 180;
      }
      function un(t22) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t22) * Math.PI / 180)) - 90;
      }
      function cn(t22, e22) {
        const r22 = Math.pow(2, e22.z), n22 = (t22.y / Hr + e22.y) / r22;
        return [ln((t22.x / Hr + e22.x) / r22), un(n22)];
      }
      function hn(t22, e22) {
        const r22 = [];
        for (let n22 = 0; n22 < t22.length; ++n22)
          r22.push(cn(t22[n22], e22));
        return r22;
      }
      function pn(t22, e22, r22) {
        const n22 = r22.pointOnLine(e22, t22).point;
        return r22.distance(t22, n22);
      }
      function fn(t22, e22, r22, n22, i2) {
        const s2 = r22.slice(n22[0], n22[1] + 1);
        let a2 = 1 / 0;
        for (let r3 = e22[0]; r3 <= e22[1]; ++r3)
          if (0 === (a2 = Math.min(a2, pn(t22[r3], s2, i2))))
            return 0;
        return a2;
      }
      function dn(t22, e22, r22, n22, i2) {
        const s2 = Math.min(i2.pointToSegmentDistance(t22, r22, n22), i2.pointToSegmentDistance(e22, r22, n22)), a2 = Math.min(i2.pointToSegmentDistance(r22, t22, e22), i2.pointToSegmentDistance(n22, t22, e22));
        return Math.min(s2, a2);
      }
      function mn(t22, e22, r22, n22, i2) {
        if (!rn(e22, t22.length) || !rn(n22, r22.length))
          return NaN;
        let s2 = 1 / 0;
        for (let a2 = e22[0]; a2 < e22[1]; ++a2)
          for (let e3 = n22[0]; e3 < n22[1]; ++e3) {
            if (zr(t22[a2], t22[a2 + 1], r22[e3], r22[e3 + 1]))
              return 0;
            s2 = Math.min(s2, dn(t22[a2], t22[a2 + 1], r22[e3], r22[e3 + 1], i2));
          }
        return s2;
      }
      function yn(t22, e22, r22, n22, i2) {
        if (!rn(e22, t22.length) || !rn(n22, r22.length))
          return NaN;
        let s2 = 1 / 0;
        for (let a2 = e22[0]; a2 <= e22[1]; ++a2)
          for (let e3 = n22[0]; e3 <= n22[1]; ++e3)
            if (0 === (s2 = Math.min(s2, i2.distance(t22[a2], r22[e3]))))
              return s2;
        return s2;
      }
      function gn(t22, e22, r22) {
        if (Ir(t22, e22, true))
          return 0;
        let n22 = 1 / 0;
        for (const i2 of e22) {
          const e3 = i2.length;
          if (e3 < 2)
            return console.warn("Distance Expression: Invalid polygon!"), NaN;
          if (i2[0] !== i2[e3 - 1] && 0 === (n22 = Math.min(n22, r22.pointToSegmentDistance(t22, i2[e3 - 1], i2[0]))))
            return n22;
          if (0 === (n22 = Math.min(n22, pn(t22, i2, r22))))
            return n22;
        }
        return n22;
      }
      function xn(t22, e22, r22, n22) {
        if (!rn(e22, t22.length))
          return NaN;
        for (let n3 = e22[0]; n3 <= e22[1]; ++n3)
          if (Ir(t22[n3], r22, true))
            return 0;
        let i2 = 1 / 0;
        for (let s2 = e22[0]; s2 < e22[1]; ++s2)
          for (const e3 of r22)
            for (let r3 = 0, a2 = e3.length, o2 = a2 - 1; r3 < a2; o2 = r3++) {
              if (zr(t22[s2], t22[s2 + 1], e3[o2], e3[r3]))
                return 0;
              i2 = Math.min(i2, dn(t22[s2], t22[s2 + 1], e3[o2], e3[r3], n22));
            }
        return i2;
      }
      function bn(t22, e22) {
        for (const r22 of t22)
          for (let t3 = 0; t3 <= r22.length - 1; ++t3)
            if (Ir(r22[t3], e22, true))
              return true;
        return false;
      }
      function vn(t22, e22, r22, n22 = 1 / 0) {
        const i2 = an(t22), s2 = an(e22);
        if (n22 !== 1 / 0 && on(i2, s2, r22) >= n22)
          return n22;
        if (Ar(i2, s2)) {
          if (bn(t22, e22))
            return 0;
        } else if (bn(e22, t22))
          return 0;
        let a2 = n22;
        for (const n3 of t22)
          for (let t3 = 0, i3 = n3.length, s3 = i3 - 1; t3 < i3; s3 = t3++)
            for (const i4 of e22)
              for (let e3 = 0, o2 = i4.length, l22 = o2 - 1; e3 < o2; l22 = e3++) {
                if (zr(n3[s3], n3[t3], i4[l22], i4[e3]))
                  return 0;
                a2 = Math.min(a2, dn(n3[s3], n3[t3], i4[l22], i4[e3], r22));
              }
        return a2;
      }
      function wn(t22, e22, r22, n22, i2, s2, a2) {
        if (null === s2 || null === a2)
          return;
        const o2 = on(sn(n22, s2), sn(i2, a2), r22);
        o2 < e22 && t22.push({ dist: o2, range1: s2, range2: a2 });
      }
      function _n(t22, e22, r22, n22, i2 = 1 / 0) {
        let s2 = Math.min(n22.distance(t22[0], r22[0][0]), i2);
        if (0 === s2)
          return s2;
        const a2 = new Wr([{ dist: 0, range1: [0, t22.length - 1], range2: [0, 0] }], Kr), o2 = e22 ? Qr : Jr, l22 = an(r22);
        for (; a2.length; ) {
          const i3 = a2.pop();
          if (i3.dist >= s2)
            continue;
          const u22 = i3.range1;
          if (en(u22) <= o2) {
            if (!rn(u22, t22.length))
              return NaN;
            if (e22) {
              const e3 = xn(t22, u22, r22, n22);
              if (0 === (s2 = Math.min(s2, e3)))
                return s2;
            } else
              for (let e3 = u22[0]; e3 <= u22[1]; ++e3) {
                const i4 = gn(t22[e3], r22, n22);
                if (0 === (s2 = Math.min(s2, i4)))
                  return s2;
              }
          } else {
            const r3 = nn(u22, e22);
            if (null !== r3[0]) {
              const e3 = on(sn(t22, r3[0]), l22, n22);
              e3 < s2 && a2.push({ dist: e3, range1: r3[0], range2: [0, 0] });
            }
            if (null !== r3[1]) {
              const e3 = on(sn(t22, r3[1]), l22, n22);
              e3 < s2 && a2.push({ dist: e3, range1: r3[1], range2: [0, 0] });
            }
          }
        }
        return s2;
      }
      function Mn(t22, e22, r22, n22, i2, s2 = 1 / 0) {
        let a2 = Math.min(s2, i2.distance(t22[0], r22[0]));
        if (0 === a2)
          return a2;
        const o2 = new Wr([{ dist: 0, range1: [0, t22.length - 1], range2: [0, r22.length - 1] }], Kr), l22 = e22 ? Qr : Jr, u22 = n22 ? Qr : Jr;
        for (; o2.length; ) {
          const s3 = o2.pop();
          if (s3.dist >= a2)
            continue;
          const c22 = s3.range1, h22 = s3.range2;
          if (en(c22) <= l22 && en(h22) <= u22) {
            if (!rn(c22, t22.length) || !rn(h22, r22.length))
              return NaN;
            if (e22 && n22 ? a2 = Math.min(a2, mn(t22, c22, r22, h22, i2)) : e22 || n22 ? e22 && !n22 ? a2 = Math.min(a2, fn(r22, h22, t22, c22, i2)) : !e22 && n22 && (a2 = Math.min(a2, fn(t22, c22, r22, h22, i2))) : a2 = Math.min(a2, yn(t22, c22, r22, h22, i2)), 0 === a2)
              return a2;
          } else {
            const s4 = nn(c22, e22), l3 = nn(h22, n22);
            wn(o2, a2, i2, t22, r22, s4[0], l3[0]), wn(o2, a2, i2, t22, r22, s4[0], l3[1]), wn(o2, a2, i2, t22, r22, s4[1], l3[0]), wn(o2, a2, i2, t22, r22, s4[1], l3[1]);
          }
        }
        return a2;
      }
      function An(t22, e22, r22, n22, i2 = 1 / 0) {
        let s2 = i2;
        const a2 = sn(t22, [0, t22.length - 1]);
        for (const i3 of r22)
          if (!(s2 !== 1 / 0 && on(a2, sn(i3, [0, i3.length - 1]), n22) >= s2) && (s2 = Math.min(s2, Mn(t22, e22, i3, true, n22, s2)), 0 === s2))
            return s2;
        return s2;
      }
      function Sn(t22, e22, r22, n22, i2 = 1 / 0) {
        let s2 = i2;
        const a2 = sn(t22, [0, t22.length - 1]);
        for (const i3 of r22) {
          if (s2 !== 1 / 0 && on(a2, an(i3), n22) >= s2)
            continue;
          const r3 = _n(t22, e22, i3, n22, s2);
          if (isNaN(r3))
            return r3;
          if (0 === (s2 = Math.min(s2, r3)))
            return s2;
        }
        return s2;
      }
      function In(t22) {
        return "Point" === t22 || "MultiPoint" === t22 || "LineString" === t22 || "MultiLineString" === t22 || "Polygon" === t22 || "MultiPolygon" === t22;
      }
      class Pn {
        constructor(t22, e22) {
          this.type = De2, this.geojson = t22, this.geometries = e22;
        }
        static parse(t22, e22) {
          if (2 !== t22.length)
            return e22.error("'distance' expression requires either one argument, but found ' ".concat(t22.length - 1, " instead."));
          if (rr(t22[1])) {
            const e3 = t22[1];
            if ("FeatureCollection" === e3.type) {
              for (let t3 = 0; t3 < e3.features.length; ++t3)
                if (In(e3.features[t3].geometry.type))
                  return new Pn(e3, e3.features[t3].geometry);
            } else if ("Feature" === e3.type) {
              if (In(e3.geometry.type))
                return new Pn(e3, e3.geometry);
            } else if (In(e3.type))
              return new Pn(e3, e3);
          }
          return e22.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
        }
        evaluate(t22) {
          const e22 = t22.geometry(), r22 = t22.canonicalID();
          if (null != e22 && null != r22) {
            if ("Point" === t22.geometryType())
              return function(t3, e3, r3) {
                const n22 = [];
                for (const r4 of t3)
                  for (const t4 of r4)
                    n22.push(cn(t4, e3));
                const i2 = new Gr(n22[0][1], "meters");
                return "Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type ? Mn(n22, false, "Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, i2) : "MultiLineString" === r3.type ? An(n22, false, r3.coordinates, i2) : "Polygon" === r3.type || "MultiPolygon" === r3.type ? Sn(n22, false, "Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, i2) : null;
              }(e22, r22, this.geometries);
            if ("LineString" === t22.geometryType())
              return function(t3, e3, r3) {
                const n22 = [];
                for (const r4 of t3) {
                  const t4 = [];
                  for (const n3 of r4)
                    t4.push(cn(n3, e3));
                  n22.push(t4);
                }
                const i2 = new Gr(n22[0][0][1], "meters");
                if ("Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type)
                  return An("Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, n22, i2);
                if ("MultiLineString" === r3.type) {
                  let t4 = 1 / 0;
                  for (let e4 = 0; e4 < r3.coordinates.length; e4++) {
                    const s2 = An(r3.coordinates[e4], true, n22, i2, t4);
                    if (isNaN(s2))
                      return s2;
                    if (0 === (t4 = Math.min(t4, s2)))
                      return t4;
                  }
                  return t4;
                }
                if ("Polygon" === r3.type || "MultiPolygon" === r3.type) {
                  let t4 = 1 / 0;
                  for (let e4 = 0; e4 < n22.length; e4++) {
                    const s2 = Sn(n22[e4], true, "Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, i2, t4);
                    if (isNaN(s2))
                      return s2;
                    if (0 === (t4 = Math.min(t4, s2)))
                      return t4;
                  }
                  return t4;
                }
                return null;
              }(e22, r22, this.geometries);
            if ("Polygon" === t22.geometryType())
              return function(t3, e3, r3) {
                const n22 = [];
                for (const r4 of function(t4, e4) {
                  const r5 = t4.length;
                  if (r5 <= 1)
                    return [t4];
                  const n3 = [];
                  let i3, s2;
                  for (let e5 = 0; e5 < r5; e5++) {
                    const r6 = _r(t4[e5]);
                    0 !== r6 && (t4[e5].area = Math.abs(r6), void 0 === s2 && (s2 = r6 < 0), s2 === r6 < 0 ? (i3 && n3.push(i3), i3 = [t4[e5]]) : i3.push(t4[e5]));
                  }
                  return i3 && n3.push(i3), n3;
                }(t3)) {
                  const t4 = [];
                  for (let n3 = 0; n3 < r4.length; ++n3)
                    t4.push(hn(r4[n3], e3));
                  n22.push(t4);
                }
                const i2 = new Gr(n22[0][0][0][1], "meters");
                if ("Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type)
                  return Sn("Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, n22, i2);
                if ("MultiLineString" === r3.type) {
                  let t4 = 1 / 0;
                  for (let e4 = 0; e4 < r3.coordinates.length; e4++) {
                    const s2 = Sn(r3.coordinates[e4], true, n22, i2, t4);
                    if (isNaN(s2))
                      return s2;
                    if (0 === (t4 = Math.min(t4, s2)))
                      return t4;
                  }
                  return t4;
                }
                return "Polygon" === r3.type || "MultiPolygon" === r3.type ? function(t4, e4, r4) {
                  let n3 = 1 / 0;
                  for (const i3 of t4)
                    for (const t5 of e4) {
                      const e5 = vn(i3, t5, r4, n3);
                      if (isNaN(e5))
                        return e5;
                      if (0 === (n3 = Math.min(n3, e5)))
                        return n3;
                    }
                  return n3;
                }("Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, n22, i2) : null;
              }(e22, r22, this.geometries);
            console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
          } else
            console.warn("Distance Expression: requirs valid feature and canonical information.");
          return null;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["distance", this.geojson];
        }
      }
      function zn(t22, e22) {
        switch (t22) {
          case "string":
            return ir(e22);
          case "number":
            return +e22;
          case "boolean":
            return !!e22;
          case "color":
            return Pe2.parse(e22);
          case "formatted":
            return Qe2.fromString(ir(e22));
          case "resolvedImage":
            return tr.fromString(ir(e22));
        }
        return e22;
      }
      function kn(t22, e22, r22, n22) {
        return void 0 !== n22 && (t22 = n22 * Math.round(t22 / n22)), void 0 !== e22 && t22 < e22 && (t22 = e22), void 0 !== r22 && t22 > r22 && (t22 = r22), t22;
      }
      class Tn {
        constructor(t22, e22, r22) {
          this.type = t22, this.key = e22, this.scope = r22;
        }
        static parse(t22, e22) {
          let r22 = e22.expectedType;
          if (null == r22 && (r22 = je2), t22.length < 2 || t22.length > 3)
            return e22.error("Invalid number of arguments for 'config' expression.");
          const n22 = e22.parse(t22[1], 1);
          if (!(n22 instanceof sr))
            return e22.error("Key name of 'config' expression must be a string literal.");
          if (t22.length >= 3) {
            const i2 = e22.parse(t22[2], 2);
            return i2 instanceof sr ? new Tn(r22, ir(n22.value), ir(i2.value)) : e22.error("Scope of 'config' expression must be a string literal.");
          }
          return new Tn(r22, ir(n22.value));
        }
        evaluate(t22) {
          const e22 = [this.key, this.scope, t22.scope].filter(Boolean).join(""), r22 = t22.getConfig(e22);
          if (!r22)
            return null;
          const { type: n22, value: i2, values: s2, minValue: a2, maxValue: o2, stepValue: l22 } = r22, u22 = r22.default.evaluate(t22);
          let c22 = u22;
          if (i2) {
            const e3 = t22.scope;
            t22.scope = (e3 || "").split("").slice(1).join(""), c22 = i2.evaluate(t22), t22.scope = e3;
          }
          return n22 && (c22 = zn(n22, c22)), void 0 === c22 || void 0 === a2 && void 0 === o2 && void 0 === l22 || ("number" == typeof c22 ? c22 = kn(c22, a2, o2, l22) : Array.isArray(c22) && (c22 = c22.map((t3) => "number" == typeof t3 ? kn(t3, a2, o2, l22) : t3))), void 0 !== i2 && void 0 !== c22 && s2 && !s2.includes(c22) && (c22 = u22, n22 && (c22 = zn(n22, c22))), (n22 && n22 !== this.type || void 0 !== c22 && nr(c22) !== this.type) && (c22 = zn(this.type.kind, c22)), c22;
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t22 = ["config", this.key];
          return this.scope && t22.concat(this.key), t22;
        }
      }
      function En(t22) {
        if (t22 instanceof yr) {
          if ("get" === t22.name && 1 === t22.args.length)
            return false;
          if ("feature-state" === t22.name)
            return false;
          if ("has" === t22.name && 1 === t22.args.length)
            return false;
          if ("properties" === t22.name || "geometry-type" === t22.name || "id" === t22.name)
            return false;
          if (/^filter-/.test(t22.name))
            return false;
        }
        if (t22 instanceof Ur)
          return false;
        if (t22 instanceof Pn)
          return false;
        let e22 = true;
        return t22.eachChild((t3) => {
          e22 && !En(t3) && (e22 = false);
        }), e22;
      }
      function Bn(t22) {
        if (t22 instanceof yr && "feature-state" === t22.name)
          return false;
        let e22 = true;
        return t22.eachChild((t3) => {
          e22 && !Bn(t3) && (e22 = false);
        }), e22;
      }
      function Vn(t22) {
        if (t22 instanceof Tn)
          return /* @__PURE__ */ new Set([t22.key]);
        let e22 = /* @__PURE__ */ new Set();
        return t22.eachChild((t3) => {
          e22 = /* @__PURE__ */ new Set([...e22, ...Vn(t3)]);
        }), e22;
      }
      function Cn(t22, e22) {
        if (t22 instanceof yr && e22.indexOf(t22.name) >= 0)
          return false;
        let r22 = true;
        return t22.eachChild((t3) => {
          r22 && !Cn(t3, e22) && (r22 = false);
        }), r22;
      }
      class Rn {
        constructor(t22, e22) {
          this.type = e22.type, this.name = t22, this.boundExpression = e22;
        }
        static parse(t22, e22) {
          if (2 !== t22.length || "string" != typeof t22[1])
            return e22.error("'var' expression requires exactly one string literal argument.");
          const r22 = t22[1];
          return e22.scope.has(r22) ? new Rn(r22, e22.scope.get(r22)) : e22.error('Unknown variable "'.concat(r22, '". Make sure "').concat(r22, '" has been bound in an enclosing "let" expression before using it.'), 1);
        }
        evaluate(t22) {
          return this.boundExpression.evaluate(t22);
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["var", this.name];
        }
      }
      class Dn {
        constructor(t22, e22 = [], r22, n22 = new Ce2(), i2 = [], s2, a2) {
          this.registry = t22, this.path = e22, this.key = e22.map((t3) => "string" == typeof t3 ? "['".concat(t3, "']") : "[".concat(t3, "]")).join(""), this.scope = n22, this.errors = i2, this.expectedType = r22, this._scope = s2, this.options = a2;
        }
        parse(t22, e22, r22, n22, i2 = {}) {
          return e22 || r22 ? this.concat(e22, null, r22, n22)._parse(t22, i2) : this._parse(t22, i2);
        }
        parseObjectValue(t22, e22, r22, n22, i2, s2 = {}) {
          return this.concat(e22, r22, n22, i2)._parse(t22, s2);
        }
        _parse(t22, e22) {
          function r22(t3, e3, r3) {
            return "assert" === r3 ? new lr(e3, [t3]) : "coerce" === r3 ? new fr(e3, [t3]) : t3;
          }
          if (null !== t22 && "string" != typeof t22 && "boolean" != typeof t22 && "number" != typeof t22 || (t22 = ["literal", t22]), Array.isArray(t22)) {
            if (0 === t22.length)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const n22 = "string" == typeof t22[0] ? this.registry[t22[0]] : void 0;
            if (n22) {
              let i2 = n22.parse(t22, this);
              if (!i2)
                return null;
              if (this.expectedType) {
                const t3 = this.expectedType, n3 = i2.type;
                if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== n3.kind)
                  if ("color" !== t3.kind && "formatted" !== t3.kind && "resolvedImage" !== t3.kind || "value" !== n3.kind && "string" !== n3.kind) {
                    if (this.checkSubtype(t3, n3))
                      return null;
                  } else
                    i2 = r22(i2, t3, e22.typeAnnotation || "coerce");
                else
                  i2 = r22(i2, t3, e22.typeAnnotation || "assert");
              }
              if (!(i2 instanceof sr) && "resolvedImage" !== i2.type.kind && Fn(i2)) {
                const t3 = new mr(this._scope, this.options);
                try {
                  i2 = new sr(i2.type, i2.evaluate(t3));
                } catch (t4) {
                  return this.error(t4.message), null;
                }
              }
              return i2;
            }
            return fr.parse(["to-array", t22], this);
          }
          return this.error(void 0 === t22 ? "'undefined' value invalid. Use null instead." : "object" == typeof t22 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : "Expected an array, but found ".concat(typeof t22, " instead."));
        }
        concat(t22, e22, r22, n22) {
          let i2 = "number" == typeof t22 ? this.path.concat(t22) : this.path;
          i2 = "string" == typeof e22 ? i2.concat(e22) : i2;
          const s2 = n22 ? this.scope.concat(n22) : this.scope;
          return new Dn(this.registry, i2, r22 || null, s2, this.errors, this._scope, this.options);
        }
        error(t22, ...e22) {
          const r22 = "".concat(this.key).concat(e22.map((t3) => "[".concat(t3, "]")).join(""));
          this.errors.push(new Ve2(r22, t22));
        }
        checkSubtype(t22, e22) {
          const r22 = Ze2(t22, e22);
          return r22 && this.error(r22), r22;
        }
      }
      var Ln = Dn;
      function Fn(t22) {
        if (t22 instanceof Rn)
          return Fn(t22.boundExpression);
        if (t22 instanceof yr && "error" === t22.name)
          return false;
        if (t22 instanceof xr)
          return false;
        if (t22 instanceof Ur)
          return false;
        if (t22 instanceof Pn)
          return false;
        if (t22 instanceof Tn)
          return false;
        const e22 = t22 instanceof fr || t22 instanceof lr;
        let r22 = true;
        return t22.eachChild((t3) => {
          r22 = e22 ? r22 && Fn(t3) : r22 && t3 instanceof sr;
        }), !!r22 && En(t22) && Cn(t22, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]);
      }
      function On(t22, e22) {
        const r22 = t22.length - 1;
        let n22, i2, s2 = 0, a2 = r22, o2 = 0;
        for (; s2 <= a2; )
          if (o2 = Math.floor((s2 + a2) / 2), n22 = t22[o2], i2 = t22[o2 + 1], n22 <= e22) {
            if (o2 === r22 || e22 < i2)
              return o2;
            s2 = o2 + 1;
          } else {
            if (!(n22 > e22))
              throw new ar("Input is not a number.");
            a2 = o2 - 1;
          }
        return 0;
      }
      class Un {
        constructor(t22, e22, r22) {
          this.type = t22, this.input = e22, this.labels = [], this.outputs = [];
          for (const [t3, e3] of r22)
            this.labels.push(t3), this.outputs.push(e3);
        }
        static parse(t22, e22) {
          if (t22.length - 1 < 4)
            return e22.error("Expected at least 4 arguments, but found only ".concat(t22.length - 1, "."));
          if ((t22.length - 1) % 2 != 0)
            return e22.error("Expected an even number of arguments.");
          const r22 = e22.parse(t22[1], 1, De2);
          if (!r22)
            return null;
          const n22 = [];
          let i2 = null;
          e22.expectedType && "value" !== e22.expectedType.kind && (i2 = e22.expectedType);
          for (let r3 = 1; r3 < t22.length; r3 += 2) {
            const s2 = 1 === r3 ? -1 / 0 : t22[r3], a2 = t22[r3 + 1], o2 = r3, l22 = r3 + 1;
            if ("number" != typeof s2)
              return e22.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
            if (n22.length && n22[n22.length - 1][0] >= s2)
              return e22.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
            const u22 = e22.parse(a2, l22, i2);
            if (!u22)
              return null;
            i2 = i2 || u22.type, n22.push([s2, u22]);
          }
          return new Un(i2, r22, n22);
        }
        evaluate(t22) {
          const e22 = this.labels, r22 = this.outputs;
          if (1 === e22.length)
            return r22[0].evaluate(t22);
          const n22 = this.input.evaluate(t22);
          if (n22 <= e22[0])
            return r22[0].evaluate(t22);
          const i2 = e22.length;
          return n22 >= e22[i2 - 1] ? r22[i2 - 1].evaluate(t22) : r22[On(e22, n22)].evaluate(t22);
        }
        eachChild(t22) {
          t22(this.input);
          for (const e22 of this.outputs)
            t22(e22);
        }
        outputDefined() {
          return this.outputs.every((t22) => t22.outputDefined());
        }
        serialize() {
          const t22 = ["step", this.input.serialize()];
          for (let e22 = 0; e22 < this.labels.length; e22++)
            e22 > 0 && t22.push(this.labels[e22]), t22.push(this.outputs[e22].serialize());
          return t22;
        }
      }
      const jn = 0.95047, Nn = 1.08883, qn = 4 / 29, $n = 6 / 29, Gn = 3 * $n * $n, Xn = $n * $n * $n, Yn = Math.PI / 180, Zn = 180 / Math.PI;
      function Wn(t22) {
        return t22 > Xn ? Math.pow(t22, 1 / 3) : t22 / Gn + qn;
      }
      function Hn(t22) {
        return t22 > $n ? t22 * t22 * t22 : Gn * (t22 - qn);
      }
      function Kn(t22) {
        return 255 * (t22 <= 31308e-7 ? 12.92 * t22 : 1.055 * Math.pow(t22, 1 / 2.4) - 0.055);
      }
      function Jn(t22) {
        return (t22 /= 255) <= 0.04045 ? t22 / 12.92 : Math.pow((t22 + 0.055) / 1.055, 2.4);
      }
      function Qn(t22) {
        const e22 = Jn(t22.r), r22 = Jn(t22.g), n22 = Jn(t22.b), i2 = Wn((0.4124564 * e22 + 0.3575761 * r22 + 0.1804375 * n22) / jn), s2 = Wn((0.2126729 * e22 + 0.7151522 * r22 + 0.072175 * n22) / 1);
        return { l: 116 * s2 - 16, a: 500 * (i2 - s2), b: 200 * (s2 - Wn((0.0193339 * e22 + 0.119192 * r22 + 0.9503041 * n22) / Nn)), alpha: t22.a };
      }
      function ti2(t22) {
        let e22 = (t22.l + 16) / 116, r22 = isNaN(t22.a) ? e22 : e22 + t22.a / 500, n22 = isNaN(t22.b) ? e22 : e22 - t22.b / 200;
        return e22 = 1 * Hn(e22), r22 = jn * Hn(r22), n22 = Nn * Hn(n22), new Pe2(Kn(3.2404542 * r22 - 1.5371385 * e22 - 0.4985314 * n22), Kn(-0.969266 * r22 + 1.8760108 * e22 + 0.041556 * n22), Kn(0.0556434 * r22 - 0.2040259 * e22 + 1.0572252 * n22), t22.alpha);
      }
      function ei2(t22, e22, r22) {
        const n22 = e22 - t22;
        return t22 + r22 * (n22 > 180 || n22 < -180 ? n22 - 360 * Math.round(n22 / 360) : n22);
      }
      const ri2 = { forward: Qn, reverse: ti2, interpolate: function(t22, e22, r22) {
        return { l: ke2(t22.l, e22.l, r22), a: ke2(t22.a, e22.a, r22), b: ke2(t22.b, e22.b, r22), alpha: ke2(t22.alpha, e22.alpha, r22) };
      } }, ni2 = { forward: function(t22) {
        const { l: e22, a: r22, b: n22 } = Qn(t22), i2 = Math.atan2(n22, r22) * Zn;
        return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r22 * r22 + n22 * n22), l: e22, alpha: t22.a };
      }, reverse: function(t22) {
        const e22 = t22.h * Yn, r22 = t22.c;
        return ti2({ l: t22.l, a: Math.cos(e22) * r22, b: Math.sin(e22) * r22, alpha: t22.alpha });
      }, interpolate: function(t22, e22, r22) {
        return { h: ei2(t22.h, e22.h, r22), c: ke2(t22.c, e22.c, r22), l: ke2(t22.l, e22.l, r22), alpha: ke2(t22.alpha, e22.alpha, r22) };
      } };
      var ii2 = Object.freeze({ __proto__: null, hcl: ni2, lab: ri2 });
      class si2 {
        constructor(t22, e22, r22, n22, i2) {
          this.type = t22, this.operator = e22, this.interpolation = r22, this.input = n22, this.labels = [], this.outputs = [];
          for (const [t3, e3] of i2)
            this.labels.push(t3), this.outputs.push(e3);
        }
        static interpolationFactor(t22, e22, r22, n22) {
          let i2 = 0;
          if ("exponential" === t22.name)
            i2 = ai2(e22, t22.base, r22, n22);
          else if ("linear" === t22.name)
            i2 = ai2(e22, 1, r22, n22);
          else if ("cubic-bezier" === t22.name) {
            const s2 = t22.controlPoints;
            i2 = new j(s2[0], s2[1], s2[2], s2[3]).solve(ai2(e22, 1, r22, n22));
          }
          return i2;
        }
        static parse(t22, e22) {
          let [r22, n22, i2, ...s2] = t22;
          if (!Array.isArray(n22) || 0 === n22.length)
            return e22.error("Expected an interpolation type expression.", 1);
          if ("linear" === n22[0])
            n22 = { name: "linear" };
          else if ("exponential" === n22[0]) {
            const t3 = n22[1];
            if ("number" != typeof t3)
              return e22.error("Exponential interpolation requires a numeric base.", 1, 1);
            n22 = { name: "exponential", base: t3 };
          } else {
            if ("cubic-bezier" !== n22[0])
              return e22.error("Unknown interpolation type ".concat(String(n22[0])), 1, 0);
            {
              const t3 = n22.slice(1);
              if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1))
                return e22.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              n22 = { name: "cubic-bezier", controlPoints: t3 };
            }
          }
          if (t22.length - 1 < 4)
            return e22.error("Expected at least 4 arguments, but found only ".concat(t22.length - 1, "."));
          if ((t22.length - 1) % 2 != 0)
            return e22.error("Expected an even number of arguments.");
          if (i2 = e22.parse(i2, 2, De2), !i2)
            return null;
          const a2 = [];
          let o2 = null;
          "interpolate-hcl" === r22 || "interpolate-lab" === r22 ? o2 = Oe2 : e22.expectedType && "value" !== e22.expectedType.kind && (o2 = e22.expectedType);
          for (let t3 = 0; t3 < s2.length; t3 += 2) {
            const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l22 = t3 + 4;
            if ("number" != typeof r3)
              return e22.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
            if (a2.length && a2[a2.length - 1][0] >= r3)
              return e22.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
            const u22 = e22.parse(n3, l22, o2);
            if (!u22)
              return null;
            o2 = o2 || u22.type, a2.push([r3, u22]);
          }
          return "number" === o2.kind || "color" === o2.kind || "array" === o2.kind && "number" === o2.itemType.kind && "number" == typeof o2.N ? new si2(o2, r22, n22, i2, a2) : e22.error("Type ".concat(Xe2(o2), " is not interpolatable."));
        }
        evaluate(t22) {
          const e22 = this.labels, r22 = this.outputs;
          if (1 === e22.length)
            return r22[0].evaluate(t22);
          const n22 = this.input.evaluate(t22);
          if (n22 <= e22[0])
            return r22[0].evaluate(t22);
          const i2 = e22.length;
          if (n22 >= e22[i2 - 1])
            return r22[i2 - 1].evaluate(t22);
          const s2 = On(e22, n22), a2 = si2.interpolationFactor(this.interpolation, n22, e22[s2], e22[s2 + 1]), o2 = r22[s2].evaluate(t22), l22 = r22[s2 + 1].evaluate(t22);
          return "interpolate" === this.operator ? Ee2[this.type.kind.toLowerCase()](o2, l22, a2) : "interpolate-hcl" === this.operator ? ni2.reverse(ni2.interpolate(ni2.forward(o2), ni2.forward(l22), a2)) : ri2.reverse(ri2.interpolate(ri2.forward(o2), ri2.forward(l22), a2));
        }
        eachChild(t22) {
          t22(this.input);
          for (const e22 of this.outputs)
            t22(e22);
        }
        outputDefined() {
          return this.outputs.every((t22) => t22.outputDefined());
        }
        serialize() {
          let t22;
          t22 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
          const e22 = [this.operator, t22, this.input.serialize()];
          for (let t3 = 0; t3 < this.labels.length; t3++)
            e22.push(this.labels[t3], this.outputs[t3].serialize());
          return e22;
        }
      }
      function ai2(t22, e22, r22, n22) {
        const i2 = n22 - r22, s2 = t22 - r22;
        return 0 === i2 ? 0 : 1 === e22 ? s2 / i2 : (Math.pow(e22, s2) - 1) / (Math.pow(e22, i2) - 1);
      }
      class oi2 {
        constructor(t22, e22) {
          this.type = t22, this.args = e22;
        }
        static parse(t22, e22) {
          if (t22.length < 2)
            return e22.error("Expectected at least one argument.");
          let r22 = null;
          const n22 = e22.expectedType;
          n22 && "value" !== n22.kind && (r22 = n22);
          const i2 = [];
          for (const n3 of t22.slice(1)) {
            const t3 = e22.parse(n3, 1 + i2.length, r22, void 0, { typeAnnotation: "omit" });
            if (!t3)
              return null;
            r22 = r22 || t3.type, i2.push(t3);
          }
          const s2 = n22 && i2.some((t3) => Ze2(n22, t3.type));
          return new oi2(s2 ? je2 : r22, i2);
        }
        evaluate(t22) {
          let e22, r22 = null, n22 = 0;
          for (const i2 of this.args) {
            if (n22++, r22 = i2.evaluate(t22), r22 && r22 instanceof tr && !r22.available && (e22 || (e22 = r22), r22 = null, n22 === this.args.length))
              return e22;
            if (null !== r22)
              break;
          }
          return r22;
        }
        eachChild(t22) {
          this.args.forEach(t22);
        }
        outputDefined() {
          return this.args.every((t22) => t22.outputDefined());
        }
        serialize() {
          const t22 = ["coalesce"];
          return this.eachChild((e22) => {
            t22.push(e22.serialize());
          }), t22;
        }
      }
      class li2 {
        constructor(t22, e22) {
          this.type = e22.type, this.bindings = [].concat(t22), this.result = e22;
        }
        evaluate(t22) {
          return this.result.evaluate(t22);
        }
        eachChild(t22) {
          for (const e22 of this.bindings)
            t22(e22[1]);
          t22(this.result);
        }
        static parse(t22, e22) {
          if (t22.length < 4)
            return e22.error("Expected at least 3 arguments, but found ".concat(t22.length - 1, " instead."));
          const r22 = [];
          for (let n3 = 1; n3 < t22.length - 1; n3 += 2) {
            const i2 = t22[n3];
            if ("string" != typeof i2)
              return e22.error("Expected string, but found ".concat(typeof i2, " instead."), n3);
            if (/[^a-zA-Z0-9_]/.test(i2))
              return e22.error("Variable names must contain only alphanumeric characters or '_'.", n3);
            const s2 = e22.parse(t22[n3 + 1], n3 + 1);
            if (!s2)
              return null;
            r22.push([i2, s2]);
          }
          const n22 = e22.parse(t22[t22.length - 1], t22.length - 1, e22.expectedType, r22);
          return n22 ? new li2(r22, n22) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
        serialize() {
          const t22 = ["let"];
          for (const [e22, r22] of this.bindings)
            t22.push(e22, r22.serialize());
          return t22.push(this.result.serialize()), t22;
        }
      }
      class ui2 {
        constructor(t22, e22, r22) {
          this.type = t22, this.index = e22, this.input = r22;
        }
        static parse(t22, e22) {
          if (3 !== t22.length)
            return e22.error("Expected 2 arguments, but found ".concat(t22.length - 1, " instead."));
          const r22 = e22.parse(t22[1], 1, De2), n22 = e22.parse(t22[2], 2, Ge2(e22.expectedType || je2));
          return r22 && n22 ? new ui2(n22.type.itemType, r22, n22) : null;
        }
        evaluate(t22) {
          const e22 = this.index.evaluate(t22), r22 = this.input.evaluate(t22);
          if (e22 < 0)
            throw new ar("Array index out of bounds: ".concat(e22, " < 0."));
          if (e22 >= r22.length)
            throw new ar("Array index out of bounds: ".concat(e22, " > ").concat(r22.length - 1, "."));
          if (e22 !== Math.floor(e22))
            throw new ar("Array index must be an integer, but found ".concat(e22, " instead."));
          return r22[e22];
        }
        eachChild(t22) {
          t22(this.index), t22(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["at", this.index.serialize(), this.input.serialize()];
        }
      }
      class ci2 {
        constructor(t22, e22) {
          this.type = Fe2, this.needle = t22, this.haystack = e22;
        }
        static parse(t22, e22) {
          if (3 !== t22.length)
            return e22.error("Expected 2 arguments, but found ".concat(t22.length - 1, " instead."));
          const r22 = e22.parse(t22[1], 1, je2), n22 = e22.parse(t22[2], 2, je2);
          return r22 && n22 ? We2(r22.type, [Fe2, Le2, De2, Re2, je2]) ? new ci2(r22, n22) : e22.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(Xe2(r22.type), " instead")) : null;
        }
        evaluate(t22) {
          const e22 = this.needle.evaluate(t22), r22 = this.haystack.evaluate(t22);
          if (null == r22)
            return false;
          if (!He2(e22, ["boolean", "string", "number", "null"]))
            throw new ar("Expected first argument to be of type boolean, string, number or null, but found ".concat(Xe2(nr(e22)), " instead."));
          if (!He2(r22, ["string", "array"]))
            throw new ar("Expected second argument to be of type array or string, but found ".concat(Xe2(nr(r22)), " instead."));
          return r22.indexOf(e22) >= 0;
        }
        eachChild(t22) {
          t22(this.needle), t22(this.haystack);
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["in", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      class hi2 {
        constructor(t22, e22, r22) {
          this.type = De2, this.needle = t22, this.haystack = e22, this.fromIndex = r22;
        }
        static parse(t22, e22) {
          if (t22.length <= 2 || t22.length >= 5)
            return e22.error("Expected 3 or 4 arguments, but found ".concat(t22.length - 1, " instead."));
          const r22 = e22.parse(t22[1], 1, je2), n22 = e22.parse(t22[2], 2, je2);
          if (!r22 || !n22)
            return null;
          if (!We2(r22.type, [Fe2, Le2, De2, Re2, je2]))
            return e22.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(Xe2(r22.type), " instead"));
          if (4 === t22.length) {
            const i2 = e22.parse(t22[3], 3, De2);
            return i2 ? new hi2(r22, n22, i2) : null;
          }
          return new hi2(r22, n22);
        }
        evaluate(t22) {
          const e22 = this.needle.evaluate(t22), r22 = this.haystack.evaluate(t22);
          if (!He2(e22, ["boolean", "string", "number", "null"]))
            throw new ar("Expected first argument to be of type boolean, string, number or null, but found ".concat(Xe2(nr(e22)), " instead."));
          if (!He2(r22, ["string", "array"]))
            throw new ar("Expected second argument to be of type array or string, but found ".concat(Xe2(nr(r22)), " instead."));
          if (this.fromIndex) {
            const n22 = this.fromIndex.evaluate(t22);
            return r22.indexOf(e22, n22);
          }
          return r22.indexOf(e22);
        }
        eachChild(t22) {
          t22(this.needle), t22(this.haystack), this.fromIndex && t22(this.fromIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (null != this.fromIndex && void 0 !== this.fromIndex) {
            const t22 = this.fromIndex.serialize();
            return ["index-of", this.needle.serialize(), this.haystack.serialize(), t22];
          }
          return ["index-of", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      class pi2 {
        constructor(t22, e22, r22, n22, i2, s2) {
          this.inputType = t22, this.type = e22, this.input = r22, this.cases = n22, this.outputs = i2, this.otherwise = s2;
        }
        static parse(t22, e22) {
          if (t22.length < 5)
            return e22.error("Expected at least 4 arguments, but found only ".concat(t22.length - 1, "."));
          if (t22.length % 2 != 1)
            return e22.error("Expected an even number of arguments.");
          let r22, n22;
          e22.expectedType && "value" !== e22.expectedType.kind && (n22 = e22.expectedType);
          const i2 = {}, s2 = [];
          for (let a3 = 2; a3 < t22.length - 1; a3 += 2) {
            let o3 = t22[a3];
            const l22 = t22[a3 + 1];
            Array.isArray(o3) || (o3 = [o3]);
            const u22 = e22.concat(a3);
            if (0 === o3.length)
              return u22.error("Expected at least one branch label.");
            for (const t3 of o3) {
              if ("number" != typeof t3 && "string" != typeof t3)
                return u22.error("Branch labels must be numbers or strings.");
              if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                return u22.error("Branch labels must be integers no larger than ".concat(Number.MAX_SAFE_INTEGER, "."));
              if ("number" == typeof t3 && Math.floor(t3) !== t3)
                return u22.error("Numeric branch labels must be integer values.");
              if (r22) {
                if (u22.checkSubtype(r22, nr(t3)))
                  return null;
              } else
                r22 = nr(t3);
              if (void 0 !== i2[String(t3)])
                return u22.error("Branch labels must be unique.");
              i2[String(t3)] = s2.length;
            }
            const c22 = e22.parse(l22, a3, n22);
            if (!c22)
              return null;
            n22 = n22 || c22.type, s2.push(c22);
          }
          const a2 = e22.parse(t22[1], 1, je2);
          if (!a2)
            return null;
          const o2 = e22.parse(t22[t22.length - 1], t22.length - 1, n22);
          return o2 ? "value" !== a2.type.kind && e22.concat(1).checkSubtype(r22, a2.type) ? null : new pi2(r22, n22, a2, i2, s2, o2) : null;
        }
        evaluate(t22) {
          const e22 = this.input.evaluate(t22);
          return (nr(e22) === this.inputType && this.outputs[this.cases[e22]] || this.otherwise).evaluate(t22);
        }
        eachChild(t22) {
          t22(this.input), this.outputs.forEach(t22), t22(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((t22) => t22.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const t22 = ["match", this.input.serialize()], e22 = Object.keys(this.cases).sort(), r22 = [], n22 = {};
          for (const t3 of e22) {
            const e3 = n22[this.cases[t3]];
            void 0 === e3 ? (n22[this.cases[t3]] = r22.length, r22.push([this.cases[t3], [t3]])) : r22[e3][1].push(t3);
          }
          const i2 = (t3) => "number" === this.inputType.kind ? Number(t3) : t3;
          for (const [e3, n3] of r22)
            t22.push(1 === n3.length ? i2(n3[0]) : n3.map(i2)), t22.push(this.outputs[e3].serialize());
          return t22.push(this.otherwise.serialize()), t22;
        }
      }
      class fi2 {
        constructor(t22, e22, r22) {
          this.type = t22, this.branches = e22, this.otherwise = r22;
        }
        static parse(t22, e22) {
          if (t22.length < 4)
            return e22.error("Expected at least 3 arguments, but found only ".concat(t22.length - 1, "."));
          if (t22.length % 2 != 0)
            return e22.error("Expected an odd number of arguments.");
          let r22;
          e22.expectedType && "value" !== e22.expectedType.kind && (r22 = e22.expectedType);
          const n22 = [];
          for (let i3 = 1; i3 < t22.length - 1; i3 += 2) {
            const s2 = e22.parse(t22[i3], i3, Fe2);
            if (!s2)
              return null;
            const a2 = e22.parse(t22[i3 + 1], i3 + 1, r22);
            if (!a2)
              return null;
            n22.push([s2, a2]), r22 = r22 || a2.type;
          }
          const i2 = e22.parse(t22[t22.length - 1], t22.length - 1, r22);
          return i2 ? new fi2(r22, n22, i2) : null;
        }
        evaluate(t22) {
          for (const [e22, r22] of this.branches)
            if (e22.evaluate(t22))
              return r22.evaluate(t22);
          return this.otherwise.evaluate(t22);
        }
        eachChild(t22) {
          for (const [e22, r22] of this.branches)
            t22(e22), t22(r22);
          t22(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([t22, e22]) => e22.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const t22 = ["case"];
          return this.eachChild((e22) => {
            t22.push(e22.serialize());
          }), t22;
        }
      }
      class di2 {
        constructor(t22, e22, r22, n22) {
          this.type = t22, this.input = e22, this.beginIndex = r22, this.endIndex = n22;
        }
        static parse(t22, e22) {
          if (t22.length <= 2 || t22.length >= 5)
            return e22.error("Expected 3 or 4 arguments, but found ".concat(t22.length - 1, " instead."));
          const r22 = e22.parse(t22[1], 1, je2), n22 = e22.parse(t22[2], 2, De2);
          if (!r22 || !n22)
            return null;
          if (!We2(r22.type, [Ge2(je2), Le2, je2]))
            return e22.error("Expected first argument to be of type array or string, but found ".concat(Xe2(r22.type), " instead"));
          if (4 === t22.length) {
            const i2 = e22.parse(t22[3], 3, De2);
            return i2 ? new di2(r22.type, r22, n22, i2) : null;
          }
          return new di2(r22.type, r22, n22);
        }
        evaluate(t22) {
          const e22 = this.input.evaluate(t22), r22 = this.beginIndex.evaluate(t22);
          if (!He2(e22, ["string", "array"]))
            throw new ar("Expected first argument to be of type array or string, but found ".concat(Xe2(nr(e22)), " instead."));
          if (this.endIndex) {
            const n22 = this.endIndex.evaluate(t22);
            return e22.slice(r22, n22);
          }
          return e22.slice(r22);
        }
        eachChild(t22) {
          t22(this.input), t22(this.beginIndex), this.endIndex && t22(this.endIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (null != this.endIndex && void 0 !== this.endIndex) {
            const t22 = this.endIndex.serialize();
            return ["slice", this.input.serialize(), this.beginIndex.serialize(), t22];
          }
          return ["slice", this.input.serialize(), this.beginIndex.serialize()];
        }
      }
      function mi2(t22, e22) {
        return "==" === t22 || "!=" === t22 ? "boolean" === e22.kind || "string" === e22.kind || "number" === e22.kind || "null" === e22.kind || "value" === e22.kind : "string" === e22.kind || "number" === e22.kind || "value" === e22.kind;
      }
      function yi2(t22, e22, r22, n22) {
        return 0 === n22.compare(e22, r22);
      }
      function gi2(t22, e22, r22) {
        const n22 = "==" !== t22 && "!=" !== t22;
        return class i2 {
          constructor(t3, e3, r3) {
            this.type = Fe2, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
          }
          static parse(t3, e3) {
            if (3 !== t3.length && 4 !== t3.length)
              return e3.error("Expected two or three arguments.");
            const r3 = t3[0];
            let s2 = e3.parse(t3[1], 1, je2);
            if (!s2)
              return null;
            if (!mi2(r3, s2.type))
              return e3.concat(1).error('"'.concat(r3, "\" comparisons are not supported for type '").concat(Xe2(s2.type), "'."));
            let a2 = e3.parse(t3[2], 2, je2);
            if (!a2)
              return null;
            if (!mi2(r3, a2.type))
              return e3.concat(2).error('"'.concat(r3, "\" comparisons are not supported for type '").concat(Xe2(a2.type), "'."));
            if (s2.type.kind !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind)
              return e3.error("Cannot compare types '".concat(Xe2(s2.type), "' and '").concat(Xe2(a2.type), "'."));
            n22 && ("value" === s2.type.kind && "value" !== a2.type.kind ? s2 = new lr(a2.type, [s2]) : "value" !== s2.type.kind && "value" === a2.type.kind && (a2 = new lr(s2.type, [a2])));
            let o2 = null;
            if (4 === t3.length) {
              if ("string" !== s2.type.kind && "string" !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind)
                return e3.error("Cannot use collator to compare non-string types.");
              if (o2 = e3.parse(t3[3], 3, Ne2), !o2)
                return null;
            }
            return new i2(s2, a2, o2);
          }
          evaluate(i3) {
            const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
            if (n22 && this.hasUntypedArgument) {
              const e3 = nr(s2), r3 = nr(a2);
              if (e3.kind !== r3.kind || "string" !== e3.kind && "number" !== e3.kind)
                throw new ar('Expected arguments for "'.concat(t22, '" to be (string, string) or (number, number), but found (').concat(e3.kind, ", ").concat(r3.kind, ") instead."));
            }
            if (this.collator && !n22 && this.hasUntypedArgument) {
              const t3 = nr(s2), r3 = nr(a2);
              if ("string" !== t3.kind || "string" !== r3.kind)
                return e22(i3, s2, a2);
            }
            return this.collator ? r22(i3, s2, a2, this.collator.evaluate(i3)) : e22(i3, s2, a2);
          }
          eachChild(t3) {
            t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            const e3 = [t22];
            return this.eachChild((t3) => {
              e3.push(t3.serialize());
            }), e3;
          }
        };
      }
      const xi2 = gi2("==", function(t22, e22, r22) {
        return e22 === r22;
      }, yi2), bi2 = gi2("!=", function(t22, e22, r22) {
        return e22 !== r22;
      }, function(t22, e22, r22, n22) {
        return !yi2(0, e22, r22, n22);
      }), vi2 = gi2("<", function(t22, e22, r22) {
        return e22 < r22;
      }, function(t22, e22, r22, n22) {
        return n22.compare(e22, r22) < 0;
      }), wi2 = gi2(">", function(t22, e22, r22) {
        return e22 > r22;
      }, function(t22, e22, r22, n22) {
        return n22.compare(e22, r22) > 0;
      }), _i = gi2("<=", function(t22, e22, r22) {
        return e22 <= r22;
      }, function(t22, e22, r22, n22) {
        return n22.compare(e22, r22) <= 0;
      }), Mi2 = gi2(">=", function(t22, e22, r22) {
        return e22 >= r22;
      }, function(t22, e22, r22, n22) {
        return n22.compare(e22, r22) >= 0;
      });
      class Ai2 {
        constructor(t22, e22, r22, n22, i2, s2) {
          this.type = Le2, this.number = t22, this.locale = e22, this.currency = r22, this.unit = n22, this.minFractionDigits = i2, this.maxFractionDigits = s2;
        }
        static parse(t22, e22) {
          if (3 !== t22.length)
            return e22.error("Expected two arguments.");
          const r22 = e22.parse(t22[1], 1, De2);
          if (!r22)
            return null;
          const n22 = t22[2];
          if ("object" != typeof n22 || Array.isArray(n22))
            return e22.error("NumberFormat options argument must be an object.");
          let i2 = null;
          if (n22.locale && (i2 = e22.parseObjectValue(n22.locale, 2, "locale", Le2), !i2))
            return null;
          let s2 = null;
          if (n22.currency && (s2 = e22.parseObjectValue(n22.currency, 2, "currency", Le2), !s2))
            return null;
          let a2 = null;
          if (n22.unit && (a2 = e22.parseObjectValue(n22.unit, 2, "unit", Le2), !a2))
            return null;
          let o2 = null;
          if (n22["min-fraction-digits"] && (o2 = e22.parseObjectValue(n22["min-fraction-digits"], 2, "min-fraction-digits", De2), !o2))
            return null;
          let l22 = null;
          return n22["max-fraction-digits"] && (l22 = e22.parseObjectValue(n22["max-fraction-digits"], 2, "max-fraction-digits", De2), !l22) ? null : new Ai2(r22, i2, s2, a2, o2, l22);
        }
        evaluate(t22) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t22) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t22) : void 0, unit: this.unit ? this.unit.evaluate(t22) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t22) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t22) : void 0 }).format(this.number.evaluate(t22));
        }
        eachChild(t22) {
          t22(this.number), this.locale && t22(this.locale), this.currency && t22(this.currency), this.unit && t22(this.unit), this.minFractionDigits && t22(this.minFractionDigits), this.maxFractionDigits && t22(this.maxFractionDigits);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t22 = {};
          return this.locale && (t22.locale = this.locale.serialize()), this.currency && (t22.currency = this.currency.serialize()), this.unit && (t22.unit = this.unit.serialize()), this.minFractionDigits && (t22["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t22["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t22];
        }
      }
      class Si2 {
        constructor(t22) {
          this.type = De2, this.input = t22;
        }
        static parse(t22, e22) {
          if (2 !== t22.length)
            return e22.error("Expected 1 argument, but found ".concat(t22.length - 1, " instead."));
          const r22 = e22.parse(t22[1], 1);
          return r22 ? "array" !== r22.type.kind && "string" !== r22.type.kind && "value" !== r22.type.kind ? e22.error("Expected argument of type string or array, but found ".concat(Xe2(r22.type), " instead.")) : new Si2(r22) : null;
        }
        evaluate(t22) {
          const e22 = this.input.evaluate(t22);
          if ("string" == typeof e22)
            return e22.length;
          if (Array.isArray(e22))
            return e22.length;
          throw new ar("Expected value to be of type string or array, but found ".concat(Xe2(nr(e22)), " instead."));
        }
        eachChild(t22) {
          t22(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t22 = ["length"];
          return this.eachChild((e22) => {
            t22.push(e22.serialize());
          }), t22;
        }
      }
      function Ii2(t22) {
        return function() {
          t22 = 1831565813 + (t22 |= 0) | 0;
          let e22 = Math.imul(t22 ^ t22 >>> 15, 1 | t22);
          return e22 = e22 + Math.imul(e22 ^ e22 >>> 7, 61 | e22) ^ e22, ((e22 ^ e22 >>> 14) >>> 0) / 4294967296;
        };
      }
      const Pi2 = { "==": xi2, "!=": bi2, ">": wi2, "<": vi2, ">=": Mi2, "<=": _i, array: lr, at: ui2, boolean: lr, case: fi2, coalesce: oi2, collator: xr, format: ur, image: cr, in: ci2, "index-of": hi2, interpolate: si2, "interpolate-hcl": si2, "interpolate-lab": si2, length: Si2, let: li2, literal: sr, match: pi2, number: lr, "number-format": Ai2, object: lr, slice: di2, step: Un, string: lr, "to-boolean": fr, "to-color": fr, "to-number": fr, "to-string": fr, var: Rn, within: Ur, distance: Pn, config: Tn };
      function zi2(t22, [e22, r22, n22, i2]) {
        e22 = e22.evaluate(t22), r22 = r22.evaluate(t22), n22 = n22.evaluate(t22);
        const s2 = i2 ? i2.evaluate(t22) : 1, a2 = er(e22, r22, n22, s2);
        if (a2)
          throw new ar(a2);
        return new Pe2(e22 / 255 * s2, r22 / 255 * s2, n22 / 255 * s2, s2);
      }
      function ki2(t22, [e22, r22, n22, i2]) {
        e22 = e22.evaluate(t22), r22 = r22.evaluate(t22), n22 = n22.evaluate(t22);
        const s2 = i2 ? i2.evaluate(t22) : 1, a2 = function(t3, e3, r3, n3) {
          return "number" == typeof t3 && t3 >= 0 && t3 <= 360 ? "number" == typeof e3 && e3 >= 0 && e3 <= 100 && "number" == typeof r3 && r3 >= 0 && r3 <= 100 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : "Invalid hsla value [".concat([t3, e3, r3, n3].join(", "), "]: 'a' must be between 0 and 1.") : "Invalid hsla value [".concat(("number" == typeof n3 ? [t3, e3, r3, n3] : [t3, e3, r3]).join(", "), "]: 's', and 'l' must be between 0 and 100.") : "Invalid hsla value [".concat(("number" == typeof n3 ? [t3, e3, r3, n3] : [t3, e3, r3]).join(", "), "]: 'h' must be between 0 and 360.");
        }(e22, r22, n22, s2);
        if (a2)
          throw new ar(a2);
        const o2 = "hsla(".concat(e22, ", ").concat(r22, "%, ").concat(n22, "%, ").concat(s2, ")"), l22 = Pe2.parse(o2);
        if (!l22)
          throw new ar("Failed to parse HSLA color: ".concat(o2));
        return l22;
      }
      function Ti2(t22, e22) {
        return t22 in e22;
      }
      function Ei2(t22, e22) {
        const r22 = e22[t22];
        return void 0 === r22 ? null : r22;
      }
      function Bi2(t22) {
        return { type: t22 };
      }
      function Vi2(t22) {
        return { result: "success", value: t22 };
      }
      function Ci2(t22) {
        return { result: "error", value: t22 };
      }
      function Ri2(t22, e22) {
        return !!t22 && !!t22.parameters && t22.parameters.indexOf(e22) > -1;
      }
      function Di2(t22) {
        return "data-driven" === t22["property-type"];
      }
      function Li2(t22) {
        return Ri2(t22.expression, "measure-light");
      }
      function Fi2(t22) {
        return Ri2(t22.expression, "zoom");
      }
      function Oi2(t22) {
        return !!t22.expression && t22.expression.interpolated;
      }
      function Ui2(t22) {
        return "object" == typeof t22 && null !== t22 && !Array.isArray(t22);
      }
      function ji2(t22) {
        return t22;
      }
      function Ni2(t22, e22) {
        const r22 = "color" === e22.type, n22 = t22.stops && "object" == typeof t22.stops[0][0], i2 = n22 || !(n22 || void 0 !== t22.property), s2 = t22.type || (Oi2(e22) ? "exponential" : "interval");
        if (r22 && ((t22 = Be2({}, t22)).stops && (t22.stops = t22.stops.map((t3) => [t3[0], Pe2.parse(t3[1])])), t22.default = Pe2.parse(t22.default ? t22.default : e22.default)), t22.colorSpace && "rgb" !== t22.colorSpace && !ii2[t22.colorSpace])
          throw new Error("Unknown color space: ".concat(t22.colorSpace));
        let a2, o2, l22;
        if ("exponential" === s2)
          a2 = Xi2;
        else if ("interval" === s2)
          a2 = Gi2;
        else if ("categorical" === s2) {
          a2 = $i2, o2 = /* @__PURE__ */ Object.create(null);
          for (const e3 of t22.stops)
            o2[e3[0]] = e3[1];
          l22 = typeof t22.stops[0][0];
        } else {
          if ("identity" !== s2)
            throw new Error('Unknown function type "'.concat(s2, '"'));
          a2 = Yi2;
        }
        if (n22) {
          const r3 = {}, n3 = [];
          for (let e3 = 0; e3 < t22.stops.length; e3++) {
            const i4 = t22.stops[e3], s4 = i4[0].zoom;
            void 0 === r3[s4] && (r3[s4] = { zoom: s4, type: t22.type, property: t22.property, default: t22.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
          }
          const i3 = [];
          for (const t3 of n3)
            i3.push([r3[t3].zoom, Ni2(r3[t3], e22)]);
          const s3 = { name: "linear" };
          return { kind: "composite", interpolationType: s3, interpolationFactor: si2.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => Xi2({ stops: i3, base: t22.base }, e22, r4).evaluate(r4, n4) };
        }
        if (i2) {
          const r3 = "exponential" === s2 ? { name: "exponential", base: void 0 !== t22.base ? t22.base : 1 } : null;
          return { kind: "camera", interpolationType: r3, interpolationFactor: si2.interpolationFactor.bind(void 0, r3), zoomStops: t22.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => a2(t22, e22, r4, o2, l22) };
        }
        return { kind: "source", evaluate(r3, n3) {
          const i3 = n3 && n3.properties ? n3.properties[t22.property] : void 0;
          return void 0 === i3 ? qi2(t22.default, e22.default) : a2(t22, e22, i3, o2, l22);
        } };
      }
      function qi2(t22, e22, r22) {
        return void 0 !== t22 ? t22 : void 0 !== e22 ? e22 : void 0 !== r22 ? r22 : void 0;
      }
      function $i2(t22, e22, r22, n22, i2) {
        return qi2(typeof r22 === i2 ? n22[r22] : void 0, t22.default, e22.default);
      }
      function Gi2(t22, e22, r22) {
        if ("number" !== hr(r22))
          return qi2(t22.default, e22.default);
        const n22 = t22.stops.length;
        if (1 === n22)
          return t22.stops[0][1];
        if (r22 <= t22.stops[0][0])
          return t22.stops[0][1];
        if (r22 >= t22.stops[n22 - 1][0])
          return t22.stops[n22 - 1][1];
        const i2 = On(t22.stops.map((t3) => t3[0]), r22);
        return t22.stops[i2][1];
      }
      function Xi2(t22, e22, r22) {
        const n22 = void 0 !== t22.base ? t22.base : 1;
        if ("number" !== hr(r22))
          return qi2(t22.default, e22.default);
        const i2 = t22.stops.length;
        if (1 === i2)
          return t22.stops[0][1];
        if (r22 <= t22.stops[0][0])
          return t22.stops[0][1];
        if (r22 >= t22.stops[i2 - 1][0])
          return t22.stops[i2 - 1][1];
        const s2 = On(t22.stops.map((t3) => t3[0]), r22), a2 = function(t3, e3, r3, n3) {
          const i3 = n3 - r3, s3 = t3 - r3;
          return 0 === i3 ? 0 : 1 === e3 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
        }(r22, n22, t22.stops[s2][0], t22.stops[s2 + 1][0]), o2 = t22.stops[s2][1], l22 = t22.stops[s2 + 1][1];
        let u22 = Ee2[e22.type] || ji2;
        if (t22.colorSpace && "rgb" !== t22.colorSpace) {
          const e3 = ii2[t22.colorSpace];
          u22 = (t3, r3) => e3.reverse(e3.interpolate(e3.forward(t3), e3.forward(r3), a2));
        }
        return "function" == typeof o2.evaluate ? { evaluate(...t3) {
          const e3 = o2.evaluate.apply(void 0, t3), r3 = l22.evaluate.apply(void 0, t3);
          if (void 0 !== e3 && void 0 !== r3)
            return u22(e3, r3, a2);
        } } : u22(o2, l22, a2);
      }
      function Yi2(t22, e22, r22) {
        return "color" === e22.type ? r22 = Pe2.parse(r22) : "formatted" === e22.type ? r22 = Qe2.fromString(r22.toString()) : "resolvedImage" === e22.type ? r22 = tr.fromString(r22.toString()) : hr(r22) === e22.type || "enum" === e22.type && e22.values[r22] || (r22 = void 0), qi2(r22, t22.default, e22.default);
      }
      yr.register(Pi2, { error: [{ kind: "error" }, [Le2], (t22, [e22]) => {
        throw new ar(e22.evaluate(t22));
      }], typeof: [Le2, [je2], (t22, [e22]) => Xe2(nr(e22.evaluate(t22)))], "to-rgba": [Ge2(De2, 4), [Oe2], (t22, [e22]) => e22.evaluate(t22).toRenderColor(null).toArray()], rgb: [Oe2, [De2, De2, De2], zi2], rgba: [Oe2, [De2, De2, De2, De2], zi2], hsl: [Oe2, [De2, De2, De2], ki2], hsla: [Oe2, [De2, De2, De2, De2], ki2], has: { type: Fe2, overloads: [[[Le2], (t22, [e22]) => Ti2(e22.evaluate(t22), t22.properties())], [[Le2, Ue2], (t22, [e22, r22]) => Ti2(e22.evaluate(t22), r22.evaluate(t22))]] }, get: { type: je2, overloads: [[[Le2], (t22, [e22]) => Ei2(e22.evaluate(t22), t22.properties())], [[Le2, Ue2], (t22, [e22, r22]) => Ei2(e22.evaluate(t22), r22.evaluate(t22))]] }, "feature-state": [je2, [Le2], (t22, [e22]) => Ei2(e22.evaluate(t22), t22.featureState || {})], properties: [Ue2, [], (t22) => t22.properties()], "geometry-type": [Le2, [], (t22) => t22.geometryType()], id: [je2, [], (t22) => t22.id()], zoom: [De2, [], (t22) => t22.globals.zoom], pitch: [De2, [], (t22) => t22.globals.pitch || 0], "distance-from-center": [De2, [], (t22) => t22.distanceFromCenter()], "measure-light": [De2, [Le2], (t22, [e22]) => t22.measureLight(e22.evaluate(t22))], "heatmap-density": [De2, [], (t22) => t22.globals.heatmapDensity || 0], "line-progress": [De2, [], (t22) => t22.globals.lineProgress || 0], "raster-value": [De2, [], (t22) => t22.globals.rasterValue || 0], "raster-particle-speed": [De2, [], (t22) => t22.globals.rasterParticleSpeed || 0], "sky-radial-progress": [De2, [], (t22) => t22.globals.skyRadialProgress || 0], accumulated: [je2, [], (t22) => void 0 === t22.globals.accumulated ? null : t22.globals.accumulated], "+": [De2, Bi2(De2), (t22, e22) => {
        let r22 = 0;
        for (const n22 of e22)
          r22 += n22.evaluate(t22);
        return r22;
      }], "*": [De2, Bi2(De2), (t22, e22) => {
        let r22 = 1;
        for (const n22 of e22)
          r22 *= n22.evaluate(t22);
        return r22;
      }], "-": { type: De2, overloads: [[[De2, De2], (t22, [e22, r22]) => e22.evaluate(t22) - r22.evaluate(t22)], [[De2], (t22, [e22]) => -e22.evaluate(t22)]] }, "/": [De2, [De2, De2], (t22, [e22, r22]) => e22.evaluate(t22) / r22.evaluate(t22)], "%": [De2, [De2, De2], (t22, [e22, r22]) => e22.evaluate(t22) % r22.evaluate(t22)], ln2: [De2, [], () => Math.LN2], pi: [De2, [], () => Math.PI], e: [De2, [], () => Math.E], "^": [De2, [De2, De2], (t22, [e22, r22]) => Math.pow(e22.evaluate(t22), r22.evaluate(t22))], sqrt: [De2, [De2], (t22, [e22]) => Math.sqrt(e22.evaluate(t22))], log10: [De2, [De2], (t22, [e22]) => Math.log(e22.evaluate(t22)) / Math.LN10], ln: [De2, [De2], (t22, [e22]) => Math.log(e22.evaluate(t22))], log2: [De2, [De2], (t22, [e22]) => Math.log(e22.evaluate(t22)) / Math.LN2], sin: [De2, [De2], (t22, [e22]) => Math.sin(e22.evaluate(t22))], cos: [De2, [De2], (t22, [e22]) => Math.cos(e22.evaluate(t22))], tan: [De2, [De2], (t22, [e22]) => Math.tan(e22.evaluate(t22))], asin: [De2, [De2], (t22, [e22]) => Math.asin(e22.evaluate(t22))], acos: [De2, [De2], (t22, [e22]) => Math.acos(e22.evaluate(t22))], atan: [De2, [De2], (t22, [e22]) => Math.atan(e22.evaluate(t22))], min: [De2, Bi2(De2), (t22, e22) => Math.min(...e22.map((e3) => e3.evaluate(t22)))], max: [De2, Bi2(De2), (t22, e22) => Math.max(...e22.map((e3) => e3.evaluate(t22)))], abs: [De2, [De2], (t22, [e22]) => Math.abs(e22.evaluate(t22))], round: [De2, [De2], (t22, [e22]) => {
        const r22 = e22.evaluate(t22);
        return r22 < 0 ? -Math.round(-r22) : Math.round(r22);
      }], floor: [De2, [De2], (t22, [e22]) => Math.floor(e22.evaluate(t22))], ceil: [De2, [De2], (t22, [e22]) => Math.ceil(e22.evaluate(t22))], "filter-==": [Fe2, [Le2, je2], (t22, [e22, r22]) => t22.properties()[e22.value] === r22.value], "filter-id-==": [Fe2, [je2], (t22, [e22]) => t22.id() === e22.value], "filter-type-==": [Fe2, [Le2], (t22, [e22]) => t22.geometryType() === e22.value], "filter-<": [Fe2, [Le2, je2], (t22, [e22, r22]) => {
        const n22 = t22.properties()[e22.value], i2 = r22.value;
        return typeof n22 == typeof i2 && n22 < i2;
      }], "filter-id-<": [Fe2, [je2], (t22, [e22]) => {
        const r22 = t22.id(), n22 = e22.value;
        return typeof r22 == typeof n22 && r22 < n22;
      }], "filter->": [Fe2, [Le2, je2], (t22, [e22, r22]) => {
        const n22 = t22.properties()[e22.value], i2 = r22.value;
        return typeof n22 == typeof i2 && n22 > i2;
      }], "filter-id->": [Fe2, [je2], (t22, [e22]) => {
        const r22 = t22.id(), n22 = e22.value;
        return typeof r22 == typeof n22 && r22 > n22;
      }], "filter-<=": [Fe2, [Le2, je2], (t22, [e22, r22]) => {
        const n22 = t22.properties()[e22.value], i2 = r22.value;
        return typeof n22 == typeof i2 && n22 <= i2;
      }], "filter-id-<=": [Fe2, [je2], (t22, [e22]) => {
        const r22 = t22.id(), n22 = e22.value;
        return typeof r22 == typeof n22 && r22 <= n22;
      }], "filter->=": [Fe2, [Le2, je2], (t22, [e22, r22]) => {
        const n22 = t22.properties()[e22.value], i2 = r22.value;
        return typeof n22 == typeof i2 && n22 >= i2;
      }], "filter-id->=": [Fe2, [je2], (t22, [e22]) => {
        const r22 = t22.id(), n22 = e22.value;
        return typeof r22 == typeof n22 && r22 >= n22;
      }], "filter-has": [Fe2, [je2], (t22, [e22]) => e22.value in t22.properties()], "filter-has-id": [Fe2, [], (t22) => null !== t22.id() && void 0 !== t22.id()], "filter-type-in": [Fe2, [Ge2(Le2)], (t22, [e22]) => e22.value.indexOf(t22.geometryType()) >= 0], "filter-id-in": [Fe2, [Ge2(je2)], (t22, [e22]) => e22.value.indexOf(t22.id()) >= 0], "filter-in-small": [Fe2, [Le2, Ge2(je2)], (t22, [e22, r22]) => r22.value.indexOf(t22.properties()[e22.value]) >= 0], "filter-in-large": [Fe2, [Le2, Ge2(je2)], (t22, [e22, r22]) => function(t3, e3, r3, n22) {
        for (; r3 <= n22; ) {
          const i2 = r3 + n22 >> 1;
          if (e3[i2] === t3)
            return true;
          e3[i2] > t3 ? n22 = i2 - 1 : r3 = i2 + 1;
        }
        return false;
      }(t22.properties()[e22.value], r22.value, 0, r22.value.length - 1)], all: { type: Fe2, overloads: [[[Fe2, Fe2], (t22, [e22, r22]) => e22.evaluate(t22) && r22.evaluate(t22)], [Bi2(Fe2), (t22, e22) => {
        for (const r22 of e22)
          if (!r22.evaluate(t22))
            return false;
        return true;
      }]] }, any: { type: Fe2, overloads: [[[Fe2, Fe2], (t22, [e22, r22]) => e22.evaluate(t22) || r22.evaluate(t22)], [Bi2(Fe2), (t22, e22) => {
        for (const r22 of e22)
          if (r22.evaluate(t22))
            return true;
        return false;
      }]] }, "!": [Fe2, [Fe2], (t22, [e22]) => !e22.evaluate(t22)], "is-supported-script": [Fe2, [Le2], (t22, [e22]) => {
        const r22 = t22.globals && t22.globals.isSupportedScript;
        return !r22 || r22(e22.evaluate(t22));
      }], upcase: [Le2, [Le2], (t22, [e22]) => e22.evaluate(t22).toUpperCase()], downcase: [Le2, [Le2], (t22, [e22]) => e22.evaluate(t22).toLowerCase()], concat: [Le2, Bi2(je2), (t22, e22) => e22.map((e3) => ir(e3.evaluate(t22))).join("")], "resolved-locale": [Le2, [Ne2], (t22, [e22]) => e22.evaluate(t22).resolvedLocale()], random: [De2, [De2, De2, je2], (t22, e22) => {
        const [r22, n22, i2] = e22.map((e3) => e3.evaluate(t22));
        if (r22 > n22)
          return r22;
        if (r22 === n22)
          return r22;
        let s2;
        if ("string" == typeof i2)
          s2 = function(t3) {
            let e3 = 0;
            if (0 === t3.length)
              return e3;
            for (let r3 = 0; r3 < t3.length; r3++)
              e3 = (e3 << 5) - e3 + t3.charCodeAt(r3), e3 |= 0;
            return e3;
          }(i2);
        else {
          if ("number" != typeof i2)
            throw new ar("Invalid seed input: ".concat(i2));
          s2 = i2;
        }
        return r22 + Ii2(s2)() * (n22 - r22);
      }] });
      class Zi2 {
        constructor(t22, e22, r22, n22) {
          this.expression = t22, this._warningHistory = {}, this._evaluator = new mr(r22, n22), this._defaultValue = e22 ? function(t3) {
            return "color" === t3.type && (Ui2(t3.default) || Array.isArray(t3.default)) ? new Pe2(0, 0, 0, 0) : "color" === t3.type ? Pe2.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
          }(e22) : null, this._enumValues = e22 && "enum" === e22.type ? e22.values : null;
        }
        evaluateWithoutErrorHandling(t22, e22, r22, n22, i2, s2, a2, o2) {
          return this._evaluator.globals = t22, this._evaluator.feature = e22, this._evaluator.featureState = r22, this._evaluator.canonical = n22 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null, this.expression.evaluate(this._evaluator);
        }
        evaluate(t22, e22, r22, n22, i2, s2, a2, o2) {
          this._evaluator.globals = t22, this._evaluator.feature = e22 || null, this._evaluator.featureState = r22 || null, this._evaluator.canonical = n22 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null;
          try {
            const t3 = this.expression.evaluate(this._evaluator);
            if (null == t3 || "number" == typeof t3 && t3 != t3)
              return this._defaultValue;
            if (this._enumValues && !(t3 in this._enumValues))
              throw new ar("Expected value to be one of ".concat(Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", "), ", but found ").concat(JSON.stringify(t3), " instead."));
            return t3;
          } catch (t3) {
            return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn('Failed to evaluate expression "'.concat(JSON.stringify(this.expression.serialize()), '". ').concat(t3.message))), this._defaultValue;
          }
        }
      }
      function Wi2(t22) {
        return Array.isArray(t22) && t22.length > 0 && "string" == typeof t22[0] && t22[0] in Pi2;
      }
      function Hi2(t22, e22, r22, n22) {
        const i2 = new Ln(Pi2, [], e22 ? function(t3) {
          const e3 = { color: Oe2, string: Le2, number: De2, enum: Le2, boolean: Fe2, formatted: qe2, resolvedImage: $e2 };
          return "array" === t3.type ? Ge2(e3[t3.value] || je2, t3.length) : e3[t3.type];
        }(e22) : void 0, void 0, void 0, r22, n22), s2 = i2.parse(t22, void 0, void 0, void 0, e22 && "string" === e22.type ? { typeAnnotation: "coerce" } : void 0);
        return s2 ? Vi2(new Zi2(s2, e22, r22, n22)) : Ci2(i2.errors);
      }
      class Ki2 {
        constructor(t22, e22, r22) {
          this.kind = t22, this._styleExpression = e22, this.isLightConstant = r22, this.isStateDependent = "constant" !== t22 && !Bn(e22.expression), this.configDependencies = Vn(e22.expression);
        }
        evaluateWithoutErrorHandling(t22, e22, r22, n22, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t22, e22, r22, n22, i2, s2);
        }
        evaluate(t22, e22, r22, n22, i2, s2) {
          return this._styleExpression.evaluate(t22, e22, r22, n22, i2, s2);
        }
      }
      class Ji2 {
        constructor(t22, e22, r22, n22, i2) {
          this.kind = t22, this.zoomStops = r22, this._styleExpression = e22, this.isStateDependent = "camera" !== t22 && !Bn(e22.expression), this.isLightConstant = i2, this.configDependencies = Vn(e22.expression), this.interpolationType = n22;
        }
        evaluateWithoutErrorHandling(t22, e22, r22, n22, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t22, e22, r22, n22, i2, s2);
        }
        evaluate(t22, e22, r22, n22, i2, s2) {
          return this._styleExpression.evaluate(t22, e22, r22, n22, i2, s2);
        }
        interpolationFactor(t22, e22, r22) {
          return this.interpolationType ? si2.interpolationFactor(this.interpolationType, t22, e22, r22) : 0;
        }
      }
      function Qi2(t22, e22, r22, n22) {
        if ("error" === (t22 = Hi2(t22, e22, r22, n22)).result)
          return t22;
        const i2 = t22.value.expression, s2 = En(i2);
        if (!s2 && !Di2(e22))
          return Ci2([new Ve2("", "data expressions not supported")]);
        const a2 = Cn(i2, ["zoom", "pitch", "distance-from-center"]);
        if (!a2 && !Fi2(e22))
          return Ci2([new Ve2("", "zoom expressions not supported")]);
        const o2 = Cn(i2, ["measure-light"]);
        if (!o2 && !Li2(e22))
          return Ci2([new Ve2("", "measure-light expression not supported")]);
        const l22 = e22.expression && e22.expression.relaxZoomRestriction, u22 = es(i2);
        return u22 || a2 || l22 ? u22 instanceof Ve2 ? Ci2([u22]) : u22 instanceof si2 && !Oi2(e22) ? Ci2([new Ve2("", '"interpolate" expressions cannot be used with this property')]) : Vi2(u22 ? new Ji2(s2 ? "camera" : "composite", t22.value, u22.labels, u22 instanceof si2 ? u22.interpolation : void 0, o2) : new Ki2(s2 ? "constant" : "source", t22.value, o2)) : Ci2([new Ve2("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')]);
      }
      class ts {
        constructor(t22, e22) {
          this._parameters = t22, this._specification = e22, Be2(this, Ni2(this._parameters, this._specification));
        }
        static deserialize(t22) {
          return new ts(t22._parameters, t22._specification);
        }
        static serialize(t22) {
          return { _parameters: t22._parameters, _specification: t22._specification };
        }
      }
      function es(t22) {
        let e22 = null;
        if (t22 instanceof li2)
          e22 = es(t22.result);
        else if (t22 instanceof oi2) {
          for (const r22 of t22.args)
            if (e22 = es(r22), e22)
              break;
        } else
          (t22 instanceof Un || t22 instanceof si2) && t22.input instanceof yr && "zoom" === t22.input.name && (e22 = t22);
        return e22 instanceof Ve2 || t22.eachChild((t3) => {
          const r22 = es(t3);
          r22 instanceof Ve2 ? e22 = r22 : e22 && r22 && e22 !== r22 && (e22 = new Ve2("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e22;
      }
      var rs, ns, is = function() {
        if (ns)
          return rs;
        ns = 1, rs = e22;
        var t22 = 3;
        function e22(e3, r22, n22) {
          var i2 = this.cells = [];
          if (e3 instanceof ArrayBuffer) {
            this.arrayBuffer = e3;
            var s2 = new Int32Array(this.arrayBuffer);
            e3 = s2[0], this.d = (r22 = s2[1]) + 2 * (n22 = s2[2]);
            for (var a2 = 0; a2 < this.d * this.d; a2++) {
              var o2 = s2[t22 + a2], l22 = s2[t22 + a2 + 1];
              i2.push(o2 === l22 ? null : s2.subarray(o2, l22));
            }
            var u22 = s2[t22 + i2.length + 1];
            this.keys = s2.subarray(s2[t22 + i2.length], u22), this.bboxes = s2.subarray(u22), this.insert = this._insertReadonly;
          } else {
            this.d = r22 + 2 * n22;
            for (var c22 = 0; c22 < this.d * this.d; c22++)
              i2.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = r22, this.extent = e3, this.padding = n22, this.scale = r22 / e3, this.uid = 0;
          var h22 = n22 / r22 * e3;
          this.min = -h22, this.max = e3 + h22;
        }
        return e22.prototype.insert = function(t3, e3, r22, n22, i2) {
          this._forEachCell(e3, r22, n22, i2, this._insertCell, this.uid++), this.keys.push(t3), this.bboxes.push(e3), this.bboxes.push(r22), this.bboxes.push(n22), this.bboxes.push(i2);
        }, e22.prototype._insertReadonly = function() {
          throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, e22.prototype._insertCell = function(t3, e3, r22, n22, i2, s2) {
          this.cells[i2].push(s2);
        }, e22.prototype.query = function(t3, e3, r22, n22, i2) {
          var s2 = this.min, a2 = this.max;
          if (t3 <= s2 && e3 <= s2 && a2 <= r22 && a2 <= n22 && !i2)
            return Array.prototype.slice.call(this.keys);
          var o2 = [];
          return this._forEachCell(t3, e3, r22, n22, this._queryCell, o2, {}, i2), o2;
        }, e22.prototype._queryCell = function(t3, e3, r22, n22, i2, s2, a2, o2) {
          var l22 = this.cells[i2];
          if (null !== l22)
            for (var u22 = this.keys, c22 = this.bboxes, h22 = 0; h22 < l22.length; h22++) {
              var p22 = l22[h22];
              if (void 0 === a2[p22]) {
                var f22 = 4 * p22;
                (o2 ? o2(c22[f22 + 0], c22[f22 + 1], c22[f22 + 2], c22[f22 + 3]) : t3 <= c22[f22 + 2] && e3 <= c22[f22 + 3] && r22 >= c22[f22 + 0] && n22 >= c22[f22 + 1]) ? (a2[p22] = true, s2.push(u22[p22])) : a2[p22] = false;
              }
            }
        }, e22.prototype._forEachCell = function(t3, e3, r22, n22, i2, s2, a2, o2) {
          for (var l22 = this._convertToCellCoord(t3), u22 = this._convertToCellCoord(e3), c22 = this._convertToCellCoord(r22), h22 = this._convertToCellCoord(n22), p22 = l22; p22 <= c22; p22++)
            for (var f22 = u22; f22 <= h22; f22++) {
              var d22 = this.d * f22 + p22;
              if ((!o2 || o2(this._convertFromCellCoord(p22), this._convertFromCellCoord(f22), this._convertFromCellCoord(p22 + 1), this._convertFromCellCoord(f22 + 1))) && i2.call(this, t3, e3, r22, n22, d22, s2, a2, o2))
                return;
            }
        }, e22.prototype._convertFromCellCoord = function(t3) {
          return (t3 - this.padding) / this.scale;
        }, e22.prototype._convertToCellCoord = function(t3) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t3 * this.scale) + this.padding));
        }, e22.prototype.toArrayBuffer = function() {
          if (this.arrayBuffer)
            return this.arrayBuffer;
          for (var e3 = this.cells, r22 = t22 + this.cells.length + 1 + 1, n22 = 0, i2 = 0; i2 < this.cells.length; i2++)
            n22 += this.cells[i2].length;
          var s2 = new Int32Array(r22 + n22 + this.keys.length + this.bboxes.length);
          s2[0] = this.extent, s2[1] = this.n, s2[2] = this.padding;
          for (var a2 = r22, o2 = 0; o2 < e3.length; o2++) {
            var l22 = e3[o2];
            s2[t22 + o2] = a2, s2.set(l22, a2), a2 += l22.length;
          }
          return s2[t22 + e3.length] = a2, s2.set(this.keys, a2), s2[t22 + e3.length + 1] = a2 += this.keys.length, s2.set(this.bboxes, a2), a2 += this.bboxes.length, s2.buffer;
        }, rs;
      }(), ss = e2(is);
      const as = {};
      function os(t22, e22, r22 = {}) {
        Object.defineProperty(t22, "_classRegistryKey", { value: e22, writable: false }), as[e22] = { klass: t22, omit: r22.omit || [] };
      }
      os(Object, "Object"), ss.serialize = function(t22, e22) {
        const r22 = t22.toArrayBuffer();
        return e22 && e22.add(r22), { buffer: r22 };
      }, ss.deserialize = function(t22) {
        return new ss(t22.buffer);
      }, Object.defineProperty(ss, "name", { value: "Grid" }), os(ss, "Grid"), os(Pe2, "Color"), os(Error, "Error"), os(Qe2, "Formatted"), os(Je2, "FormattedSection"), os(re2, "AJAXError"), os(tr, "ResolvedImage"), os(ts, "StylePropertyFunction"), os(Zi2, "StyleExpression", { omit: ["_evaluator"] }), os(Ji2, "ZoomDependentExpression"), os(Ki2, "ZoomConstantExpression"), os(yr, "CompoundExpression", { omit: ["_evaluate"] });
      for (const t22 in Pi2)
        as[Pi2[t22]._classRegistryKey] || os(Pi2[t22], "Expression".concat(t22));
      function ls(t22) {
        return t22 && "undefined" != typeof ArrayBuffer && (t22 instanceof ArrayBuffer || t22.constructor && "ArrayBuffer" === t22.constructor.name);
      }
      function us(t22) {
        return self.ImageBitmap && t22 instanceof ImageBitmap;
      }
      function cs(t22, e22) {
        if (null == t22 || "boolean" == typeof t22 || "number" == typeof t22 || "string" == typeof t22 || t22 instanceof Boolean || t22 instanceof Number || t22 instanceof String || t22 instanceof Date || t22 instanceof RegExp)
          return t22;
        if (ls(t22) || us(t22))
          return e22 && e22.add(t22), t22;
        if (ArrayBuffer.isView(t22)) {
          const r22 = t22;
          return e22 && e22.add(r22.buffer), r22;
        }
        if (t22 instanceof ImageData)
          return e22 && e22.add(t22.data.buffer), t22;
        if (Array.isArray(t22)) {
          const r22 = [];
          for (const n22 of t22)
            r22.push(cs(n22, e22));
          return r22;
        }
        if (t22 instanceof Map) {
          const e3 = { $name: "Map" };
          for (const [r22, n22] of t22.entries())
            e3[r22] = cs(n22);
          return e3;
        }
        if (t22 instanceof Set) {
          const e3 = { $name: "Set" };
          let r22 = 0;
          for (const n22 of t22.values())
            e3[++r22] = cs(n22);
          return e3;
        }
        if ("object" == typeof t22) {
          const r22 = t22.constructor, n22 = r22._classRegistryKey;
          if (!n22)
            throw new Error("can't serialize object of unregistered class ".concat(n22));
          const i2 = r22.serialize ? r22.serialize(t22, e22) : {};
          if (!r22.serialize) {
            for (const r3 in t22)
              t22.hasOwnProperty(r3) && (as[n22].omit.indexOf(r3) >= 0 || (i2[r3] = cs(t22[r3], e22)));
            t22 instanceof Error && (i2.message = t22.message);
          }
          if (i2.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return "Object" !== n22 && (i2.$name = n22), i2;
        }
        throw new Error("can't serialize object of type " + typeof t22);
      }
      function hs(t22) {
        if (null == t22 || "boolean" == typeof t22 || "number" == typeof t22 || "string" == typeof t22 || t22 instanceof Boolean || t22 instanceof Number || t22 instanceof String || t22 instanceof Date || t22 instanceof RegExp || ls(t22) || us(t22) || ArrayBuffer.isView(t22) || t22 instanceof ImageData)
          return t22;
        if (Array.isArray(t22))
          return t22.map(hs);
        if ("object" == typeof t22) {
          const e22 = t22.$name || "Object";
          if ("Map" === e22) {
            const e3 = /* @__PURE__ */ new Map();
            for (const r3 of Object.keys(t22))
              "$name" !== r3 && e3.set(r3, hs(t22[r3]));
            return e3;
          }
          if ("Set" === e22) {
            const e3 = /* @__PURE__ */ new Set();
            for (const r3 of Object.keys(t22))
              "$name" !== r3 && e3.add(hs(t22[r3]));
            return e3;
          }
          const { klass: r22 } = as[e22];
          if (!r22)
            throw new Error("can't deserialize unregistered class ".concat(e22));
          if (r22.deserialize)
            return r22.deserialize(t22);
          const n22 = Object.create(r22.prototype);
          for (const e3 of Object.keys(t22))
            "$name" !== e3 && (n22[e3] = hs(t22[e3]));
          return n22;
        }
        throw new Error("can't deserialize object of type " + typeof t22);
      }
      const ps = { "Latin-1 Supplement": (t22) => t22 >= 128 && t22 <= 255, Arabic: (t22) => t22 >= 1536 && t22 <= 1791, "Arabic Supplement": (t22) => t22 >= 1872 && t22 <= 1919, "Arabic Extended-A": (t22) => t22 >= 2208 && t22 <= 2303, "Hangul Jamo": (t22) => t22 >= 4352 && t22 <= 4607, "Unified Canadian Aboriginal Syllabics": (t22) => t22 >= 5120 && t22 <= 5759, Khmer: (t22) => t22 >= 6016 && t22 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t22) => t22 >= 6320 && t22 <= 6399, "General Punctuation": (t22) => t22 >= 8192 && t22 <= 8303, "Letterlike Symbols": (t22) => t22 >= 8448 && t22 <= 8527, "Number Forms": (t22) => t22 >= 8528 && t22 <= 8591, "Miscellaneous Technical": (t22) => t22 >= 8960 && t22 <= 9215, "Control Pictures": (t22) => t22 >= 9216 && t22 <= 9279, "Optical Character Recognition": (t22) => t22 >= 9280 && t22 <= 9311, "Enclosed Alphanumerics": (t22) => t22 >= 9312 && t22 <= 9471, "Geometric Shapes": (t22) => t22 >= 9632 && t22 <= 9727, "Miscellaneous Symbols": (t22) => t22 >= 9728 && t22 <= 9983, "Miscellaneous Symbols and Arrows": (t22) => t22 >= 11008 && t22 <= 11263, "CJK Radicals Supplement": (t22) => t22 >= 11904 && t22 <= 12031, "Kangxi Radicals": (t22) => t22 >= 12032 && t22 <= 12255, "Ideographic Description Characters": (t22) => t22 >= 12272 && t22 <= 12287, "CJK Symbols and Punctuation": (t22) => t22 >= 12288 && t22 <= 12351, Hiragana: (t22) => t22 >= 12352 && t22 <= 12447, Katakana: (t22) => t22 >= 12448 && t22 <= 12543, Bopomofo: (t22) => t22 >= 12544 && t22 <= 12591, "Hangul Compatibility Jamo": (t22) => t22 >= 12592 && t22 <= 12687, Kanbun: (t22) => t22 >= 12688 && t22 <= 12703, "Bopomofo Extended": (t22) => t22 >= 12704 && t22 <= 12735, "CJK Strokes": (t22) => t22 >= 12736 && t22 <= 12783, "Katakana Phonetic Extensions": (t22) => t22 >= 12784 && t22 <= 12799, "Enclosed CJK Letters and Months": (t22) => t22 >= 12800 && t22 <= 13055, "CJK Compatibility": (t22) => t22 >= 13056 && t22 <= 13311, "CJK Unified Ideographs Extension A": (t22) => t22 >= 13312 && t22 <= 19903, "Yijing Hexagram Symbols": (t22) => t22 >= 19904 && t22 <= 19967, "CJK Unified Ideographs": (t22) => t22 >= 19968 && t22 <= 40959, "Yi Syllables": (t22) => t22 >= 40960 && t22 <= 42127, "Yi Radicals": (t22) => t22 >= 42128 && t22 <= 42191, "Hangul Jamo Extended-A": (t22) => t22 >= 43360 && t22 <= 43391, "Hangul Syllables": (t22) => t22 >= 44032 && t22 <= 55215, "Hangul Jamo Extended-B": (t22) => t22 >= 55216 && t22 <= 55295, "Private Use Area": (t22) => t22 >= 57344 && t22 <= 63743, "CJK Compatibility Ideographs": (t22) => t22 >= 63744 && t22 <= 64255, "Arabic Presentation Forms-A": (t22) => t22 >= 64336 && t22 <= 65023, "Vertical Forms": (t22) => t22 >= 65040 && t22 <= 65055, "CJK Compatibility Forms": (t22) => t22 >= 65072 && t22 <= 65103, "Small Form Variants": (t22) => t22 >= 65104 && t22 <= 65135, "Arabic Presentation Forms-B": (t22) => t22 >= 65136 && t22 <= 65279, "Halfwidth and Fullwidth Forms": (t22) => t22 >= 65280 && t22 <= 65519, "CJK Unified Ideographs Extension B": (t22) => t22 >= 131072 && t22 <= 173791 };
      function fs(t22) {
        for (const e22 of t22)
          if (ys(e22.charCodeAt(0)))
            return true;
        return false;
      }
      function ds(t22) {
        for (const e22 of t22)
          if (!ms(e22.charCodeAt(0)))
            return false;
        return true;
      }
      function ms(t22) {
        return !(ps.Arabic(t22) || ps["Arabic Supplement"](t22) || ps["Arabic Extended-A"](t22) || ps["Arabic Presentation Forms-A"](t22) || ps["Arabic Presentation Forms-B"](t22));
      }
      function ys(t22) {
        return !(746 !== t22 && 747 !== t22 && (t22 < 4352 || !(ps["Bopomofo Extended"](t22) || ps.Bopomofo(t22) || ps["CJK Compatibility Forms"](t22) && !(t22 >= 65097 && t22 <= 65103) || ps["CJK Compatibility Ideographs"](t22) || ps["CJK Compatibility"](t22) || ps["CJK Radicals Supplement"](t22) || ps["CJK Strokes"](t22) || !(!ps["CJK Symbols and Punctuation"](t22) || t22 >= 12296 && t22 <= 12305 || t22 >= 12308 && t22 <= 12319 || 12336 === t22) || ps["CJK Unified Ideographs Extension A"](t22) || ps["CJK Unified Ideographs"](t22) || ps["Enclosed CJK Letters and Months"](t22) || ps["Hangul Compatibility Jamo"](t22) || ps["Hangul Jamo Extended-A"](t22) || ps["Hangul Jamo Extended-B"](t22) || ps["Hangul Jamo"](t22) || ps["Hangul Syllables"](t22) || ps.Hiragana(t22) || ps["Ideographic Description Characters"](t22) || ps.Kanbun(t22) || ps["Kangxi Radicals"](t22) || ps["Katakana Phonetic Extensions"](t22) || ps.Katakana(t22) && 12540 !== t22 || !(!ps["Halfwidth and Fullwidth Forms"](t22) || 65288 === t22 || 65289 === t22 || 65293 === t22 || t22 >= 65306 && t22 <= 65310 || 65339 === t22 || 65341 === t22 || 65343 === t22 || t22 >= 65371 && t22 <= 65503 || 65507 === t22 || t22 >= 65512 && t22 <= 65519) || !(!ps["Small Form Variants"](t22) || t22 >= 65112 && t22 <= 65118 || t22 >= 65123 && t22 <= 65126) || ps["Unified Canadian Aboriginal Syllabics"](t22) || ps["Unified Canadian Aboriginal Syllabics Extended"](t22) || ps["Vertical Forms"](t22) || ps["Yijing Hexagram Symbols"](t22) || ps["Yi Syllables"](t22) || ps["Yi Radicals"](t22))));
      }
      function gs(t22) {
        return !(ys(t22) || function(t3) {
          return !!(ps["Latin-1 Supplement"](t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || ps["General Punctuation"](t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || ps["Letterlike Symbols"](t3) || ps["Number Forms"](t3) || ps["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || ps["Control Pictures"](t3) && 9251 !== t3 || ps["Optical Character Recognition"](t3) || ps["Enclosed Alphanumerics"](t3) || ps["Geometric Shapes"](t3) || ps["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || ps["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || ps["CJK Symbols and Punctuation"](t3) || ps.Katakana(t3) || ps["Private Use Area"](t3) || ps["CJK Compatibility Forms"](t3) || ps["Small Form Variants"](t3) || ps["Halfwidth and Fullwidth Forms"](t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
        }(t22));
      }
      function xs(t22) {
        return t22 >= 1424 && t22 <= 2303 || ps["Arabic Presentation Forms-A"](t22) || ps["Arabic Presentation Forms-B"](t22);
      }
      function bs(t22, e22) {
        return !(!e22 && xs(t22) || t22 >= 2304 && t22 <= 3583 || t22 >= 3840 && t22 <= 4255 || ps.Khmer(t22));
      }
      function vs(t22) {
        for (const e22 of t22)
          if (xs(e22.charCodeAt(0)))
            return true;
        return false;
      }
      const ws = "deferred", _s = "loading", Ms = "loaded";
      let As = null, Ss = "unavailable", Is = null;
      const Ps = function(t22) {
        t22 && "string" == typeof t22 && t22.indexOf("NetworkError") > -1 && (Ss = "error"), As && As(t22);
      };
      function zs() {
        ks.fire(new be2("pluginStateChange", { pluginStatus: Ss, pluginURL: Is }));
      }
      const ks = new Me2(), Ts = function() {
        return Ss;
      }, Es = function() {
        if (Ss !== ws || !Is)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        Ss = _s, zs(), Is && se2({ url: Is }, (t22) => {
          t22 ? Ps(t22) : (Ss = Ms, zs());
        });
      }, Bs = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Ss === Ms || null != Bs.applyArabicShaping, isLoading: () => Ss === _s, setState(t22) {
        Ss = t22.pluginStatus, Is = t22.pluginURL;
      }, isParsed: () => null != Bs.applyArabicShaping && null != Bs.processBidirectionalText && null != Bs.processStyledBidirectionalText, getPluginURL: () => Is };
      class Vs {
        constructor(t22, e22) {
          this.zoom = t22, e22 ? (this.now = e22.now, this.fadeDuration = e22.fadeDuration, this.transition = e22.transition, this.pitch = e22.pitch, this.brightness = e22.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
        }
        isSupportedScript(t22) {
          return function(t3, e22) {
            for (const r22 of t3)
              if (!bs(r22.charCodeAt(0), e22))
                return false;
            return true;
          }(t22, Bs.isLoaded());
        }
      }
      class Cs {
        constructor(t22, e22, r22, n22) {
          this.property = t22, this.value = e22, this.expression = function(t3, e3, r3, n3) {
            if (Ui2(t3))
              return new ts(t3, e3);
            if (Wi2(t3) || Array.isArray(t3) && t3.length > 0) {
              const i2 = Qi2(t3, e3, r3, n3);
              if ("error" === i2.result)
                throw new Error(i2.value.map((t4) => "".concat(t4.key, ": ").concat(t4.message)).join(", "));
              return i2.value;
            }
            {
              let r4 = t3;
              return "string" == typeof t3 && "color" === e3.type && (r4 = Pe2.parse(t3)), { kind: "constant", configDependencies: /* @__PURE__ */ new Set(), evaluate: () => r4 };
            }
          }(void 0 === e22 ? t22.specification.default : e22, t22.specification, r22, n22);
        }
        isDataDriven() {
          return "source" === this.expression.kind || "composite" === this.expression.kind;
        }
        possiblyEvaluate(t22, e22, r22) {
          return this.property.possiblyEvaluate(this, t22, e22, r22);
        }
      }
      class Rs {
        constructor(t22, e22, r22) {
          this.property = t22, this.value = new Cs(t22, void 0, e22, r22);
        }
        transitioned(t22, e22) {
          return new Ls(this.property, this.value, e22, nt({}, t22.transition, this.transition), t22.now);
        }
        untransitioned() {
          return new Ls(this.property, this.value, null, {}, 0);
        }
      }
      class Ds {
        constructor(t22, e22, r22) {
          this._properties = t22, this._values = Object.create(t22.defaultTransitionablePropertyValues), this._scope = e22, this._options = r22, this.configDependencies = /* @__PURE__ */ new Set();
        }
        getValue(t22) {
          return ht(this._values[t22].value.value);
        }
        setValue(t22, e22) {
          this._values.hasOwnProperty(t22) || (this._values[t22] = new Rs(this._values[t22].property, this._scope, this._options)), this._values[t22].value = new Cs(this._values[t22].property, null === e22 ? void 0 : ht(e22), this._scope, this._options), this._values[t22].value.expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[t22].value.expression.configDependencies]));
        }
        setTransitionOrValue(t22, e22) {
          e22 && (this._options = e22);
          const r22 = this._properties.properties;
          if (t22)
            for (const e3 in t22) {
              const n22 = t22[e3];
              if (lt(e3, "-transition")) {
                const t3 = e3.slice(0, -11);
                r22[t3] && this.setTransition(t3, n22);
              } else
                r22.hasOwnProperty(e3) && this.setValue(e3, n22);
            }
        }
        getTransition(t22) {
          return ht(this._values[t22].transition);
        }
        setTransition(t22, e22) {
          this._values.hasOwnProperty(t22) || (this._values[t22] = new Rs(this._values[t22].property)), this._values[t22].transition = ht(e22) || void 0;
        }
        serialize() {
          const t22 = {};
          for (const e22 of Object.keys(this._values)) {
            const r22 = this.getValue(e22);
            void 0 !== r22 && (t22[e22] = r22);
            const n22 = this.getTransition(e22);
            void 0 !== n22 && (t22["".concat(e22, "-transition")] = n22);
          }
          return t22;
        }
        transitioned(t22, e22) {
          const r22 = new Fs(this._properties);
          for (const n22 of Object.keys(this._values))
            r22._values[n22] = this._values[n22].transitioned(t22, e22._values[n22]);
          return r22;
        }
        untransitioned() {
          const t22 = new Fs(this._properties);
          for (const e22 of Object.keys(this._values))
            t22._values[e22] = this._values[e22].untransitioned();
          return t22;
        }
      }
      class Ls {
        constructor(t22, e22, r22, n22, i2) {
          const s2 = n22.delay || 0, a2 = n22.duration || 0;
          i2 = i2 || 0, this.property = t22, this.value = e22, this.begin = i2 + s2, this.end = this.begin + a2, t22.specification.transition && (n22.delay || n22.duration) && (this.prior = r22);
        }
        possiblyEvaluate(t22, e22, r22) {
          const n22 = t22.now || 0, i2 = this.value.possiblyEvaluate(t22, e22, r22), s2 = this.prior;
          if (s2) {
            if (n22 > this.end)
              return this.prior = null, i2;
            if (this.value.isDataDriven())
              return this.prior = null, i2;
            if (n22 < this.begin)
              return s2.possiblyEvaluate(t22, e22, r22);
            {
              const a2 = (n22 - this.begin) / (this.end - this.begin);
              return this.property.interpolate(s2.possiblyEvaluate(t22, e22, r22), i2, H2(a2));
            }
          }
          return i2;
        }
      }
      class Fs {
        constructor(t22) {
          this._properties = t22, this._values = Object.create(t22.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(t22, e22, r22) {
          const n22 = new js(this._properties);
          for (const i2 of Object.keys(this._values))
            n22._values[i2] = this._values[i2].possiblyEvaluate(t22, e22, r22);
          return n22;
        }
        hasTransition() {
          for (const t22 of Object.keys(this._values))
            if (this._values[t22].prior)
              return true;
          return false;
        }
      }
      class Os {
        constructor(t22, e22, r22) {
          this._properties = t22, this._values = Object.create(t22.defaultPropertyValues), this._scope = e22, this._options = r22, this.configDependencies = /* @__PURE__ */ new Set();
        }
        getValue(t22) {
          return ht(this._values[t22].value);
        }
        setValue(t22, e22) {
          this._values[t22] = new Cs(this._values[t22].property, null === e22 ? void 0 : ht(e22), this._scope, this._options), this._values[t22].expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[t22].expression.configDependencies]));
        }
        serialize() {
          const t22 = {};
          for (const e22 of Object.keys(this._values)) {
            const r22 = this.getValue(e22);
            void 0 !== r22 && (t22[e22] = r22);
          }
          return t22;
        }
        possiblyEvaluate(t22, e22, r22) {
          const n22 = new js(this._properties);
          for (const i2 of Object.keys(this._values))
            n22._values[i2] = this._values[i2].possiblyEvaluate(t22, e22, r22);
          return n22;
        }
      }
      class Us {
        constructor(t22, e22, r22) {
          this.property = t22, this.value = e22, this.parameters = r22;
        }
        isConstant() {
          return "constant" === this.value.kind;
        }
        constantOr(t22) {
          return "constant" === this.value.kind ? this.value.value : t22;
        }
        evaluate(t22, e22, r22, n22) {
          return this.property.evaluate(this.value, this.parameters, t22, e22, r22, n22);
        }
      }
      class js {
        constructor(t22) {
          this._properties = t22, this._values = Object.create(t22.defaultPossiblyEvaluatedValues);
        }
        get(t22) {
          return this._values[t22];
        }
      }
      class Ns {
        constructor(t22) {
          this.specification = t22;
        }
        possiblyEvaluate(t22, e22) {
          return t22.expression.evaluate(e22);
        }
        interpolate(t22, e22, r22) {
          const n22 = Ee2[this.specification.type];
          return n22 ? n22(t22, e22, r22) : t22;
        }
      }
      class qs {
        constructor(t22, e22) {
          this.specification = t22, this.overrides = e22;
        }
        possiblyEvaluate(t22, e22, r22, n22) {
          return new Us(this, "constant" === t22.expression.kind || "camera" === t22.expression.kind ? { kind: "constant", value: t22.expression.evaluate(e22, null, {}, r22, n22) } : t22.expression, e22);
        }
        interpolate(t22, e22, r22) {
          if ("constant" !== t22.value.kind || "constant" !== e22.value.kind)
            return t22;
          if (void 0 === t22.value.value || void 0 === e22.value.value)
            return new Us(this, { kind: "constant", value: void 0 }, t22.parameters);
          const n22 = Ee2[this.specification.type];
          return n22 ? new Us(this, { kind: "constant", value: n22(t22.value.value, e22.value.value, r22) }, t22.parameters) : t22;
        }
        evaluate(t22, e22, r22, n22, i2, s2) {
          return "constant" === t22.kind ? t22.value : t22.evaluate(e22, r22, n22, i2, s2);
        }
      }
      class $s {
        constructor(t22) {
          this.specification = t22;
        }
        possiblyEvaluate(t22, e22, r22, n22) {
          return !!t22.expression.evaluate(e22, null, {}, r22, n22);
        }
        interpolate() {
          return false;
        }
      }
      class Gs {
        constructor(t22) {
          this.properties = t22, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          const e22 = new Vs(0, {});
          for (const r22 in t22) {
            const n22 = t22[r22];
            n22.specification.overridable && this.overridableProperties.push(r22);
            const i2 = this.defaultPropertyValues[r22] = new Cs(n22, void 0), s2 = this.defaultTransitionablePropertyValues[r22] = new Rs(n22);
            this.defaultTransitioningPropertyValues[r22] = s2.untransitioned(), this.defaultPossiblyEvaluatedValues[r22] = i2.possiblyEvaluate(e22);
          }
        }
      }
      os(qs, "DataDrivenProperty"), os(Ns, "DataConstantProperty"), os($s, "ColorRampProperty");
      var Xs = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"experimental":true,"type":"featuresets"}},"featuresets":{"experimental":true,"*":{"type":"featureset"}},"featureset":{"experimental":true,"selectors":{"type":"array","value":"selector"}},"selector":{"experimental":true,"layer":{"type":"string","required":true},"properties":{"type":"selectorProperty","required":false},"featureNamespace":{"type":"string","required":false}},"selectorProperty":{"experimental":true,"*":{"type":"*"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","property-type":"data-constant","expression":{},"required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"property-type":"data-constant"},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"experimental":true,"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"raster-particle":{"experimental":true},"hillshade":{},"model":{"experimental":true},"background":{},"sky":{},"slot":{},"clip":{"experimental":true}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{},"property-type":"data-constant","experimental":true},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{},"property-type":"data-constant","experimental":true}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","experimental":true,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"colorTheme":{"data":{"type":"string","property-type":"data-constant","expression":{}}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","experimental":true,"default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","experimental":true,"default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"experimental":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-trim-fade-range":{"type":"array","value":"number","experimental":true,"length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-trim-color":{"type":"color","experimental":true,"default":"transparent","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"property-type":"data-constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1},"default":"ground","experimental":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"experimental":true,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-particle-count":{"type":"number","default":512,"minimum":1,"property-type":"data-constant"},"raster-particle-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-particle-speed"]},"property-type":"color-ramp"},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1,"property-type":"data-constant"},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1,"property-type":"data-constant"},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]},"property-type":"data-constant"},"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"model-front-cutoff":{"type":"array","private":true,"value":"number","property-type":"data-constant","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
      function Ys(t22) {
        return t22 instanceof Number || t22 instanceof String || t22 instanceof Boolean ? t22.valueOf() : t22;
      }
      function Zs(t22) {
        if (Array.isArray(t22))
          return t22.map(Zs);
        if (t22 instanceof Object && !(t22 instanceof Number || t22 instanceof String || t22 instanceof Boolean)) {
          const e22 = {};
          for (const r22 in t22)
            e22[r22] = Zs(t22[r22]);
          return e22;
        }
        return Ys(t22);
      }
      function Ws(t22) {
        if (true === t22 || false === t22)
          return true;
        if (!Array.isArray(t22) || 0 === t22.length)
          return false;
        switch (t22[0]) {
          case "has":
            return t22.length >= 2 && "$id" !== t22[1] && "$type" !== t22[1];
          case "in":
            return t22.length >= 3 && ("string" != typeof t22[1] || Array.isArray(t22[2]));
          case "!in":
          case "!has":
          case "none":
            return false;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return 3 !== t22.length || Array.isArray(t22[1]) || Array.isArray(t22[2]);
          case "any":
          case "all":
            for (const e22 of t22.slice(1))
              if (!Ws(e22) && "boolean" != typeof e22)
                return false;
            return true;
          default:
            return true;
        }
      }
      function Hs(t22, e22 = "", r22 = null, n22 = "fill") {
        if (null == t22)
          return { filter: () => true, needGeometry: false, needFeature: false };
        Ws(t22) || (t22 = na(t22));
        const i2 = t22;
        let s2 = true;
        try {
          s2 = function(t3) {
            if (!Qs(t3))
              return t3;
            let e3 = Zs(t3);
            return Js(e3), e3 = Ks(e3), e3;
          }(i2);
        } catch (t3) {
          console.warn("Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n".concat(JSON.stringify(i2, null, 2), "\n        "));
        }
        const a2 = Xs["filter_".concat(n22)], o2 = Hi2(s2, a2, e22, r22);
        let l22 = null;
        if ("error" === o2.result)
          throw new Error(o2.value.map((t3) => "".concat(t3.key, ": ").concat(t3.message)).join(", "));
        l22 = (t3, e3, r3) => o2.value.evaluate(t3, e3, {}, r3);
        let u22 = null, c22 = null;
        if (s2 !== i2) {
          const t3 = Hi2(i2, a2, e22, r22);
          if ("error" === t3.result)
            throw new Error(t3.value.map((t4) => "".concat(t4.key, ": ").concat(t4.message)).join(", "));
          u22 = (e3, r3, n3, i3, s3) => t3.value.evaluate(e3, r3, {}, n3, void 0, void 0, i3, s3), c22 = !En(t3.value.expression);
        }
        return { filter: l22, dynamicFilter: u22 || void 0, needGeometry: ra2(s2), needFeature: !!c22 };
      }
      function Ks(t22) {
        if (!Array.isArray(t22))
          return t22;
        const e22 = function(t3) {
          if (ta2.has(t3[0])) {
            for (let e3 = 1; e3 < t3.length; e3++)
              if (Qs(t3[e3]))
                return true;
          }
          return t3;
        }(t22);
        return true === e22 ? e22 : e22.map((t3) => Ks(t3));
      }
      function Js(t22) {
        let e22 = false;
        const r22 = [];
        if ("case" === t22[0]) {
          for (let n22 = 1; n22 < t22.length - 1; n22 += 2)
            e22 = e22 || Qs(t22[n22]), r22.push(t22[n22 + 1]);
          r22.push(t22[t22.length - 1]);
        } else if ("match" === t22[0]) {
          e22 = e22 || Qs(t22[1]);
          for (let e3 = 2; e3 < t22.length - 1; e3 += 2)
            r22.push(t22[e3 + 1]);
          r22.push(t22[t22.length - 1]);
        } else if ("step" === t22[0]) {
          e22 = e22 || Qs(t22[1]);
          for (let e3 = 1; e3 < t22.length - 1; e3 += 2)
            r22.push(t22[e3 + 1]);
        }
        e22 && (t22.length = 0, t22.push("any", ...r22));
        for (let e3 = 1; e3 < t22.length; e3++)
          Js(t22[e3]);
      }
      function Qs(t22) {
        if (!Array.isArray(t22))
          return false;
        if ("pitch" === (e22 = t22[0]) || "distance-from-center" === e22)
          return true;
        var e22;
        for (let e3 = 1; e3 < t22.length; e3++)
          if (Qs(t22[e3]))
            return true;
        return false;
      }
      const ta2 = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
      function ea2(t22, e22) {
        return t22 < e22 ? -1 : t22 > e22 ? 1 : 0;
      }
      function ra2(t22) {
        if (!Array.isArray(t22))
          return false;
        if ("within" === t22[0] || "distance" === t22[0])
          return true;
        for (let e22 = 1; e22 < t22.length; e22++)
          if (ra2(t22[e22]))
            return true;
        return false;
      }
      function na(t22) {
        if (!t22)
          return true;
        const e22 = t22[0];
        return t22.length <= 1 ? "any" !== e22 : "==" === e22 ? ia2(t22[1], t22[2], "==") : "!=" === e22 ? oa2(ia2(t22[1], t22[2], "==")) : "<" === e22 || ">" === e22 || "<=" === e22 || ">=" === e22 ? ia2(t22[1], t22[2], e22) : "any" === e22 ? (r22 = t22.slice(1), ["any"].concat(r22.map(na))) : "all" === e22 ? ["all"].concat(t22.slice(1).map(na)) : "none" === e22 ? ["all"].concat(t22.slice(1).map(na).map(oa2)) : "in" === e22 ? sa2(t22[1], t22.slice(2)) : "!in" === e22 ? oa2(sa2(t22[1], t22.slice(2))) : "has" === e22 ? aa2(t22[1]) : "!has" !== e22 || oa2(aa2(t22[1]));
        var r22;
      }
      function ia2(t22, e22, r22) {
        switch (t22) {
          case "$type":
            return ["filter-type-".concat(r22), e22];
          case "$id":
            return ["filter-id-".concat(r22), e22];
          default:
            return ["filter-".concat(r22), t22, e22];
        }
      }
      function sa2(t22, e22) {
        if (0 === e22.length)
          return false;
        switch (t22) {
          case "$type":
            return ["filter-type-in", ["literal", e22]];
          case "$id":
            return ["filter-id-in", ["literal", e22]];
          default:
            return e22.length > 200 && !e22.some((t3) => typeof t3 != typeof e22[0]) ? ["filter-in-large", t22, ["literal", e22.sort(ea2)]] : ["filter-in-small", t22, ["literal", e22]];
        }
      }
      function aa2(t22) {
        switch (t22) {
          case "$type":
            return true;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", t22];
        }
      }
      function oa2(t22) {
        return ["!", t22];
      }
      const la2 = "";
      function ua2(t22, e22) {
        return e22 ? "".concat(t22).concat(la2).concat(e22) : t22;
      }
      const ca2 = "-transition", ha2 = /* @__PURE__ */ new Set(["fill", "line", "background", "hillshade", "raster"]);
      class pa2 extends Me2 {
        constructor(t22, e22, r22, n22, i2) {
          if (super(), this.id = t22.id, this.fqid = ua2(this.id, r22), this.type = t22.type, this.scope = r22, this.lut = n22, this.options = i2, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, this.configDependencies = /* @__PURE__ */ new Set(), "custom" !== t22.type && (this.metadata = t22.metadata, this.minzoom = t22.minzoom, this.maxzoom = t22.maxzoom, "background" !== t22.type && "sky" !== t22.type && "slot" !== t22.type && (this.source = t22.source, this.sourceLayer = t22["source-layer"], this.filter = t22.filter), t22.slot && (this.slot = t22.slot), e22.layout && (this._unevaluatedLayout = new Os(e22.layout, this.scope, i2), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._unevaluatedLayout.configDependencies])), e22.paint)) {
            this._transitionablePaint = new Ds(e22.paint, this.scope, i2);
            for (const e3 in t22.paint)
              this.setPaintProperty(e3, t22.paint[e3]);
            for (const e3 in t22.layout)
              this.setLayoutProperty(e3, t22.layout[e3]);
            this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._transitionablePaint.configDependencies]), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new js(e22.paint);
          }
        }
        onAdd(t22) {
        }
        onRemove(t22) {
        }
        isDraped(t22) {
          return !this.is3D() && ha2.has(this.type);
        }
        getLayoutProperty(t22) {
          return "visibility" === t22 ? this.visibility : this._unevaluatedLayout.getValue(t22);
        }
        setLayoutProperty(t22, e22) {
          if ("custom" === this.type && "visibility" === t22)
            return void (this.visibility = e22);
          const r22 = this._unevaluatedLayout;
          r22._properties.properties[t22] && (r22.setValue(t22, e22), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...r22.configDependencies]), "visibility" === t22 && this.possiblyEvaluateVisibility());
        }
        possiblyEvaluateVisibility() {
          this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 });
        }
        getPaintProperty(t22) {
          return lt(t22, ca2) ? this._transitionablePaint.getTransition(t22.slice(0, -11)) : this._transitionablePaint.getValue(t22);
        }
        setPaintProperty(t22, e22) {
          const r22 = this._transitionablePaint, n22 = r22._properties.properties;
          if (lt(t22, ca2)) {
            const i3 = t22.slice(0, -11);
            return n22[i3] && r22.setTransition(i3, e22 || void 0), false;
          }
          if (!n22[t22])
            return false;
          const i2 = r22._values[t22], s2 = i2.value.isDataDriven(), a2 = i2.value;
          r22.setValue(t22, e22), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...r22.configDependencies]), this._handleSpecialPaintPropertyUpdate(t22);
          const o2 = r22._values[t22].value, l22 = o2.isDataDriven(), u22 = lt(t22, "pattern") || "line-dasharray" === t22;
          return l22 || s2 || u22 || this._handleOverridablePaintPropertyUpdate(t22, a2, o2);
        }
        _handleSpecialPaintPropertyUpdate(t22) {
        }
        getProgramIds() {
          return null;
        }
        getDefaultProgramParams(t22, e22, r22) {
          return null;
        }
        _handleOverridablePaintPropertyUpdate(t22, e22, r22) {
          return false;
        }
        isHidden(t22) {
          return !!(this.minzoom && t22 < this.minzoom) || !!(this.maxzoom && t22 >= this.maxzoom) || "none" === this.visibility;
        }
        updateTransitions(t22) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t22, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t22, e22) {
          this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t22, void 0, e22)), this.paint = this._transitioningPaint.possiblyEvaluate(t22, void 0, e22);
        }
        serialize() {
          return ct({ id: this.id, type: this.type, slot: this.slot, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }, (t22, e22) => !(void 0 === t22 || "layout" === e22 && !Object.keys(t22).length || "paint" === e22 && !Object.keys(t22).length));
        }
        is3D() {
          return false;
        }
        isSky() {
          return false;
        }
        isTileClipped() {
          return false;
        }
        hasOffscreenPass() {
          return false;
        }
        hasShadowPass() {
          return false;
        }
        canCastShadows() {
          return false;
        }
        hasLightBeamPass() {
          return false;
        }
        cutoffRange() {
          return 0;
        }
        tileCoverLift() {
          return 0;
        }
        resize() {
        }
        isStateDependent() {
          for (const t22 in this.paint._values) {
            const e22 = this.paint.get(t22);
            if (e22 instanceof Us && Di2(e22.property.specification) && ("source" === e22.value.kind || "composite" === e22.value.kind) && e22.value.isStateDependent)
              return true;
          }
          return false;
        }
        compileFilter(t22) {
          this._filterCompiled || (this._featureFilter = Hs(this.filter, this.scope, t22), this._filterCompiled = true);
        }
        invalidateCompiledFilter() {
          this._filterCompiled = false;
        }
        dynamicFilter() {
          return this._featureFilter.dynamicFilter;
        }
        dynamicFilterNeedsFeature() {
          return this._featureFilter.needFeature;
        }
        getLayerRenderingStats() {
          return this._stats;
        }
        resetLayerRenderingStats(t22) {
          this._stats && ("shadow" === t22.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
        }
        queryRadius(t22) {
        }
        queryIntersectsFeature(t22, e22, r22, n22, i2, s2, a2, o2, l22) {
        }
        queryIntersectsMatchingFeature(t22, e22, r22, n22) {
        }
      }
      const fa2 = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class da2 {
        constructor(t22, e22) {
          this._structArray = t22, this._pos1 = e22 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class ma2 {
        constructor() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        }
        static serialize(t22, e22) {
          return t22._trim(), e22 && (t22.isTransferred = true, e22.add(t22.arrayBuffer)), { length: t22.length, arrayBuffer: t22.arrayBuffer };
        }
        static deserialize(t22) {
          const e22 = Object.create(this.prototype);
          return e22.arrayBuffer = t22.arrayBuffer, e22.length = t22.length, e22.capacity = t22.arrayBuffer.byteLength / e22.bytesPerElement, e22._refreshViews(), e22;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t22) {
          this.reserve(t22), this.length = t22;
        }
        reserve(t22) {
          if (t22 > this.capacity) {
            this.capacity = Math.max(t22, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const e22 = this.uint8;
            this._refreshViews(), e22 && this.uint8.set(e22);
          }
        }
        _refreshViews() {
          throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
        }
        emplace(...t22) {
          throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
        }
        emplaceBack(...t22) {
          throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
        }
        destroy() {
          this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
        }
      }
      function ya2(t22, e22 = 1) {
        let r22 = 0, n22 = 0;
        return { members: t22.map((t3) => {
          const i2 = fa2[t3.type].BYTES_PER_ELEMENT, s2 = r22 = ga(r22, Math.max(e22, i2)), a2 = t3.components || 1;
          return n22 = Math.max(n22, i2), r22 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
        }), size: ga(r22, Math.max(n22, e22)), alignment: e22 };
      }
      function ga(t22, e22) {
        return Math.ceil(t22 / e22) * e22;
      }
      class xa extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22) {
          const r22 = this.length;
          return this.resize(r22 + 1), this.emplace(r22, t22, e22);
        }
        emplace(t22, e22, r22) {
          const n22 = 2 * t22;
          return this.int16[n22 + 0] = e22, this.int16[n22 + 1] = r22, t22;
        }
      }
      xa.prototype.bytesPerElement = 4, os(xa, "StructArrayLayout2i4");
      class ba extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22) {
          const n22 = this.length;
          return this.resize(n22 + 1), this.emplace(n22, t22, e22, r22);
        }
        emplace(t22, e22, r22, n22) {
          const i2 = 3 * t22;
          return this.int16[i2 + 0] = e22, this.int16[i2 + 1] = r22, this.int16[i2 + 2] = n22, t22;
        }
      }
      ba.prototype.bytesPerElement = 6, os(ba, "StructArrayLayout3i6");
      class va2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t22, e22, r22, n22);
        }
        emplace(t22, e22, r22, n22, i2) {
          const s2 = 4 * t22;
          return this.int16[s2 + 0] = e22, this.int16[s2 + 1] = r22, this.int16[s2 + 2] = n22, this.int16[s2 + 3] = i2, t22;
        }
      }
      va2.prototype.bytesPerElement = 8, os(va2, "StructArrayLayout4i8");
      class wa2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t22, e22, r22, n22, i2);
        }
        emplace(t22, e22, r22, n22, i2, s2) {
          const a2 = 5 * t22;
          return this.int16[a2 + 0] = e22, this.int16[a2 + 1] = r22, this.int16[a2 + 2] = n22, this.int16[a2 + 3] = i2, this.int16[a2 + 4] = s2, t22;
        }
      }
      wa2.prototype.bytesPerElement = 10, os(wa2, "StructArrayLayout5i10");
      class _a extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2, s2, a2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t22, e22, r22, n22, i2, s2, a2);
        }
        emplace(t22, e22, r22, n22, i2, s2, a2, o2) {
          const l22 = 6 * t22, u22 = 12 * t22, c22 = 3 * t22;
          return this.int16[l22 + 0] = e22, this.int16[l22 + 1] = r22, this.uint8[u22 + 4] = n22, this.uint8[u22 + 5] = i2, this.uint8[u22 + 6] = s2, this.uint8[u22 + 7] = a2, this.float32[c22 + 2] = o2, t22;
        }
      }
      _a.prototype.bytesPerElement = 12, os(_a, "StructArrayLayout2i4ub1f12");
      class Ma2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t22, e22, r22, n22);
        }
        emplace(t22, e22, r22, n22, i2) {
          const s2 = 4 * t22;
          return this.float32[s2 + 0] = e22, this.float32[s2 + 1] = r22, this.float32[s2 + 2] = n22, this.float32[s2 + 3] = i2, t22;
        }
      }
      Ma2.prototype.bytesPerElement = 16, os(Ma2, "StructArrayLayout4f16");
      class Aa2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22) {
          const n22 = this.length;
          return this.resize(n22 + 1), this.emplace(n22, t22, e22, r22);
        }
        emplace(t22, e22, r22, n22) {
          const i2 = 3 * t22;
          return this.float32[i2 + 0] = e22, this.float32[i2 + 1] = r22, this.float32[i2 + 2] = n22, t22;
        }
      }
      Aa2.prototype.bytesPerElement = 12, os(Aa2, "StructArrayLayout3f12");
      class Sa2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t22, e22, r22, n22, i2);
        }
        emplace(t22, e22, r22, n22, i2, s2) {
          const a2 = 6 * t22, o2 = 3 * t22;
          return this.uint16[a2 + 0] = e22, this.uint16[a2 + 1] = r22, this.uint16[a2 + 2] = n22, this.uint16[a2 + 3] = i2, this.float32[o2 + 2] = s2, t22;
        }
      }
      Sa2.prototype.bytesPerElement = 12, os(Sa2, "StructArrayLayout4ui1f12");
      class Ia2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t22, e22, r22, n22);
        }
        emplace(t22, e22, r22, n22, i2) {
          const s2 = 4 * t22;
          return this.uint16[s2 + 0] = e22, this.uint16[s2 + 1] = r22, this.uint16[s2 + 2] = n22, this.uint16[s2 + 3] = i2, t22;
        }
      }
      Ia2.prototype.bytesPerElement = 8, os(Ia2, "StructArrayLayout4ui8");
      class Pa2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t22, e22, r22, n22, i2, s2);
        }
        emplace(t22, e22, r22, n22, i2, s2, a2) {
          const o2 = 6 * t22;
          return this.int16[o2 + 0] = e22, this.int16[o2 + 1] = r22, this.int16[o2 + 2] = n22, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t22;
        }
      }
      Pa2.prototype.bytesPerElement = 12, os(Pa2, "StructArrayLayout6i12");
      class za2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22) {
          const p22 = this.length;
          return this.resize(p22 + 1), this.emplace(p22, t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22);
        }
        emplace(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22) {
          const f22 = 12 * t22;
          return this.int16[f22 + 0] = e22, this.int16[f22 + 1] = r22, this.int16[f22 + 2] = n22, this.int16[f22 + 3] = i2, this.uint16[f22 + 4] = s2, this.uint16[f22 + 5] = a2, this.uint16[f22 + 6] = o2, this.uint16[f22 + 7] = l22, this.int16[f22 + 8] = u22, this.int16[f22 + 9] = c22, this.int16[f22 + 10] = h22, this.int16[f22 + 11] = p22, t22;
        }
      }
      za2.prototype.bytesPerElement = 24, os(za2, "StructArrayLayout4i4ui4i24");
      class ka2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t22, e22, r22, n22, i2, s2);
        }
        emplace(t22, e22, r22, n22, i2, s2, a2) {
          const o2 = 10 * t22, l22 = 5 * t22;
          return this.int16[o2 + 0] = e22, this.int16[o2 + 1] = r22, this.int16[o2 + 2] = n22, this.float32[l22 + 2] = i2, this.float32[l22 + 3] = s2, this.float32[l22 + 4] = a2, t22;
        }
      }
      ka2.prototype.bytesPerElement = 20, os(ka2, "StructArrayLayout3i3f20");
      class Ta2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t22) {
          const e22 = this.length;
          return this.resize(e22 + 1), this.emplace(e22, t22);
        }
        emplace(t22, e22) {
          return this.uint32[1 * t22 + 0] = e22, t22;
        }
      }
      Ta2.prototype.bytesPerElement = 4, os(Ta2, "StructArrayLayout1ul4");
      class Ea2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22) {
          const r22 = this.length;
          return this.resize(r22 + 1), this.emplace(r22, t22, e22);
        }
        emplace(t22, e22, r22) {
          const n22 = 2 * t22;
          return this.uint16[n22 + 0] = e22, this.uint16[n22 + 1] = r22, t22;
        }
      }
      Ea2.prototype.bytesPerElement = 4, os(Ea2, "StructArrayLayout2ui4");
      class Ba2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22) {
          const f22 = this.length;
          return this.resize(f22 + 1), this.emplace(f22, t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22);
        }
        emplace(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22, f22) {
          const d22 = 20 * t22, m22 = 10 * t22;
          return this.int16[d22 + 0] = e22, this.int16[d22 + 1] = r22, this.int16[d22 + 2] = n22, this.int16[d22 + 3] = i2, this.int16[d22 + 4] = s2, this.float32[m22 + 3] = a2, this.float32[m22 + 4] = o2, this.float32[m22 + 5] = l22, this.float32[m22 + 6] = u22, this.int16[d22 + 14] = c22, this.uint32[m22 + 8] = h22, this.uint16[d22 + 18] = p22, this.uint16[d22 + 19] = f22, t22;
        }
      }
      Ba2.prototype.bytesPerElement = 40, os(Ba2, "StructArrayLayout5i4f1i1ul2ui40");
      class Va2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2, s2, a2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t22, e22, r22, n22, i2, s2, a2);
        }
        emplace(t22, e22, r22, n22, i2, s2, a2, o2) {
          const l22 = 8 * t22;
          return this.int16[l22 + 0] = e22, this.int16[l22 + 1] = r22, this.int16[l22 + 2] = n22, this.int16[l22 + 4] = i2, this.int16[l22 + 5] = s2, this.int16[l22 + 6] = a2, this.int16[l22 + 7] = o2, t22;
        }
      }
      Va2.prototype.bytesPerElement = 16, os(Va2, "StructArrayLayout3i2i2i16");
      class Ca2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t22, e22, r22, n22, i2);
        }
        emplace(t22, e22, r22, n22, i2, s2) {
          const a2 = 4 * t22, o2 = 8 * t22;
          return this.float32[a2 + 0] = e22, this.float32[a2 + 1] = r22, this.float32[a2 + 2] = n22, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t22;
        }
      }
      Ca2.prototype.bytesPerElement = 16, os(Ca2, "StructArrayLayout2f1f2i16");
      class Ra2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t22, e22, r22, n22, i2, s2);
        }
        emplace(t22, e22, r22, n22, i2, s2, a2) {
          const o2 = 20 * t22, l22 = 5 * t22;
          return this.uint8[o2 + 0] = e22, this.uint8[o2 + 1] = r22, this.float32[l22 + 1] = n22, this.float32[l22 + 2] = i2, this.float32[l22 + 3] = s2, this.float32[l22 + 4] = a2, t22;
        }
      }
      Ra2.prototype.bytesPerElement = 20, os(Ra2, "StructArrayLayout2ub4f20");
      class Da2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22) {
          const n22 = this.length;
          return this.resize(n22 + 1), this.emplace(n22, t22, e22, r22);
        }
        emplace(t22, e22, r22, n22) {
          const i2 = 3 * t22;
          return this.uint16[i2 + 0] = e22, this.uint16[i2 + 1] = r22, this.uint16[i2 + 2] = n22, t22;
        }
      }
      Da2.prototype.bytesPerElement = 6, os(Da2, "StructArrayLayout3ui6");
      class La2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22, x22, b22, v22) {
          const w22 = this.length;
          return this.resize(w22 + 1), this.emplace(w22, t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22, x22, b22, v22);
        }
        emplace(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22, x22, b22, v22, w22) {
          const _2 = 30 * t22, M22 = 15 * t22, A22 = 60 * t22;
          return this.int16[_2 + 0] = e22, this.int16[_2 + 1] = r22, this.int16[_2 + 2] = n22, this.float32[M22 + 2] = i2, this.float32[M22 + 3] = s2, this.uint16[_2 + 8] = a2, this.uint16[_2 + 9] = o2, this.uint32[M22 + 5] = l22, this.uint32[M22 + 6] = u22, this.uint32[M22 + 7] = c22, this.uint16[_2 + 16] = h22, this.uint16[_2 + 17] = p22, this.uint16[_2 + 18] = f22, this.float32[M22 + 10] = d22, this.float32[M22 + 11] = m22, this.uint8[A22 + 48] = y22, this.uint8[A22 + 49] = g22, this.uint8[A22 + 50] = x22, this.uint32[M22 + 13] = b22, this.int16[_2 + 28] = v22, this.uint8[A22 + 58] = w22, t22;
        }
      }
      La2.prototype.bytesPerElement = 60, os(La2, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
      class Fa2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22, x22, b22, v22, w22, _2, M22, A22, S22, I22, P22, z22, k22, T22, E22) {
          const B22 = this.length;
          return this.resize(B22 + 1), this.emplace(B22, t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22, x22, b22, v22, w22, _2, M22, A22, S22, I22, P22, z22, k22, T22, E22);
        }
        emplace(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22, x22, b22, v22, w22, _2, M22, A22, S22, I22, P22, z22, k22, T22, E22, B22) {
          const V22 = 20 * t22, C22 = 40 * t22, R22 = 80 * t22;
          return this.float32[V22 + 0] = e22, this.float32[V22 + 1] = r22, this.int16[C22 + 4] = n22, this.int16[C22 + 5] = i2, this.int16[C22 + 6] = s2, this.int16[C22 + 7] = a2, this.int16[C22 + 8] = o2, this.int16[C22 + 9] = l22, this.int16[C22 + 10] = u22, this.int16[C22 + 11] = c22, this.int16[C22 + 12] = h22, this.uint16[C22 + 13] = p22, this.uint16[C22 + 14] = f22, this.uint16[C22 + 15] = d22, this.uint16[C22 + 16] = m22, this.uint16[C22 + 17] = y22, this.uint16[C22 + 18] = g22, this.uint16[C22 + 19] = x22, this.uint16[C22 + 20] = b22, this.uint16[C22 + 21] = v22, this.uint16[C22 + 22] = w22, this.uint16[C22 + 23] = _2, this.uint16[C22 + 24] = M22, this.uint16[C22 + 25] = A22, this.uint16[C22 + 26] = S22, this.uint16[C22 + 27] = I22, this.uint32[V22 + 14] = P22, this.float32[V22 + 15] = z22, this.float32[V22 + 16] = k22, this.float32[V22 + 17] = T22, this.float32[V22 + 18] = E22, this.uint8[R22 + 76] = B22, t22;
        }
      }
      Fa2.prototype.bytesPerElement = 80, os(Fa2, "StructArrayLayout2f9i15ui1ul4f1ub80");
      class Oa2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22) {
          const e22 = this.length;
          return this.resize(e22 + 1), this.emplace(e22, t22);
        }
        emplace(t22, e22) {
          return this.float32[1 * t22 + 0] = e22, t22;
        }
      }
      Oa2.prototype.bytesPerElement = 4, os(Oa2, "StructArrayLayout1f4");
      class Ua2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t22, e22, r22, n22, i2);
        }
        emplace(t22, e22, r22, n22, i2, s2) {
          const a2 = 5 * t22;
          return this.float32[a2 + 0] = e22, this.float32[a2 + 1] = r22, this.float32[a2 + 2] = n22, this.float32[a2 + 3] = i2, this.float32[a2 + 4] = s2, t22;
        }
      }
      Ua2.prototype.bytesPerElement = 20, os(Ua2, "StructArrayLayout5f20");
      class ja2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2, s2, a2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t22, e22, r22, n22, i2, s2, a2);
        }
        emplace(t22, e22, r22, n22, i2, s2, a2, o2) {
          const l22 = 7 * t22;
          return this.float32[l22 + 0] = e22, this.float32[l22 + 1] = r22, this.float32[l22 + 2] = n22, this.float32[l22 + 3] = i2, this.float32[l22 + 4] = s2, this.float32[l22 + 5] = a2, this.float32[l22 + 6] = o2, t22;
        }
      }
      ja2.prototype.bytesPerElement = 28, os(ja2, "StructArrayLayout7f28");
      class Na2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t22, e22, r22, n22);
        }
        emplace(t22, e22, r22, n22, i2) {
          const s2 = 6 * t22;
          return this.uint32[3 * t22 + 0] = e22, this.uint16[s2 + 2] = r22, this.uint16[s2 + 3] = n22, this.uint16[s2 + 4] = i2, t22;
        }
      }
      Na2.prototype.bytesPerElement = 12, os(Na2, "StructArrayLayout1ul3ui12");
      class qa2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t22) {
          const e22 = this.length;
          return this.resize(e22 + 1), this.emplace(e22, t22);
        }
        emplace(t22, e22) {
          return this.uint16[1 * t22 + 0] = e22, t22;
        }
      }
      qa2.prototype.bytesPerElement = 2, os(qa2, "StructArrayLayout1ui2");
      class $a extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22) {
          const r22 = this.length;
          return this.resize(r22 + 1), this.emplace(r22, t22, e22);
        }
        emplace(t22, e22, r22) {
          const n22 = 2 * t22;
          return this.float32[n22 + 0] = e22, this.float32[n22 + 1] = r22, t22;
        }
      }
      $a.prototype.bytesPerElement = 8, os($a, "StructArrayLayout2f8");
      class Ga2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22, f22, d22, m22) {
          const y22 = this.length;
          return this.resize(y22 + 1), this.emplace(y22, t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22, f22, d22, m22);
        }
        emplace(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22, f22, d22, m22, y22) {
          const g22 = 16 * t22;
          return this.float32[g22 + 0] = e22, this.float32[g22 + 1] = r22, this.float32[g22 + 2] = n22, this.float32[g22 + 3] = i2, this.float32[g22 + 4] = s2, this.float32[g22 + 5] = a2, this.float32[g22 + 6] = o2, this.float32[g22 + 7] = l22, this.float32[g22 + 8] = u22, this.float32[g22 + 9] = c22, this.float32[g22 + 10] = h22, this.float32[g22 + 11] = p22, this.float32[g22 + 12] = f22, this.float32[g22 + 13] = d22, this.float32[g22 + 14] = m22, this.float32[g22 + 15] = y22, t22;
        }
      }
      Ga2.prototype.bytesPerElement = 64, os(Ga2, "StructArrayLayout16f64");
      class Xa2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t22, e22, r22, n22, i2, s2, a2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t22, e22, r22, n22, i2, s2, a2);
        }
        emplace(t22, e22, r22, n22, i2, s2, a2, o2) {
          const l22 = 10 * t22, u22 = 5 * t22;
          return this.uint16[l22 + 0] = e22, this.uint16[l22 + 1] = r22, this.uint16[l22 + 2] = n22, this.uint16[l22 + 3] = i2, this.float32[u22 + 2] = s2, this.float32[u22 + 3] = a2, this.float32[u22 + 4] = o2, t22;
        }
      }
      Xa2.prototype.bytesPerElement = 20, os(Xa2, "StructArrayLayout4ui3f20");
      class Ya2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t22) {
          const e22 = this.length;
          return this.resize(e22 + 1), this.emplace(e22, t22);
        }
        emplace(t22, e22) {
          return this.int16[1 * t22 + 0] = e22, t22;
        }
      }
      Ya2.prototype.bytesPerElement = 2, os(Ya2, "StructArrayLayout1i2");
      class Za2 extends ma2 {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
        }
        emplaceBack(t22) {
          const e22 = this.length;
          return this.resize(e22 + 1), this.emplace(e22, t22);
        }
        emplace(t22, e22) {
          return this.uint8[1 * t22 + 0] = e22, t22;
        }
      }
      Za2.prototype.bytesPerElement = 1, os(Za2, "StructArrayLayout1ub1");
      class Wa2 extends da2 {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get tileAnchorY() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get x1() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get y1() {
          return this._structArray.float32[this._pos4 + 4];
        }
        get x2() {
          return this._structArray.float32[this._pos4 + 5];
        }
        get y2() {
          return this._structArray.float32[this._pos4 + 6];
        }
        get padding() {
          return this._structArray.int16[this._pos2 + 14];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 8];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
      }
      Wa2.prototype.size = 40;
      class Ha2 extends Ba2 {
        get(t22) {
          return new Wa2(this, t22);
        }
      }
      os(Ha2, "CollisionBoxArray");
      class Ka2 extends da2 {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 5];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 6];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 7];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 10];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 11];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 48];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 49];
        }
        set placedOrientation(t22) {
          this._structArray.uint8[this._pos1 + 49] = t22;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 50];
        }
        set hidden(t22) {
          this._structArray.uint8[this._pos1 + 50] = t22;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 13];
        }
        set crossTileID(t22) {
          this._structArray.uint32[this._pos4 + 13] = t22;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 28];
        }
        get flipState() {
          return this._structArray.uint8[this._pos1 + 58];
        }
        set flipState(t22) {
          this._structArray.uint8[this._pos1 + 58] = t22;
        }
      }
      Ka2.prototype.size = 60;
      class Ja2 extends La2 {
        get(t22) {
          return new Ka2(this, t22);
        }
      }
      os(Ja2, "PlacedSymbolArray");
      class Qa2 extends da2 {
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 0];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 8];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 9];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 10];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 11];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 12];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 23];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 24];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 25];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 26];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 27];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 14];
        }
        set crossTileID(t22) {
          this._structArray.uint32[this._pos4 + 14] = t22;
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 15];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 16];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 17];
        }
        get zOffset() {
          return this._structArray.float32[this._pos4 + 18];
        }
        set zOffset(t22) {
          this._structArray.float32[this._pos4 + 18] = t22;
        }
        get hasIconTextFit() {
          return this._structArray.uint8[this._pos1 + 76];
        }
      }
      Qa2.prototype.size = 80;
      class to extends Fa2 {
        get(t22) {
          return new Qa2(this, t22);
        }
      }
      os(to, "SymbolInstanceArray");
      class eo extends Oa2 {
        getoffsetX(t22) {
          return this.float32[1 * t22 + 0];
        }
      }
      os(eo, "GlyphOffsetArray");
      class ro extends xa {
        getx(t22) {
          return this.int16[2 * t22 + 0];
        }
        gety(t22) {
          return this.int16[2 * t22 + 1];
        }
      }
      os(ro, "SymbolLineVertexArray");
      class no extends da2 {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get layoutVertexArrayOffset() {
          return this._structArray.uint16[this._pos2 + 4];
        }
      }
      no.prototype.size = 12;
      class io extends Na2 {
        get(t22) {
          return new no(this, t22);
        }
      }
      os(io, "FeatureIndexArray");
      class so extends Ea2 {
        geta_centroid_pos0(t22) {
          return this.uint16[2 * t22 + 0];
        }
        geta_centroid_pos1(t22) {
          return this.uint16[2 * t22 + 1];
        }
      }
      os(so, "FillExtrusionCentroidArray");
      class ao extends da2 {
        get a_join_normal_inside0() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get a_join_normal_inside1() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get a_join_normal_inside2() {
          return this._structArray.int16[this._pos2 + 2];
        }
      }
      ao.prototype.size = 6;
      class oo extends ba {
        get(t22) {
          return new ao(this, t22);
        }
      }
      os(oo, "FillExtrusionWallArray");
      const lo = ya2([{ name: "a_pos", components: 2, type: "Int16" }], 4), uo = ya2([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
      class co {
        constructor(t22 = []) {
          this.segments = t22;
        }
        _prepareSegment(t22, e22, r22, n22) {
          let i2 = this.segments[this.segments.length - 1];
          return t22 > co.MAX_VERTEX_ARRAY_LENGTH && ft("Max vertices per segment is ".concat(co.MAX_VERTEX_ARRAY_LENGTH, ": bucket requested ").concat(t22)), (!i2 || i2.vertexLength + t22 > co.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n22) && (i2 = { vertexOffset: e22, primitiveOffset: r22, vertexLength: 0, primitiveLength: 0 }, void 0 !== n22 && (i2.sortKey = n22), this.segments.push(i2)), i2;
        }
        prepareSegment(t22, e22, r22, n22) {
          return this._prepareSegment(t22, e22.length, r22.length, n22);
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t22 of this.segments)
            for (const e22 in t22.vaos)
              t22.vaos[e22].destroy();
        }
        static simpleSegment(t22, e22, r22, n22) {
          return new co([{ vertexOffset: t22, primitiveOffset: e22, vertexLength: r22, primitiveLength: n22, vaos: {}, sortKey: 0 }]);
        }
      }
      function ho(t22, e22) {
        return 256 * (t22 = Q2(Math.floor(t22), 0, 255)) + Q2(Math.floor(e22), 0, 255);
      }
      co.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, os(co, "SegmentVector");
      const po = ya2([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), fo = ya2([{ name: "a_dash", components: 4, type: "Uint16" }]);
      class mo {
        constructor() {
          this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = false;
        }
        add(t22, e22, r22, n22) {
          this.ids.push(yo(t22)), this.positions.push(e22, r22, n22);
        }
        eachPosition(t22, e22) {
          const r22 = yo(t22);
          let n22 = 0, i2 = this.ids.length - 1;
          for (; n22 < i2; ) {
            const t3 = n22 + i2 >> 1;
            this.ids[t3] >= r22 ? i2 = t3 : n22 = t3 + 1;
          }
          for (; this.ids[n22] === r22; )
            e22(this.positions[3 * n22], this.positions[3 * n22 + 1], this.positions[3 * n22 + 2]), n22++;
        }
        static serialize(t22, e22) {
          const r22 = new Float64Array(t22.ids), n22 = new Uint32Array(t22.positions);
          return go(r22, n22, 0, r22.length - 1), e22 && (e22.add(r22.buffer), e22.add(n22.buffer)), { ids: r22, positions: n22 };
        }
        static deserialize(t22) {
          const e22 = new mo();
          let r22;
          e22.ids = t22.ids, e22.positions = t22.positions;
          for (const t3 of e22.ids)
            t3 !== r22 && e22.uniqueIds.push(t3), r22 = t3;
          return e22.indexed = true, e22;
        }
      }
      function yo(t22) {
        const e22 = +t22;
        return !isNaN(e22) && Number.MIN_SAFE_INTEGER <= e22 && e22 <= Number.MAX_SAFE_INTEGER ? e22 : xe(String(t22));
      }
      function go(t22, e22, r22, n22) {
        for (; r22 < n22; ) {
          const i2 = t22[r22 + n22 >> 1];
          let s2 = r22 - 1, a2 = n22 + 1;
          for (; ; ) {
            do {
              s2++;
            } while (t22[s2] < i2);
            do {
              a2--;
            } while (t22[a2] > i2);
            if (s2 >= a2)
              break;
            xo(t22, s2, a2), xo(e22, 3 * s2, 3 * a2), xo(e22, 3 * s2 + 1, 3 * a2 + 1), xo(e22, 3 * s2 + 2, 3 * a2 + 2);
          }
          a2 - r22 < n22 - a2 ? (go(t22, e22, r22, a2), r22 = a2 + 1) : (go(t22, e22, a2 + 1, n22), n22 = a2);
        }
      }
      function xo(t22, e22, r22) {
        const n22 = t22[e22];
        t22[e22] = t22[r22], t22[r22] = n22;
      }
      os(mo, "FeaturePositionMap");
      class bo {
        constructor(t22) {
          this.gl = t22.gl, this.initialized = false;
        }
        fetchUniformLocation(t22, e22) {
          return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t22, e22), this.initialized = true), !!this.location;
        }
        set(t22, e22, r22) {
          throw new Error("Uniform#set() must be implemented by each concrete Uniform");
        }
      }
      class vo extends bo {
        constructor(t22) {
          super(t22), this.current = 0;
        }
        set(t22, e22, r22) {
          this.fetchUniformLocation(t22, e22) && this.current !== r22 && (this.current = r22, this.gl.uniform1i(this.location, r22));
        }
      }
      class wo extends bo {
        constructor(t22) {
          super(t22), this.current = 0;
        }
        set(t22, e22, r22) {
          this.fetchUniformLocation(t22, e22) && this.current !== r22 && (this.current = r22, this.gl.uniform1f(this.location, r22));
        }
      }
      class _o extends bo {
        constructor(t22) {
          super(t22), this.current = [0, 0];
        }
        set(t22, e22, r22) {
          this.fetchUniformLocation(t22, e22) && (r22[0] === this.current[0] && r22[1] === this.current[1] || (this.current = r22, this.gl.uniform2f(this.location, r22[0], r22[1])));
        }
      }
      class Mo extends bo {
        constructor(t22) {
          super(t22), this.current = [0, 0, 0];
        }
        set(t22, e22, r22) {
          this.fetchUniformLocation(t22, e22) && (r22[0] === this.current[0] && r22[1] === this.current[1] && r22[2] === this.current[2] || (this.current = r22, this.gl.uniform3f(this.location, r22[0], r22[1], r22[2])));
        }
      }
      class Ao extends bo {
        constructor(t22) {
          super(t22), this.current = [0, 0, 0, 0];
        }
        set(t22, e22, r22) {
          this.fetchUniformLocation(t22, e22) && (r22[0] === this.current[0] && r22[1] === this.current[1] && r22[2] === this.current[2] && r22[3] === this.current[3] || (this.current = r22, this.gl.uniform4f(this.location, r22[0], r22[1], r22[2], r22[3])));
        }
      }
      class So extends bo {
        constructor(t22) {
          super(t22), this.current = Pe2.transparent.toRenderColor(null);
        }
        set(t22, e22, r22) {
          this.fetchUniformLocation(t22, e22) && (r22.r === this.current.r && r22.g === this.current.g && r22.b === this.current.b && r22.a === this.current.a || (this.current = r22, this.gl.uniform4f(this.location, r22.r, r22.g, r22.b, r22.a)));
        }
      }
      const Io = new Float32Array(16);
      class Po extends bo {
        constructor(t22) {
          super(t22), this.current = Io;
        }
        set(t22, e22, r22) {
          if (this.fetchUniformLocation(t22, e22)) {
            if (r22[12] !== this.current[12] || r22[0] !== this.current[0])
              return this.current = r22, void this.gl.uniformMatrix4fv(this.location, false, r22);
            for (let t3 = 1; t3 < 16; t3++)
              if (r22[t3] !== this.current[t3]) {
                this.current = r22, this.gl.uniformMatrix4fv(this.location, false, r22);
                break;
              }
          }
        }
      }
      const zo = new Float32Array(9), ko = new Float32Array(4);
      class To extends bo {
        constructor(t22) {
          super(t22), this.current = ko;
        }
        set(t22, e22, r22) {
          if (this.fetchUniformLocation(t22, e22)) {
            for (let t3 = 0; t3 < 4; t3++)
              if (r22[t3] !== this.current[t3]) {
                this.current = r22, this.gl.uniformMatrix2fv(this.location, false, r22);
                break;
              }
          }
        }
      }
      function Eo(t22) {
        return [ho(255 * t22.r, 255 * t22.g), ho(255 * t22.b, 255 * t22.a)];
      }
      class Bo {
        constructor(t22, e22, r22, n22) {
          this.value = t22, this.uniformNames = e22.map((t3) => "u_".concat(t3)), this.type = r22, this.context = n22;
        }
        setUniform(t22, e22, r22, n22, i2) {
          const s2 = n22.constantOr(this.value);
          e22.set(t22, i2, s2 instanceof Pe2 ? s2.toRenderColor(this.context.lut) : s2);
        }
        getBinding(t22, e22) {
          return "color" === this.type ? new So(t22) : new wo(t22);
        }
      }
      class Vo {
        constructor(t22, e22) {
          this.uniformNames = e22.map((t3) => "u_".concat(t3)), this.pattern = null, this.pixelRatio = 1;
        }
        setConstantPatternPositions(t22) {
          this.pixelRatio = t22.pixelRatio || 1, this.pattern = t22.tl.concat(t22.br);
        }
        setUniform(t22, e22, r22, n22, i2) {
          const s2 = "u_pattern" === i2 || "u_dash" === i2 ? this.pattern : "u_pixel_ratio" === i2 ? this.pixelRatio : null;
          s2 && e22.set(t22, i2, s2);
        }
        getBinding(t22, e22) {
          return "u_pattern" === e22 || "u_dash" === e22 ? new Ao(t22) : new wo(t22);
        }
      }
      class Co {
        constructor(t22, e22, r22, n22) {
          this.expression = t22, this.type = r22, this.maxValue = 0, this.paintVertexAttributes = e22.map((t3) => ({ name: "a_".concat(t3), type: "Float32", components: "color" === r22 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n22();
        }
        populatePaintArray(t22, e22, r22, n22, i2, s2, a2) {
          const o2 = this.paintVertexArray.length, l22 = this.expression.evaluate(new Vs(0, { brightness: s2 }), e22, {}, i2, n22, a2);
          this.paintVertexArray.resize(t22), this._setPaintValue(o2, t22, l22, this.context);
        }
        updatePaintArray(t22, e22, r22, n22, i2, s2, a2) {
          const o2 = this.expression.evaluate({ zoom: 0, brightness: a2 }, r22, n22, void 0, i2);
          this._setPaintValue(t22, e22, o2, this.context);
        }
        _setPaintValue(t22, e22, r22, n22) {
          if ("color" === this.type) {
            const i2 = Eo(r22.toRenderColor(n22.lut));
            for (let r3 = t22; r3 < e22; r3++)
              this.paintVertexArray.emplace(r3, i2[0], i2[1]);
          } else {
            for (let n3 = t22; n3 < e22; n3++)
              this.paintVertexArray.emplace(n3, r22);
            this.maxValue = Math.max(this.maxValue, Math.abs(r22));
          }
        }
        upload(t22) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t22.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class Ro {
        constructor(t22, e22, r22, n22, i2, s2) {
          this.expression = t22, this.uniformNames = e22.map((t3) => "u_".concat(t3, "_t")), this.type = r22, this.useIntegerZoom = n22, this.context = i2, this.maxValue = 0, this.paintVertexAttributes = e22.map((t3) => ({ name: "a_".concat(t3), type: "Float32", components: "color" === r22 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
        }
        populatePaintArray(t22, e22, r22, n22, i2, s2, a2) {
          const o2 = this.expression.evaluate(new Vs(this.context.zoom, { brightness: s2 }), e22, {}, i2, n22, a2), l22 = this.expression.evaluate(new Vs(this.context.zoom + 1, { brightness: s2 }), e22, {}, i2, n22, a2), u22 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t22), this._setPaintValue(u22, t22, o2, l22, this.context);
        }
        updatePaintArray(t22, e22, r22, n22, i2, s2, a2) {
          const o2 = this.expression.evaluate({ zoom: this.context.zoom, brightness: a2 }, r22, n22, void 0, i2), l22 = this.expression.evaluate({ zoom: this.context.zoom + 1, brightness: a2 }, r22, n22, void 0, i2);
          this._setPaintValue(t22, e22, o2, l22, this.context);
        }
        _setPaintValue(t22, e22, r22, n22, i2) {
          if ("color" === this.type) {
            const n3 = Eo(r22.toRenderColor(i2.lut)), s2 = Eo(r22.toRenderColor(i2.lut));
            for (let r3 = t22; r3 < e22; r3++)
              this.paintVertexArray.emplace(r3, n3[0], n3[1], s2[0], s2[1]);
          } else {
            for (let i3 = t22; i3 < e22; i3++)
              this.paintVertexArray.emplace(i3, r22, n22);
            this.maxValue = Math.max(this.maxValue, Math.abs(r22), Math.abs(n22));
          }
        }
        upload(t22) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t22.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t22, e22, r22, n22, i2) {
          const s2 = this.useIntegerZoom ? Math.floor(r22.zoom) : r22.zoom, a2 = Q2(this.expression.interpolationFactor(s2, this.context.zoom, this.context.zoom + 1), 0, 1);
          e22.set(t22, i2, a2);
        }
        getBinding(t22, e22) {
          return new wo(t22);
        }
      }
      class Do {
        constructor(t22, e22, r22, n22, i2) {
          this.expression = t22, this.layerId = i2, this.paintVertexAttributes = ("array" === r22 ? fo : po).members;
          for (let t3 = 0; t3 < e22.length; ++t3)
            ;
          this.paintVertexArray = new n22();
        }
        populatePaintArray(t22, e22, r22, n22) {
          const i2 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t22), this._setPaintValues(i2, t22, e22.patterns && e22.patterns[this.layerId], r22);
        }
        updatePaintArray(t22, e22, r22, n22, i2, s2, a2) {
          this._setPaintValues(t22, e22, r22.patterns && r22.patterns[this.layerId], s2);
        }
        _setPaintValues(t22, e22, r22, n22) {
          if (!n22 || !r22)
            return;
          const i2 = n22[r22];
          if (!i2)
            return;
          const { tl: s2, br: a2, pixelRatio: o2 } = i2;
          for (let r3 = t22; r3 < e22; r3++)
            this.paintVertexArray.emplace(r3, s2[0], s2[1], a2[0], a2[1], o2);
        }
        upload(t22) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t22.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class Lo {
        constructor(t22, e22, r22 = () => true) {
          this.binders = {}, this._buffers = [], this.context = e22;
          const n22 = [];
          for (const i2 in t22.paint._values) {
            const s2 = t22.paint.get(i2);
            if (!r22(i2))
              continue;
            if (!(s2 instanceof Us && Di2(s2.property.specification)))
              continue;
            const a2 = Uo(i2, t22.type), o2 = s2.value, l22 = s2.property.specification.type, u22 = !!s2.property.useIntegerZoom, c22 = "line-dasharray" === i2 || i2.endsWith("pattern"), h22 = "line-dasharray" === i2 && "constant" !== t22.layout.get("line-cap").value.kind;
            if ("constant" !== o2.kind || h22)
              if ("source" === o2.kind || h22 || c22) {
                const e3 = qo(i2, l22, "source");
                this.binders[i2] = c22 ? new Do(o2, a2, l22, e3, t22.id) : new Co(o2, a2, l22, e3), n22.push("/a_".concat(i2));
              } else {
                const t3 = qo(i2, l22, "composite");
                this.binders[i2] = new Ro(o2, a2, l22, u22, e22, t3), n22.push("/z_".concat(i2));
              }
            else
              this.binders[i2] = c22 ? new Vo(o2.value, a2) : new Bo(o2.value, a2, l22, e22), n22.push("/u_".concat(i2));
          }
          this.cacheKey = n22.sort().join("");
        }
        getMaxValue(t22) {
          const e22 = this.binders[t22];
          return e22 instanceof Co || e22 instanceof Ro ? e22.maxValue : 0;
        }
        populatePaintArrays(t22, e22, r22, n22, i2, s2, a2) {
          for (const o2 in this.binders) {
            const l22 = this.binders[o2];
            l22.context = this.context, (l22 instanceof Co || l22 instanceof Ro || l22 instanceof Do) && l22.populatePaintArray(t22, e22, r22, n22, i2, s2, a2);
          }
        }
        setConstantPatternPositions(t22) {
          for (const e22 in this.binders) {
            const r22 = this.binders[e22];
            r22 instanceof Vo && r22.setConstantPatternPositions(t22);
          }
        }
        updatePaintArrays(t22, e22, r22, n22, i2, s2, a2, o2) {
          let l22 = false;
          const u22 = Object.keys(t22), c22 = 0 !== u22.length, h22 = c22 ? u22 : e22.uniqueIds;
          this.context.lut = i2.lut;
          for (const u3 in this.binders) {
            const p22 = this.binders[u3];
            if (p22.context = this.context, (p22 instanceof Co || p22 instanceof Ro || p22 instanceof Do) && (true === p22.expression.isStateDependent || false === p22.expression.isLightConstant)) {
              const f22 = i2.paint.get(u3);
              p22.expression = f22.value;
              for (const r3 of h22) {
                const i3 = t22[r3.toString()];
                e22.eachPosition(r3, (t3, e3, r4) => {
                  const l3 = n22.feature(t3);
                  p22.updatePaintArray(e3, r4, l3, i3, s2, a2, o2);
                });
              }
              if (!c22)
                for (const e3 of r22.uniqueIds) {
                  const i3 = t22[e3.toString()];
                  r22.eachPosition(e3, (t3, e4, r3) => {
                    const l3 = n22.feature(t3);
                    p22.updatePaintArray(e4, r3, l3, i3, s2, a2, o2);
                  });
                }
              l22 = true;
            }
          }
          return l22;
        }
        defines() {
          const t22 = [];
          for (const e22 in this.binders) {
            const r22 = this.binders[e22];
            (r22 instanceof Bo || r22 instanceof Vo) && t22.push(...r22.uniformNames.map((t3) => "#define HAS_UNIFORM_".concat(t3)));
          }
          return t22;
        }
        getBinderAttributes() {
          const t22 = [];
          for (const e22 in this.binders) {
            const r22 = this.binders[e22];
            if (r22 instanceof Co || r22 instanceof Ro || r22 instanceof Do)
              for (let e3 = 0; e3 < r22.paintVertexAttributes.length; e3++)
                t22.push(r22.paintVertexAttributes[e3].name);
          }
          return t22;
        }
        getBinderUniforms() {
          const t22 = [];
          for (const e22 in this.binders) {
            const r22 = this.binders[e22];
            if (r22 instanceof Bo || r22 instanceof Vo || r22 instanceof Ro)
              for (const e3 of r22.uniformNames)
                t22.push(e3);
          }
          return t22;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t22) {
          const e22 = [];
          for (const r22 in this.binders) {
            const n22 = this.binders[r22];
            if (n22 instanceof Bo || n22 instanceof Vo || n22 instanceof Ro)
              for (const i2 of n22.uniformNames)
                e22.push({ name: i2, property: r22, binding: n22.getBinding(t22, i2) });
          }
          return e22;
        }
        setUniforms(t22, e22, r22, n22, i2) {
          for (const { name: e3, property: s2, binding: a2 } of r22)
            this.binders[s2].setUniform(t22, a2, i2, n22.get(s2), e3);
        }
        updatePaintBuffers() {
          this._buffers = [];
          for (const t22 in this.binders) {
            const e22 = this.binders[t22];
            (e22 instanceof Co || e22 instanceof Ro || e22 instanceof Do) && e22.paintVertexBuffer && this._buffers.push(e22.paintVertexBuffer);
          }
        }
        upload(t22) {
          for (const e22 in this.binders) {
            const r22 = this.binders[e22];
            (r22 instanceof Co || r22 instanceof Ro || r22 instanceof Do) && r22.upload(t22);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t22 in this.binders) {
            const e22 = this.binders[t22];
            (e22 instanceof Co || e22 instanceof Ro || e22 instanceof Do) && e22.destroy();
          }
        }
      }
      class Fo {
        constructor(t22, e22, r22 = () => true) {
          this.programConfigurations = {};
          for (const n22 of t22)
            this.programConfigurations[n22.id] = new Lo(n22, e22, r22);
          this.needsUpload = false, this._featureMap = new mo(), this._featureMapWithoutIds = new mo(), this._bufferOffset = 0, this._idlessCounter = 0;
        }
        populatePaintArrays(t22, e22, r22, n22, i2, s2, a2, o2) {
          for (const r3 in this.programConfigurations)
            this.programConfigurations[r3].populatePaintArrays(t22, e22, n22, i2, s2, a2, o2);
          void 0 !== e22.id ? this._featureMap.add(e22.id, r22, this._bufferOffset, t22) : (this._featureMapWithoutIds.add(this._idlessCounter, r22, this._bufferOffset, t22), this._idlessCounter += 1), this._bufferOffset = t22, this.needsUpload = true;
        }
        updatePaintArrays(t22, e22, r22, n22, i2, s2) {
          for (const a2 of r22)
            this.needsUpload = this.programConfigurations[a2.id].updatePaintArrays(t22, this._featureMap, this._featureMapWithoutIds, e22, a2, n22, i2, s2 || 0) || this.needsUpload;
        }
        get(t22) {
          return this.programConfigurations[t22];
        }
        upload(t22) {
          if (this.needsUpload) {
            for (const e22 in this.programConfigurations)
              this.programConfigurations[e22].upload(t22);
            this.needsUpload = false;
          }
        }
        destroy() {
          for (const t22 in this.programConfigurations)
            this.programConfigurations[t22].destroy();
        }
      }
      const Oo = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-occlusion-opacity": ["occlusion_opacity"], "icon-occlusion-opacity": ["occlusion_opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-emissive-strength": ["emissive_strength"], "icon-emissive-strength": ["emissive_strength"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "symbol-z-offset": ["z_offset"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
      function Uo(t22, e22) {
        return Oo[t22] || [t22.replace("".concat(e22, "-"), "").replace(/-/g, "_")];
      }
      const jo = { "line-pattern": { source: Sa2, composite: Sa2 }, "fill-pattern": { source: Sa2, composite: Sa2 }, "fill-extrusion-pattern": { source: Sa2, composite: Sa2 }, "line-dasharray": { source: Ia2, composite: Ia2 } }, No = { color: { source: $a, composite: Ma2 }, number: { source: Oa2, composite: $a } };
      function qo(t22, e22, r22) {
        const n22 = jo[t22];
        return n22 && n22[r22] || No[e22][r22];
      }
      os(Bo, "ConstantBinder"), os(Vo, "PatternConstantBinder"), os(Co, "SourceExpressionBinder"), os(Do, "PatternCompositeBinder"), os(Ro, "CompositeExpressionBinder"), os(Lo, "ProgramConfiguration", { omit: ["_buffers"] }), os(Fo, "ProgramConfigurationSet");
      const $o = Hr / Math.PI / 2, Go = 5, Xo = 6, Yo = 16383, Zo = 64, Wo = [Zo, 32, 16], Ho = -$o, Ko = $o;
      function Jo(t22, e22, r22, n22 = $o) {
        return r22 = Y2(r22), [t22 * Math.sin(r22) * n22, -e22 * n22, t22 * Math.cos(r22) * n22];
      }
      function Qo(t22, e22, r22) {
        return Jo(Math.cos(Y2(t22)), Math.sin(Y2(t22)), e22, r22);
      }
      const tl2 = 63710088e-1, el2 = 2 * Math.PI * tl2;
      class rl2 {
        constructor(t22, e22) {
          if (isNaN(t22) || isNaN(e22))
            throw new Error("Invalid LngLat object: (".concat(t22, ", ").concat(e22, ")"));
          if (this.lng = +t22, this.lat = +e22, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new rl2(et(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return "LngLat(".concat(this.lng, ", ").concat(this.lat, ")");
        }
        distanceTo(t22) {
          const e22 = Math.PI / 180, r22 = this.lat * e22, n22 = t22.lat * e22, i2 = Math.sin(r22) * Math.sin(n22) + Math.cos(r22) * Math.cos(n22) * Math.cos((t22.lng - this.lng) * e22);
          return tl2 * Math.acos(Math.min(i2, 1));
        }
        toBounds(t22 = 0) {
          const e22 = 360 * t22 / 40075017, r22 = e22 / Math.cos(Math.PI / 180 * this.lat);
          return new nl2({ lng: this.lng - r22, lat: this.lat - e22 }, { lng: this.lng + r22, lat: this.lat + e22 });
        }
        toEcef(t22) {
          return Qo(this.lat, this.lng, $o + t22 * $o / tl2);
        }
        static convert(t22) {
          if (t22 instanceof rl2)
            return t22;
          if (Array.isArray(t22) && (2 === t22.length || 3 === t22.length))
            return new rl2(Number(t22[0]), Number(t22[1]));
          if (!Array.isArray(t22) && "object" == typeof t22 && null !== t22)
            return new rl2(Number("lng" in t22 ? t22.lng : t22.lon), Number(t22.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      class nl2 {
        constructor(t22, e22) {
          if (t22)
            if (e22)
              this.setSouthWest(t22).setNorthEast(e22);
            else if (4 === t22.length) {
              const e3 = t22;
              this.setSouthWest([e3[0], e3[1]]).setNorthEast([e3[2], e3[3]]);
            } else {
              const e3 = t22;
              this.setSouthWest(e3[0]).setNorthEast(e3[1]);
            }
        }
        setNorthEast(t22) {
          return this._ne = t22 instanceof rl2 ? new rl2(t22.lng, t22.lat) : rl2.convert(t22), this;
        }
        setSouthWest(t22) {
          return this._sw = t22 instanceof rl2 ? new rl2(t22.lng, t22.lat) : rl2.convert(t22), this;
        }
        extend(t22) {
          const e22 = this._sw, r22 = this._ne;
          let n22, i2;
          if (t22 instanceof rl2)
            n22 = t22, i2 = t22;
          else {
            if (!(t22 instanceof nl2))
              return Array.isArray(t22) ? 4 === t22.length || t22.every(Array.isArray) ? this.extend(nl2.convert(t22)) : this.extend(rl2.convert(t22)) : "object" == typeof t22 && null !== t22 && t22.hasOwnProperty("lat") && (t22.hasOwnProperty("lon") || t22.hasOwnProperty("lng")) ? this.extend(rl2.convert(t22)) : this;
            if (n22 = t22._sw, i2 = t22._ne, !n22 || !i2)
              return this;
          }
          return e22 || r22 ? (e22.lng = Math.min(n22.lng, e22.lng), e22.lat = Math.min(n22.lat, e22.lat), r22.lng = Math.max(i2.lng, r22.lng), r22.lat = Math.max(i2.lat, r22.lat)) : (this._sw = new rl2(n22.lng, n22.lat), this._ne = new rl2(i2.lng, i2.lat)), this;
        }
        getCenter() {
          return new rl2((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new rl2(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new rl2(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return "LngLatBounds(".concat(this._sw.toString(), ", ").concat(this._ne.toString(), ")");
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(t22) {
          const { lng: e22, lat: r22 } = rl2.convert(t22);
          let n22 = this._sw.lng <= e22 && e22 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (n22 = this._sw.lng >= e22 && e22 >= this._ne.lng), this._sw.lat <= r22 && r22 <= this._ne.lat && n22;
        }
        static convert(t22) {
          if (t22)
            return t22 instanceof nl2 ? t22 : new nl2(t22);
        }
      }
      const il2 = 0, sl2 = 25.5;
      function al2(t22) {
        return el2 * Math.cos(t22 * Math.PI / 180);
      }
      function ol2(t22) {
        return (180 + t22) / 360;
      }
      function ll2(t22) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t22 * Math.PI / 360))) / 360;
      }
      function ul2(t22, e22) {
        return t22 / al2(e22);
      }
      function cl2(t22) {
        return 360 * t22 - 180;
      }
      function hl2(t22) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t22) * Math.PI / 180)) - 90;
      }
      function pl2(t22, e22) {
        return t22 * al2(hl2(e22));
      }
      const fl2 = 85.051129;
      function dl2(t22) {
        return Math.cos(Y2(Q2(t22, -fl2, fl2)));
      }
      function ml2(t22, e22) {
        const r22 = Q2(e22, il2, sl2), n22 = Math.pow(2, r22);
        return dl2(t22) * el2 / (512 * n22);
      }
      function yl(t22) {
        return 1 / Math.cos(t22 * Math.PI / 180);
      }
      function gl2(t22, e22 = 0) {
        const r22 = Math.exp(Math.PI * (1 - (t22.y + e22 / Hr) / (1 << t22.z) * 2));
        return 80150034 * r22 / (r22 * r22 + 1) / Hr / (1 << t22.z);
      }
      class xl {
        constructor(t22, e22, r22 = 0) {
          this.x = +t22, this.y = +e22, this.z = +r22;
        }
        static fromLngLat(t22, e22 = 0) {
          const r22 = rl2.convert(t22);
          return new xl(ol2(r22.lng), ll2(r22.lat), ul2(e22, r22.lat));
        }
        toLngLat() {
          return new rl2(cl2(this.x), hl2(this.y));
        }
        toAltitude() {
          return pl2(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return 1 / el2 * yl(hl2(this.y));
        }
      }
      function bl2(t22, e22, r22, n22, i2, s2, a2, o2, l22) {
        const u22 = (e22 + n22) / 2, c22 = (r22 + i2) / 2, h22 = new q2(u22, c22);
        o2(h22), function(t3, e3, r3, n3, i3, s3) {
          const a3 = r3 - i3, o3 = n3 - s3;
          return Math.abs((n3 - e3) * a3 - (r3 - t3) * o3) / Math.hypot(a3, o3);
        }(h22.x, h22.y, s2.x, s2.y, a2.x, a2.y) >= l22 ? (bl2(t22, e22, r22, u22, c22, s2, h22, o2, l22), bl2(t22, u22, c22, n22, i2, h22, a2, o2, l22)) : t22.push(a2);
      }
      function vl(t22, e22, r22) {
        let n22 = t22[0], i2 = n22.x, s2 = n22.y;
        e22(n22);
        const a2 = [n22];
        for (let o2 = 1; o2 < t22.length; o2++) {
          const l22 = t22[o2], { x: u22, y: c22 } = l22;
          e22(l22), bl2(a2, i2, s2, u22, c22, n22, l22, e22, r22), i2 = u22, s2 = c22, n22 = l22;
        }
        return a2;
      }
      function wl(t22, e22, r22, n22) {
        if (n22(e22, r22)) {
          const i2 = e22.add(r22)._mult(0.5);
          wl(t22, e22, i2, n22), wl(t22, i2, r22, n22);
        } else
          t22.push(r22);
      }
      function _l(t22, e22) {
        let r22 = t22[0];
        const n22 = [r22];
        for (let i2 = 1; i2 < t22.length; i2++) {
          const s2 = t22[i2];
          wl(n22, r22, s2, e22), r22 = s2;
        }
        return n22;
      }
      const Ml = Math.pow(2, 14) - 1, Al = -Ml - 1;
      function Sl(t22, e22) {
        const r22 = Math.round(t22.x * e22), n22 = Math.round(t22.y * e22);
        return t22.x = Q2(r22, Al, Ml), t22.y = Q2(n22, Al, Ml), (r22 < t22.x || r22 > t22.x + 1 || n22 < t22.y || n22 > t22.y + 1) && ft("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t22;
      }
      function Il(t22, e22, r22) {
        const n22 = t22.loadGeometry(), i2 = t22.extent, s2 = Hr / i2;
        if (e22 && r22 && r22.projection.isReprojectedInTileSpace) {
          const s3 = 1 << e22.z, { scale: a2, x: o2, y: l22, projection: u22 } = r22, c22 = (t3) => {
            const r3 = cl2((e22.x + t3.x / i2) / s3), n3 = hl2((e22.y + t3.y / i2) / s3), c3 = u22.project(r3, n3);
            t3.x = (c3.x * a2 - o2) * i2, t3.y = (c3.y * a2 - l22) * i2;
          };
          for (let e3 = 0; e3 < n22.length; e3++)
            if (1 !== t22.type)
              n22[e3] = vl(n22[e3], c22, 1);
            else {
              const t3 = [];
              for (const r3 of n22[e3])
                r3.x < 0 || r3.x >= i2 || r3.y < 0 || r3.y >= i2 || (c22(r3), t3.push(r3));
              n22[e3] = t3;
            }
        }
        for (const t3 of n22)
          for (const e3 of t3)
            Sl(e3, s2);
        return n22;
      }
      function Pl(t22, e22) {
        return { type: t22.type, id: t22.id, properties: t22.properties, geometry: e22 ? Il(t22) : [] };
      }
      function zl(t22, e22, r22, n22, i2) {
        t22.emplaceBack(2 * e22 + (n22 + 1) / 2, 2 * r22 + (i2 + 1) / 2);
      }
      function kl2(t22, e22, r22) {
        const n22 = 16384;
        t22.emplaceBack(e22.x, e22.y, e22.z, r22[0] * n22, r22[1] * n22, r22[2] * n22);
      }
      class Tl {
        constructor(t22) {
          this.zoom = t22.zoom, this.overscaling = t22.overscaling, this.layers = t22.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t22.index, this.hasPattern = false, this.projection = t22.projection, this.layoutVertexArray = new xa(), this.indexArray = new Da2(), this.segments = new co(), this.programConfigurations = new Fo(t22.layers, { zoom: t22.zoom, lut: t22.lut }), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        updateFootprints(t22, e22) {
        }
        populate(t22, e22, r22, n22) {
          const i2 = this.layers[0], s2 = [];
          let a2 = null;
          "circle" === i2.type && (a2 = i2.layout.get("circle-sort-key"));
          for (const { feature: e3, id: i3, index: o3, sourceLayerIndex: l22 } of t22) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u22 = Pl(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new Vs(this.zoom), u22, r22))
              continue;
            const c22 = a2 ? a2.evaluate(u22, {}, r22) : void 0, h22 = { id: i3, properties: e3.properties, type: e3.type, sourceLayerIndex: l22, index: o3, geometry: t3 ? u22.geometry : Il(e3, r22, n22), patterns: {}, sortKey: c22 };
            s2.push(h22);
          }
          a2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          let o2 = null;
          "globe" === n22.projection.name && (this.globeExtVertexArray = new Pa2(), o2 = n22.projection);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, l22 = t22[s3].feature;
            this.addFeature(n3, i3, s3, e22.availableImages, r22, o2, e22.brightness), e22.featureIndex.insert(l22, i3, s3, a3, this.index);
          }
        }
        update(t22, e22, r22, n22, i2) {
          const s2 = 0 !== Object.keys(t22).length;
          s2 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t22, e22, s2 ? this.stateDependentLayers : this.layers, r22, n22, i2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t22) {
          this.uploaded || (this.layoutVertexBuffer = t22.createVertexBuffer(this.layoutVertexArray, lo.members), this.indexBuffer = t22.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t22.createVertexBuffer(this.globeExtVertexArray, uo.members))), this.programConfigurations.upload(t22), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
        addFeature(t22, e22, r22, n22, i2, s2, a2) {
          for (const r3 of e22)
            for (const e3 of r3) {
              const r4 = e3.x, n3 = e3.y;
              if (r4 < 0 || r4 >= Hr || n3 < 0 || n3 >= Hr)
                continue;
              if (s2) {
                const t3 = s2.projectTilePoint(r4, n3, i2), e4 = s2.upVector(i2, r4, n3), a4 = this.globeExtVertexArray;
                kl2(a4, t3, e4), kl2(a4, t3, e4), kl2(a4, t3, e4), kl2(a4, t3, e4);
              }
              const a3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t22.sortKey), o2 = a3.vertexLength;
              zl(this.layoutVertexArray, r4, n3, -1, -1), zl(this.layoutVertexArray, r4, n3, 1, -1), zl(this.layoutVertexArray, r4, n3, 1, 1), zl(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(o2, o2 + 1, o2 + 2), this.indexArray.emplaceBack(o2, o2 + 2, o2 + 3), a3.vertexLength += 4, a3.primitiveLength += 2;
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t22, r22, {}, n22, i2, a2);
        }
      }
      function El(t22, e22) {
        for (let r22 = 0; r22 < t22.length; r22++)
          if (Ul(e22, t22[r22]))
            return true;
        for (let r22 = 0; r22 < e22.length; r22++)
          if (Ul(t22, e22[r22]))
            return true;
        return !!Rl(t22, e22);
      }
      function Bl(t22, e22, r22) {
        return !!Ul(t22, e22) || !!Ll(e22, t22, r22);
      }
      function Vl(t22, e22) {
        if (1 === t22.length)
          return Ol(e22, t22[0]);
        for (let r22 = 0; r22 < e22.length; r22++) {
          const n22 = e22[r22];
          for (let e3 = 0; e3 < n22.length; e3++)
            if (Ul(t22, n22[e3]))
              return true;
        }
        for (let r22 = 0; r22 < t22.length; r22++)
          if (Ol(e22, t22[r22]))
            return true;
        for (let r22 = 0; r22 < e22.length; r22++)
          if (Rl(t22, e22[r22]))
            return true;
        return false;
      }
      function Cl(t22, e22, r22) {
        if (t22.length > 1) {
          if (Rl(t22, e22))
            return true;
          for (let n22 = 0; n22 < e22.length; n22++)
            if (Ll(e22[n22], t22, r22))
              return true;
        }
        for (let n22 = 0; n22 < t22.length; n22++)
          if (Ll(t22[n22], e22, r22))
            return true;
        return false;
      }
      function Rl(t22, e22) {
        if (0 === t22.length || 0 === e22.length)
          return false;
        for (let r22 = 0; r22 < t22.length - 1; r22++) {
          const n22 = t22[r22], i2 = t22[r22 + 1];
          for (let t3 = 0; t3 < e22.length - 1; t3++)
            if (Dl(n22, i2, e22[t3], e22[t3 + 1]))
              return true;
        }
        return false;
      }
      function Dl(t22, e22, r22, n22) {
        return dt(t22, r22, n22) !== dt(e22, r22, n22) && dt(t22, e22, r22) !== dt(t22, e22, n22);
      }
      function Ll(t22, e22, r22) {
        const n22 = r22 * r22;
        if (1 === e22.length)
          return t22.distSqr(e22[0]) < n22;
        for (let r3 = 1; r3 < e22.length; r3++)
          if (Fl(t22, e22[r3 - 1], e22[r3]) < n22)
            return true;
        return false;
      }
      function Fl(t22, e22, r22) {
        const n22 = e22.distSqr(r22);
        if (0 === n22)
          return t22.distSqr(e22);
        const i2 = ((t22.x - e22.x) * (r22.x - e22.x) + (t22.y - e22.y) * (r22.y - e22.y)) / n22;
        return t22.distSqr(i2 < 0 ? e22 : i2 > 1 ? r22 : r22.sub(e22)._mult(i2)._add(e22));
      }
      function Ol(t22, e22) {
        let r22, n22, i2, s2 = false;
        for (let a2 = 0; a2 < t22.length; a2++) {
          r22 = t22[a2];
          for (let t3 = 0, a3 = r22.length - 1; t3 < r22.length; a3 = t3++)
            n22 = r22[t3], i2 = r22[a3], n22.y > e22.y != i2.y > e22.y && e22.x < (i2.x - n22.x) * (e22.y - n22.y) / (i2.y - n22.y) + n22.x && (s2 = !s2);
        }
        return s2;
      }
      function Ul(t22, e22) {
        let r22 = false;
        for (let n22 = 0, i2 = t22.length - 1; n22 < t22.length; i2 = n22++) {
          const s2 = t22[n22], a2 = t22[i2];
          s2.y > e22.y != a2.y > e22.y && e22.x < (a2.x - s2.x) * (e22.y - s2.y) / (a2.y - s2.y) + s2.x && (r22 = !r22);
        }
        return r22;
      }
      function jl2(t22, e22, r22, n22, i2) {
        for (const s3 of t22)
          if (e22 <= s3.x && r22 <= s3.y && n22 >= s3.x && i2 >= s3.y)
            return true;
        const s2 = [new q2(e22, r22), new q2(e22, i2), new q2(n22, i2), new q2(n22, r22)];
        if (t22.length > 2) {
          for (const e3 of s2)
            if (Ul(t22, e3))
              return true;
        }
        for (let e3 = 0; e3 < t22.length - 1; e3++)
          if (Nl(t22[e3], t22[e3 + 1], s2))
            return true;
        return false;
      }
      function Nl(t22, e22, r22) {
        const n22 = r22[0], i2 = r22[2];
        if (t22.x < n22.x && e22.x < n22.x || t22.x > i2.x && e22.x > i2.x || t22.y < n22.y && e22.y < n22.y || t22.y > i2.y && e22.y > i2.y)
          return false;
        const s2 = dt(t22, e22, r22[0]);
        return s2 !== dt(t22, e22, r22[1]) || s2 !== dt(t22, e22, r22[2]) || s2 !== dt(t22, e22, r22[3]);
      }
      function ql2(t22, e22, r22, n22, i2, s2) {
        let a2 = e22.y - t22.y, o2 = t22.x - e22.x;
        if (s2 = s2 || 0) {
          const t3 = a2 * a2 + o2 * o2;
          if (0 === t3)
            return true;
          const e3 = Math.sqrt(t3);
          a2 /= e3, o2 /= e3;
        }
        return !((r22.x - t22.x) * a2 + (r22.y - t22.y) * o2 - s2 < 0 || (n22.x - t22.x) * a2 + (n22.y - t22.y) * o2 - s2 < 0 || (i2.x - t22.x) * a2 + (i2.y - t22.y) * o2 - s2 < 0);
      }
      function $l(t22, e22, r22, n22, i2, s2, a2) {
        return !(ql2(t22, e22, n22, i2, s2, a2) || ql2(e22, r22, n22, i2, s2, a2) || ql2(r22, t22, n22, i2, s2, a2) || ql2(n22, i2, t22, e22, r22, a2) || ql2(i2, s2, t22, e22, r22, a2) || ql2(s2, n22, t22, e22, r22, a2));
      }
      function Gl(t22, e22, r22) {
        const n22 = e22.paint.get(t22).value;
        return "constant" === n22.kind ? n22.value : r22.programConfigurations.get(e22.id).getMaxValue(t22);
      }
      function Xl(t22) {
        return Math.sqrt(t22[0] * t22[0] + t22[1] * t22[1]);
      }
      function Yl(t22, e22, r22, n22, i2) {
        if (!e22[0] && !e22[1])
          return t22;
        const s2 = q2.convert(e22)._mult(i2);
        "viewport" === r22 && s2._rotate(-n22);
        const a2 = [];
        for (let e3 = 0; e3 < t22.length; e3++)
          a2.push(t22[e3].sub(s2));
        return a2;
      }
      function Zl(t22, e22, r22, n22) {
        const i2 = q2.convert(t22)._mult(n22);
        return "viewport" === e22 && i2._rotate(-r22), i2;
      }
      let Wl, Hl;
      os(Tl, "CircleBucket", { omit: ["layers"] });
      var Kl, Jl = { exports: {} }, Ql = (Kl || (Kl = 1, function(t22, e22) {
        !function(t3) {
          function e3(t4, e4, n22) {
            var i2 = r22(256 * t4, 256 * (e4 = Math.pow(2, n22) - e4 - 1), n22), s2 = r22(256 * (t4 + 1), 256 * (e4 + 1), n22);
            return i2[0] + "," + i2[1] + "," + s2[0] + "," + s2[1];
          }
          function r22(t4, e4, r3) {
            var n22 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r3);
            return [t4 * n22 - 2 * Math.PI * 6378137 / 2, e4 * n22 - 2 * Math.PI * 6378137 / 2];
          }
          t3.getURL = function(t4, r3, n22, i2, s2, a2) {
            return a2 = a2 || {}, t4 + "?" + ["bbox=" + e3(n22, i2, s2), "format=" + (a2.format || "image/png"), "service=" + (a2.service || "WMS"), "version=" + (a2.version || "1.1.1"), "request=" + (a2.request || "GetMap"), "srs=" + (a2.srs || "EPSG:3857"), "width=" + (a2.width || 256), "height=" + (a2.height || 256), "layers=" + r3].join("&");
          }, t3.getTileBBox = e3, t3.getMercCoords = r22, Object.defineProperty(t3, "__esModule", { value: true });
        }(e22);
      }(0, Jl.exports)), Jl.exports);
      class tu {
        constructor(t22, e22, r22) {
          this.z = t22, this.x = e22, this.y = r22, this.key = nu(0, t22, t22, e22, r22);
        }
        equals(t22) {
          return this.z === t22.z && this.x === t22.x && this.y === t22.y;
        }
        url(t22, e22) {
          const r22 = Ql.getTileBBox(this.x, this.y, this.z), n22 = function(t3, e3, r3) {
            let n3, i2 = "";
            for (let s2 = t3; s2 > 0; s2--)
              n3 = 1 << s2 - 1, i2 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
            return i2;
          }(this.z, this.x, this.y);
          return t22[(this.x + this.y) % t22.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e22 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n22).replace("{bbox-epsg-3857}", r22);
        }
        toString() {
          return "".concat(this.z, "/").concat(this.x, "/").concat(this.y);
        }
      }
      class eu {
        constructor(t22, e22) {
          this.wrap = t22, this.canonical = e22, this.key = nu(t22, e22.z, e22.z, e22.x, e22.y);
        }
      }
      class ru {
        constructor(t22, e22, r22, n22, i2) {
          this.overscaledZ = t22, this.wrap = e22, this.canonical = new tu(r22, +n22, +i2), this.key = 0 === e22 && t22 === r22 ? this.canonical.key : nu(e22, t22, r22, n22, i2);
        }
        equals(t22) {
          return this.overscaledZ === t22.overscaledZ && this.wrap === t22.wrap && this.canonical.equals(t22.canonical);
        }
        scaledTo(t22) {
          const e22 = this.canonical.z - t22;
          return t22 > this.canonical.z ? new ru(t22, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new ru(t22, this.wrap, t22, this.canonical.x >> e22, this.canonical.y >> e22);
        }
        calculateScaledKey(t22, e22 = true) {
          if (this.overscaledZ === t22 && e22)
            return this.key;
          if (t22 > this.canonical.z)
            return nu(this.wrap * +e22, t22, this.canonical.z, this.canonical.x, this.canonical.y);
          {
            const r22 = this.canonical.z - t22;
            return nu(this.wrap * +e22, t22, t22, this.canonical.x >> r22, this.canonical.y >> r22);
          }
        }
        isChildOf(t22) {
          if (t22.wrap !== this.wrap)
            return false;
          const e22 = this.canonical.z - t22.canonical.z;
          return 0 === t22.overscaledZ || t22.overscaledZ < this.overscaledZ && t22.canonical.z < this.canonical.z && t22.canonical.x === this.canonical.x >> e22 && t22.canonical.y === this.canonical.y >> e22;
        }
        children(t22) {
          if (this.overscaledZ >= t22)
            return [new ru(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const e22 = this.canonical.z + 1, r22 = 2 * this.canonical.x, n22 = 2 * this.canonical.y;
          return [new ru(e22, this.wrap, e22, r22, n22), new ru(e22, this.wrap, e22, r22 + 1, n22), new ru(e22, this.wrap, e22, r22, n22 + 1), new ru(e22, this.wrap, e22, r22 + 1, n22 + 1)];
        }
        isLessThan(t22) {
          return this.wrap < t22.wrap || !(this.wrap > t22.wrap) && (this.overscaledZ < t22.overscaledZ || !(this.overscaledZ > t22.overscaledZ) && (this.canonical.x < t22.canonical.x || !(this.canonical.x > t22.canonical.x) && this.canonical.y < t22.canonical.y));
        }
        wrapped() {
          return new ru(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(t22) {
          return new ru(this.overscaledZ, t22, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new eu(this.wrap, this.canonical);
        }
        toString() {
          return "".concat(this.overscaledZ, "/").concat(this.canonical.x, "/").concat(this.canonical.y);
        }
      }
      function nu(t22, e22, r22, n22, i2) {
        const s2 = 1 << Math.min(r22, 22);
        let a2 = s2 * (i2 % s2) + n22 % s2;
        return t22 && r22 < 22 && (a2 += s2 * s2 * ((t22 < 0 ? -2 * t22 - 1 : 2 * t22) % (1 << 2 * (22 - r22)))), 16 * (32 * a2 + r22) + (e22 - r22);
      }
      const iu = [(t22) => {
        let e22 = t22.canonical.x - 1, r22 = t22.wrap;
        return e22 < 0 && (e22 = (1 << t22.canonical.z) - 1, r22--), new ru(t22.overscaledZ, r22, t22.canonical.z, e22, t22.canonical.y);
      }, (t22) => {
        let e22 = t22.canonical.x + 1, r22 = t22.wrap;
        return e22 === 1 << t22.canonical.z && (e22 = 0, r22++), new ru(t22.overscaledZ, r22, t22.canonical.z, e22, t22.canonical.y);
      }, (t22) => new ru(t22.overscaledZ, t22.wrap, t22.canonical.z, t22.canonical.x, (0 === t22.canonical.y ? 1 << t22.canonical.z : t22.canonical.y) - 1), (t22) => new ru(t22.overscaledZ, t22.wrap, t22.canonical.z, t22.canonical.x, t22.canonical.y === (1 << t22.canonical.z) - 1 ? 0 : t22.canonical.y + 1)];
      os(tu, "CanonicalTileID"), os(ru, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
      const su = ya2([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: au } = su, ou = ya2([{ name: "a_pos_3", components: 3, type: "Int16" }]);
      var lu = ya2([{ name: "a_pos", type: "Int16", components: 2 }]);
      class uu {
        constructor(t22, e22) {
          this.pos = t22, this.dir = e22;
        }
        intersectsPlane(t22, e22, r22) {
          const n22 = O2.vec3.dot(e22, this.dir);
          if (Math.abs(n22) < 1e-6)
            return false;
          const i2 = ((t22[0] - this.pos[0]) * e22[0] + (t22[1] - this.pos[1]) * e22[1] + (t22[2] - this.pos[2]) * e22[2]) / n22;
          return r22[0] = this.pos[0] + this.dir[0] * i2, r22[1] = this.pos[1] + this.dir[1] * i2, r22[2] = this.pos[2] + this.dir[2] * i2, true;
        }
        closestPointOnSphere(t22, e22, r22) {
          if (O2.vec3.equals(this.pos, t22) || 0 === e22)
            return r22[0] = r22[1] = r22[2] = 0, false;
          const [n22, i2, s2] = this.dir, a2 = this.pos[0] - t22[0], o2 = this.pos[1] - t22[1], l22 = this.pos[2] - t22[2], u22 = n22 * n22 + i2 * i2 + s2 * s2, c22 = 2 * (a2 * n22 + o2 * i2 + l22 * s2), h22 = c22 * c22 - 4 * u22 * (a2 * a2 + o2 * o2 + l22 * l22 - e22 * e22);
          if (h22 < 0) {
            const t3 = Math.max(-c22 / 2, 0), u3 = a2 + n22 * t3, h3 = o2 + i2 * t3, p22 = l22 + s2 * t3, f22 = Math.hypot(u3, h3, p22);
            return r22[0] = u3 * e22 / f22, r22[1] = h3 * e22 / f22, r22[2] = p22 * e22 / f22, false;
          }
          {
            const t3 = (-c22 - Math.sqrt(h22)) / (2 * u22);
            if (t3 < 0) {
              const t4 = Math.hypot(a2, o2, l22);
              return r22[0] = a2 * e22 / t4, r22[1] = o2 * e22 / t4, r22[2] = l22 * e22 / t4, false;
            }
            return r22[0] = a2 + n22 * t3, r22[1] = o2 + i2 * t3, r22[2] = l22 + s2 * t3, true;
          }
        }
      }
      class cu {
        constructor(t22, e22, r22, n22, i2) {
          this.TL = t22, this.TR = e22, this.BR = r22, this.BL = n22, this.horizon = i2;
        }
        static fromInvProjectionMatrix(t22, e22, r22) {
          const n22 = [-1, 1, 1], i2 = [1, 1, 1], s2 = [1, -1, 1], a2 = [-1, -1, 1], o2 = O2.vec3.transformMat4(n22, n22, t22), l22 = O2.vec3.transformMat4(i2, i2, t22), u22 = O2.vec3.transformMat4(s2, s2, t22), c22 = O2.vec3.transformMat4(a2, a2, t22);
          return new cu(o2, l22, u22, c22, e22 / r22);
        }
      }
      function hu(t22, e22, r22) {
        let n22 = 1 / 0, i2 = -1 / 0;
        const s2 = [];
        for (const a2 of t22) {
          O2.vec3.sub(s2, a2, e22);
          const t3 = O2.vec3.dot(s2, r22);
          n22 = Math.min(n22, t3), i2 = Math.max(i2, t3);
        }
        return [n22, i2];
      }
      function pu(t22, e22) {
        let r22 = true;
        for (let n22 = 0; n22 < t22.planes.length; n22++) {
          const i2 = t22.planes[n22];
          let s2 = 0;
          for (let t3 = 0; t3 < e22.length; t3++)
            s2 += O2.vec3.dot(i2, e22[t3]) + i2[3] >= 0;
          if (0 === s2)
            return 0;
          s2 !== e22.length && (r22 = false);
        }
        return r22 ? 2 : 1;
      }
      function fu(t22, e22) {
        for (const r22 of t22.projections) {
          const n22 = hu(e22, t22.points[0], r22.axis);
          if (r22.projection[1] < n22[0] || r22.projection[0] > n22[1])
            return 0;
        }
        return 1;
      }
      function du(t22, e22) {
        let r22 = 0;
        const n22 = [0, 0, 0, 0];
        for (let i2 = 0; i2 < t22.length; i2++)
          n22[0] = t22[i2][0], n22[1] = t22[i2][1], n22[2] = t22[i2][2], n22[3] = 1, O2.vec4.dot(n22, e22) >= 0 && r22++;
        return r22;
      }
      class mu {
        constructor(t22, e22) {
          this.points = t22 || new Array(8).fill([0, 0, 0]), this.planes = e22 || new Array(6).fill([0, 0, 0, 0]), this.bounds = yu.fromPoints(this.points), this.projections = [], this.frustumEdges = [O2.vec3.sub([], this.points[2], this.points[3]), O2.vec3.sub([], this.points[0], this.points[3]), O2.vec3.sub([], this.points[4], this.points[0]), O2.vec3.sub([], this.points[5], this.points[1]), O2.vec3.sub([], this.points[6], this.points[2]), O2.vec3.sub([], this.points[7], this.points[3])];
          for (const t3 of this.frustumEdges) {
            const e3 = [0, -t3[2], t3[1]], r22 = [t3[2], 0, -t3[0]];
            this.projections.push({ axis: e3, projection: hu(this.points, this.points[0], e3) }), this.projections.push({ axis: r22, projection: hu(this.points, this.points[0], r22) });
          }
        }
        static fromInvProjectionMatrix(t22, e22, r22, n22) {
          const i2 = Math.pow(2, r22), s2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r3) => {
            const s3 = O2.vec4.transformMat4([], r3, t22), a3 = 1 / s3[3] / e22 * i2;
            return O2.vec4.mul(s3, s3, [a3, a3, n22 ? 1 / s3[3] : a3, a3]);
          }), a2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
            const e3 = O2.vec3.sub([], s2[t3[0]], s2[t3[1]]), r3 = O2.vec3.sub([], s2[t3[2]], s2[t3[1]]), n3 = O2.vec3.normalize([], O2.vec3.cross([], e3, r3)), i3 = -O2.vec3.dot(n3, s2[t3[1]]);
            return n3.concat(i3);
          }), o2 = [];
          for (let t3 = 0; t3 < s2.length; t3++)
            o2.push([s2[t3][0], s2[t3][1], s2[t3][2]]);
          return new mu(o2, a2);
        }
        intersectsPrecise(t22, e22, r22) {
          for (let r3 = 0; r3 < e22.length; r3++)
            if (!du(t22, e22[r3]))
              return 0;
          for (let e3 = 0; e3 < this.planes.length; e3++)
            if (!du(t22, this.planes[e3]))
              return 0;
          for (const e3 of r22)
            for (const r3 of this.frustumEdges) {
              const n22 = O2.vec3.cross([], e3, r3), i2 = O2.vec3.length(n22);
              if (0 === i2)
                continue;
              O2.vec3.scale(n22, n22, 1 / i2);
              const s2 = hu(this.points, this.points[0], n22), a2 = hu(t22, this.points[0], n22);
              if (s2[0] > a2[1] || a2[0] > s2[1])
                return 0;
            }
          return 1;
        }
        containsPoint(t22) {
          for (const e22 of this.planes) {
            const r22 = e22[3];
            if (O2.vec3.dot([e22[0], e22[1], e22[2]], t22) + r22 < 0)
              return false;
          }
          return true;
        }
      }
      class yu {
        static fromPoints(t22) {
          const e22 = [1 / 0, 1 / 0, 1 / 0], r22 = [-1 / 0, -1 / 0, -1 / 0];
          for (const n22 of t22)
            O2.vec3.min(e22, e22, n22), O2.vec3.max(r22, r22, n22);
          return new yu(e22, r22);
        }
        static fromTileIdAndHeight(t22, e22, r22) {
          const n22 = 1 << t22.canonical.z, i2 = t22.canonical.x, s2 = t22.canonical.y;
          return new yu([i2 / n22, s2 / n22, e22], [(i2 + 1) / n22, (s2 + 1) / n22, r22]);
        }
        static applyTransform(t22, e22) {
          const r22 = t22.getCorners();
          for (let t3 = 0; t3 < r22.length; ++t3)
            O2.vec3.transformMat4(r22[t3], r22[t3], e22);
          return yu.fromPoints(r22);
        }
        static applyTransformFast(t22, e22) {
          const r22 = [e22[12], e22[13], e22[14]], n22 = [...r22];
          for (let i2 = 0; i2 < 3; i2++)
            for (let s2 = 0; s2 < 3; s2++) {
              const a2 = e22[4 * s2 + i2], o2 = a2 * t22.min[s2], l22 = a2 * t22.max[s2];
              r22[i2] += Math.min(o2, l22), n22[i2] += Math.max(o2, l22);
            }
          return new yu(r22, n22);
        }
        static projectAabbCorners(t22, e22) {
          const r22 = t22.getCorners();
          for (let t3 = 0; t3 < r22.length; ++t3)
            O2.vec3.transformMat4(r22[t3], r22[t3], e22);
          return r22;
        }
        constructor(t22, e22) {
          this.min = t22, this.max = e22, this.center = O2.vec3.scale([], O2.vec3.add([], this.min, this.max), 0.5);
        }
        quadrant(t22) {
          const e22 = [t22 % 2 == 0, t22 < 2], r22 = O2.vec3.clone(this.min), n22 = O2.vec3.clone(this.max);
          for (let t3 = 0; t3 < e22.length; t3++)
            r22[t3] = e22[t3] ? this.min[t3] : this.center[t3], n22[t3] = e22[t3] ? this.center[t3] : this.max[t3];
          return n22[2] = this.max[2], new yu(r22, n22);
        }
        distanceX(t22) {
          return Math.max(Math.min(this.max[0], t22[0]), this.min[0]) - t22[0];
        }
        distanceY(t22) {
          return Math.max(Math.min(this.max[1], t22[1]), this.min[1]) - t22[1];
        }
        distanceZ(t22) {
          return Math.max(Math.min(this.max[2], t22[2]), this.min[2]) - t22[2];
        }
        getCorners() {
          const t22 = this.min, e22 = this.max;
          return [[t22[0], t22[1], t22[2]], [e22[0], t22[1], t22[2]], [e22[0], e22[1], t22[2]], [t22[0], e22[1], t22[2]], [t22[0], t22[1], e22[2]], [e22[0], t22[1], e22[2]], [e22[0], e22[1], e22[2]], [t22[0], e22[1], e22[2]]];
        }
        intersects(t22) {
          return this.intersectsAabb(t22.bounds) ? pu(t22, this.getCorners()) : 0;
        }
        intersectsFlat(t22) {
          return this.intersectsAabb(t22.bounds) ? pu(t22, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
        }
        intersectsPrecise(t22, e22) {
          return e22 || this.intersects(t22) ? fu(t22, this.getCorners()) : 0;
        }
        intersectsPreciseFlat(t22, e22) {
          return e22 || this.intersectsFlat(t22) ? fu(t22, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
        }
        intersectsAabb(t22) {
          for (let e22 = 0; e22 < 3; ++e22)
            if (this.min[e22] > t22.max[e22] || t22.min[e22] > this.max[e22])
              return false;
          return true;
        }
        intersectsAabbXY(t22) {
          return !(this.min[0] > t22.max[0] || t22.min[0] > this.max[0] || this.min[1] > t22.max[1] || t22.min[1] > this.max[1]);
        }
        encapsulate(t22) {
          for (let e22 = 0; e22 < 3; e22++)
            this.min[e22] = Math.min(this.min[e22], t22.min[e22]), this.max[e22] = Math.max(this.max[e22], t22.max[e22]);
        }
        encapsulatePoint(t22) {
          for (let e22 = 0; e22 < 3; e22++)
            this.min[e22] = Math.min(this.min[e22], t22[e22]), this.max[e22] = Math.max(this.max[e22], t22[e22]);
        }
        closestPoint(t22) {
          return [Math.max(Math.min(this.max[0], t22[0]), this.min[0]), Math.max(Math.min(this.max[1], t22[1]), this.min[1]), Math.max(Math.min(this.max[2], t22[2]), this.min[2])];
        }
      }
      function gu(t22) {
        return t22 * $o / tl2;
      }
      os(yu, "Aabb");
      const xu = [new yu([Ho, Ho, Ho], [Ko, Ko, Ko]), new yu([Ho, Ho, Ho], [0, 0, Ko]), new yu([0, Ho, Ho], [Ko, 0, Ko]), new yu([Ho, 0, Ho], [0, Ko, Ko]), new yu([0, 0, Ho], [Ko, Ko, Ko])];
      function bu(t22, e22, r22, n22 = true) {
        const i2 = O2.vec3.scale([], t22._camera.position, t22.worldSize), s2 = [e22, r22, 1, 1];
        O2.vec4.transformMat4(s2, s2, t22.pixelMatrixInverse), O2.vec4.scale(s2, s2, 1 / s2[3]);
        const a2 = O2.vec3.sub([], s2, i2), o2 = O2.vec3.normalize([], a2), l22 = t22.globeMatrix, u22 = [l22[12], l22[13], l22[14]], c22 = O2.vec3.sub([], u22, i2), h22 = O2.vec3.length(c22), p22 = O2.vec3.normalize([], c22), f22 = t22.worldSize / (2 * Math.PI), d22 = O2.vec3.dot(p22, o2), m22 = Math.asin(f22 / h22);
        if (m22 < Math.acos(d22)) {
          if (!n22)
            return null;
          const t3 = [], e3 = [];
          O2.vec3.scale(t3, o2, h22 / d22), O2.vec3.normalize(e3, O2.vec3.sub(e3, t3, c22)), O2.vec3.normalize(o2, O2.vec3.add(o2, c22, O2.vec3.scale(o2, e3, Math.tan(m22) * h22)));
        }
        const y22 = [];
        new uu(i2, o2).closestPointOnSphere(u22, f22, y22);
        const g22 = O2.vec3.normalize([], wt(l22, 0)), x22 = O2.vec3.normalize([], wt(l22, 1)), b22 = O2.vec3.normalize([], wt(l22, 2)), v22 = O2.vec3.dot(g22, y22), w22 = O2.vec3.dot(x22, y22), _2 = O2.vec3.dot(b22, y22), M22 = Z2(Math.asin(-w22 / f22));
        let A22 = Z2(Math.atan2(v22, _2));
        A22 = t22.center.lng + function(t3, e3) {
          const r3 = (e3 - t3 + 180) % 360 - 180;
          return r3 < -180 ? r3 + 360 : r3;
        }(t22.center.lng, A22);
        const S22 = ol2(A22), I22 = Q2(ll2(M22), 0, 1);
        return new xl(S22, I22);
      }
      class vu {
        constructor(t22, e22, r22) {
          this.a = O2.vec3.sub([], t22, r22), this.b = O2.vec3.sub([], e22, r22), this.center = r22;
          const n22 = O2.vec3.normalize([], this.a), i2 = O2.vec3.normalize([], this.b);
          this.angle = Math.acos(O2.vec3.dot(n22, i2));
        }
      }
      function wu(t22, e22) {
        if (0 === t22.angle)
          return null;
        let r22;
        return r22 = 0 === t22.a[e22] ? 1 / t22.angle * 0.5 * Math.PI : 1 / t22.angle * Math.atan(t22.b[e22] / t22.a[e22] / Math.sin(t22.angle) - 1 / Math.tan(t22.angle)), r22 < 0 || r22 > 1 ? null : function(t3, e3, r3, n22) {
          const i2 = Math.sin(r3);
          return t3 * (Math.sin((1 - n22) * r3) / i2) + e3 * (Math.sin(n22 * r3) / i2);
        }(t22.a[e22], t22.b[e22], t22.angle, Q2(r22, 0, 1)) + t22.center[e22];
      }
      function _u(t22) {
        if (t22.z <= 1)
          return xu[t22.z + 2 * t22.y + t22.x];
        const e22 = Pu(Iu(t22));
        return yu.fromPoints(e22);
      }
      function Mu(t22, e22, r22) {
        return O2.vec3.scale(t22, t22, 1 - r22), O2.vec3.scaleAndAdd(t22, t22, e22, r22);
      }
      function Au(t22, e22, r22) {
        for (const n22 of t22)
          O2.vec3.transformMat4(n22, n22, e22), O2.vec3.scale(n22, n22, r22);
      }
      function Su(t22, e22, r22, n22) {
        const i2 = e22 / t22.worldSize, s2 = t22.globeMatrix;
        if (r22.z <= 1) {
          const t3 = _u(r22).getCorners();
          return Au(t3, s2, i2), yu.fromPoints(t3);
        }
        const a2 = Iu(r22, n22), o2 = Pu(a2, $o + gu(t22._tileCoverLift));
        Au(o2, s2, i2);
        const l22 = Number.MAX_VALUE, u22 = [-l22, -l22, -l22], c22 = [l22, l22, l22];
        if (a2.contains(t22.center)) {
          for (const t3 of o2)
            O2.vec3.min(c22, c22, t3), O2.vec3.max(u22, u22, t3);
          u22[2] = 0;
          const e3 = t22.point, r3 = [e3.x * i2, e3.y * i2, 0];
          return O2.vec3.min(c22, c22, r3), O2.vec3.max(u22, u22, r3), new yu(c22, u22);
        }
        if (t22._tileCoverLift > 0) {
          for (const t3 of o2)
            O2.vec3.min(c22, c22, t3), O2.vec3.max(u22, u22, t3);
          return new yu(c22, u22);
        }
        const h22 = [s2[12] * i2, s2[13] * i2, s2[14] * i2], p22 = a2.getCenter(), f22 = Q2(t22.center.lat, -fl2, fl2), d22 = Q2(p22.lat, -fl2, fl2), m22 = ol2(t22.center.lng), y22 = ll2(f22);
        let g22 = m22 - ol2(p22.lng);
        const x22 = y22 - ll2(d22);
        g22 > 0.5 ? g22 -= 1 : g22 < -0.5 && (g22 += 1);
        let b22 = 0;
        if (Math.abs(g22) > Math.abs(x22))
          b22 = g22 >= 0 ? 1 : 3;
        else {
          b22 = x22 >= 0 ? 0 : 2;
          const t3 = [s2[4] * i2, s2[5] * i2, s2[6] * i2], e3 = -Math.sin(Y2(x22 >= 0 ? a2.getSouth() : a2.getNorth())) * $o;
          O2.vec3.scaleAndAdd(h22, h22, t3, e3);
        }
        const v22 = o2[b22], w22 = o2[(b22 + 1) % 4], _2 = new vu(v22, w22, h22), M22 = [wu(_2, 0) || v22[0], wu(_2, 1) || v22[1], wu(_2, 2) || v22[2]], A22 = Du(t22.zoom);
        if (A22 > 0) {
          const n3 = function({ x: t3, y: e3, z: r3 }, n4, i4, s3, a3) {
            const o3 = 1 / (1 << r3);
            let l3 = t3 * o3, u3 = l3 + o3, c3 = e3 * o3, h3 = c3 + o3, p3 = 0;
            const f3 = (l3 + u3) / 2 - s3;
            return f3 > 0.5 ? p3 = -1 : f3 < -0.5 && (p3 = 1), l3 = ((l3 + p3) * n4 - (s3 *= n4)) * i4 + s3, u3 = ((u3 + p3) * n4 - s3) * i4 + s3, c3 = (c3 * n4 - (a3 *= n4)) * i4 + a3, h3 = (h3 * n4 - a3) * i4 + a3, [[l3, h3, 0], [u3, h3, 0], [u3, c3, 0], [l3, c3, 0]];
          }(r22, e22, t22._pixelsPerMercatorPixel, m22, y22);
          for (let t3 = 0; t3 < o2.length; t3++)
            Mu(o2[t3], n3[t3], A22);
          const i3 = O2.vec3.add([], n3[b22], n3[(b22 + 1) % 4]);
          O2.vec3.scale(i3, i3, 0.5), Mu(M22, i3, A22);
        }
        for (const t3 of o2)
          O2.vec3.min(c22, c22, t3), O2.vec3.max(u22, u22, t3);
        return c22[2] = Math.min(v22[2], w22[2]), O2.vec3.min(c22, c22, M22), O2.vec3.max(u22, u22, M22), new yu(c22, u22);
      }
      function Iu({ x: t22, y: e22, z: r22 }, n22 = false) {
        const i2 = 1 / (1 << r22), s2 = new rl2(cl2(t22 * i2), e22 === (1 << r22) - 1 && n22 ? -90 : hl2((e22 + 1) * i2)), a2 = new rl2(cl2((t22 + 1) * i2), 0 === e22 && n22 ? 90 : hl2(e22 * i2));
        return new nl2(s2, a2);
      }
      function Pu(t22, e22 = $o) {
        const r22 = Y2(t22.getNorth()), n22 = Y2(t22.getSouth()), i2 = Math.cos(r22), s2 = Math.cos(n22), a2 = Math.sin(r22), o2 = Math.sin(n22), l22 = t22.getWest(), u22 = t22.getEast();
        return [Jo(s2, o2, l22, e22), Jo(s2, o2, u22, e22), Jo(i2, a2, u22, e22), Jo(i2, a2, l22, e22)];
      }
      function zu(t22, e22, r22, n22) {
        const i2 = 1 << r22.z, s2 = (t22 / Hr + r22.x) / i2;
        return Qo(hl2((e22 / Hr + r22.y) / i2), cl2(s2), n22);
      }
      function ku({ min: t22, max: e22 }) {
        return Yo / Math.max(e22[0] - t22[0], e22[1] - t22[1], e22[2] - t22[2]);
      }
      const Tu = new Float64Array(16);
      function Eu(t22) {
        const e22 = ku(t22), r22 = O2.mat4.fromScaling(Tu, [e22, e22, e22]);
        return O2.mat4.translate(r22, r22, O2.vec3.negate([], t22.min));
      }
      function Bu(t22) {
        const e22 = O2.mat4.fromTranslation(Tu, t22.min), r22 = 1 / ku(t22);
        return O2.mat4.scale(e22, e22, [r22, r22, r22]);
      }
      function Vu(t22) {
        const e22 = Hr / (2 * Math.PI);
        return t22 / (2 * Math.PI) / e22;
      }
      function Cu(t22, e22) {
        return Hr / (512 * Math.pow(2, t22)) * ku(_u(e22));
      }
      function Ru(t22, e22, r22, n22, i2) {
        const s2 = Vu(r22), a2 = [t22, e22, -r22 / (2 * Math.PI)], o2 = O2.mat4.identity(new Float64Array(16));
        return O2.mat4.translate(o2, o2, a2), O2.mat4.scale(o2, o2, [s2, s2, s2]), O2.mat4.rotateX(o2, o2, Y2(-i2)), O2.mat4.rotateY(o2, o2, Y2(-n22)), o2;
      }
      function Du(t22) {
        return tt(Go, Xo, t22);
      }
      function Lu(t22, e22) {
        const r22 = Qo(e22.lat, e22.lng), n22 = function(t3) {
          const e3 = Qo(t3._center.lat, t3._center.lng), r3 = O2.vec3.fromValues(0, 1, 0);
          let n3 = O2.vec3.cross([], r3, e3);
          const i3 = O2.mat4.fromRotation([], -t3.angle, e3);
          n3 = O2.vec3.transformMat4(n3, n3, i3), O2.mat4.fromRotation(i3, -t3._pitch, n3);
          const s2 = O2.vec3.normalize([], e3);
          return O2.vec3.scale(s2, s2, gu(t3.cameraToCenterDistance / t3.pixelsPerMeter)), O2.vec3.transformMat4(s2, s2, i3), O2.vec3.add([], e3, s2);
        }(t22), i2 = O2.vec3.subtract([], n22, r22);
        return O2.vec3.angle(i2, r22);
      }
      function Fu(t22, e22) {
        return Lu(t22, e22) > Math.PI / 2 * 1.01;
      }
      const Ou = Y2(85), Uu = Math.cos(Ou), ju = Math.sin(Ou), Nu = O2.mat4.create(), qu = (t22) => {
        const e22 = [];
        return "map" === t22.paint.get("circle-pitch-alignment") && e22.push("PITCH_WITH_MAP"), "map" === t22.paint.get("circle-pitch-scale") && e22.push("SCALE_WITH_MAP"), e22;
      };
      function $u(t22, e22, r22, n22, i2, s2, a2, o2, l22) {
        if (s2 && t22.queryGeometry.isAboveHorizon)
          return false;
        s2 && (l22 *= t22.pixelToTileUnitsFactor);
        const u22 = t22.tileID.canonical, c22 = r22.projection.upVectorScale(u22, r22.center.lat, r22.worldSize).metersToTile;
        for (const h22 of e22)
          for (const e3 of h22) {
            const h3 = e3.add(o2), p22 = i2 && r22.elevation ? r22.elevation.exaggeration() * i2.getElevationAt(h3.x, h3.y, true) : 0, f22 = r22.projection.projectTilePoint(h3.x, h3.y, u22);
            if (p22 > 0) {
              const t3 = r22.projection.upVector(u22, h3.x, h3.y);
              f22.x += t3[0] * c22 * p22, f22.y += t3[1] * c22 * p22, f22.z += t3[2] * c22 * p22;
            }
            const d22 = s2 ? h3 : Gu(f22.x, f22.y, f22.z, n22), m22 = s2 ? t22.tilespaceRays.map((t3) => Zu(t3, p22)) : t22.queryGeometry.screenGeometry, y22 = O2.vec4.transformMat4([], [f22.x, f22.y, f22.z, 1], n22);
            if (!a2 && s2 ? l22 *= y22[3] / r22.cameraToCenterDistance : a2 && !s2 && (l22 *= r22.cameraToCenterDistance / y22[3]), s2) {
              const t3 = hl2((e3.y / Hr + u22.y) / (1 << u22.z));
              l22 /= r22.projection.pixelsPerMeter(t3, 1) / ul2(1, t3);
            }
            if (Bl(m22, d22, l22))
              return true;
          }
        return false;
      }
      function Gu(t22, e22, r22, n22) {
        const i2 = O2.vec4.transformMat4([], [t22, e22, r22, 1], n22);
        return new q2(i2[0] / i2[3], i2[1] / i2[3]);
      }
      const Xu = O2.vec3.fromValues(0, 0, 0), Yu = O2.vec3.fromValues(0, 0, 1);
      function Zu(t22, e22) {
        const r22 = O2.vec3.create();
        return Xu[2] = e22, t22.intersectsPlane(Xu, Yu, r22), new q2(r22[0], r22[1]);
      }
      class Wu extends Tl {
      }
      let Hu, Ku, Ju, Qu;
      function tc2(t22, { width: e22, height: r22 }, n22, i2) {
        if (i2) {
          if (i2 instanceof Uint8ClampedArray)
            i2 = new Uint8Array(i2.buffer);
          else if (i2.length !== e22 * r22 * n22)
            throw new RangeError("mismatched image size");
        } else
          i2 = new Uint8Array(e22 * r22 * n22);
        return t22.width = e22, t22.height = r22, t22.data = i2, t22;
      }
      function ec2(t22, e22, r22) {
        const { width: n22, height: i2 } = e22;
        n22 === t22.width && i2 === t22.height || (rc2(t22, e22, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t22.width, n22), height: Math.min(t22.height, i2) }, r22, null), t22.width = n22, t22.height = i2, t22.data = e22.data);
      }
      function rc2(t22, e22, r22, n22, i2, s2, a2, o2) {
        if (0 === i2.width || 0 === i2.height)
          return e22;
        if (i2.width > t22.width || i2.height > t22.height || r22.x > t22.width - i2.width || r22.y > t22.height - i2.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (i2.width > e22.width || i2.height > e22.height || n22.x > e22.width - i2.width || n22.y > e22.height - i2.height)
          throw new RangeError("out of range destination coordinates for image copy");
        const l22 = t22.data, u22 = e22.data, c22 = 4 === s2 && o2;
        for (let o3 = 0; o3 < i2.height; o3++) {
          const h22 = ((r22.y + o3) * t22.width + r22.x) * s2, p22 = ((n22.y + o3) * e22.width + n22.x) * s2;
          if (c22)
            for (let t3 = 0; t3 < i2.width; t3++) {
              const e3 = h22 + t3 * s2 + 3, r3 = p22 + t3 * s2;
              u22[r3 + 0] = 255, u22[r3 + 1] = 255, u22[r3 + 2] = 255, u22[r3 + 3] = l22[e3];
            }
          else if (a2)
            for (let t3 = 0; t3 < i2.width; t3++) {
              const e3 = h22 + t3 * s2, r3 = p22 + t3 * s2, n3 = l22[e3 + 3], i3 = new Pe2(l22[e3 + 0] / 255 * n3, l22[e3 + 1] / 255 * n3, l22[e3 + 2] / 255 * n3, n3).toRenderColor(a2).toArray();
              u22[r3 + 0] = i3[0], u22[r3 + 1] = i3[1], u22[r3 + 2] = i3[2], u22[r3 + 3] = i3[3];
            }
          else
            for (let t3 = 0; t3 < i2.width * s2; t3++)
              u22[p22 + t3] = l22[h22 + t3];
        }
        return e22;
      }
      os(Wu, "HeatmapBucket", { omit: ["layers"] });
      class nc2 {
        constructor(t22, e22) {
          tc2(this, t22, 1, e22);
        }
        resize(t22) {
          ec2(this, new nc2(t22), 1);
        }
        clone() {
          return new nc2({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t22, e22, r22, n22, i2) {
          rc2(t22, e22, r22, n22, i2, 1, null);
        }
      }
      class ic2 {
        constructor(t22, e22) {
          tc2(this, t22, 4, e22);
        }
        resize(t22) {
          ec2(this, new ic2(t22), 4);
        }
        replace(t22, e22) {
          e22 ? this.data.set(t22) : this.data = t22 instanceof Uint8ClampedArray ? new Uint8Array(t22.buffer) : t22;
        }
        clone() {
          return new ic2({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t22, e22, r22, n22, i2, s2, a2) {
          rc2(t22, e22, r22, n22, i2, 4, s2, a2);
        }
      }
      class sc2 {
        constructor(t22, e22) {
          this.width = t22.width, this.height = t22.height, this.data = e22 instanceof Uint8Array ? new Float32Array(e22.buffer) : e22;
        }
      }
      function ac2(t22) {
        const e22 = {}, r22 = t22.resolution || 256, n22 = t22.clips ? t22.clips.length : 1, i2 = t22.image || new ic2({ width: r22, height: n22 }), s2 = (r3, n3, s3) => {
          e22[t22.evaluationKey] = s3;
          const a2 = t22.expression.evaluate(e22);
          a2 && (i2.data[r3 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * a2.a));
        };
        if (t22.clips)
          for (let e3 = 0, i3 = 0; e3 < n22; ++e3, i3 += 4 * r22)
            for (let n3 = 0, a2 = 0; n3 < r22; n3++, a2 += 4) {
              const o2 = n3 / (r22 - 1), { start: l22, end: u22 } = t22.clips[e3];
              s2(i3, a2, l22 * (1 - o2) + u22 * o2);
            }
        else
          for (let t3 = 0, e3 = 0; t3 < r22; t3++, e3 += 4)
            s2(0, e3, t3 / (r22 - 1));
        return i2;
      }
      os(nc2, "AlphaImage"), os(ic2, "RGBAImage");
      const oc2 = ya2([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: lc2 } = oc2;
      function uc2(t22, e22, r22 = 2) {
        const n22 = e22 && e22.length, i2 = n22 ? e22[0] * r22 : t22.length;
        let s2 = cc2(t22, 0, i2, r22, true);
        const a2 = [];
        if (!s2 || s2.next === s2.prev)
          return a2;
        let o2, l22, u22;
        if (n22 && (s2 = function(t3, e3, r3, n3) {
          const i3 = [];
          for (let r4 = 0, s3 = e3.length; r4 < s3; r4++) {
            const a3 = cc2(t3, e3[r4] * n3, r4 < s3 - 1 ? e3[r4 + 1] * n3 : t3.length, n3, false);
            a3 === a3.next && (a3.steiner = true), i3.push(wc2(a3));
          }
          i3.sort(gc2);
          for (let t4 = 0; t4 < i3.length; t4++)
            r3 = xc2(i3[t4], r3);
          return r3;
        }(t22, e22, s2, r22)), t22.length > 80 * r22) {
          o2 = 1 / 0, l22 = 1 / 0;
          let e3 = -1 / 0, n3 = -1 / 0;
          for (let s3 = r22; s3 < i2; s3 += r22) {
            const r3 = t22[s3], i3 = t22[s3 + 1];
            r3 < o2 && (o2 = r3), i3 < l22 && (l22 = i3), r3 > e3 && (e3 = r3), i3 > n3 && (n3 = i3);
          }
          u22 = Math.max(e3 - o2, n3 - l22), u22 = 0 !== u22 ? 32767 / u22 : 0;
        }
        return pc2(s2, a2, r22, o2, l22, u22, 0), a2;
      }
      function cc2(t22, e22, r22, n22, i2) {
        let s2;
        if (i2 === function(t3, e3, r3, n3) {
          let i3 = 0;
          for (let s3 = e3, a2 = r3 - n3; s3 < r3; s3 += n3)
            i3 += (t3[a2] - t3[s3]) * (t3[s3 + 1] + t3[a2 + 1]), a2 = s3;
          return i3;
        }(t22, e22, r22, n22) > 0)
          for (let i3 = e22; i3 < r22; i3 += n22)
            s2 = Ec2(i3 / n22 | 0, t22[i3], t22[i3 + 1], s2);
        else
          for (let i3 = r22 - n22; i3 >= e22; i3 -= n22)
            s2 = Ec2(i3 / n22 | 0, t22[i3], t22[i3 + 1], s2);
        return s2 && Sc2(s2, s2.next) && (Bc2(s2), s2 = s2.next), s2;
      }
      function hc2(t22, e22) {
        if (!t22)
          return t22;
        e22 || (e22 = t22);
        let r22, n22 = t22;
        do {
          if (r22 = false, n22.steiner || !Sc2(n22, n22.next) && 0 !== Ac2(n22.prev, n22, n22.next))
            n22 = n22.next;
          else {
            if (Bc2(n22), n22 = e22 = n22.prev, n22 === n22.next)
              break;
            r22 = true;
          }
        } while (r22 || n22 !== e22);
        return e22;
      }
      function pc2(t22, e22, r22, n22, i2, s2, a2) {
        if (!t22)
          return;
        !a2 && s2 && function(t3, e3, r3, n3) {
          let i3 = t3;
          do {
            0 === i3.z && (i3.z = vc2(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
          } while (i3 !== t3);
          i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
            let e4, r4 = 1;
            do {
              let n4, i4 = t4;
              t4 = null;
              let s3 = null;
              for (e4 = 0; i4; ) {
                e4++;
                let a3 = i4, o3 = 0;
                for (let t5 = 0; t5 < r4 && (o3++, a3 = a3.nextZ, a3); t5++)
                  ;
                let l22 = r4;
                for (; o3 > 0 || l22 > 0 && a3; )
                  0 !== o3 && (0 === l22 || !a3 || i4.z <= a3.z) ? (n4 = i4, i4 = i4.nextZ, o3--) : (n4 = a3, a3 = a3.nextZ, l22--), s3 ? s3.nextZ = n4 : t4 = n4, n4.prevZ = s3, s3 = n4;
                i4 = a3;
              }
              s3.nextZ = null, r4 *= 2;
            } while (e4 > 1);
          }(i3);
        }(t22, n22, i2, s2);
        let o2 = t22;
        for (; t22.prev !== t22.next; ) {
          const l22 = t22.prev, u22 = t22.next;
          if (s2 ? dc2(t22, n22, i2, s2) : fc2(t22))
            e22.push(l22.i, t22.i, u22.i), Bc2(t22), t22 = u22.next, o2 = u22.next;
          else if ((t22 = u22) === o2) {
            a2 ? 1 === a2 ? pc2(t22 = mc2(hc2(t22), e22), e22, r22, n22, i2, s2, 2) : 2 === a2 && yc2(t22, e22, r22, n22, i2, s2) : pc2(hc2(t22), e22, r22, n22, i2, s2, 1);
            break;
          }
        }
      }
      function fc2(t22) {
        const e22 = t22.prev, r22 = t22, n22 = t22.next;
        if (Ac2(e22, r22, n22) >= 0)
          return false;
        const i2 = e22.x, s2 = r22.x, a2 = n22.x, o2 = e22.y, l22 = r22.y, u22 = n22.y, c22 = i2 < s2 ? i2 < a2 ? i2 : a2 : s2 < a2 ? s2 : a2, h22 = o2 < l22 ? o2 < u22 ? o2 : u22 : l22 < u22 ? l22 : u22, p22 = i2 > s2 ? i2 > a2 ? i2 : a2 : s2 > a2 ? s2 : a2, f22 = o2 > l22 ? o2 > u22 ? o2 : u22 : l22 > u22 ? l22 : u22;
        let d22 = n22.next;
        for (; d22 !== e22; ) {
          if (d22.x >= c22 && d22.x <= p22 && d22.y >= h22 && d22.y <= f22 && _c(i2, o2, s2, l22, a2, u22, d22.x, d22.y) && Ac2(d22.prev, d22, d22.next) >= 0)
            return false;
          d22 = d22.next;
        }
        return true;
      }
      function dc2(t22, e22, r22, n22) {
        const i2 = t22.prev, s2 = t22, a2 = t22.next;
        if (Ac2(i2, s2, a2) >= 0)
          return false;
        const o2 = i2.x, l22 = s2.x, u22 = a2.x, c22 = i2.y, h22 = s2.y, p22 = a2.y, f22 = o2 < l22 ? o2 < u22 ? o2 : u22 : l22 < u22 ? l22 : u22, d22 = c22 < h22 ? c22 < p22 ? c22 : p22 : h22 < p22 ? h22 : p22, m22 = o2 > l22 ? o2 > u22 ? o2 : u22 : l22 > u22 ? l22 : u22, y22 = c22 > h22 ? c22 > p22 ? c22 : p22 : h22 > p22 ? h22 : p22, g22 = vc2(f22, d22, e22, r22, n22), x22 = vc2(m22, y22, e22, r22, n22);
        let b22 = t22.prevZ, v22 = t22.nextZ;
        for (; b22 && b22.z >= g22 && v22 && v22.z <= x22; ) {
          if (b22.x >= f22 && b22.x <= m22 && b22.y >= d22 && b22.y <= y22 && b22 !== i2 && b22 !== a2 && _c(o2, c22, l22, h22, u22, p22, b22.x, b22.y) && Ac2(b22.prev, b22, b22.next) >= 0)
            return false;
          if (b22 = b22.prevZ, v22.x >= f22 && v22.x <= m22 && v22.y >= d22 && v22.y <= y22 && v22 !== i2 && v22 !== a2 && _c(o2, c22, l22, h22, u22, p22, v22.x, v22.y) && Ac2(v22.prev, v22, v22.next) >= 0)
            return false;
          v22 = v22.nextZ;
        }
        for (; b22 && b22.z >= g22; ) {
          if (b22.x >= f22 && b22.x <= m22 && b22.y >= d22 && b22.y <= y22 && b22 !== i2 && b22 !== a2 && _c(o2, c22, l22, h22, u22, p22, b22.x, b22.y) && Ac2(b22.prev, b22, b22.next) >= 0)
            return false;
          b22 = b22.prevZ;
        }
        for (; v22 && v22.z <= x22; ) {
          if (v22.x >= f22 && v22.x <= m22 && v22.y >= d22 && v22.y <= y22 && v22 !== i2 && v22 !== a2 && _c(o2, c22, l22, h22, u22, p22, v22.x, v22.y) && Ac2(v22.prev, v22, v22.next) >= 0)
            return false;
          v22 = v22.nextZ;
        }
        return true;
      }
      function mc2(t22, e22) {
        let r22 = t22;
        do {
          const n22 = r22.prev, i2 = r22.next.next;
          !Sc2(n22, i2) && Ic2(n22, r22, r22.next, i2) && kc2(n22, i2) && kc2(i2, n22) && (e22.push(n22.i, r22.i, i2.i), Bc2(r22), Bc2(r22.next), r22 = t22 = i2), r22 = r22.next;
        } while (r22 !== t22);
        return hc2(r22);
      }
      function yc2(t22, e22, r22, n22, i2, s2) {
        let a2 = t22;
        do {
          let t3 = a2.next.next;
          for (; t3 !== a2.prev; ) {
            if (a2.i !== t3.i && Mc2(a2, t3)) {
              let o2 = Tc2(a2, t3);
              return a2 = hc2(a2, a2.next), o2 = hc2(o2, o2.next), pc2(a2, e22, r22, n22, i2, s2, 0), void pc2(o2, e22, r22, n22, i2, s2, 0);
            }
            t3 = t3.next;
          }
          a2 = a2.next;
        } while (a2 !== t22);
      }
      function gc2(t22, e22) {
        return t22.x - e22.x;
      }
      function xc2(t22, e22) {
        const r22 = function(t3, e3) {
          let r3 = e3;
          const n3 = t3.x, i2 = t3.y;
          let s2, a2 = -1 / 0;
          do {
            if (i2 <= r3.y && i2 >= r3.next.y && r3.next.y !== r3.y) {
              const t4 = r3.x + (i2 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
              if (t4 <= n3 && t4 > a2 && (a2 = t4, s2 = r3.x < r3.next.x ? r3 : r3.next, t4 === n3))
                return s2;
            }
            r3 = r3.next;
          } while (r3 !== e3);
          if (!s2)
            return null;
          const o2 = s2, l22 = s2.x, u22 = s2.y;
          let c22 = 1 / 0;
          r3 = s2;
          do {
            if (n3 >= r3.x && r3.x >= l22 && n3 !== r3.x && _c(i2 < u22 ? n3 : a2, i2, l22, u22, i2 < u22 ? a2 : n3, i2, r3.x, r3.y)) {
              const e4 = Math.abs(i2 - r3.y) / (n3 - r3.x);
              kc2(r3, t3) && (e4 < c22 || e4 === c22 && (r3.x > s2.x || r3.x === s2.x && bc2(s2, r3))) && (s2 = r3, c22 = e4);
            }
            r3 = r3.next;
          } while (r3 !== o2);
          return s2;
        }(t22, e22);
        if (!r22)
          return e22;
        const n22 = Tc2(r22, t22);
        return hc2(n22, n22.next), hc2(r22, r22.next);
      }
      function bc2(t22, e22) {
        return Ac2(t22.prev, t22, e22.prev) < 0 && Ac2(e22.next, t22, t22.next) < 0;
      }
      function vc2(t22, e22, r22, n22, i2) {
        return (t22 = 1431655765 & ((t22 = 858993459 & ((t22 = 252645135 & ((t22 = 16711935 & ((t22 = (t22 - r22) * i2 | 0) | t22 << 8)) | t22 << 4)) | t22 << 2)) | t22 << 1)) | (e22 = 1431655765 & ((e22 = 858993459 & ((e22 = 252645135 & ((e22 = 16711935 & ((e22 = (e22 - n22) * i2 | 0) | e22 << 8)) | e22 << 4)) | e22 << 2)) | e22 << 1)) << 1;
      }
      function wc2(t22) {
        let e22 = t22, r22 = t22;
        do {
          (e22.x < r22.x || e22.x === r22.x && e22.y < r22.y) && (r22 = e22), e22 = e22.next;
        } while (e22 !== t22);
        return r22;
      }
      function _c(t22, e22, r22, n22, i2, s2, a2, o2) {
        return (i2 - a2) * (e22 - o2) >= (t22 - a2) * (s2 - o2) && (t22 - a2) * (n22 - o2) >= (r22 - a2) * (e22 - o2) && (r22 - a2) * (s2 - o2) >= (i2 - a2) * (n22 - o2);
      }
      function Mc2(t22, e22) {
        return t22.next.i !== e22.i && t22.prev.i !== e22.i && !function(t3, e3) {
          let r22 = t3;
          do {
            if (r22.i !== t3.i && r22.next.i !== t3.i && r22.i !== e3.i && r22.next.i !== e3.i && Ic2(r22, r22.next, t3, e3))
              return true;
            r22 = r22.next;
          } while (r22 !== t3);
          return false;
        }(t22, e22) && (kc2(t22, e22) && kc2(e22, t22) && function(t3, e3) {
          let r22 = t3, n22 = false;
          const i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
          do {
            r22.y > s2 != r22.next.y > s2 && r22.next.y !== r22.y && i2 < (r22.next.x - r22.x) * (s2 - r22.y) / (r22.next.y - r22.y) + r22.x && (n22 = !n22), r22 = r22.next;
          } while (r22 !== t3);
          return n22;
        }(t22, e22) && (Ac2(t22.prev, t22, e22.prev) || Ac2(t22, e22.prev, e22)) || Sc2(t22, e22) && Ac2(t22.prev, t22, t22.next) > 0 && Ac2(e22.prev, e22, e22.next) > 0);
      }
      function Ac2(t22, e22, r22) {
        return (e22.y - t22.y) * (r22.x - e22.x) - (e22.x - t22.x) * (r22.y - e22.y);
      }
      function Sc2(t22, e22) {
        return t22.x === e22.x && t22.y === e22.y;
      }
      function Ic2(t22, e22, r22, n22) {
        const i2 = zc2(Ac2(t22, e22, r22)), s2 = zc2(Ac2(t22, e22, n22)), a2 = zc2(Ac2(r22, n22, t22)), o2 = zc2(Ac2(r22, n22, e22));
        return i2 !== s2 && a2 !== o2 || !(0 !== i2 || !Pc2(t22, r22, e22)) || !(0 !== s2 || !Pc2(t22, n22, e22)) || !(0 !== a2 || !Pc2(r22, t22, n22)) || !(0 !== o2 || !Pc2(r22, e22, n22));
      }
      function Pc2(t22, e22, r22) {
        return e22.x <= Math.max(t22.x, r22.x) && e22.x >= Math.min(t22.x, r22.x) && e22.y <= Math.max(t22.y, r22.y) && e22.y >= Math.min(t22.y, r22.y);
      }
      function zc2(t22) {
        return t22 > 0 ? 1 : t22 < 0 ? -1 : 0;
      }
      function kc2(t22, e22) {
        return Ac2(t22.prev, t22, t22.next) < 0 ? Ac2(t22, e22, t22.next) >= 0 && Ac2(t22, t22.prev, e22) >= 0 : Ac2(t22, e22, t22.prev) < 0 || Ac2(t22, t22.next, e22) < 0;
      }
      function Tc2(t22, e22) {
        const r22 = Vc2(t22.i, t22.x, t22.y), n22 = Vc2(e22.i, e22.x, e22.y), i2 = t22.next, s2 = e22.prev;
        return t22.next = e22, e22.prev = t22, r22.next = i2, i2.prev = r22, n22.next = r22, r22.prev = n22, s2.next = n22, n22.prev = s2, n22;
      }
      function Ec2(t22, e22, r22, n22) {
        const i2 = Vc2(t22, e22, r22);
        return n22 ? (i2.next = n22.next, i2.prev = n22, n22.next.prev = i2, n22.next = i2) : (i2.prev = i2, i2.next = i2), i2;
      }
      function Bc2(t22) {
        t22.next.prev = t22.prev, t22.prev.next = t22.next, t22.prevZ && (t22.prevZ.nextZ = t22.nextZ), t22.nextZ && (t22.nextZ.prevZ = t22.prevZ);
      }
      function Vc2(t22, e22, r22) {
        return { i: t22, x: e22, y: r22, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
      }
      function Cc2(t22, e22) {
        const r22 = t22.length;
        if (r22 <= 1)
          return [t22];
        const n22 = [];
        let i2, s2;
        for (let e3 = 0; e3 < r22; e3++) {
          const r3 = mt(t22[e3]);
          0 !== r3 && (t22[e3].area = Math.abs(r3), void 0 === s2 && (s2 = r3 < 0), s2 === r3 < 0 ? (i2 && n22.push(i2), i2 = [t22[e3]]) : i2.push(t22[e3]));
        }
        if (i2 && n22.push(i2), e22 > 1)
          for (let t3 = 0; t3 < n22.length; t3++)
            n22[t3].length <= e22 || (br(n22[t3], e22, 1, n22[t3].length - 1, Rc2), n22[t3] = n22[t3].slice(0, e22));
        return n22;
      }
      function Rc2(t22, e22) {
        return e22.area - t22.area;
      }
      function Dc2(t22, e22, r22) {
        const n22 = r22.patternDependencies;
        let i2 = false;
        for (const r3 of e22) {
          const e3 = r3.paint.get("".concat(t22, "-pattern"));
          e3.isConstant() || (i2 = true);
          const s2 = e3.constantOr(null);
          s2 && (i2 = true, n22[s2] = true);
        }
        return i2;
      }
      function Lc2(t22, e22, r22, n22, i2) {
        const s2 = i2.patternDependencies;
        for (const a2 of e22) {
          const e3 = a2.paint.get("".concat(t22, "-pattern")).value;
          if ("constant" !== e3.kind) {
            let t3 = e3.evaluate({ zoom: n22 }, r22, {}, i2.availableImages);
            t3 = t3 && t3.name ? t3.name : t3, s2[t3] = true, r22.patterns[a2.id] = t3;
          }
        }
        return r22;
      }
      class Fc2 {
        constructor(t22) {
          this.zoom = t22.zoom, this.overscaling = t22.overscaling, this.layers = t22.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t22.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new xa(), this.indexArray = new Da2(), this.indexArray2 = new Ea2(), this.programConfigurations = new Fo(t22.layers, { zoom: t22.zoom, lut: t22.lut }), this.segments = new co(), this.segments2 = new co(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.projection = t22.projection;
        }
        updateFootprints(t22, e22) {
        }
        populate(t22, e22, r22, n22) {
          this.hasPattern = Dc2("fill", this.layers, e22);
          const i2 = this.layers[0].layout.get("fill-sort-key"), s2 = [];
          for (const { feature: a2, id: o2, index: l22, sourceLayerIndex: u22 } of t22) {
            const t3 = this.layers[0]._featureFilter.needGeometry, c22 = Pl(a2, t3);
            if (!this.layers[0]._featureFilter.filter(new Vs(this.zoom), c22, r22))
              continue;
            const h22 = i2 ? i2.evaluate(c22, {}, r22, e22.availableImages) : void 0, p22 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u22, index: l22, geometry: t3 ? c22.geometry : Il(a2, r22, n22), patterns: {}, sortKey: h22 };
            s2.push(p22);
          }
          i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
            if (this.hasPattern) {
              const t3 = Lc2("fill", this.layers, n3, this.zoom, e22);
              this.patternFeatures.push(t3);
            } else
              this.addFeature(n3, i3, s3, r22, {}, e22.availableImages, e22.brightness);
            e22.featureIndex.insert(t22[s3].feature, i3, s3, a2, this.index);
          }
        }
        update(t22, e22, r22, n22, i2) {
          const s2 = 0 !== Object.keys(t22).length;
          s2 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t22, e22, s2 ? this.stateDependentLayers : this.layers, r22, n22, i2);
        }
        addFeatures(t22, e22, r22, n22, i2, s2) {
          for (const t3 of this.patternFeatures)
            this.addFeature(t3, t3.geometry, t3.index, e22, r22, n22, s2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t22) {
          this.uploaded || (this.layoutVertexBuffer = t22.createVertexBuffer(this.layoutVertexArray, lc2), this.indexBuffer = t22.createIndexBuffer(this.indexArray), this.indexBuffer2 = t22.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t22), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(t22, e22, r22, n22, i2, s2 = [], a2) {
          for (const t3 of Cc2(e22, 500)) {
            let e3 = 0;
            for (const r4 of t3)
              e3 += r4.length;
            const r3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i3 = [], s3 = [];
            for (const e4 of t3) {
              if (0 === e4.length)
                continue;
              e4 !== t3[0] && s3.push(i3.length / 2);
              const r4 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
              this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i3.push(e4[0].x), i3.push(e4[0].y);
              for (let t4 = 1; t4 < e4.length; t4++)
                this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
              r4.vertexLength += e4.length, r4.primitiveLength += e4.length;
            }
            const a3 = uc2(i3, s3);
            for (let t4 = 0; t4 < a3.length; t4 += 3)
              this.indexArray.emplaceBack(n3 + a3[t4], n3 + a3[t4 + 1], n3 + a3[t4 + 2]);
            r3.vertexLength += e3, r3.primitiveLength += a3.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t22, r22, i2, s2, n22, a2);
        }
      }
      let Oc2, Uc2, jc2, Nc2;
      os(Fc2, "FillBucket", { omit: ["layers", "patternFeatures"] });
      class qc2 {
        constructor(t22, e22, r22, n22) {
          if (this.triangleCount = e22.length / 3, this.min = new q2(0, 0), this.max = new q2(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t22.length)
            return;
          const [i2, s2] = [t22[0].clone(), t22[0].clone()];
          for (let e3 = 1; e3 < t22.length; ++e3) {
            const r3 = t22[e3];
            i2.x = Math.min(i2.x, r3.x), i2.y = Math.min(i2.y, r3.y), s2.x = Math.max(s2.x, r3.x), s2.y = Math.max(s2.y, r3.y);
          }
          if (n22) {
            const t3 = Math.ceil(Math.max(s2.x - i2.x, s2.y - i2.y) / n22);
            r22 = Math.max(r22, t3);
          }
          if (0 === r22)
            return;
          this.min = i2, this.max = s2;
          const a2 = this.max.sub(this.min);
          a2.x = Math.max(a2.x, 1), a2.y = Math.max(a2.y, 1);
          const o2 = Math.max(a2.x, a2.y) / r22;
          this.cellsX = Math.max(1, Math.ceil(a2.x / o2)), this.cellsY = Math.max(1, Math.ceil(a2.y / o2)), this.xScale = 1 / o2, this.yScale = 1 / o2;
          const l22 = [];
          for (let r3 = 0; r3 < this.triangleCount; r3++) {
            const n3 = t22[e22[3 * r3 + 0]].sub(this.min), i3 = t22[e22[3 * r3 + 1]].sub(this.min), s3 = t22[e22[3 * r3 + 2]].sub(this.min), a3 = $c2(Math.floor(Math.min(n3.x, i3.x, s3.x)), this.xScale, this.cellsX), u3 = $c2(Math.floor(Math.max(n3.x, i3.x, s3.x)), this.xScale, this.cellsX), c22 = $c2(Math.floor(Math.min(n3.y, i3.y, s3.y)), this.yScale, this.cellsY), h22 = $c2(Math.floor(Math.max(n3.y, i3.y, s3.y)), this.yScale, this.cellsY), p22 = new q2(0, 0), f22 = new q2(0, 0), d22 = new q2(0, 0), m22 = new q2(0, 0);
            for (let t3 = c22; t3 <= h22; ++t3) {
              p22.y = f22.y = t3 * o2, d22.y = m22.y = (t3 + 1) * o2;
              for (let e3 = a3; e3 <= u3; ++e3)
                p22.x = d22.x = e3 * o2, f22.x = m22.x = (e3 + 1) * o2, ($l(n3, i3, s3, p22, f22, m22) || $l(n3, i3, s3, p22, m22, d22)) && l22.push({ cellIdx: t3 * this.cellsX + e3, triIdx: r3 });
            }
          }
          if (0 === l22.length)
            return;
          l22.sort((t3, e3) => t3.cellIdx - e3.cellIdx || t3.triIdx - e3.triIdx);
          let u22 = 0;
          for (; u22 < l22.length; ) {
            const t3 = l22[u22].cellIdx, e3 = { start: this.payload.length, len: 0 };
            for (; u22 < l22.length && l22[u22].cellIdx === t3; )
              ++e3.len, this.payload.push(l22[u22++].triIdx);
            this.cells[t3] = e3;
          }
        }
        _lazyInitLookup() {
          this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);
        }
        queryPoint(t22, e22) {
          if (0 === this.triangleCount || 0 === this.cells.length)
            return;
          if (t22.x > this.max.x || this.min.x > t22.x || t22.y > this.max.y || this.min.y > t22.y)
            return;
          const r22 = $c2(t22.x - this.min.x, this.xScale, this.cellsX), n22 = $c2(t22.y - this.min.y, this.yScale, this.cellsY), i2 = this.cells[n22 * this.cellsX + r22];
          if (i2) {
            this._lazyInitLookup();
            for (let t3 = 0; t3 < i2.len; t3++) {
              const r3 = this.payload[i2.start + t3], n3 = Math.floor(r3 / 8), s2 = 1 << r3 % 8;
              if (!(this.lookup[n3] & s2) && (this.lookup[n3] |= s2, e22.push(r3), e22.length === this.triangleCount))
                return;
            }
          }
        }
        query(t22, e22, r22) {
          if (0 === this.triangleCount || 0 === this.cells.length)
            return;
          if (t22.x > this.max.x || this.min.x > e22.x)
            return;
          if (t22.y > this.max.y || this.min.y > e22.y)
            return;
          this._lazyInitLookup();
          const n22 = $c2(t22.x - this.min.x, this.xScale, this.cellsX), i2 = $c2(e22.x - this.min.x, this.xScale, this.cellsX), s2 = $c2(t22.y - this.min.y, this.yScale, this.cellsY), a2 = $c2(e22.y - this.min.y, this.yScale, this.cellsY);
          for (let t3 = s2; t3 <= a2; t3++)
            for (let e3 = n22; e3 <= i2; e3++) {
              const n3 = this.cells[t3 * this.cellsX + e3];
              if (n3)
                for (let t4 = 0; t4 < n3.len; t4++) {
                  const e4 = this.payload[n3.start + t4], i3 = Math.floor(e4 / 8), s3 = 1 << e4 % 8;
                  if (!(this.lookup[i3] & s3) && (this.lookup[i3] |= s3, r22.push(e4), r22.length === this.triangleCount))
                    return;
                }
            }
        }
      }
      function $c2(t22, e22, r22) {
        return Math.max(0, Math.min(r22 - 1, Math.floor(t22 * e22)));
      }
      os(qc2, "TriangleGridIndex");
      class Gc2 {
        constructor(t22) {
          this.zoom = t22.zoom, this.layers = t22.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t22.index, this.hasPattern = false, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.footprints = [];
        }
        updateFootprints(t22, e22) {
          for (const r22 of this.footprints)
            e22.push({ footprint: r22, id: t22 });
        }
        populate(t22, e22, r22, n22) {
          const i2 = [];
          for (const { feature: e3, id: s2, index: a2, sourceLayerIndex: o2 } of t22) {
            const t3 = this.layers[0]._featureFilter.needGeometry, l22 = Pl(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new Vs(this.zoom), l22, r22))
              continue;
            const u22 = { id: s2, properties: e3.properties, type: e3.type, sourceLayerIndex: o2, index: a2, geometry: t3 ? l22.geometry : Il(e3, r22, n22), patterns: {} };
            i2.push(u22);
          }
          for (const n3 of i2) {
            const { geometry: i3, index: s2, sourceLayerIndex: a2 } = n3;
            this.addFeature(n3, i3, s2, r22, {}, e22.availableImages, e22.brightness), e22.featureIndex.insert(t22[s2].feature, i3, s2, a2, this.index);
          }
        }
        isEmpty() {
          return 0 === this.footprints.length;
        }
        uploadPending() {
          return false;
        }
        upload(t22) {
        }
        update(t22, e22, r22, n22, i2) {
        }
        destroy() {
        }
        addFeature(t22, e22, r22, n22, i2, s2 = [], a2) {
          for (const t3 of Cc2(e22, 2)) {
            const e3 = [], r3 = [], n3 = [], i3 = new q2(1 / 0, 1 / 0), s3 = new q2(-1 / 0, -1 / 0);
            for (const a4 of t3)
              if (0 !== a4.length) {
                a4 !== t3[0] && n3.push(r3.length / 2);
                for (let t4 = 0; t4 < a4.length; t4++)
                  r3.push(a4[t4].x), r3.push(a4[t4].y), e3.push(a4[t4]), i3.x = Math.min(i3.x, a4[t4].x), i3.y = Math.min(i3.y, a4[t4].y), s3.x = Math.max(s3.x, a4[t4].x), s3.y = Math.max(s3.y, a4[t4].y);
              }
            const a3 = uc2(r3, n3), o2 = new qc2(e3, a3, 8, 256);
            this.footprints.push({ vertices: e3, indices: a3, grid: o2, min: i3, max: s3 });
          }
        }
      }
      os(Gc2, "ClipBucket", { omit: ["layers"] });
      const Xc2 = ya2([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Yc2 = ya2([{ name: "a_pos_end", components: 4, type: "Int16" }, { name: "a_angular_offset_factor", components: 1, type: "Int16" }]), Zc2 = ya2([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Wc2 = ya2([{ name: "a_join_normal_inside", components: 3, type: "Int16" }]), Hc2 = ya2([{ name: "a_hidden_by_landmark", components: 1, type: "Uint8" }]), Kc2 = ya2([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Jc2 } = Xc2;
      var Qc2, th2, eh2, rh2, nh2, ih2, sh2, ah2 = {};
      function oh2() {
        if (th2)
          return Qc2;
        th2 = 1;
        var t22 = N2();
        function e22(t3, e3, n3, i2, s2) {
          this.properties = {}, this.extent = n3, this.type = 0, this._pbf = t3, this._geometry = -1, this._keys = i2, this._values = s2, t3.readFields(r22, this, e3);
        }
        function r22(t3, e3, r3) {
          1 == t3 ? e3.id = r3.readVarint() : 2 == t3 ? function(t4, e4) {
            for (var r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
              var n3 = e4._keys[t4.readVarint()], i2 = e4._values[t4.readVarint()];
              e4.properties[n3] = i2;
            }
          }(r3, e3) : 3 == t3 ? e3.type = r3.readVarint() : 4 == t3 && (e3._geometry = r3.pos);
        }
        function n22(t3) {
          for (var e3, r3, n3 = 0, i2 = 0, s2 = t3.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
            n3 += ((r3 = t3[a2]).x - (e3 = t3[i2]).x) * (e3.y + r3.y);
          return n3;
        }
        return Qc2 = e22, e22.types = ["Unknown", "Point", "LineString", "Polygon"], e22.prototype.loadGeometry = function() {
          var e3 = this._pbf;
          e3.pos = this._geometry;
          for (var r3, n3 = e3.readVarint() + e3.pos, i2 = 1, s2 = 0, a2 = 0, o2 = 0, l22 = []; e3.pos < n3; ) {
            if (s2 <= 0) {
              var u22 = e3.readVarint();
              i2 = 7 & u22, s2 = u22 >> 3;
            }
            if (s2--, 1 === i2 || 2 === i2)
              a2 += e3.readSVarint(), o2 += e3.readSVarint(), 1 === i2 && (r3 && l22.push(r3), r3 = []), r3.push(new t22(a2, o2));
            else {
              if (7 !== i2)
                throw new Error("unknown command " + i2);
              r3 && r3.push(r3[0].clone());
            }
          }
          return r3 && l22.push(r3), l22;
        }, e22.prototype.bbox = function() {
          var t3 = this._pbf;
          t3.pos = this._geometry;
          for (var e3 = t3.readVarint() + t3.pos, r3 = 1, n3 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l22 = 1 / 0, u22 = -1 / 0; t3.pos < e3; ) {
            if (n3 <= 0) {
              var c22 = t3.readVarint();
              r3 = 7 & c22, n3 = c22 >> 3;
            }
            if (n3--, 1 === r3 || 2 === r3)
              (i2 += t3.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t3.readSVarint()) < l22 && (l22 = s2), s2 > u22 && (u22 = s2);
            else if (7 !== r3)
              throw new Error("unknown command " + r3);
          }
          return [a2, l22, o2, u22];
        }, e22.prototype.toGeoJSON = function(t3, r3, i2) {
          var s2, a2, o2 = this.extent * Math.pow(2, i2), l22 = this.extent * t3, u22 = this.extent * r3, c22 = this.loadGeometry(), h22 = e22.types[this.type];
          function p22(t4) {
            for (var e3 = 0; e3 < t4.length; e3++) {
              var r4 = t4[e3];
              t4[e3] = [360 * (r4.x + l22) / o2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r4.y + u22) / o2) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var f22 = [];
              for (s2 = 0; s2 < c22.length; s2++)
                f22[s2] = c22[s2][0];
              p22(c22 = f22);
              break;
            case 2:
              for (s2 = 0; s2 < c22.length; s2++)
                p22(c22[s2]);
              break;
            case 3:
              for (c22 = function(t4) {
                var e3 = t4.length;
                if (e3 <= 1)
                  return [t4];
                for (var r4, i3, s3 = [], a3 = 0; a3 < e3; a3++) {
                  var o3 = n22(t4[a3]);
                  0 !== o3 && (void 0 === i3 && (i3 = o3 < 0), i3 === o3 < 0 ? (r4 && s3.push(r4), r4 = [t4[a3]]) : r4.push(t4[a3]));
                }
                return r4 && s3.push(r4), s3;
              }(c22), s2 = 0; s2 < c22.length; s2++)
                for (a2 = 0; a2 < c22[s2].length; a2++)
                  p22(c22[s2][a2]);
          }
          1 === c22.length ? c22 = c22[0] : h22 = "Multi" + h22;
          var d22 = { type: "Feature", geometry: { type: h22, coordinates: c22 }, properties: this.properties };
          return "id" in this && (d22.id = this.id), d22;
        }, Qc2;
      }
      function lh2() {
        if (rh2)
          return eh2;
        rh2 = 1;
        var t22 = oh2();
        function e22(t3, e3) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t3, this._keys = [], this._values = [], this._features = [], t3.readFields(r22, this, e3), this.length = this._features.length;
        }
        function r22(t3, e3, r3) {
          15 === t3 ? e3.version = r3.readVarint() : 1 === t3 ? e3.name = r3.readString() : 5 === t3 ? e3.extent = r3.readVarint() : 2 === t3 ? e3._features.push(r3.pos) : 3 === t3 ? e3._keys.push(r3.readString()) : 4 === t3 && e3._values.push(function(t4) {
            for (var e4 = null, r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
              var n22 = t4.readVarint() >> 3;
              e4 = 1 === n22 ? t4.readString() : 2 === n22 ? t4.readFloat() : 3 === n22 ? t4.readDouble() : 4 === n22 ? t4.readVarint64() : 5 === n22 ? t4.readVarint() : 6 === n22 ? t4.readSVarint() : 7 === n22 ? t4.readBoolean() : null;
            }
            return e4;
          }(r3));
        }
        return eh2 = e22, e22.prototype.feature = function(e3) {
          if (e3 < 0 || e3 >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[e3];
          var r3 = this._pbf.readVarint() + this._pbf.pos;
          return new t22(this._pbf, r3, this.extent, this._keys, this._values);
        }, eh2;
      }
      function uh2() {
        return sh2 || (sh2 = 1, ah2.VectorTile = function() {
          if (ih2)
            return nh2;
          ih2 = 1;
          var t22 = lh2();
          function e22(e3, r22, n22) {
            if (3 === e3) {
              var i2 = new t22(n22, n22.readVarint() + n22.pos);
              i2.length && (r22[i2.name] = i2);
            }
          }
          return nh2 = function(t3, r22) {
            this.layers = t3.readFields(e22, {}, r22);
          }, nh2;
        }(), ah2.VectorTileFeature = oh2(), ah2.VectorTileLayer = lh2()), ah2;
      }
      var ch2 = uh2();
      class hh2 extends q2 {
        constructor(t22, e22, r22) {
          super(t22, e22), this.z = r22;
        }
      }
      class ph2 extends hh2 {
        constructor(t22, e22, r22, n22) {
          super(t22, e22, r22), this.w = n22;
        }
      }
      function fh2(t22, e22, r22, n22) {
        const i2 = [], s2 = 0 === n22 ? (t3, e3, r3, n3, i3, s3) => {
          t3.push(new q2(s3, r3 + (s3 - e3) / (n3 - e3) * (i3 - r3)));
        } : (t3, e3, r3, n3, i3, s3) => {
          t3.push(new q2(e3 + (s3 - r3) / (i3 - r3) * (n3 - e3), s3));
        };
        for (const a2 of t22) {
          const t3 = [];
          for (const i3 of a2) {
            if (i3.length <= 2)
              continue;
            const a3 = [];
            for (let t4 = 0; t4 < i3.length - 1; t4++) {
              const o3 = i3[t4].x, l3 = i3[t4].y, u22 = i3[t4 + 1].x, c22 = i3[t4 + 1].y, h22 = 0 === n22 ? o3 : l3, p22 = 0 === n22 ? u22 : c22;
              h22 < e22 ? p22 > e22 && s2(a3, o3, l3, u22, c22, e22) : h22 > r22 ? p22 < r22 && s2(a3, o3, l3, u22, c22, r22) : a3.push(i3[t4]), p22 < e22 && h22 >= e22 && s2(a3, o3, l3, u22, c22, e22), p22 > r22 && h22 <= r22 && s2(a3, o3, l3, u22, c22, r22);
            }
            let o2 = i3[i3.length - 1];
            const l22 = 0 === n22 ? o2.x : o2.y;
            l22 >= e22 && l22 <= r22 && a3.push(o2), a3.length && (o2 = a3[a3.length - 1], a3[0].x === o2.x && a3[0].y === o2.y || a3.push(a3[0]), t3.push(a3));
          }
          t3.length && i2.push(t3);
        }
        return i2;
      }
      function dh2(t22, e22, r22, n22) {
        const i2 = "x" === r22 ? "y" : "x", s2 = (n22 - t22[r22]) / (e22[r22] - t22[r22]);
        t22[i2] = t22[i2] + (e22[i2] - t22[i2]) * s2, t22[r22] = n22, t22.hasOwnProperty("z") && (t22.z = ke2(t22.z, e22.z, s2)), t22.hasOwnProperty("w") && (t22.w = ke2(t22.w, e22.w, s2));
      }
      function mh2(t22, e22, r22, n22) {
        const i2 = r22, s2 = n22;
        for (const r3 of ["x", "y"]) {
          let n3 = t22, a2 = e22;
          n3[r3] >= a2[r3] && (n3 = e22, a2 = t22), n3[r3] < i2 && a2[r3] > i2 && dh2(n3, a2, r3, i2), n3[r3] < s2 && a2[r3] > s2 && dh2(a2, n3, r3, s2);
        }
      }
      const yh2 = Number.MAX_SAFE_INTEGER;
      function gh2(t22, e22, r22, n22) {
        return t22.order < e22 || t22.order === yh2 || !(t22.clipMask & r22) || function(t3, e3) {
          return 0 !== e3.length && void 0 === e3.find((e4) => e4 === t3);
        }(n22, t22.clipScope);
      }
      function xh2(t22, e22) {
        return t22.x - e22.x || t22.y - e22.y;
      }
      function bh2(t22, e22) {
        return 0 === xh2(t22.min, e22.min) && 0 === xh2(t22.max, e22.max);
      }
      function vh2(t22, e22) {
        return !(t22.min.x > e22.max.x || t22.max.x < e22.min.x || t22.min.y > e22.max.y || t22.max.y < e22.min.y);
      }
      function wh2(t22, e22) {
        if (t22.length !== e22.length)
          return false;
        for (let r22 = 0; r22 < t22.length; r22++)
          if (t22[r22].sourceId !== e22[r22].sourceId || !bh2(t22[r22], e22[r22]) || t22[r22].order !== e22[r22].order || t22[r22].clipMask !== e22[r22].clipMask || !$(t22[r22].clipScope, e22[r22].clipScope))
            return false;
        return true;
      }
      function _h(t22, e22, r22) {
        const n22 = 1 / Hr, i2 = 1 / (1 << r22.canonical.z), s2 = (e22.x * n22 + r22.canonical.x) * i2 + r22.wrap, a2 = (e22.y * n22 + r22.canonical.y) * i2;
        return { min: new q2((t22.x * n22 + r22.canonical.x) * i2 + r22.wrap, (t22.y * n22 + r22.canonical.y) * i2), max: new q2(s2, a2) };
      }
      function Mh2(t22, e22, r22) {
        const n22 = 1 << r22.canonical.z, i2 = ((e22.x - r22.wrap) * n22 - r22.canonical.x) * Hr, s2 = (e22.y * n22 - r22.canonical.y) * Hr;
        return { min: new q2(((t22.x - r22.wrap) * n22 - r22.canonical.x) * Hr, (t22.y * n22 - r22.canonical.y) * Hr), max: new q2(i2, s2) };
      }
      function Ah2(t22, e22, r22, n22, i2, s2, a2) {
        const o2 = t22.indices, l22 = t22.vertices, u22 = [];
        for (let c22 = n22; c22 < n22 + i2; c22 += 3) {
          const n3 = e22[r22[c22 + 0] + s2], i3 = e22[r22[c22 + 1] + s2], h22 = e22[r22[c22 + 2] + s2], p22 = Math.min(n3.x, i3.x, h22.x), f22 = Math.max(n3.x, i3.x, h22.x), d22 = Math.min(n3.y, i3.y, h22.y), m22 = Math.max(n3.y, i3.y, h22.y);
          u22.length = 0, t22.grid.query(new q2(p22, d22), new q2(f22, m22), u22);
          for (let t3 = 0; t3 < u22.length; t3++) {
            const e3 = u22[t3];
            if ($l(l22[o2[3 * e3 + 0]], l22[o2[3 * e3 + 1]], l22[o2[3 * e3 + 2]], n3, i3, h22, a2))
              return true;
          }
        }
        return false;
      }
      function Sh2(t22, e22, r22, n22) {
        if (!t22 || !r22)
          return false;
        let i2 = t22.vertices;
        if (!e22.canonical.equals(n22.canonical) || e22.wrap !== n22.wrap) {
          if (r22.vertices.length < t22.vertices.length)
            return Sh2(r22, n22, t22, e22);
          const s2 = e22.canonical, a2 = n22.canonical, o2 = Math.pow(2, a2.z - s2.z);
          i2 = t22.vertices.map((t3) => new q2((t3.x + s2.x * Hr) * o2 - a2.x * Hr, (t3.y + s2.y * Hr) * o2 - a2.y * Hr));
        }
        return Ah2(r22, i2, t22.indices, 0, t22.indices.length, 0, 0);
      }
      function Ih2(t22, e22, r22, n22) {
        const i2 = Math.pow(2, n22.z - r22.z);
        return new q2((t22 + r22.x * Hr) * i2 - n22.x * Hr, (e22 + r22.y * Hr) * i2 - n22.y * Hr);
      }
      function Ph2(t22, e22) {
        const r22 = [];
        e22.grid.queryPoint(t22, r22);
        const n22 = e22.indices, i2 = e22.vertices;
        for (let e3 = 0; e3 < r22.length; e3++) {
          const s2 = r22[e3];
          if (Ul([i2[n22[3 * s2 + 0]], i2[n22[3 * s2 + 1]], i2[n22[3 * s2 + 2]]], t22))
            return true;
        }
        return false;
      }
      const zh2 = [new q2(0, 0), new q2(Hr, 0), new q2(Hr, Hr), new q2(0, Hr)];
      function kh2(t22, e22) {
        const r22 = [];
        let n22 = [];
        if (!e22 || t22.length < 2)
          return [t22];
        if (2 === t22.length)
          return Nl(t22[0], t22[1], zh2) ? [t22] : [];
        for (let e3 = 0; e3 < t22.length + 2; e3++) {
          const i2 = t22[e3 % t22.length], s2 = t22[(e3 + 1) % t22.length], a2 = Nl(0 === e3 ? t22[t22.length - 1] : t22[(e3 - 1) % t22.length], i2, zh2), o2 = Nl(i2, s2, zh2), l22 = a2 || o2;
          l22 && n22.push(i2), l22 && o2 || n22.length > 0 && (n22.length > 1 && r22.push(n22), n22 = []);
        }
        return n22.length > 1 && r22.push(n22), r22;
      }
      const Th2 = ch2.VectorTileFeature.types, Eh2 = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius", "fill-extrusion-line-width", "fill-extrusion-emissive-strength"], Bh2 = ["fill-extrusion-flood-light-ground-radius"], Vh2 = Math.pow(2, 13), Ch2 = Math.pow(2, 15) - 1, Rh2 = new q2(0, 1), Dh2 = 2147483648;
      function Lh2(t22, e22, r22, n22, i2, s2, a2, o2) {
        t22.emplaceBack((e22 << 1) + a2, (r22 << 1) + s2, (Math.floor(n22 * Vh2) << 1) + i2, Math.round(o2));
      }
      function Fh2(t22, e22, r22) {
        t22.emplaceBack(e22.x * Hr, e22.y * Hr, r22 ? 1 : 0);
      }
      function Oh2(t22, e22, r22, n22, i2, s2) {
        t22.emplaceBack(e22.x, e22.y, (r22.x << 1) + n22, (r22.y << 1) + i2, s2);
      }
      function Uh2(t22, e22, r22) {
        const n22 = 16384;
        t22.emplaceBack(e22.x, e22.y, e22.z, r22[0] * n22, r22[1] * n22, r22[2] * n22);
      }
      class jh2 {
        constructor() {
          this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
        }
      }
      class Nh2 {
        constructor() {
          this.centroidXY = new q2(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new q2(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new q2(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;
        }
        span() {
          return new q2(this.max.x - this.min.x, this.max.y - this.min.y);
        }
      }
      class qh2 {
        constructor() {
          this.acc = new q2(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
        }
        startRing(t22, e22) {
          t22.min.x === Number.MAX_VALUE && (t22.min.x = t22.max.x = e22.x, t22.min.y = t22.max.y = e22.y);
        }
        appendEdge(t22, e22, r22) {
          this.accCount++, this.acc._add(e22);
          let n22 = !!this.borders;
          e22.x < t22.min.x ? (t22.min.x = e22.x, n22 = true) : e22.x > t22.max.x && (t22.max.x = e22.x, n22 = true), e22.y < t22.min.y ? (t22.min.y = e22.y, n22 = true) : e22.y > t22.max.y && (t22.max.y = e22.y, n22 = true), ((0 === e22.x || e22.x === Hr) && e22.x === r22.x) != ((0 === e22.y || e22.y === Hr) && e22.y === r22.y) && this.processBorderOverlap(e22, r22), n22 && this.checkBorderIntersection(e22, r22);
        }
        checkBorderIntersection(t22, e22) {
          e22.x < 0 != t22.x < 0 && this.addBorderIntersection(0, ke2(e22.y, t22.y, (0 - e22.x) / (t22.x - e22.x))), e22.x > Hr != t22.x > Hr && this.addBorderIntersection(1, ke2(e22.y, t22.y, (Hr - e22.x) / (t22.x - e22.x))), e22.y < 0 != t22.y < 0 && this.addBorderIntersection(2, ke2(e22.x, t22.x, (0 - e22.y) / (t22.y - e22.y))), e22.y > Hr != t22.y > Hr && this.addBorderIntersection(3, ke2(e22.x, t22.x, (Hr - e22.y) / (t22.y - e22.y)));
        }
        addBorderIntersection(t22, e22) {
          this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
          const r22 = this.borders[t22];
          e22 < r22[0] && (r22[0] = e22), e22 > r22[1] && (r22[1] = e22);
        }
        processBorderOverlap(t22, e22) {
          if (t22.x === e22.x) {
            if (t22.y === e22.y)
              return;
            const r22 = 0 === t22.x ? 0 : 1;
            this.addBorderIntersection(r22, e22.y), this.addBorderIntersection(r22, t22.y);
          } else {
            const r22 = 0 === t22.y ? 2 : 3;
            this.addBorderIntersection(r22, e22.x), this.addBorderIntersection(r22, t22.x);
          }
        }
        centroid() {
          return 0 === this.accCount ? new q2(0, 0) : new q2(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
        }
        intersectsCount() {
          return this.borders ? this.borders.reduce((t22, e22) => t22 + +(e22[0] !== Number.MAX_VALUE), 0) : 0;
        }
      }
      function $h2(t22, e22) {
        const r22 = t22.add(e22)._unit(), n22 = Q2(t22.x * r22.x + t22.y * r22.y, -1, 1);
        var i2, s2, a2;
        return a2 = Math.acos(n22), Math.min(4, Math.max(-4, Math.tan(a2))) / 4 * Ch2 * ((i2 = t22).x * (s2 = e22).y - i2.y * s2.x < 0 ? -1 : 1);
      }
      const Gh2 = [(t22) => t22.x < 0, (t22) => t22.x > Hr, (t22) => t22.y < 0, (t22) => t22.y > Hr];
      function Xh2(t22, e22, r22, n22) {
        const i2 = [4];
        if (0 === n22)
          return i2;
        r22._mult(n22);
        const s2 = t22.sub(r22), a2 = e22.sub(r22), o2 = [t22, e22, s2, a2];
        for (let t3 = 0; t3 < 4; t3++)
          for (const e3 of o2)
            if (Gh2[t3](e3)) {
              i2.push(t3);
              break;
            }
        return i2;
      }
      class Yh2 {
        constructor(t22) {
          this.vertexArray = new wa2(), this.indexArray = new Da2(), this.programConfigurations = new Fo(t22.layers, { zoom: t22.zoom, lut: t22.lut }, (t3) => Bh2.includes(t3)), this._segments = new co(), this.hiddenByLandmarkVertexArray = new Za2(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new co();
        }
        getDefaultSegment() {
          return this.regionSegments[4];
        }
        hasData() {
          return 0 !== this.vertexArray.length;
        }
        addData(t22, e22, r22, n22 = false) {
          const i2 = t22.length;
          if (i2 > 2) {
            let s2 = Math.max(0, this._segments.get().length - 1);
            const a2 = this._segments._prepareSegment(4 * i2, this.vertexArray.length, 2 * this._segmentToGroundQuads[s2].length);
            let o2;
            s2 !== this._segments.get().length - 1 && (s2++, this._segmentToGroundQuads[s2] = [], this._segmentToRegionTriCounts[s2] = [0, 0, 0, 0, 0]);
            {
              const e3 = t22[0], r3 = t22[1];
              o2 = $h2(e3.sub(t22[i2 - 1])._perp()._unit(), r3.sub(e3)._perp()._unit());
            }
            for (let l22 = 0; l22 < i2; l22++) {
              const u22 = l22 === i2 - 1 ? 0 : l22 + 1, c22 = t22[l22], h22 = t22[u22], p22 = t22[u22 === i2 - 1 ? 0 : u22 + 1], f22 = h22.sub(c22)._perp()._unit(), d22 = $h2(f22, p22.sub(h22)._perp()._unit()), m22 = o2, y22 = d22;
              if (Jh2(c22, h22, e22) || n22 && Qh2(c22, e22) && Qh2(h22, e22)) {
                o2 = d22;
                continue;
              }
              const g22 = a2.vertexLength;
              Oh2(this.vertexArray, c22, h22, 1, 1, m22), Oh2(this.vertexArray, c22, h22, 1, 0, m22), Oh2(this.vertexArray, c22, h22, 0, 1, y22), Oh2(this.vertexArray, c22, h22, 0, 0, y22), a2.vertexLength += 4;
              const x22 = Xh2(c22, h22, f22, r22);
              for (const t3 of x22)
                this._segmentToGroundQuads[s2].push({ id: g22, region: t3 }), this._segmentToRegionTriCounts[s2][t3] += 2, a2.primitiveLength += 2;
              o2 = d22;
            }
          }
        }
        prepareBorderSegments() {
          if (!this.hasData())
            return;
          const t22 = this._segments.get(), e22 = t22.length;
          for (let t3 = 0; t3 < e22; t3++)
            this._segmentToGroundQuads[t3].sort((t4, e3) => t4.region - e3.region);
          for (let r22 = 0; r22 < e22; r22++) {
            const e3 = this._segmentToGroundQuads[r22], n22 = t22[r22], i2 = this._segmentToRegionTriCounts[r22];
            i2.reduce((t3, e4) => t3 + e4, 0);
            let s2 = 0;
            for (let t3 = 0; t3 <= 4; t3++) {
              const e4 = i2[t3];
              if (0 !== e4) {
                let r3 = this.regionSegments[t3];
                r3 || (r3 = this.regionSegments[t3] = new co());
                const i3 = { vertexOffset: n22.vertexOffset, primitiveOffset: n22.primitiveOffset + s2, vertexLength: n22.vertexLength, primitiveLength: e4 };
                r3.get().push(i3);
              }
              s2 += e4;
            }
            for (let t3 = 0; t3 < e3.length; t3++) {
              const r3 = e3[t3].id;
              this.indexArray.emplaceBack(r3, r3 + 1, r3 + 3), this.indexArray.emplaceBack(r3, r3 + 3, r3 + 2);
            }
          }
          this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
        }
        addPaintPropertiesData(t22, e22, r22, n22, i2, s2) {
          this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t22, e22, r22, n22, i2, s2);
        }
        upload(t22) {
          this.hasData() && (this.vertexBuffer = t22.createVertexBuffer(this.vertexArray, Yc2.members), this.indexBuffer = t22.createIndexBuffer(this.indexArray));
        }
        uploadPaintProperties(t22) {
          this.hasData() && this.programConfigurations.upload(t22);
        }
        update(t22, e22, r22, n22, i2, s2) {
          this.hasData() && this.programConfigurations.updatePaintArrays(t22, e22, r22, n22, i2, s2);
        }
        updateHiddenByLandmark(t22) {
          if (!this.hasData())
            return;
          const e22 = t22.groundVertexCount + t22.groundVertexArrayOffset;
          if (0 === t22.groundVertexCount)
            return;
          const r22 = t22.flags & Dh2 ? 1 : 0;
          for (let n22 = t22.groundVertexArrayOffset; n22 < e22; ++n22)
            this.hiddenByLandmarkVertexArray.emplace(n22, r22);
          this._needsHiddenByLandmarkUpdate = true;
        }
        uploadHiddenByLandmark(t22) {
          this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t22.createVertexBuffer(this.hiddenByLandmarkVertexArray, Hc2.members, true) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = false);
        }
        destroy() {
          if (this.vertexBuffer) {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
            for (let t22 = 0; t22 <= 4; t22++) {
              const e22 = this.regionSegments[t22];
              e22 && e22.destroy();
            }
          }
        }
      }
      class Zh2 {
        constructor(t22) {
          this.zoom = t22.zoom, this.canonical = t22.canonical, this.overscaling = t22.overscaling, this.layers = t22.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t22.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = t22.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new Da2(), this.footprintVertices = new xa(), this.footprintSegments = [], this.layoutVertexArray = new va2(), this.centroidVertexArray = new so(), this.wallVertexArray = new oo(), this.indexArray = new Da2(), this.programConfigurations = new Fo(t22.layers, { zoom: t22.zoom, lut: t22.lut }, (t3) => Eh2.includes(t3)), this.segments = new co(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.groundEffect = new Yh2(t22), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];
        }
        updateFootprints(t22, e22) {
        }
        populate(t22, e22, r22, n22) {
          this.features = [], this.hasPattern = Dc2("fill-extrusion", this.layers, e22), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = gl2(r22), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = 0 !== this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1);
          for (const { feature: i2, id: s2, index: a2, sourceLayerIndex: o2 } of t22) {
            const t3 = this.layers[0]._featureFilter.needGeometry, l22 = Pl(i2, t3);
            if (!this.layers[0]._featureFilter.filter(new Vs(this.zoom), l22, r22))
              continue;
            const u22 = { id: s2, sourceLayerIndex: o2, index: a2, geometry: t3 ? l22.geometry : Il(i2, r22, n22), properties: i2.properties, type: i2.type, patterns: {} }, c22 = this.layoutVertexArray.length, h22 = "Polygon" === Th2[u22.type];
            if (this.hasPattern)
              this.features.push(Lc2("fill-extrusion", this.layers, u22, this.zoom, e22));
            else if (this.wallMode)
              for (const t4 of u22.geometry)
                for (const i3 of kh2(t4, h22))
                  this.addFeature(u22, [i3], a2, r22, {}, e22.availableImages, n22, e22.brightness);
            else
              this.addFeature(u22, u22.geometry, a2, r22, {}, e22.availableImages, n22, e22.brightness);
            e22.featureIndex.insert(i2, u22.geometry, a2, o2, this.index, c22);
          }
          this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
        }
        addFeatures(t22, e22, r22, n22, i2, s2) {
          for (const t3 of this.features) {
            const a2 = "Polygon" === Th2[t3.type], { geometry: o2 } = t3;
            if (this.wallMode)
              for (const l22 of o2)
                for (const o3 of kh2(l22, a2))
                  this.addFeature(t3, [o3], t3.index, e22, r22, n22, i2, s2);
            else
              this.addFeature(t3, o2, t3.index, e22, r22, n22, i2, s2);
          }
          this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles();
        }
        update(t22, e22, r22, n22, i2) {
          const s2 = 0 !== Object.keys(t22).length;
          if (s2 && !this.stateDependentLayers.length)
            return;
          const a2 = s2 ? this.stateDependentLayers : this.layers;
          this.programConfigurations.updatePaintArrays(t22, e22, a2, r22, n22, i2), this.groundEffect.update(t22, e22, a2, r22, n22, i2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
        }
        upload(t22) {
          this.uploaded || (this.layoutVertexBuffer = t22.createVertexBuffer(this.layoutVertexArray, Jc2), this.indexBuffer = t22.createIndexBuffer(this.indexArray), this.wallVertexBuffer = t22.createVertexBuffer(this.wallVertexArray, Wc2.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t22.createVertexBuffer(this.layoutVertexExtArray, Kc2.members, true)), this.groundEffect.upload(t22)), this.groundEffect.uploadPaintProperties(t22), this.programConfigurations.upload(t22), this.uploaded = true;
        }
        uploadCentroid(t22) {
          this.groundEffect.uploadHiddenByLandmark(t22), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t22.createVertexBuffer(this.centroidVertexArray, Zc2.members, true) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = false);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t22, e22, r22, n22, i2, s2, a2, o2) {
          const l22 = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(t22, {}) / this.tileToMeter, u22 = [new q2(0, 0), new q2(Hr, Hr)], c22 = a2.projection, h22 = "globe" === c22.name, p22 = this.wallMode || "Polygon" === Th2[t22.type], f22 = new qh2();
          f22.centroidDataIndex = this.centroidData.length;
          const d22 = new Nh2(), m22 = this.layers[0].paint.get("fill-extrusion-base").evaluate(t22, {}, n22) <= 0, y22 = this.layers[0].paint.get("fill-extrusion-height").evaluate(t22, {}, n22);
          let g22;
          if (d22.height = y22, d22.vertexArrayOffset = this.layoutVertexArray.length, d22.groundVertexArrayOffset = this.groundEffect.vertexArray.length, h22 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Pa2()), this.wallMode) {
            if (h22)
              return void ft("Non zero fill-extrusion-line-width is not yet supported on globe.");
            if (1 !== e22.length)
              return;
            g22 = function(t3) {
              const e3 = t3[0].x === t3[t3.length - 1].x && t3[0].y === t3[t3.length - 1].y, r3 = function(t4) {
                let e4 = 0;
                const r4 = t4.length;
                for (let n4 = 0; n4 < r4; n4++)
                  e4 += (t4[(n4 + 1) % r4].x - t4[n4].x) * (t4[(n4 + 1) % r4].y + t4[n4].y);
                return e4 >= 0;
              }(t3);
              r3 || (t3 = t3.reverse());
              const n3 = { geometry: [], joinNormals: [], indices: [] }, i3 = [], s3 = [], a3 = [];
              let o3 = t3.length;
              if (o3 < (e3 ? 3 : 2))
                return n3;
              for (; o3 >= 2 && t3[o3 - 1].equals(t3[o3 - 2]); )
                o3--;
              let l3, u3, c3, h3, p3, f3 = 0;
              for (; f3 < o3 - 1 && t3[f3].equals(t3[f3 + 1]); )
                f3++;
              e3 && (l3 = t3[o3 - 2], p3 = t3[f3].sub(l3)._unit()._perp());
              for (let r4 = f3; r4 < o3; r4++) {
                if (c3 = r4 === o3 - 1 ? e3 ? t3[f3 + 1] : void 0 : t3[r4 + 1], c3 && t3[r4].equals(c3))
                  continue;
                p3 && (h3 = p3), l3 && (u3 = l3), l3 = t3[r4], p3 = c3 ? c3.sub(l3)._unit()._perp() : h3, h3 = h3 || p3;
                let n4 = h3.add(p3);
                0 === n4.x && 0 === n4.y || n4._unit();
                const d4 = n4.x * p3.x + n4.y * p3.y, m3 = 0 !== d4 ? 1 / d4 : 1 / 0, y3 = h3.x * p3.y - h3.y * p3.x > 0;
                let g3 = "miter";
                const x3 = 2;
                "miter" === g3 && m3 > x3 && (g3 = "bevel"), "bevel" === g3 && (m3 > 100 && (g3 = "flipbevel"), m3 < x3 && (g3 = "miter"));
                const b3 = (t4, e4, r5, n5) => {
                  const o4 = new q2(t4.x, t4.y), l4 = new q2(t4.x, t4.y);
                  o4.x += e4.x * n5, o4.y += e4.y * n5, l4.x -= e4.x * Math.max(r5, 1), l4.y -= e4.y * Math.max(r5, 1), a3.push(e4), i3.push(o4), s3.push(l4);
                };
                if ("miter" === g3)
                  n4._mult(m3), b3(l3, n4, 0, 0);
                else if ("flipbevel" === g3)
                  n4 = p3.mult(-1), b3(l3, n4, 0, 0), b3(l3, n4.mult(-1), 0, 0);
                else {
                  const t4 = -Math.sqrt(m3 * m3 - 1), e4 = y3 ? t4 : 0, r5 = y3 ? 0 : t4;
                  u3 && b3(l3, h3, e4, r5), c3 && b3(l3, p3, e4, r5);
                }
              }
              n3.geometry = [...i3, ...s3.reverse(), i3[0]], n3.joinNormals = [...a3, ...a3.reverse(), a3[a3.length - 1]];
              const d3 = n3.geometry.length - 1;
              for (let t4 = 0; t4 < d3 / 2; t4++)
                if (t4 + 1 < d3 / 2) {
                  let e4 = t4, r4 = t4 + 1, i4 = d3 - 1 - t4, s4 = d3 - 2 - t4;
                  e4 = 0 === e4 ? d3 - 1 : e4 - 1, r4 = 0 === r4 ? d3 - 1 : r4 - 1, i4 = 0 === i4 ? d3 - 1 : i4 - 1, s4 = 0 === s4 ? d3 - 1 : s4 - 1, n3.indices.push(i4), n3.indices.push(r4), n3.indices.push(e4), n3.indices.push(i4), n3.indices.push(s4), n3.indices.push(r4);
                }
              return n3;
            }(e22[0]), e22 = [g22.geometry];
          }
          const x22 = (t3, e3) => t3 < (e3.length - 1) / 2 || t3 === e3.length - 1, b22 = this.wallMode ? [e22] : Cc2(e22, 500);
          for (let t3 = b22.length - 1; t3 >= 0; t3--) {
            const e3 = b22[t3];
            (0 === e3.length || (v22 = e3[0]).every((t4) => t4.x <= 0) || v22.every((t4) => t4.x >= Hr) || v22.every((t4) => t4.y <= 0) || v22.every((t4) => t4.y >= Hr)) && b22.splice(t3, 1);
          }
          var v22;
          let w22;
          if (h22)
            w22 = np(b22, u22, n22);
          else {
            w22 = [];
            for (const t3 of b22)
              w22.push({ polygon: t3, bounds: u22 });
          }
          const _2 = p22 ? this.edgeRadius : 0, M22 = _2 > 0 && this.zoom < 17, A22 = (t3, e3) => {
            if (0 === t3.length)
              return false;
            const r3 = t3[t3.length - 1];
            return e3.x === r3.x && e3.y === r3.y;
          };
          for (const { polygon: t3, bounds: e3 } of w22) {
            let r3 = 0, i3 = 0;
            for (const e4 of t3)
              p22 && !e4[0].equals(e4[e4.length - 1]) && e4.push(e4[0]), i3 += p22 ? e4.length - 1 : e4.length;
            const s3 = this.segments.prepareSegment((p22 ? 5 : 4) * i3, this.layoutVertexArray, this.indexArray);
            d22.footprintSegIdx < 0 && (d22.footprintSegIdx = this.footprintSegments.length), d22.polygonSegIdx < 0 && (d22.polygonSegIdx = this.polygonSegments.length);
            const a3 = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 }, o3 = new jh2();
            if (o3.vertexOffset = this.footprintVertices.length, o3.indexOffset = 3 * this.footprintIndices.length, o3.ringIndices = [], p22) {
              const i4 = [], a4 = [];
              r3 = s3.vertexLength;
              for (let r4 = 0; r4 < t3.length; r4++) {
                const u4 = t3[r4];
                u4.length && 0 !== r4 && a4.push(i4.length / 2);
                const p3 = [];
                let f3, d3;
                f3 = u4[1].sub(u4[0])._perp()._unit(), o3.ringIndices.push(u4.length - 1);
                for (let t4 = 1; t4 < u4.length; t4++) {
                  const e4 = u4[t4], r5 = u4[t4 === u4.length - 1 ? 1 : t4 + 1], a5 = e4.clone();
                  if (_2) {
                    d3 = r5.sub(e4)._perp()._unit();
                    const t5 = f3.add(d3)._unit(), n3 = _2 * Math.min(4, 1 / (f3.x * t5.x + f3.y * t5.y));
                    a5.x += n3 * t5.x, a5.y += n3 * t5.y, a5.x = Math.round(a5.x), a5.y = Math.round(a5.y), f3 = d3;
                  }
                  if (!m22 || 0 !== _2 && !M22 || A22(p3, a5) || p3.push(a5), Lh2(this.layoutVertexArray, a5.x, a5.y, 0, 0, 1, 1, 0), this.wallMode) {
                    const e5 = x22(t4, u4);
                    Fh2(this.wallVertexArray, g22.joinNormals[t4], !e5);
                  }
                  s3.vertexLength++, this.footprintVertices.emplaceBack(e4.x, e4.y), i4.push(e4.x, e4.y), h22 && Uh2(this.layoutVertexExtArray, c22.projectTilePoint(a5.x, a5.y, n22), c22.upVector(n22, a5.x, a5.y));
                }
                m22 && (0 === _2 || M22) && (0 !== p3.length && A22(p3, p3[0]) && p3.pop(), this.groundEffect.addData(p3, e3, l22));
              }
              const u3 = this.wallMode ? g22.indices : uc2(i4, a4);
              for (let t4 = 0; t4 < u3.length; t4 += 3)
                this.footprintIndices.emplaceBack(o3.vertexOffset + u3[t4 + 0], o3.vertexOffset + u3[t4 + 1], o3.vertexOffset + u3[t4 + 2]), this.indexArray.emplaceBack(r3 + u3[t4], r3 + u3[t4 + 2], r3 + u3[t4 + 1]), s3.primitiveLength++;
              o3.indexCount += u3.length, o3.vertexCount += this.footprintVertices.length - o3.vertexOffset;
            }
            for (let i4 = 0; i4 < t3.length; i4++) {
              const a4 = t3[i4];
              f22.startRing(d22, a4[0]);
              let o4 = a4.length > 4 && tp(a4[a4.length - 2], a4[0], a4[1]), u3 = _2 ? Hh2(a4[a4.length - 2], a4[0], a4[1], _2) : 0;
              const y3 = [];
              let b3, v3, w3;
              v3 = a4[1].sub(a4[0])._perp()._unit();
              let M3 = true;
              for (let t4 = 1, i5 = 0; t4 < a4.length; t4++) {
                let l3 = a4[t4 - 1], p3 = a4[t4];
                const S22 = a4[t4 === a4.length - 1 ? 1 : t4 + 1];
                if (f22.appendEdge(d22, p3, l3), Jh2(p3, l3, e3)) {
                  _2 && (v3 = S22.sub(p3)._perp()._unit(), M3 = !M3);
                  continue;
                }
                const I22 = p3.sub(l3)._perp(), P22 = I22.x / (Math.abs(I22.x) + Math.abs(I22.y)), z22 = I22.y > 0 ? 1 : 0, k22 = l3.dist(p3);
                if (i5 + k22 > 32768 && (i5 = 0), _2) {
                  w3 = S22.sub(p3)._perp()._unit();
                  let t5 = Kh2(l3, p3, S22, Wh2(v3, w3), _2);
                  isNaN(t5) && (t5 = 0);
                  const e4 = p3.sub(l3)._unit();
                  l3 = l3.add(e4.mult(u3))._round(), p3 = p3.add(e4.mult(-t5))._round(), u3 = t5, v3 = w3, m22 && this.zoom >= 17 && (A22(y3, l3) || y3.push(l3), A22(y3, p3) || y3.push(p3));
                }
                const T22 = s3.vertexLength, E22 = a4.length > 4 && tp(l3, p3, S22);
                let B22 = ep(i5, o4, M3);
                if (Lh2(this.layoutVertexArray, l3.x, l3.y, P22, z22, 0, 0, B22), Lh2(this.layoutVertexArray, l3.x, l3.y, P22, z22, 0, 1, B22), this.wallMode) {
                  const e4 = x22(t4 - 1, a4), r4 = g22.joinNormals[t4 - 1];
                  Fh2(this.wallVertexArray, r4, e4), Fh2(this.wallVertexArray, r4, e4);
                }
                if (i5 += k22, B22 = ep(i5, E22, !M3), o4 = E22, Lh2(this.layoutVertexArray, p3.x, p3.y, P22, z22, 0, 0, B22), Lh2(this.layoutVertexArray, p3.x, p3.y, P22, z22, 0, 1, B22), this.wallMode) {
                  const e4 = x22(t4, a4), r4 = g22.joinNormals[t4];
                  Fh2(this.wallVertexArray, r4, e4), Fh2(this.wallVertexArray, r4, e4);
                }
                if (s3.vertexLength += 4, this.indexArray.emplaceBack(T22 + 0, T22 + 1, T22 + 2), this.indexArray.emplaceBack(T22 + 1, T22 + 3, T22 + 2), s3.primitiveLength += 2, _2) {
                  const n3 = r3 + (1 === t4 ? a4.length - 2 : t4 - 2), i6 = 1 === t4 ? r3 : n3 + 1;
                  if (this.indexArray.emplaceBack(T22 + 1, n3, T22 + 3), this.indexArray.emplaceBack(n3, i6, T22 + 3), s3.primitiveLength += 2, void 0 === b3 && (b3 = T22), !Jh2(S22, a4[t4], e3)) {
                    const e4 = t4 === a4.length - 1 ? b3 : s3.vertexLength;
                    this.indexArray.emplaceBack(T22 + 2, T22 + 3, e4), this.indexArray.emplaceBack(T22 + 3, e4 + 1, e4), this.indexArray.emplaceBack(T22 + 3, i6, e4 + 1), s3.primitiveLength += 3;
                  }
                  M3 = !M3;
                }
                if (h22) {
                  const t5 = this.layoutVertexExtArray, e4 = c22.projectTilePoint(l3.x, l3.y, n22), r4 = c22.projectTilePoint(p3.x, p3.y, n22), i6 = c22.upVector(n22, l3.x, l3.y), s4 = c22.upVector(n22, p3.x, p3.y);
                  Uh2(t5, e4, i6), Uh2(t5, e4, i6), Uh2(t5, r4, s4), Uh2(t5, r4, s4);
                }
              }
              p22 && (r3 += a4.length - 1), m22 && _2 && this.zoom >= 17 && (0 !== y3.length && A22(y3, y3[0]) && y3.pop(), this.groundEffect.addData(y3, e3, l22, _2 > 0));
            }
            this.footprintSegments.push(o3), a3.triangleCount = this.indexArray.length - a3.triangleArrayOffset, this.polygonSegments.push(a3), ++d22.footprintSegLen, ++d22.polygonSegLen;
          }
          if (d22.vertexCount = this.layoutVertexArray.length - d22.vertexArrayOffset, d22.groundVertexCount = this.groundEffect.vertexArray.length - d22.groundVertexArrayOffset, 0 !== d22.vertexCount) {
            if (d22.centroidXY = f22.borders ? Rh2 : this.encodeCentroid(f22, d22), this.centroidData.push(d22), f22.borders) {
              this.featuresOnBorder.push(f22);
              const t3 = this.featuresOnBorder.length - 1;
              for (let e3 = 0; e3 < f22.borders.length; e3++)
                f22.borders[e3][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e3].push(t3);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t22, r22, i2, s2, n22, o2), this.groundEffect.addPaintPropertiesData(t22, r22, i2, s2, n22, o2), this.maxHeight = Math.max(this.maxHeight, y22);
          }
        }
        sortBorders() {
          for (let t22 = 0; t22 < this.borderFeatureIndices.length; t22++)
            this.borderFeatureIndices[t22].sort((e22, r22) => this.featuresOnBorder[e22].borders[t22][0] - this.featuresOnBorder[r22].borders[t22][0]);
        }
        splitToSubtiles() {
          const t22 = [];
          for (let e3 = 0; e3 < this.centroidData.length; e3++) {
            const r3 = this.centroidData[e3], n3 = +(r3.min.y + r3.max.y > Hr), i3 = 2 * n3 + (+(r3.min.x + r3.max.x > Hr) ^ n3);
            for (let n4 = 0; n4 < r3.polygonSegLen; n4++) {
              const s3 = r3.polygonSegIdx + n4;
              t22.push({ centroidIdx: e3, subtile: i3, polygonSegmentIdx: s3, triangleSegmentIdx: this.polygonSegments[s3].triangleSegIdx });
            }
          }
          const e22 = new Da2();
          t22.sort((t3, e3) => t3.triangleSegmentIdx === e3.triangleSegmentIdx ? t3.subtile - e3.subtile : t3.triangleSegmentIdx - e3.triangleSegmentIdx);
          let r22 = 0, n22 = 0, i2 = 0;
          for (const e3 of t22) {
            if (e3.triangleSegmentIdx !== r22)
              break;
            i2++;
          }
          const s2 = t22.length;
          for (; n22 !== t22.length; ) {
            r22 = t22[n22].triangleSegmentIdx;
            let a2 = 0, o2 = n22, l22 = n22;
            for (let e3 = o2; e3 < i2 && t22[e3].subtile === a2; e3++)
              l22++;
            for (; o2 !== i2; ) {
              const n3 = t22[o2];
              a2 = n3.subtile;
              const s3 = this.centroidData[n3.centroidIdx].min.clone(), u22 = this.centroidData[n3.centroidIdx].max.clone(), c22 = { vertexOffset: this.segments.segments[r22].vertexOffset, primitiveOffset: e22.length, vertexLength: this.segments.segments[r22].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
              for (let r3 = o2; r3 < l22; r3++) {
                const n4 = t22[r3], i3 = this.polygonSegments[n4.polygonSegmentIdx], a3 = this.centroidData[n4.centroidIdx].min, o3 = this.centroidData[n4.centroidIdx].max, l3 = this.indexArray.uint16;
                for (let t3 = i3.triangleArrayOffset; t3 < i3.triangleArrayOffset + i3.triangleCount; t3++)
                  e22.emplaceBack(l3[3 * t3], l3[3 * t3 + 1], l3[3 * t3 + 2]);
                c22.primitiveLength += i3.triangleCount, s3.x = Math.min(s3.x, a3.x), s3.y = Math.min(s3.y, a3.y), u22.x = Math.max(u22.x, o3.x), u22.y = Math.max(u22.y, o3.y);
              }
              c22.primitiveLength > 0 && this.triangleSubSegments.push({ segment: c22, min: s3, max: u22 }), o2 = l22;
              for (let e3 = o2; e3 < i2 && t22[e3].subtile === t22[o2].subtile; e3++)
                l22++;
            }
            n22 = i2;
            for (let e3 = n22; e3 < s2 && t22[e3].triangleSegmentIdx === t22[n22].triangleSegmentIdx; e3++)
              i2++;
          }
          e22._trim(), this.indexArray = e22;
        }
        getVisibleSegments(t22, e22, r22) {
          const n22 = new co();
          if (this.wallMode) {
            for (const t3 of this.triangleSubSegments)
              n22.segments.push(t3.segment);
            return n22;
          }
          let i2 = 0, s2 = 0;
          const a2 = 1 << t22.canonical.z;
          if (e22) {
            const r3 = e22.getMinMaxForTile(t22);
            r3 && (i2 = r3.min, s2 = r3.max);
          }
          s2 += this.maxHeight;
          const o2 = t22.toUnwrapped();
          let l22;
          const u22 = [o2.canonical.x / a2 + o2.wrap, o2.canonical.y / a2], c22 = [(o2.canonical.x + 1) / a2 + o2.wrap, (o2.canonical.y + 1) / a2], h22 = (t3, e3, r3) => [t3[0] * (1 - r3[0]) + e3[0] * r3[0], t3[1] * (1 - r3[1]) + e3[1] * r3[1]], p22 = [], f22 = [];
          for (const t3 of this.triangleSubSegments) {
            p22[0] = t3.min.x / Hr, p22[1] = t3.min.y / Hr, f22[0] = t3.max.x / Hr, f22[1] = t3.max.y / Hr;
            const e3 = h22(u22, c22, p22), a3 = h22(u22, c22, f22);
            if (0 === new yu([e3[0], e3[1], i2], [a3[0], a3[1], s2]).intersectsPrecise(r22)) {
              l22 && (n22.segments.push(l22), l22 = void 0);
              continue;
            }
            const o3 = t3.segment;
            l22 && l22.vertexOffset !== o3.vertexOffset && (n22.segments.push(l22), l22 = void 0), l22 ? (l22.vertexLength += o3.vertexLength, l22.primitiveLength += o3.primitiveLength) : l22 = { vertexOffset: o3.vertexOffset, primitiveLength: o3.primitiveLength, vertexLength: o3.vertexLength, primitiveOffset: o3.primitiveOffset, sortKey: void 0, vaos: {} };
          }
          return l22 && n22.segments.push(l22), n22;
        }
        encodeCentroid(t22, e22) {
          const r22 = t22.centroid(), n22 = e22.span(), i2 = Math.min(7, Math.round(n22.x * this.tileToMeter / 10)), s2 = Math.min(7, Math.round(n22.y * this.tileToMeter / 10));
          return new q2(Q2(r22.x, 1, Hr - 1) << 3 | i2, Q2(r22.y, 1, Hr - 1) << 3 | s2);
        }
        encodeBorderCentroid(t22) {
          if (!t22.borders)
            return new q2(0, 0);
          const e22 = t22.borders, r22 = Number.MAX_VALUE;
          if (e22[0][0] !== r22 || e22[1][0] !== r22) {
            const t3 = e22[0][0] !== r22 ? 0 : 1;
            return new q2(6 | (e22[0][0] !== r22 ? 0 : 65528), (e22[t3][0] + e22[t3][1]) / 2 << 3 | 6);
          }
          {
            const t3 = e22[2][0] !== r22 ? 2 : 3;
            return new q2((e22[t3][0] + e22[t3][1]) / 2 << 3 | 6, 6 | (e22[2][0] !== r22 ? 0 : 65528));
          }
        }
        showCentroid(t22) {
          const e22 = this.centroidData[t22.centroidDataIndex];
          e22.flags &= Dh2, e22.centroidXY.x = 0, e22.centroidXY.y = 0, this.writeCentroidToBuffer(e22);
        }
        writeCentroidToBuffer(t22) {
          this.groundEffect.updateHiddenByLandmark(t22);
          const e22 = t22.vertexArrayOffset, r22 = t22.vertexCount + t22.vertexArrayOffset, n22 = t22.flags & Dh2 ? Rh2 : t22.centroidXY, i2 = this.centroidVertexArray.geta_centroid_pos0(e22);
          if (this.centroidVertexArray.geta_centroid_pos1(e22) !== n22.y || i2 !== n22.x) {
            for (let t3 = e22; t3 < r22; ++t3)
              this.centroidVertexArray.emplace(t3, n22.x, n22.y);
            this.needsCentroidUpdate = true;
          }
        }
        createCentroidsBuffer() {
          this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
          for (const t22 of this.centroidData)
            this.writeCentroidToBuffer(t22);
        }
        updateReplacement(t22, e22, r22) {
          if (e22.updateTime === this.replacementUpdateTime)
            return;
          this.replacementUpdateTime = e22.updateTime;
          const n22 = e22.getReplacementRegionsForTile(t22.toUnwrapped());
          if (wh2(this.activeReplacements, n22))
            return;
          if (this.activeReplacements = n22, 0 === this.centroidVertexArray.length)
            this.createCentroidsBuffer();
          else
            for (const t3 of this.centroidData)
              t3.flags &= 2147483647;
          const i2 = [];
          for (const e3 of this.activeReplacements) {
            if (e3.order < r22)
              continue;
            const n3 = Math.pow(2, e3.footprintTileId.canonical.z - t22.canonical.z);
            for (const r3 of this.centroidData)
              if (!(r3.flags & Dh2 || e3.min.x > r3.max.x || r3.min.x > e3.max.x || e3.min.y > r3.max.y || r3.min.y > e3.max.y))
                for (let s2 = 0; s2 < r3.footprintSegLen; s2++) {
                  const a2 = this.footprintSegments[r3.footprintSegIdx + s2];
                  if (i2.length = 0, ip(this.footprintVertices, a2.vertexOffset, a2.vertexCount, e3.footprintTileId.canonical, t22.canonical, i2), Ah2(e3.footprint, i2, this.footprintIndices.uint16, a2.indexOffset, a2.indexCount, -a2.vertexOffset, -n3)) {
                    r3.flags |= Dh2;
                    break;
                  }
                }
          }
          for (const t3 of this.centroidData)
            this.writeCentroidToBuffer(t3);
          this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
        }
        footprintContainsPoint(t22, e22, r22) {
          let n22 = false;
          for (let i2 = 0; i2 < r22.footprintSegLen; i2++) {
            const s2 = this.footprintSegments[r22.footprintSegIdx + i2];
            let a2 = 0;
            for (const r3 of s2.ringIndices) {
              for (let i3 = a2, o2 = r3 + a2 - 1; i3 < r3 + a2; o2 = i3++) {
                const r4 = this.footprintVertices.int16[2 * (i3 + s2.vertexOffset) + 0], a3 = this.footprintVertices.int16[2 * (i3 + s2.vertexOffset) + 1], l22 = this.footprintVertices.int16[2 * (o2 + s2.vertexOffset) + 1];
                a3 > e22 != l22 > e22 && t22 < (this.footprintVertices.int16[2 * (o2 + s2.vertexOffset) + 0] - r4) * (e22 - a3) / (l22 - a3) + r4 && (n22 = !n22);
              }
              a2 = r3;
            }
          }
          return n22;
        }
        getHeightAtTileCoord(t22, e22) {
          let r22 = Number.NEGATIVE_INFINITY, n22 = true;
          const i2 = 4 * (t22 + Hr) * Hr + (e22 + Hr);
          if (this.partLookup.hasOwnProperty(i2)) {
            const t3 = this.partLookup[i2];
            return t3 ? { height: t3.height, hidden: !!(t3.flags & Dh2) } : void 0;
          }
          for (const s2 of this.centroidData)
            t22 > s2.max.x || s2.min.x > t22 || e22 > s2.max.y || s2.min.y > e22 || this.footprintContainsPoint(t22, e22, s2) && s2 && s2.height > r22 && (r22 = s2.height, this.partLookup[i2] = s2, n22 = !!(s2.flags & Dh2));
          if (r22 !== Number.NEGATIVE_INFINITY)
            return { height: r22, hidden: n22 };
          this.partLookup[i2] = void 0;
        }
      }
      function Wh2(t22, e22) {
        const r22 = t22.add(e22)._unit();
        return t22.x * r22.x + t22.y * r22.y;
      }
      function Hh2(t22, e22, r22, n22) {
        const i2 = e22.sub(t22)._perp()._unit(), s2 = r22.sub(e22)._perp()._unit();
        return Kh2(t22, e22, r22, Wh2(i2, s2), n22);
      }
      function Kh2(t22, e22, r22, n22, i2) {
        const s2 = Math.sqrt(1 - n22 * n22);
        return Math.min(t22.dist(e22) / 3, e22.dist(r22) / 3, i2 * s2 / n22);
      }
      function Jh2(t22, e22, r22) {
        return t22.x < r22[0].x && e22.x < r22[0].x || t22.x > r22[1].x && e22.x > r22[1].x || t22.y < r22[0].y && e22.y < r22[0].y || t22.y > r22[1].y && e22.y > r22[1].y;
      }
      function Qh2(t22, e22) {
        return t22.x < e22[0].x || t22.x > e22[1].x || t22.y < e22[0].y || t22.y > e22[1].y;
      }
      function tp(t22, e22, r22) {
        if (t22.x < 0 || t22.x >= Hr || e22.x < 0 || e22.x >= Hr || r22.x < 0 || r22.x >= Hr)
          return false;
        const n22 = r22.sub(e22), i2 = n22.perp(), s2 = t22.sub(e22);
        return (n22.x * s2.x + n22.y * s2.y) / Math.sqrt((n22.x * n22.x + n22.y * n22.y) * (s2.x * s2.x + s2.y * s2.y)) > -0.866 && i2.x * s2.x + i2.y * s2.y < 0;
      }
      function ep(t22, e22, r22) {
        const n22 = e22 ? 2 | t22 : -3 & t22;
        return r22 ? 1 | n22 : -2 & n22;
      }
      function rp() {
        const t22 = Math.PI / 32, e22 = Math.tan(t22), r22 = tl2;
        return r22 * Math.sqrt(1 + 2 * e22 * e22) - r22;
      }
      function np(t22, e22, r22) {
        const n22 = 1 << r22.z, i2 = cl2(r22.x / n22), s2 = cl2((r22.x + 1) / n22), a2 = hl2(r22.y / n22), o2 = hl2((r22.y + 1) / n22);
        return function(t3, e3, r3, n3, i3 = 0, s3) {
          const a3 = [];
          if (!t3.length || !r3 || !n3)
            return a3;
          const o3 = (t4, e4) => {
            for (const r4 of t4)
              a3.push({ polygon: r4, bounds: e4 });
          }, l22 = Math.ceil(Math.log2(r3)), u22 = Math.ceil(Math.log2(n3)), c22 = l22 - u22, h22 = [];
          for (let t4 = 0; t4 < Math.abs(c22); t4++)
            h22.push(c22 > 0 ? 0 : 1);
          for (let t4 = 0; t4 < Math.min(l22, u22); t4++)
            h22.push(0), h22.push(1);
          let p22 = t3;
          if (p22 = fh2(p22, e3[0].y - i3, e3[1].y + i3, 1), p22 = fh2(p22, e3[0].x - i3, e3[1].x + i3, 0), !p22.length)
            return a3;
          const f22 = [];
          for (h22.length ? f22.push({ polygons: p22, bounds: e3, depth: 0 }) : o3(p22, e3); f22.length; ) {
            const t4 = f22.pop(), e4 = t4.depth, r4 = h22[e4], n4 = t4.bounds[0], a4 = t4.bounds[1], l3 = 0 === r4 ? n4.x : n4.y, u3 = 0 === r4 ? a4.x : a4.y, c3 = s3 ? s3(r4, l3, u3) : 0.5 * (l3 + u3), p3 = fh2(t4.polygons, l3 - i3, c3 + i3, r4), d22 = fh2(t4.polygons, c3 - i3, u3 + i3, r4);
            if (p3.length) {
              const t5 = [n4, new q2(0 === r4 ? c3 : a4.x, 1 === r4 ? c3 : a4.y)];
              h22.length > e4 + 1 ? f22.push({ polygons: p3, bounds: t5, depth: e4 + 1 }) : o3(p3, t5);
            }
            if (d22.length) {
              const t5 = [new q2(0 === r4 ? c3 : n4.x, 1 === r4 ? c3 : n4.y), a4];
              h22.length > e4 + 1 ? f22.push({ polygons: d22, bounds: t5, depth: e4 + 1 }) : o3(d22, t5);
            }
          }
          return a3;
        }(t22, e22, Math.ceil((s2 - i2) / 11.25), Math.ceil((a2 - o2) / 11.25), 1, (t3, e3, i3) => {
          if (0 === t3)
            return 0.5 * (e3 + i3);
          {
            const t4 = hl2((r22.y + e3 / Hr) / n22);
            return (ll2(0.5 * (hl2((r22.y + i3 / Hr) / n22) + t4)) * n22 - r22.y) * Hr;
          }
        });
      }
      function ip(t22, e22, r22, n22, i2, s2) {
        const a2 = Math.pow(2, n22.z - i2.z);
        for (let o2 = 0; o2 < r22; o2++) {
          let r3 = t22.int16[2 * (o2 + e22) + 0], l22 = t22.int16[2 * (o2 + e22) + 1];
          r3 = (r3 + i2.x * Hr) * a2 - n22.x * Hr, l22 = (l22 + i2.y * Hr) * a2 - n22.y * Hr, s2.push(new q2(r3, l22));
        }
      }
      let sp, ap;
      function op(t22, e22) {
        return t22.x * e22.x + t22.y * e22.y;
      }
      function lp(t22, e22) {
        if (1 === t22.length) {
          let r22 = 0;
          const n22 = e22[r22++];
          let i2;
          for (; !i2 || n22.equals(i2); )
            if (i2 = e22[r22++], !i2)
              return 1 / 0;
          for (; r22 < e22.length; r22++) {
            const s2 = e22[r22], a2 = t22[0], o2 = i2.sub(n22), l22 = s2.sub(n22), u22 = a2.sub(n22), c22 = op(o2, o2), h22 = op(o2, l22), p22 = op(l22, l22), f22 = op(u22, o2), d22 = op(u22, l22), m22 = c22 * p22 - h22 * h22, y22 = (p22 * f22 - h22 * d22) / m22, g22 = (c22 * d22 - h22 * f22) / m22, x22 = n22.z * (1 - y22 - g22) + i2.z * y22 + s2.z * g22;
            if (isFinite(x22))
              return x22;
          }
          return 1 / 0;
        }
        {
          let t3 = 1 / 0;
          for (const r22 of e22)
            t3 = Math.min(t3, r22.z);
          return t3;
        }
      }
      function up(t22, e22, r22, n22, i2, s2, a2, o2) {
        const l22 = a2 * i2.getElevationAt(t22, e22, true, true), u22 = 0 !== s2[0], c22 = u22 ? 0 === s2[1] ? a2 * (s2[0] / 7 - 450) : a2 * function(t3, e3, r3) {
          const n3 = Math.floor(e3[0] / 8), i3 = Math.floor(e3[1] / 8), s3 = 10 * (e3[0] - 8 * n3), a3 = 10 * (e3[1] - 8 * i3), o3 = t3.getElevationAt(n3, i3, true, true), l3 = t3.getMeterToDEM(r3), u3 = Math.floor(0.5 * (s3 * l3 - 1)), c3 = Math.floor(0.5 * (a3 * l3 - 1)), h22 = t3.tileCoordToPixel(n3, i3), p22 = 2 * u3 + 1, f22 = 2 * c3 + 1, d22 = function(t4, e4, r4, n4, i4) {
            return [t4.getElevationAtPixel(e4, r4, true), t4.getElevationAtPixel(e4 + i4, r4, true), t4.getElevationAtPixel(e4, r4 + i4, true), t4.getElevationAtPixel(e4 + n4, r4 + i4, true)];
          }(t3, h22.x - u3, h22.y - c3, p22, f22), m22 = Math.abs(d22[0] - d22[1]), y22 = Math.abs(d22[2] - d22[3]), g22 = Math.abs(d22[0] - d22[2]) + Math.abs(d22[1] - d22[3]), x22 = Math.min(0.25, 0.5 * l3 * (m22 + y22) / p22), b22 = Math.min(0.25, 0.5 * l3 * g22 / f22);
          return o3 + Math.max(x22 * s3, b22 * a3);
        }(i2, s2, o2) : l22;
        return { base: l22 + (0 === r22) ? -1 : r22, top: u22 ? Math.max(c22 + n22, l22 + r22 + 2) : l22 + n22 };
      }
      os(Zh2, "FillExtrusionBucket", { omit: ["layers", "features"] }), os(Nh2, "PartData"), os(jh2, "FootprintSegment"), os(qh2, "BorderCentroidData"), os(Yh2, "GroundEffect");
      const cp = ya2([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), hp = ya2([{ name: "a_z_offset", components: 1, type: "Float32" }], 4), { members: pp } = cp, fp = ya2([{ name: "a_packed", components: 4, type: "Float32" }]), { members: dp } = fp, mp = ya2([{ name: "a_pattern_data", components: 3, type: "Float32" }]), { members: yp } = mp;
      class gp {
        constructor(t22, e22) {
          this.width = t22, this.height = e22, this.nextRow = 0, this.image = new nc2({ width: t22, height: e22 }), this.positions = {}, this.uploaded = false;
        }
        getDash(t22, e22) {
          const r22 = this.getKey(t22, e22);
          return this.positions[r22];
        }
        trim() {
          const t22 = this.width, e22 = this.height = at(this.nextRow);
          this.image.resize({ width: t22, height: e22 });
        }
        getKey(t22, e22) {
          return t22.join(",") + e22;
        }
        getDashRanges(t22, e22, r22) {
          const n22 = [];
          let i2 = t22.length % 2 == 1 ? -t22[t22.length - 1] * r22 : 0, s2 = t22[0] * r22, a2 = true;
          n22.push({ left: i2, right: s2, isDash: a2, zeroLength: 0 === t22[0] });
          let o2 = t22[0];
          for (let e3 = 1; e3 < t22.length; e3++) {
            a2 = !a2;
            const l22 = t22[e3];
            i2 = o2 * r22, o2 += l22, s2 = o2 * r22, n22.push({ left: i2, right: s2, isDash: a2, zeroLength: 0 === l22 });
          }
          return n22;
        }
        addRoundDash(t22, e22, r22) {
          const n22 = e22 / 2;
          for (let e3 = -r22; e3 <= r22; e3++) {
            const i2 = this.width * (this.nextRow + r22 + e3);
            let s2 = 0, a2 = t22[s2];
            for (let o2 = 0; o2 < this.width; o2++) {
              o2 / a2.right > 1 && (a2 = t22[++s2]);
              const l22 = Math.abs(o2 - a2.left), u22 = Math.abs(o2 - a2.right), c22 = Math.min(l22, u22);
              let h22;
              const p22 = e3 / r22 * (n22 + 1);
              if (a2.isDash) {
                const t3 = n22 - Math.abs(p22);
                h22 = Math.sqrt(c22 * c22 + t3 * t3);
              } else
                h22 = n22 - Math.sqrt(c22 * c22 + p22 * p22);
              this.image.data[i2 + o2] = Math.max(0, Math.min(255, h22 + 128));
            }
          }
        }
        addRegularDash(t22, e22) {
          for (let e3 = t22.length - 1; e3 >= 0; --e3) {
            const r3 = t22[e3], n3 = t22[e3 + 1];
            r3.zeroLength ? t22.splice(e3, 1) : n3 && n3.isDash === r3.isDash && (n3.left = r3.left, t22.splice(e3, 1));
          }
          const r22 = t22[0], n22 = t22[t22.length - 1];
          r22.isDash === n22.isDash && (r22.left = n22.left - this.width, n22.right = r22.right + this.width);
          const i2 = this.width * this.nextRow;
          let s2 = 0, a2 = t22[s2];
          for (let r3 = 0; r3 < this.width; r3++) {
            r3 / a2.right > 1 && (a2 = t22[++s2]);
            const n3 = Math.abs(r3 - a2.left), o2 = Math.abs(r3 - a2.right), l22 = Math.min(n3, o2);
            this.image.data[i2 + r3] = Math.max(0, Math.min(255, (a2.isDash ? l22 : -l22) + e22 + 128));
          }
        }
        addDash(t22, e22) {
          const r22 = this.getKey(t22, e22);
          if (this.positions[r22])
            return this.positions[r22];
          const n22 = "round" === e22, i2 = n22 ? 7 : 0, s2 = 2 * i2 + 1;
          if (this.nextRow + s2 > this.height)
            return ft("LineAtlas out of space"), null;
          0 === t22.length && t22.push(1);
          let a2 = 0;
          for (let e3 = 0; e3 < t22.length; e3++)
            t22[e3] < 0 && (ft("Negative value is found in line dasharray, replacing values with 0"), t22[e3] = 0), a2 += t22[e3];
          if (0 !== a2) {
            const r3 = this.width / a2, s3 = this.getDashRanges(t22, this.width, r3);
            n22 ? this.addRoundDash(s3, r3, i2) : this.addRegularDash(s3, "square" === e22 ? 0.5 * r3 : 0);
          }
          const o2 = this.nextRow + i2;
          this.nextRow += s2;
          const l22 = { tl: [o2, i2], br: [a2, 0] };
          return this.positions[r22] = l22, l22;
        }
      }
      os(gp, "LineAtlas");
      const xp = ch2.VectorTileFeature.types, bp = Math.cos(Math.PI / 180 * 37.5), vp = Math.cos(Math.PI / 180 * 5);
      class wp {
        constructor(t22) {
          this.zoom = t22.zoom, this.overscaling = t22.overscaling, this.layers = t22.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t22.index, this.projection = t22.projection, this.hasPattern = false, this.hasZOffset = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
            this.gradients[t3.id] = {};
          }), this.layoutVertexArray = new _a(), this.layoutVertexArray2 = new Ma2(), this.patternVertexArray = new Aa2(), this.indexArray = new Da2(), this.programConfigurations = new Fo(t22.layers, { zoom: t22.zoom, lut: t22.lut }), this.segments = new co(), this.maxLineLength = 0, this.zOffsetVertexArray = new Oa2(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.tessellationStep = t22.tessellationStep ? t22.tessellationStep : Hr / 64;
        }
        updateFootprints(t22, e22) {
        }
        populate(t22, e22, r22, n22) {
          this.hasPattern = Dc2("line", this.layers, e22);
          const i2 = this.layers[0].layout.get("line-sort-key"), s2 = this.layers[0].layout.get("line-z-offset");
          this.hasZOffset = !s2.isConstant() || !!s2.constantOr(0);
          const a2 = [];
          for (const { feature: e3, id: s3, index: o3, sourceLayerIndex: l3 } of t22) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u3 = Pl(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new Vs(this.zoom), u3, r22))
              continue;
            const c22 = i2 ? i2.evaluate(u3, {}, r22) : void 0, h22 = { id: s3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t3 ? u3.geometry : Il(e3, r22, n22), patterns: {}, sortKey: c22 };
            a2.push(h22);
          }
          i2 && a2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          const { lineAtlas: o2, featureIndex: l22 } = e22, u22 = this.addConstantDashes(o2);
          for (const n3 of a2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3;
            if (u22 && this.addFeatureDashes(n3, o2), this.hasPattern) {
              const t3 = Lc2("line", this.layers, n3, this.zoom, e22);
              this.patternFeatures.push(t3);
            } else
              this.addFeature(n3, i3, s3, r22, o2.positions, e22.availableImages, e22.brightness);
            l22.insert(t22[s3].feature, i3, s3, a3, this.index);
          }
        }
        addConstantDashes(t22) {
          let e22 = false;
          for (const r22 of this.layers) {
            const n22 = r22.paint.get("line-dasharray").value, i2 = r22.layout.get("line-cap").value;
            if ("constant" !== n22.kind || "constant" !== i2.kind)
              e22 = true;
            else {
              const e3 = i2.value, r3 = n22.value;
              if (!r3)
                continue;
              t22.addDash(r3, e3);
            }
          }
          return e22;
        }
        addFeatureDashes(t22, e22) {
          const r22 = this.zoom;
          for (const n22 of this.layers) {
            const i2 = n22.paint.get("line-dasharray").value, s2 = n22.layout.get("line-cap").value;
            if ("constant" === i2.kind && "constant" === s2.kind)
              continue;
            let a2, o2;
            if ("constant" === i2.kind) {
              if (a2 = i2.value, !a2)
                continue;
            } else
              a2 = i2.evaluate({ zoom: r22 }, t22);
            o2 = "constant" === s2.kind ? s2.value : s2.evaluate({ zoom: r22 }, t22), e22.addDash(a2, o2), t22.patterns[n22.id] = e22.getKey(a2, o2);
          }
        }
        update(t22, e22, r22, n22, i2) {
          const s2 = 0 !== Object.keys(t22).length;
          s2 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t22, e22, s2 ? this.stateDependentLayers : this.layers, r22, n22, i2);
        }
        addFeatures(t22, e22, r22, n22, i2, s2) {
          for (const t3 of this.patternFeatures)
            this.addFeature(t3, t3.geometry, t3.index, e22, r22, n22, s2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t22) {
          this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t22.createVertexBuffer(this.layoutVertexArray2, dp)), 0 !== this.patternVertexArray.length && (this.patternVertexBuffer = t22.createVertexBuffer(this.patternVertexArray, yp)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = t22.createVertexBuffer(this.zOffsetVertexArray, hp.members, true)), this.layoutVertexBuffer = t22.createVertexBuffer(this.layoutVertexArray, pp), this.indexBuffer = t22.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t22), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(t22) {
          if (t22.properties && t22.properties.hasOwnProperty("mapbox_clip_start") && t22.properties.hasOwnProperty("mapbox_clip_end"))
            return { start: +t22.properties.mapbox_clip_start, end: +t22.properties.mapbox_clip_end };
        }
        addFeature(t22, e22, r22, n22, i2, s2, a2) {
          const o2 = this.layers[0].layout, l22 = o2.get("line-join").evaluate(t22, {}), u22 = o2.get("line-cap").evaluate(t22, {}), c22 = o2.get("line-miter-limit"), h22 = o2.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t22);
          for (const r3 of e22)
            this.addLine(r3, t22, n22, l22, u22, c22, h22);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t22, r22, i2, s2, n22, a2);
        }
        addLine(t22, e22, r22, n22, i2, s2, a2) {
          this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.currentVertex = void 0;
          const o2 = { zoom: this.zoom, lineProgress: void 0 }, l22 = this.layers[0].layout, u22 = "none" === n22;
          if (this.patternJoinNone = this.hasPattern && u22, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [], this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let e3 = 0; e3 < t22.length - 1; e3++)
              this.totalDistance += t22[e3].dist(t22[e3 + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const c22 = "Polygon" === xp[e22.type];
          let h22 = t22.length;
          for (; h22 >= 2 && t22[h22 - 1].equals(t22[h22 - 2]); )
            h22--;
          let p22 = 0;
          for (; p22 < h22 - 1 && t22[p22].equals(t22[p22 + 1]); )
            p22++;
          if (h22 < (c22 ? 3 : 2))
            return;
          "bevel" === n22 && (s2 = 1.05);
          const f22 = this.overscaling <= 16 ? 15 * Hr / (512 * this.overscaling) : 0, d22 = this.segments.prepareSegment(10 * h22, this.layoutVertexArray, this.indexArray);
          let m22, y22, g22, x22, b22, v22;
          this.e1 = this.e2 = -1, c22 && (m22 = t22[h22 - 2], b22 = t22[p22].sub(m22)._unit()._perp());
          for (let r3 = p22; r3 < h22; r3++) {
            if (g22 = r3 === h22 - 1 ? c22 ? t22[p22 + 1] : void 0 : t22[r3 + 1], g22 && t22[r3].equals(g22))
              continue;
            if (b22 && (x22 = b22), m22 && (y22 = m22), m22 = t22[r3], this.hasZOffset) {
              const t3 = l22.get("line-z-offset").value;
              if ("constant" === t3.kind)
                v22 = t3.value;
              else {
                if (this.lineClips) {
                  const t4 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                  o2.lineProgress = (t4 * this.lineClips.start + this.distance + (y22 ? y22.dist(m22) : 0)) / t4;
                } else
                  ft("line-z-offset evaluation for ".concat(this.layerIds[0], " requires enabling 'lineMetrics' for the source.")), o2.lineProgress = 0;
                v22 = t3.evaluate(o2, e22);
              }
              v22 = v22 || 0;
            }
            b22 = g22 ? g22.sub(m22)._unit()._perp() : x22, x22 = x22 || b22;
            const w22 = y22 && g22;
            let _2 = w22 ? n22 : c22 || u22 ? "butt" : i2;
            const M22 = x22.x * b22.x + x22.y * b22.y;
            if (u22) {
              const t3 = function(t4) {
                if (t4.patternJoinNone) {
                  const e3 = t4.segmentPoints.length / 2, r4 = t4.lineSoFar - t4.segmentStart;
                  for (let n3 = 0; n3 < e3; ++n3) {
                    const e4 = t4.segmentPoints[2 * n3 + 1], i3 = Math.round(t4.segmentPoints[2 * n3]) + 0.5 + 0.25 * e4;
                    t4.patternVertexArray.emplaceBack(i3, r4, t4.segmentStart), t4.patternVertexArray.emplaceBack(i3, r4, t4.segmentStart);
                  }
                  t4.segmentPoints.length = 0;
                }
                t4.e1 = t4.e2 = -1;
              };
              if (w22 && M22 < vp) {
                this.updateDistance(y22, m22), this.addCurrentVertex(m22, x22, 1, 1, d22, v22), t3(this), this.addCurrentVertex(m22, b22, -1, -1, d22, v22);
                continue;
              }
              if (y22) {
                if (!g22) {
                  this.updateDistance(y22, m22), this.addCurrentVertex(m22, x22, 1, 1, d22, v22), t3(this);
                  continue;
                }
                _2 = "miter";
              }
            }
            let A22 = x22.add(b22);
            0 === A22.x && 0 === A22.y || A22._unit();
            const S22 = A22.x * b22.x + A22.y * b22.y, I22 = 0 !== S22 ? 1 / S22 : 1 / 0, P22 = 2 * Math.sqrt(2 - 2 * S22), z22 = S22 < bp && y22 && g22, k22 = x22.x * b22.y - x22.y * b22.x > 0;
            if (z22 && r3 > p22) {
              const t3 = m22.dist(y22);
              if (t3 > 2 * f22) {
                const e3 = m22.sub(m22.sub(y22)._mult(f22 / t3)._round());
                this.updateDistance(y22, e3), this.addCurrentVertex(e3, x22, 0, 0, d22, v22), y22 = e3;
              }
            }
            if (w22 && "round" === _2 && (I22 < a2 ? _2 = "miter" : I22 <= 2 && (_2 = "fakeround")), "miter" === _2 && I22 > s2 && (_2 = "bevel"), "bevel" === _2 && (I22 > 2 && (_2 = "flipbevel"), I22 < s2 && (_2 = "miter")), y22 && this.updateDistance(y22, m22), "miter" === _2)
              A22._mult(I22), this.addCurrentVertex(m22, A22, 0, 0, d22, v22);
            else if ("flipbevel" === _2) {
              if (I22 > 100)
                A22 = b22.mult(-1);
              else {
                const t3 = I22 * x22.add(b22).mag() / x22.sub(b22).mag();
                A22._perp()._mult(t3 * (k22 ? -1 : 1));
              }
              this.addCurrentVertex(m22, A22, 0, 0, d22, v22), this.addCurrentVertex(m22, A22.mult(-1), 0, 0, d22, v22);
            } else if ("bevel" === _2 || "fakeround" === _2) {
              const t3 = -Math.sqrt(I22 * I22 - 1), e3 = k22 ? t3 : 0, r4 = k22 ? 0 : t3;
              if (y22 && this.addCurrentVertex(m22, x22, e3, r4, d22, v22), "fakeround" === _2) {
                const t4 = Math.round(180 * P22 / Math.PI / 20);
                for (let e4 = 1; e4 < t4; e4++) {
                  let r5 = e4 / t4;
                  if (0.5 !== r5) {
                    const t5 = r5 - 0.5;
                    r5 += r5 * t5 * (r5 - 1) * ((1.0904 + M22 * (M22 * (3.55645 - 1.43519 * M22) - 3.2452)) * t5 * t5 + (0.848013 + M22 * (0.215638 * M22 - 1.06021)));
                  }
                  const n3 = b22.sub(x22)._mult(r5)._add(x22)._unit()._mult(k22 ? -1 : 1);
                  this.addHalfVertex(m22, n3.x, n3.y, false, k22, 0, d22, v22);
                }
              }
              g22 && this.addCurrentVertex(m22, b22, -e3, -r4, d22, v22);
            } else
              "butt" === _2 ? this.addCurrentVertex(m22, A22, 0, 0, d22, v22) : "square" === _2 ? (y22 || this.addCurrentVertex(m22, A22, -1, -1, d22, v22), this.addCurrentVertex(m22, A22, 0, 0, d22, v22), y22 && this.addCurrentVertex(m22, A22, 1, 1, d22, v22)) : "round" === _2 && (y22 && (this.addCurrentVertex(m22, x22, 0, 0, d22, v22), this.addCurrentVertex(m22, x22, 1, 1, d22, v22, true)), g22 && (this.addCurrentVertex(m22, b22, -1, -1, d22, v22, true), this.addCurrentVertex(m22, b22, 0, 0, d22, v22)));
            if (z22 && r3 < h22 - 1) {
              const t3 = m22.dist(g22);
              if (t3 > 2 * f22) {
                const e3 = m22.add(g22.sub(m22)._mult(f22 / t3)._round());
                this.updateDistance(m22, e3), this.addCurrentVertex(e3, b22, 0, 0, d22, v22), m22 = e3;
              }
            }
          }
        }
        addVerticesTo(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22) {
          const c22 = (e22.w - t22.w) / this.tessellationStep | 0;
          if (c22 > 1) {
            this.lineSoFar = t22.w;
            const h22 = (e22.x - t22.x) / c22, p22 = (e22.y - t22.y) / c22, f22 = (e22.z - t22.z) / c22, d22 = (e22.w - t22.w) / c22;
            for (let e3 = 1; e3 < c22; ++e3)
              t22.x += h22, t22.y += p22, t22.z += f22, this.lineSoFar += d22, this.addHalfVertex(t22, r22, n22, u22, false, a2, l22, t22.z), this.addHalfVertex(t22, i2, s2, u22, true, -o2, l22, t22.z);
          }
          this.lineSoFar = e22.w, this.addHalfVertex(e22, r22, n22, u22, false, a2, l22, e22.z), this.addHalfVertex(e22, i2, s2, u22, true, -o2, l22, e22.z);
        }
        addCurrentVertex(t22, e22, r22, n22, i2, s2, a2 = false) {
          const o2 = e22.x + e22.y * r22, l22 = e22.y - e22.x * r22, u22 = e22.y * n22 - e22.x, c22 = -e22.y - e22.x * n22;
          if (null != s2) {
            const e3 = -10, h22 = Hr + 10, p22 = s2, f22 = new ph2(t22.x, t22.y, p22, this.lineSoFar), d22 = _p(t22, e3, h22), m22 = this.lineSoFar;
            if (this.currentVertex)
              if (d22) {
                const s3 = this.currentVertexIsOutside, f3 = this.currentVertex, d3 = new ph2(t22.x, t22.y, p22, this.lineSoFar);
                mh2(f3, d3, e3, h22), _p(d3, e3, h22) || (s3 && (this.e1 = this.e2 = -1, this.lineSoFar = f3.w, this.addHalfVertex(f3, o2, l22, a2, false, r22, i2, f3.z), this.addHalfVertex(f3, u22, c22, a2, true, -n22, i2, f3.z)), this.addVerticesTo(f3, d3, o2, l22, u22, c22, r22, n22, i2, a2));
              } else {
                const t3 = this.currentVertex;
                this.currentVertexIsOutside && (mh2(t3, f22, e3, h22), this.e1 = this.e2 = -1, this.lineSoFar = t3.w, this.addHalfVertex(t3, o2, l22, a2, false, r22, i2, t3.z), this.addHalfVertex(t3, u22, c22, a2, true, -n22, i2, t3.z)), this.addVerticesTo(t3, f22, o2, l22, u22, c22, r22, n22, i2, a2);
              }
            else
              d22 || (this.addHalfVertex(t22, o2, l22, a2, false, r22, i2, s2), this.addHalfVertex(t22, u22, c22, a2, true, -n22, i2, s2));
            this.currentVertex = f22, this.currentVertexIsOutside = d22, this.lineSoFar = m22;
          } else
            this.addHalfVertex(t22, o2, l22, a2, false, r22, i2, s2), this.addHalfVertex(t22, u22, c22, a2, true, -n22, i2, s2);
        }
        addHalfVertex({ x: t22, y: e22 }, r22, n22, i2, s2, a2, o2, l22) {
          this.patternJoinNone && (0 === this.segmentPoints.length && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), s2 || this.segmentPoints.push(this.lineSoFar - this.segmentStart, a2)), this.layoutVertexArray.emplaceBack((t22 << 1) + (i2 ? 1 : 0), (e22 << 1) + (s2 ? 1 : 0), Math.round(63 * r22) + 128, Math.round(63 * n22) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
          const u22 = o2.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u22), o2.primitiveLength++), s2 ? this.e2 = u22 : this.e1 = u22, null != l22 && this.zOffsetVertexArray.emplaceBack(l22);
        }
        updateScaledDistance() {
          if (this.lineClips) {
            const t22 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
            this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t22 * this.lineClips.start + this.distance;
          } else
            this.lineSoFar = this.distance;
        }
        updateDistance(t22, e22) {
          this.distance += t22.dist(e22), this.updateScaledDistance();
        }
      }
      function _p(t22, e22, r22) {
        return t22.x < e22 || t22.x > r22 || t22.y < e22 || t22.y > r22;
      }
      let Mp, Ap;
      function Sp(t22, e22, r22) {
        return e22 * (Hr / (t22.tileSize * Math.pow(2, r22 - t22.tileID.overscaledZ)));
      }
      function Ip(t22, e22) {
        return 1 / Sp(t22, 1, e22.tileZoom);
      }
      function Pp(t22, e22, r22, n22) {
        return t22.translatePosMatrix(n22 || e22.tileID.projMatrix, e22, r22.paint.get("line-translate"), r22.paint.get("line-translate-anchor"));
      }
      os(wp, "LineBucket", { omit: ["layers", "patternFeatures", "currentVertex", "currentVertexIsOutside"] });
      const zp = (t22) => {
        const e22 = [];
        kp(t22) && e22.push("RENDER_LINE_DASH"), t22.paint.get("line-gradient") && e22.push("RENDER_LINE_GRADIENT");
        const r22 = t22.paint.get("line-trim-offset");
        0 === r22[0] && 0 === r22[1] || e22.push("RENDER_LINE_TRIM_OFFSET"), 0 !== t22.paint.get("line-border-width").constantOr(1) && e22.push("RENDER_LINE_BORDER");
        const n22 = "none" === t22.layout.get("line-join").constantOr("miter"), i2 = !!t22.paint.get("line-pattern").constantOr(1);
        return n22 && i2 && e22.push("LINE_JOIN_NONE"), e22;
      };
      function kp(t22) {
        const e22 = t22.paint.get("line-dasharray").value;
        return e22.value || "constant" !== e22.kind;
      }
      let Tp;
      const Ep = () => Tp || (Tp = { layout: Mp || (Mp = new Gs({ "line-cap": new qs(Xs.layout_line["line-cap"]), "line-join": new qs(Xs.layout_line["line-join"]), "line-miter-limit": new Ns(Xs.layout_line["line-miter-limit"]), "line-round-limit": new Ns(Xs.layout_line["line-round-limit"]), "line-sort-key": new qs(Xs.layout_line["line-sort-key"]), "line-z-offset": new qs(Xs.layout_line["line-z-offset"]), visibility: new Ns(Xs.layout_line.visibility) })), paint: Ap || (Ap = new Gs({ "line-opacity": new qs(Xs.paint_line["line-opacity"]), "line-color": new qs(Xs.paint_line["line-color"]), "line-translate": new Ns(Xs.paint_line["line-translate"]), "line-translate-anchor": new Ns(Xs.paint_line["line-translate-anchor"]), "line-width": new qs(Xs.paint_line["line-width"]), "line-gap-width": new qs(Xs.paint_line["line-gap-width"]), "line-offset": new qs(Xs.paint_line["line-offset"]), "line-blur": new qs(Xs.paint_line["line-blur"]), "line-dasharray": new qs(Xs.paint_line["line-dasharray"]), "line-pattern": new qs(Xs.paint_line["line-pattern"]), "line-gradient": new $s(Xs.paint_line["line-gradient"]), "line-trim-offset": new Ns(Xs.paint_line["line-trim-offset"]), "line-trim-fade-range": new Ns(Xs.paint_line["line-trim-fade-range"]), "line-trim-color": new Ns(Xs.paint_line["line-trim-color"]), "line-emissive-strength": new Ns(Xs.paint_line["line-emissive-strength"]), "line-border-width": new qs(Xs.paint_line["line-border-width"]), "line-border-color": new qs(Xs.paint_line["line-border-color"]), "line-occlusion-opacity": new Ns(Xs.paint_line["line-occlusion-opacity"]) })) }, Tp);
      class Bp extends qs {
        possiblyEvaluate(t22, e22) {
          return e22 = new Vs(Math.floor(e22.zoom), { now: e22.now, fadeDuration: e22.fadeDuration, transition: e22.transition }), super.possiblyEvaluate(t22, e22);
        }
        evaluate(t22, e22, r22, n22) {
          return e22 = nt({}, e22, { zoom: Math.floor(e22.zoom) }), super.evaluate(t22, e22, r22, n22);
        }
      }
      let Vp;
      function Cp(t22, e22) {
        return e22 > 0 ? e22 + 2 * t22 : t22;
      }
      const Rp = ya2([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Dp = ya2([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), Lp = ya2([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
      ya2([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const Fp = ya2([{ name: "a_auto_z_offset", components: 1, type: "Float32" }], 4), Op = ya2([{ name: "a_texb", components: 2, type: "Uint16" }]), Up = ya2([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_elevation_from_sea", components: 2, type: "Float32" }]), jp = ya2([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }, { name: "a_auto_z_offset", components: 1, type: "Float32" }]);
      ya2([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const Np = ya2([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), qp = ya2([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      ya2([{ name: "triangle", components: 3, type: "Uint16" }]), ya2([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), ya2([{ type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Float32", name: "zOffset" }, { type: "Uint8", name: "hasIconTextFit" }]), ya2([{ type: "Float32", name: "offsetX" }]), ya2([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
      var $p = 24;
      const Gp = 128;
      function Xp(t22, e22) {
        const { expression: r22 } = e22;
        if ("constant" === r22.kind)
          return { kind: "constant", layoutSize: r22.evaluate(new Vs(t22 + 1)) };
        if ("source" === r22.kind)
          return { kind: "source" };
        {
          const { zoomStops: e3, interpolationType: n22 } = r22;
          let i2 = 0;
          for (; i2 < e3.length && e3[i2] <= t22; )
            i2++;
          i2 = Math.max(0, i2 - 1);
          let s2 = i2;
          for (; s2 < e3.length && e3[s2] < t22 + 1; )
            s2++;
          s2 = Math.min(e3.length - 1, s2);
          const a2 = e3[i2], o2 = e3[s2];
          return "composite" === r22.kind ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n22 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r22.evaluate(new Vs(a2)), maxSize: r22.evaluate(new Vs(o2)), interpolationType: n22 };
        }
      }
      function Yp(t22, { uSize: e22, uSizeT: r22 }, { lowerSize: n22, upperSize: i2 }) {
        return "source" === t22.kind ? n22 / Gp : "composite" === t22.kind ? ke2(n22 / Gp, i2 / Gp, r22) : e22;
      }
      function Zp(t22, e22) {
        let r22 = 0, n22 = 0;
        if ("constant" === t22.kind)
          n22 = t22.layoutSize;
        else if ("source" !== t22.kind) {
          const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t22, o2 = i2 ? Q2(si2.interpolationFactor(i2, e22, s2, a2), 0, 1) : 0;
          "camera" === t22.kind ? n22 = ke2(t22.minSize, t22.maxSize, o2) : r22 = o2;
        }
        return { uSizeT: r22, uSize: n22 };
      }
      var Wp = Object.freeze({ __proto__: null, SIZE_PACK_FACTOR: Gp, evaluateSizeForFeature: Yp, evaluateSizeForZoom: Zp, getSizeData: Xp });
      function Hp(t22, e22, r22) {
        return t22.sections.forEach((t3) => {
          t3.text = function(t4, e3, r3) {
            const n22 = e3.layout.get("text-transform").evaluate(r3, {});
            return "uppercase" === n22 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n22 && (t4 = t4.toLocaleLowerCase()), Bs.applyArabicShaping && (t4 = Bs.applyArabicShaping(t4)), t4;
          }(t3.text, e22, r22);
        }), t22;
      }
      const Kp = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂", "←": "↑", "→": "↓" };
      function Jp(t22) {
        return "︶" === t22 || "﹈" === t22 || "︸" === t22 || "﹄" === t22 || "﹂" === t22 || "︾" === t22 || "︼" === t22 || "︺" === t22 || "︘" === t22 || "﹀" === t22 || "︐" === t22 || "︓" === t22 || "︔" === t22 || "｀" === t22 || "￣" === t22 || "︑" === t22 || "︒" === t22;
      }
      function Qp(t22) {
        return "︵" === t22 || "﹇" === t22 || "︷" === t22 || "﹃" === t22 || "﹁" === t22 || "︽" === t22 || "︻" === t22 || "︹" === t22 || "︗" === t22 || "︿" === t22;
      }
      var tf2, ef2, rf2, nf2 = {};
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      function sf2() {
        return tf2 || (tf2 = 1, nf2.read = function(t22, e22, r22, n22, i2) {
          var s2, a2, o2 = 8 * i2 - n22 - 1, l22 = (1 << o2) - 1, u22 = l22 >> 1, c22 = -7, h22 = r22 ? i2 - 1 : 0, p22 = r22 ? -1 : 1, f22 = t22[e22 + h22];
          for (h22 += p22, s2 = f22 & (1 << -c22) - 1, f22 >>= -c22, c22 += o2; c22 > 0; s2 = 256 * s2 + t22[e22 + h22], h22 += p22, c22 -= 8)
            ;
          for (a2 = s2 & (1 << -c22) - 1, s2 >>= -c22, c22 += n22; c22 > 0; a2 = 256 * a2 + t22[e22 + h22], h22 += p22, c22 -= 8)
            ;
          if (0 === s2)
            s2 = 1 - u22;
          else {
            if (s2 === l22)
              return a2 ? NaN : 1 / 0 * (f22 ? -1 : 1);
            a2 += Math.pow(2, n22), s2 -= u22;
          }
          return (f22 ? -1 : 1) * a2 * Math.pow(2, s2 - n22);
        }, nf2.write = function(t22, e22, r22, n22, i2, s2) {
          var a2, o2, l22, u22 = 8 * s2 - i2 - 1, c22 = (1 << u22) - 1, h22 = c22 >> 1, p22 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f22 = n22 ? 0 : s2 - 1, d22 = n22 ? 1 : -1, m22 = e22 < 0 || 0 === e22 && 1 / e22 < 0 ? 1 : 0;
          for (e22 = Math.abs(e22), isNaN(e22) || e22 === 1 / 0 ? (o2 = isNaN(e22) ? 1 : 0, a2 = c22) : (a2 = Math.floor(Math.log(e22) / Math.LN2), e22 * (l22 = Math.pow(2, -a2)) < 1 && (a2--, l22 *= 2), (e22 += a2 + h22 >= 1 ? p22 / l22 : p22 * Math.pow(2, 1 - h22)) * l22 >= 2 && (a2++, l22 /= 2), a2 + h22 >= c22 ? (o2 = 0, a2 = c22) : a2 + h22 >= 1 ? (o2 = (e22 * l22 - 1) * Math.pow(2, i2), a2 += h22) : (o2 = e22 * Math.pow(2, h22 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t22[r22 + f22] = 255 & o2, f22 += d22, o2 /= 256, i2 -= 8)
            ;
          for (a2 = a2 << i2 | o2, u22 += i2; u22 > 0; t22[r22 + f22] = 255 & a2, f22 += d22, a2 /= 256, u22 -= 8)
            ;
          t22[r22 + f22 - d22] |= 128 * m22;
        }), nf2;
      }
      function af2() {
        if (rf2)
          return ef2;
        rf2 = 1, ef2 = e22;
        var t22 = sf2();
        function e22(t3) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t3) ? t3 : new Uint8Array(t3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        e22.Varint = 0, e22.Fixed64 = 1, e22.Bytes = 2, e22.Fixed32 = 5;
        var r22 = 4294967296, n22 = 1 / r22, i2 = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function s2(t3) {
          return t3.type === e22.Bytes ? t3.readVarint() + t3.pos : t3.pos + 1;
        }
        function a2(t3, e3, r3) {
          return r3 ? 4294967296 * e3 + (t3 >>> 0) : 4294967296 * (e3 >>> 0) + (t3 >>> 0);
        }
        function o2(t3, e3, r3) {
          var n3 = e3 <= 16383 ? 1 : e3 <= 2097151 ? 2 : e3 <= 268435455 ? 3 : Math.floor(Math.log(e3) / (7 * Math.LN2));
          r3.realloc(n3);
          for (var i3 = r3.pos - 1; i3 >= t3; i3--)
            r3.buf[i3 + n3] = r3.buf[i3];
        }
        function l22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeVarint(t3[r3]);
        }
        function u22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeSVarint(t3[r3]);
        }
        function c22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeFloat(t3[r3]);
        }
        function h22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeDouble(t3[r3]);
        }
        function p22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeBoolean(t3[r3]);
        }
        function f22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeFixed32(t3[r3]);
        }
        function d22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeSFixed32(t3[r3]);
        }
        function m22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeFixed64(t3[r3]);
        }
        function y22(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeSFixed64(t3[r3]);
        }
        function g22(t3, e3) {
          return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + 16777216 * t3[e3 + 3];
        }
        function x22(t3, e3, r3) {
          t3[r3] = e3, t3[r3 + 1] = e3 >>> 8, t3[r3 + 2] = e3 >>> 16, t3[r3 + 3] = e3 >>> 24;
        }
        function b22(t3, e3) {
          return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + (t3[e3 + 3] << 24);
        }
        return e22.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t3, e3, r3) {
          for (r3 = r3 || this.length; this.pos < r3; ) {
            var n3 = this.readVarint(), i3 = n3 >> 3, s3 = this.pos;
            this.type = 7 & n3, t3(i3, e3, this), this.pos === s3 && this.skip(n3);
          }
          return e3;
        }, readMessage: function(t3, e3) {
          return this.readFields(t3, e3, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t3 = g22(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readSFixed32: function() {
          var t3 = b22(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readFixed64: function() {
          var t3 = g22(this.buf, this.pos) + g22(this.buf, this.pos + 4) * r22;
          return this.pos += 8, t3;
        }, readSFixed64: function() {
          var t3 = g22(this.buf, this.pos) + b22(this.buf, this.pos + 4) * r22;
          return this.pos += 8, t3;
        }, readFloat: function() {
          var e3 = t22.read(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, e3;
        }, readDouble: function() {
          var e3 = t22.read(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, e3;
        }, readVarint: function(t3) {
          var e3, r3, n3 = this.buf;
          return e3 = 127 & (r3 = n3[this.pos++]), r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 7, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 14, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 21, r3 < 128 ? e3 : function(t4, e4, r4) {
            var n4, i3, s3 = r4.buf;
            if (n4 = (112 & (i3 = s3[r4.pos++])) >> 4, i3 < 128)
              return a2(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 3, i3 < 128)
              return a2(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 10, i3 < 128)
              return a2(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 17, i3 < 128)
              return a2(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 24, i3 < 128)
              return a2(t4, n4, e4);
            if (n4 |= (1 & (i3 = s3[r4.pos++])) << 31, i3 < 128)
              return a2(t4, n4, e4);
            throw new Error("Expected varint not more than 10 bytes");
          }(e3 |= (15 & (r3 = n3[this.pos])) << 28, t3, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t3 = this.readVarint();
          return t3 % 2 == 1 ? (t3 + 1) / -2 : t3 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t3 = this.readVarint() + this.pos, e3 = this.pos;
          return this.pos = t3, t3 - e3 >= 12 && i2 ? function(t4, e4, r3) {
            return i2.decode(t4.subarray(e4, r3));
          }(this.buf, e3, t3) : function(t4, e4, r3) {
            for (var n3 = "", i3 = e4; i3 < r3; ) {
              var s3, a3, o3, l3 = t4[i3], u3 = null, c3 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
              if (i3 + c3 > r3)
                break;
              1 === c3 ? l3 < 128 && (u3 = l3) : 2 === c3 ? 128 == (192 & (s3 = t4[i3 + 1])) && (u3 = (31 & l3) << 6 | 63 & s3) <= 127 && (u3 = null) : 3 === c3 ? (a3 = t4[i3 + 2], 128 == (192 & (s3 = t4[i3 + 1])) && 128 == (192 & a3) && ((u3 = (15 & l3) << 12 | (63 & s3) << 6 | 63 & a3) <= 2047 || u3 >= 55296 && u3 <= 57343) && (u3 = null)) : 4 === c3 && (a3 = t4[i3 + 2], o3 = t4[i3 + 3], 128 == (192 & (s3 = t4[i3 + 1])) && 128 == (192 & a3) && 128 == (192 & o3) && ((u3 = (15 & l3) << 18 | (63 & s3) << 12 | (63 & a3) << 6 | 63 & o3) <= 65535 || u3 >= 1114112) && (u3 = null)), null === u3 ? (u3 = 65533, c3 = 1) : u3 > 65535 && (u3 -= 65536, n3 += String.fromCharCode(u3 >>> 10 & 1023 | 55296), u3 = 56320 | 1023 & u3), n3 += String.fromCharCode(u3), i3 += c3;
            }
            return n3;
          }(this.buf, e3, t3);
        }, readBytes: function() {
          var t3 = this.readVarint() + this.pos, e3 = this.buf.subarray(this.pos, t3);
          return this.pos = t3, e3;
        }, readPackedVarint: function(t3, r3) {
          if (this.type !== e22.Bytes)
            return t3.push(this.readVarint(r3));
          var n3 = s2(this);
          for (t3 = t3 || []; this.pos < n3; )
            t3.push(this.readVarint(r3));
          return t3;
        }, readPackedSVarint: function(t3) {
          if (this.type !== e22.Bytes)
            return t3.push(this.readSVarint());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; )
            t3.push(this.readSVarint());
          return t3;
        }, readPackedBoolean: function(t3) {
          if (this.type !== e22.Bytes)
            return t3.push(this.readBoolean());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; )
            t3.push(this.readBoolean());
          return t3;
        }, readPackedFloat: function(t3) {
          if (this.type !== e22.Bytes)
            return t3.push(this.readFloat());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; )
            t3.push(this.readFloat());
          return t3;
        }, readPackedDouble: function(t3) {
          if (this.type !== e22.Bytes)
            return t3.push(this.readDouble());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; )
            t3.push(this.readDouble());
          return t3;
        }, readPackedFixed32: function(t3) {
          if (this.type !== e22.Bytes)
            return t3.push(this.readFixed32());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; )
            t3.push(this.readFixed32());
          return t3;
        }, readPackedSFixed32: function(t3) {
          if (this.type !== e22.Bytes)
            return t3.push(this.readSFixed32());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; )
            t3.push(this.readSFixed32());
          return t3;
        }, readPackedFixed64: function(t3) {
          if (this.type !== e22.Bytes)
            return t3.push(this.readFixed64());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; )
            t3.push(this.readFixed64());
          return t3;
        }, readPackedSFixed64: function(t3) {
          if (this.type !== e22.Bytes)
            return t3.push(this.readSFixed64());
          var r3 = s2(this);
          for (t3 = t3 || []; this.pos < r3; )
            t3.push(this.readSFixed64());
          return t3;
        }, skip: function(t3) {
          var r3 = 7 & t3;
          if (r3 === e22.Varint)
            for (; this.buf[this.pos++] > 127; )
              ;
          else if (r3 === e22.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (r3 === e22.Fixed32)
            this.pos += 4;
          else {
            if (r3 !== e22.Fixed64)
              throw new Error("Unimplemented type: " + r3);
            this.pos += 8;
          }
        }, writeTag: function(t3, e3) {
          this.writeVarint(t3 << 3 | e3);
        }, realloc: function(t3) {
          for (var e3 = this.length || 16; e3 < this.pos + t3; )
            e3 *= 2;
          if (e3 !== this.length) {
            var r3 = new Uint8Array(e3);
            r3.set(this.buf), this.buf = r3, this.length = e3;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t3) {
          this.realloc(4), x22(this.buf, t3, this.pos), this.pos += 4;
        }, writeSFixed32: function(t3) {
          this.realloc(4), x22(this.buf, t3, this.pos), this.pos += 4;
        }, writeFixed64: function(t3) {
          this.realloc(8), x22(this.buf, -1 & t3, this.pos), x22(this.buf, Math.floor(t3 * n22), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t3) {
          this.realloc(8), x22(this.buf, -1 & t3, this.pos), x22(this.buf, Math.floor(t3 * n22), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t3) {
          (t3 = +t3 || 0) > 268435455 || t3 < 0 ? function(t4, e3) {
            var r3, n3;
            if (t4 >= 0 ? (r3 = t4 % 4294967296 | 0, n3 = t4 / 4294967296 | 0) : (n3 = ~(-t4 / 4294967296), 4294967295 ^ (r3 = ~(-t4 % 4294967296)) ? r3 = r3 + 1 | 0 : (r3 = 0, n3 = n3 + 1 | 0)), t4 >= 18446744073709552e3 || t4 < -18446744073709552e3)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e3.realloc(10), function(t5, e4, r4) {
              r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, r4.buf[r4.pos] = 127 & (t5 >>>= 7);
            }(r3, 0, e3), function(t5, e4) {
              var r4 = (7 & t5) << 4;
              e4.buf[e4.pos++] |= r4 | ((t5 >>>= 3) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5)))));
            }(n3, e3);
          }(t3, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t3 | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = t3 >>> 7 & 127))));
        }, writeSVarint: function(t3) {
          this.writeVarint(t3 < 0 ? 2 * -t3 - 1 : 2 * t3);
        }, writeBoolean: function(t3) {
          this.writeVarint(Boolean(t3));
        }, writeString: function(t3) {
          t3 = String(t3), this.realloc(4 * t3.length), this.pos++;
          var e3 = this.pos;
          this.pos = function(t4, e4, r4) {
            for (var n3, i3, s3 = 0; s3 < e4.length; s3++) {
              if ((n3 = e4.charCodeAt(s3)) > 55295 && n3 < 57344) {
                if (!i3) {
                  n3 > 56319 || s3 + 1 === e4.length ? (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189) : i3 = n3;
                  continue;
                }
                if (n3 < 56320) {
                  t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = n3;
                  continue;
                }
                n3 = i3 - 55296 << 10 | n3 - 56320 | 65536, i3 = null;
              } else
                i3 && (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = null);
              n3 < 128 ? t4[r4++] = n3 : (n3 < 2048 ? t4[r4++] = n3 >> 6 | 192 : (n3 < 65536 ? t4[r4++] = n3 >> 12 | 224 : (t4[r4++] = n3 >> 18 | 240, t4[r4++] = n3 >> 12 & 63 | 128), t4[r4++] = n3 >> 6 & 63 | 128), t4[r4++] = 63 & n3 | 128);
            }
            return r4;
          }(this.buf, t3, this.pos);
          var r3 = this.pos - e3;
          r3 >= 128 && o2(e3, r3, this), this.pos = e3 - 1, this.writeVarint(r3), this.pos += r3;
        }, writeFloat: function(e3) {
          this.realloc(4), t22.write(this.buf, e3, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(e3) {
          this.realloc(8), t22.write(this.buf, e3, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t3) {
          var e3 = t3.length;
          this.writeVarint(e3), this.realloc(e3);
          for (var r3 = 0; r3 < e3; r3++)
            this.buf[this.pos++] = t3[r3];
        }, writeRawMessage: function(t3, e3) {
          this.pos++;
          var r3 = this.pos;
          t3(e3, this);
          var n3 = this.pos - r3;
          n3 >= 128 && o2(r3, n3, this), this.pos = r3 - 1, this.writeVarint(n3), this.pos += n3;
        }, writeMessage: function(t3, r3, n3) {
          this.writeTag(t3, e22.Bytes), this.writeRawMessage(r3, n3);
        }, writePackedVarint: function(t3, e3) {
          e3.length && this.writeMessage(t3, l22, e3);
        }, writePackedSVarint: function(t3, e3) {
          e3.length && this.writeMessage(t3, u22, e3);
        }, writePackedBoolean: function(t3, e3) {
          e3.length && this.writeMessage(t3, p22, e3);
        }, writePackedFloat: function(t3, e3) {
          e3.length && this.writeMessage(t3, c22, e3);
        }, writePackedDouble: function(t3, e3) {
          e3.length && this.writeMessage(t3, h22, e3);
        }, writePackedFixed32: function(t3, e3) {
          e3.length && this.writeMessage(t3, f22, e3);
        }, writePackedSFixed32: function(t3, e3) {
          e3.length && this.writeMessage(t3, d22, e3);
        }, writePackedFixed64: function(t3, e3) {
          e3.length && this.writeMessage(t3, m22, e3);
        }, writePackedSFixed64: function(t3, e3) {
          e3.length && this.writeMessage(t3, y22, e3);
        }, writeBytesField: function(t3, r3) {
          this.writeTag(t3, e22.Bytes), this.writeBytes(r3);
        }, writeFixed32Field: function(t3, r3) {
          this.writeTag(t3, e22.Fixed32), this.writeFixed32(r3);
        }, writeSFixed32Field: function(t3, r3) {
          this.writeTag(t3, e22.Fixed32), this.writeSFixed32(r3);
        }, writeFixed64Field: function(t3, r3) {
          this.writeTag(t3, e22.Fixed64), this.writeFixed64(r3);
        }, writeSFixed64Field: function(t3, r3) {
          this.writeTag(t3, e22.Fixed64), this.writeSFixed64(r3);
        }, writeVarintField: function(t3, r3) {
          this.writeTag(t3, e22.Varint), this.writeVarint(r3);
        }, writeSVarintField: function(t3, r3) {
          this.writeTag(t3, e22.Varint), this.writeSVarint(r3);
        }, writeStringField: function(t3, r3) {
          this.writeTag(t3, e22.Bytes), this.writeString(r3);
        }, writeFloatField: function(t3, r3) {
          this.writeTag(t3, e22.Fixed32), this.writeFloat(r3);
        }, writeDoubleField: function(t3, r3) {
          this.writeTag(t3, e22.Fixed64), this.writeDouble(r3);
        }, writeBooleanField: function(t3, e3) {
          this.writeVarintField(t3, Boolean(e3));
        } }, ef2;
      }
      var of2 = e2(af2());
      const lf2 = 3;
      function uf2(t22, e22, r22) {
        e22.glyphs = [], 1 === t22 && r22.readMessage(cf2, e22);
      }
      function cf2(t22, e22, r22) {
        if (3 === t22) {
          const { id: t3, bitmap: n22, width: i2, height: s2, left: a2, top: o2, advance: l22 } = r22.readMessage(hf, {});
          e22.glyphs.push({ id: t3, bitmap: new nc2({ width: i2 + 2 * lf2, height: s2 + 2 * lf2 }, n22), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l22 } });
        } else
          4 === t22 ? e22.ascender = r22.readSVarint() : 5 === t22 && (e22.descender = r22.readSVarint());
      }
      function hf(t22, e22, r22) {
        1 === t22 ? e22.id = r22.readVarint() : 2 === t22 ? e22.bitmap = r22.readBytes() : 3 === t22 ? e22.width = r22.readVarint() : 4 === t22 ? e22.height = r22.readVarint() : 5 === t22 ? e22.left = r22.readSVarint() : 6 === t22 ? e22.top = r22.readSVarint() : 7 === t22 && (e22.advance = r22.readVarint());
      }
      const pf2 = lf2, ff2 = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
      class df2 {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(t22, e22) {
          const r22 = new df2();
          return r22.scale = t22 || 1, r22.fontStack = e22, r22;
        }
        static forImage(t22) {
          const e22 = new df2();
          return e22.imageName = t22, e22;
        }
      }
      class mf2 {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(t22, e22) {
          const r22 = new mf2();
          for (let n22 = 0; n22 < t22.sections.length; n22++) {
            const i2 = t22.sections[n22];
            i2.image ? r22.addImageSection(i2) : r22.addTextSection(i2, e22);
          }
          return r22;
        }
        length() {
          return this.text.length;
        }
        getSection(t22) {
          return this.sections[this.sectionIndex[t22]];
        }
        getSections() {
          return this.sections;
        }
        getSectionIndex(t22) {
          return this.sectionIndex[t22];
        }
        getCodePoint(t22) {
          return this.text.codePointAt(t22);
        }
        verticalizePunctuation(t22) {
          this.text = function(t3, e22) {
            let r22 = "";
            for (let n22 = 0; n22 < t3.length; n22++) {
              const i2 = t3.charCodeAt(n22 + 1) || null, s2 = t3.charCodeAt(n22 - 1) || null;
              r22 += !e22 && (i2 && gs(i2) && !Kp[t3[n22 + 1]] || s2 && gs(s2) && !Kp[t3[n22 - 1]]) || !Kp[t3[n22]] ? t3[n22] : Kp[t3[n22]];
            }
            return r22;
          }(this.text, t22);
        }
        trim() {
          let t22 = 0;
          for (let e3 = 0; e3 < this.text.length && gf[this.text.charCodeAt(e3)]; e3++)
            t22++;
          let e22 = this.text.length;
          for (let r22 = this.text.length - 1; r22 >= 0 && r22 >= t22 && gf[this.text.charCodeAt(r22)]; r22--)
            e22--;
          this.text = this.text.substring(t22, e22), this.sectionIndex = this.sectionIndex.slice(t22, e22);
        }
        substring(t22, e22) {
          const r22 = new mf2();
          return r22.text = this.text.substring(t22, e22), r22.sectionIndex = this.sectionIndex.slice(t22, e22), r22.sections = this.sections, r22;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((t22, e22) => Math.max(t22, this.sections[e22].scale), 0);
        }
        addTextSection(t22, e22) {
          this.text += t22.text, this.sections.push(df2.forText(t22.scale, t22.fontStack || e22));
          const r22 = this.sections.length - 1;
          for (let e3 = 0; e3 < t22.text.length; ++e3)
            this.sectionIndex.push(r22);
        }
        addImageSection(t22) {
          const e22 = t22.image ? t22.image.namePrimary : "";
          if (0 === e22.length)
            return void ft("Can't add FormattedSection with an empty image.");
          const r22 = this.getNextImageSectionCharCode();
          r22 ? (this.text += String.fromCodePoint(r22), this.sections.push(df2.forImage(e22)), this.sectionIndex.push(this.sections.length - 1)) : ft("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function yf2(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22, f22, d22) {
        const m22 = mf2.fromFeature(t22, i2);
        h22 === ff2.vertical && m22.verticalizePunctuation(p22);
        let y22 = [];
        const g22 = function(t3, e3, r3, n3, i3, s3) {
          if (!t3)
            return [];
          const a3 = [], o3 = function(t4, e4, r4, n4, i4, s4) {
            let a4 = 0;
            for (let r5 = 0; r5 < t4.length(); r5++) {
              const o4 = t4.getSection(r5);
              a4 += bf2(t4.getCodePoint(r5), o4, n4, i4, e4, s4);
            }
            return a4 / Math.max(1, Math.ceil(a4 / r4));
          }(t3, e3, r3, n3, i3, s3), l3 = t3.text.indexOf("​") >= 0;
          let u3 = 0;
          for (let r4 = 0; r4 < t3.length(); r4++) {
            const h3 = t3.getSection(r4), p3 = t3.getCodePoint(r4);
            if (gf[p3] || (u3 += bf2(p3, h3, n3, i3, e3, s3)), r4 < t3.length() - 1) {
              const e4 = !((c3 = p3) < 11904 || !(ps["Bopomofo Extended"](c3) || ps.Bopomofo(c3) || ps["CJK Compatibility Forms"](c3) || ps["CJK Compatibility Ideographs"](c3) || ps["CJK Compatibility"](c3) || ps["CJK Radicals Supplement"](c3) || ps["CJK Strokes"](c3) || ps["CJK Symbols and Punctuation"](c3) || ps["CJK Unified Ideographs Extension A"](c3) || ps["CJK Unified Ideographs"](c3) || ps["Enclosed CJK Letters and Months"](c3) || ps["Halfwidth and Fullwidth Forms"](c3) || ps.Hiragana(c3) || ps["Ideographic Description Characters"](c3) || ps["Kangxi Radicals"](c3) || ps["Katakana Phonetic Extensions"](c3) || ps.Katakana(c3) || ps["Vertical Forms"](c3) || ps["Yi Radicals"](c3) || ps["Yi Syllables"](c3)));
              (xf2[p3] || e4 || h3.imageName) && a3.push(_f(r4 + 1, u3, o3, a3, wf2(p3, t3.getCodePoint(r4 + 1), e4 && l3), false));
            }
          }
          var c3;
          return Mf2(_f(t3.length(), u3, o3, a3, 0, true));
        }(m22, u22, s2, e22, n22, f22), { processBidirectionalText: x22, processStyledBidirectionalText: b22 } = Bs;
        if (x22 && 1 === m22.sections.length) {
          const t3 = x22(m22.toString(), g22);
          for (const e3 of t3) {
            const t4 = new mf2();
            t4.text = e3, t4.sections = m22.sections;
            for (let r3 = 0; r3 < e3.length; r3++)
              t4.sectionIndex.push(0);
            y22.push(t4);
          }
        } else if (b22) {
          const t3 = b22(m22.text, m22.sectionIndex, g22);
          for (const e3 of t3) {
            const t4 = new mf2();
            t4.text = e3[0], t4.sectionIndex = e3[1], t4.sections = m22.sections, y22.push(t4);
          }
        } else
          y22 = function(t3, e3) {
            const r3 = [], n3 = t3.text;
            let i3 = 0;
            for (const n4 of e3)
              r3.push(t3.substring(i3, n4)), i3 = n4;
            return i3 < n3.length && r3.push(t3.substring(i3, n3.length)), r3;
          }(m22, g22);
        const v22 = [], w22 = { positionedLines: v22, text: m22.toString(), top: c22[1], bottom: c22[1], left: c22[0], right: c22[0], writingMode: h22, iconsInText: false, verticalizable: false, hasBaseline: false };
        return function(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3, h3) {
          let p3 = 0, f3 = 0, d3 = 0;
          const m3 = "right" === o3 ? 1 : "left" === o3 ? 0 : 0.5;
          let y3 = false;
          for (const t4 of i3) {
            const r4 = t4.getSections();
            for (const t5 of r4) {
              if (t5.imageName)
                continue;
              const r5 = e3[t5.fontStack];
              if (r5 && (y3 = void 0 !== r5.ascender && void 0 !== r5.descender, !y3))
                break;
            }
            if (!y3)
              break;
          }
          let g3 = 0;
          for (const a4 of i3) {
            a4.trim();
            const i4 = a4.getMaxScale(), o4 = (i4 - 1) * $p, b4 = { positionedGlyphs: [], lineOffset: 0 };
            t3.positionedLines[g3] = b4;
            const v4 = b4.positionedGlyphs;
            let w4 = 0;
            if (!a4.length()) {
              f3 += s3, ++g3;
              continue;
            }
            let _2 = 0, M22 = 0;
            for (let s4 = 0; s4 < a4.length(); s4++) {
              const o5 = a4.getSection(s4), d4 = a4.getSectionIndex(s4), m4 = a4.getCodePoint(s4);
              let g4 = o5.scale, b5 = null, A3 = null, S22 = null, I22 = $p, P22 = 0;
              const z22 = !(l3 === ff2.horizontal || !c3 && !ys(m4) || c3 && (gf[m4] || (x3 = m4, ps.Arabic(x3) || ps["Arabic Supplement"](x3) || ps["Arabic Extended-A"](x3) || ps["Arabic Presentation Forms-A"](x3) || ps["Arabic Presentation Forms-B"](x3))));
              if (o5.imageName) {
                const e4 = n3[o5.imageName];
                if (!e4)
                  continue;
                S22 = o5.imageName, t3.iconsInText = t3.iconsInText || true, A3 = e4.paddedRect;
                const r4 = e4.displaySize;
                g4 = g4 * $p / h3, b5 = { width: r4[0], height: r4[1], left: 0, top: -pf2, advance: z22 ? r4[1] : r4[0], localGlyph: false }, P22 = y3 ? -b5.height * g4 : i4 * $p - 17 - r4[1] * g4, I22 = b5.advance;
                const s5 = (z22 ? r4[0] : r4[1]) * g4 - $p * i4;
                s5 > 0 && s5 > w4 && (w4 = s5);
              } else {
                const t4 = r3[o5.fontStack];
                if (!t4)
                  continue;
                t4[m4] && (A3 = t4[m4]);
                const n4 = e3[o5.fontStack];
                if (!n4)
                  continue;
                const s5 = n4.glyphs[m4];
                if (!s5)
                  continue;
                if (b5 = s5.metrics, I22 = 8203 !== m4 ? $p : 0, y3) {
                  const t5 = void 0 !== n4.ascender ? Math.abs(n4.ascender) : 0, e4 = void 0 !== n4.descender ? Math.abs(n4.descender) : 0, r4 = (t5 + e4) * g4;
                  _2 < r4 && (_2 = r4, M22 = (t5 - e4) / 2 * g4), P22 = -t5 * g4;
                } else
                  P22 = (i4 - g4) * $p - 17;
              }
              z22 ? (t3.verticalizable = true, v4.push({ glyph: m4, imageName: S22, x: p3, y: f3 + P22, vertical: z22, scale: g4, localGlyph: b5.localGlyph, fontStack: o5.fontStack, sectionIndex: d4, metrics: b5, rect: A3 }), p3 += I22 * g4 + u3) : (v4.push({ glyph: m4, imageName: S22, x: p3, y: f3 + P22, vertical: z22, scale: g4, localGlyph: b5.localGlyph, fontStack: o5.fontStack, sectionIndex: d4, metrics: b5, rect: A3 }), p3 += b5.advance * g4 + u3);
            }
            0 !== v4.length && (d3 = Math.max(p3 - u3, d3), y3 ? Sf2(v4, m3, w4, M22, s3 * i4 / 2) : Sf2(v4, m3, w4, 0, s3 / 2)), p3 = 0;
            const A22 = s3 * i4 + w4;
            b4.lineOffset = Math.max(w4, o4), f3 += A22, ++g3;
          }
          var x3;
          const b3 = f3, { horizontalAlign: v3, verticalAlign: w3 } = Af2(a3);
          (function(t4, e4, r4, n4, i4, s4) {
            const a4 = (e4 - r4) * i4, o4 = -s4 * n4;
            for (const e5 of t4)
              for (const t5 of e5.positionedGlyphs)
                t5.x += a4, t5.y += o4;
          })(t3.positionedLines, m3, v3, w3, d3, b3), t3.top += -w3 * b3, t3.bottom = t3.top + b3, t3.left += -v3 * d3, t3.right = t3.left + d3, t3.hasBaseline = y3;
        }(w22, e22, r22, n22, y22, a2, o2, l22, h22, u22, p22, d22), !function(t3) {
          for (const e3 of t3)
            if (0 !== e3.positionedGlyphs.length)
              return false;
          return true;
        }(v22) && w22;
      }
      const gf = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, xf2 = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
      function bf2(t22, e22, r22, n22, i2, s2) {
        if (e22.imageName) {
          const t3 = n22[e22.imageName];
          return t3 ? t3.displaySize[0] * e22.scale * $p / s2 + i2 : 0;
        }
        {
          const n3 = r22[e22.fontStack], s3 = n3 && n3.glyphs[t22];
          return s3 ? s3.metrics.advance * e22.scale + i2 : 0;
        }
      }
      function vf2(t22, e22, r22, n22) {
        const i2 = Math.pow(t22 - e22, 2);
        return n22 ? t22 < e22 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r22) * r22;
      }
      function wf2(t22, e22, r22) {
        let n22 = 0;
        return 10 === t22 && (n22 -= 1e4), r22 && (n22 += 150), 40 !== t22 && 65288 !== t22 || (n22 += 50), 41 !== e22 && 65289 !== e22 || (n22 += 50), n22;
      }
      function _f(t22, e22, r22, n22, i2, s2) {
        let a2 = null, o2 = vf2(e22, r22, i2, s2);
        for (const t3 of n22) {
          const n3 = vf2(e22 - t3.x, r22, i2, s2) + t3.badness;
          n3 <= o2 && (a2 = t3, o2 = n3);
        }
        return { index: t22, x: e22, priorBreak: a2, badness: o2 };
      }
      function Mf2(t22) {
        return t22 ? Mf2(t22.priorBreak).concat(t22.index) : [];
      }
      function Af2(t22) {
        let e22 = 0.5, r22 = 0.5;
        switch (t22) {
          case "right":
          case "top-right":
          case "bottom-right":
            e22 = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e22 = 0;
        }
        switch (t22) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            r22 = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            r22 = 0;
        }
        return { horizontalAlign: e22, verticalAlign: r22 };
      }
      function Sf2(t22, e22, r22, n22, i2) {
        if (!(e22 || r22 || n22 || i2))
          return;
        const s2 = t22.length - 1, a2 = t22[s2], o2 = (a2.x + a2.metrics.advance * a2.scale) * e22;
        for (let e3 = 0; e3 <= s2; e3++)
          t22[e3].x -= o2, t22[e3].y += r22 + n22 + i2;
      }
      function If2(t22, e22, r22, n22) {
        const { horizontalAlign: i2, verticalAlign: s2 } = Af2(n22), a2 = r22[0] - t22.displaySize[0] * i2, o2 = r22[1] - t22.displaySize[1] * s2;
        return { imagePrimary: t22, imageSecondary: e22, top: o2, bottom: o2 + t22.displaySize[1], left: a2, right: a2 + t22.displaySize[0] };
      }
      function Pf2(t22, e22, r22, n22, i2, s2) {
        const a2 = t22.imagePrimary;
        let o2;
        if (a2.content) {
          const t3 = a2.content, e3 = a2.pixelRatio || 1;
          o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
        }
        const l22 = e22.left * s2, u22 = e22.right * s2;
        let c22, h22, p22, f22;
        "width" === r22 || "both" === r22 ? (f22 = i2[0] + l22 - n22[3], h22 = i2[0] + u22 + n22[1]) : (f22 = i2[0] + (l22 + u22 - a2.displaySize[0]) / 2, h22 = f22 + a2.displaySize[0]);
        const d22 = e22.top * s2, m22 = e22.bottom * s2;
        return "height" === r22 || "both" === r22 ? (c22 = i2[1] + d22 - n22[0], p22 = i2[1] + m22 + n22[2]) : (c22 = i2[1] + (d22 + m22 - a2.displaySize[1]) / 2, p22 = c22 + a2.displaySize[1]), { imagePrimary: a2, imageSecondary: void 0, top: c22, right: h22, bottom: p22, left: f22, collisionPadding: o2 };
      }
      class zf2 extends q2 {
        constructor(t22, e22, r22, n22, i2) {
          super(t22, e22), this.angle = n22, this.z = r22, void 0 !== i2 && (this.segment = i2);
        }
        clone() {
          return new zf2(this.x, this.y, this.z, this.angle, this.segment);
        }
      }
      function kf(t22, e22, r22, n22, i2) {
        if (void 0 === e22.segment)
          return true;
        let s2 = e22, a2 = e22.segment + 1, o2 = 0;
        for (; o2 > -r22 / 2; ) {
          if (a2--, a2 < 0)
            return false;
          o2 -= t22[a2].dist(s2), s2 = t22[a2];
        }
        o2 += t22[a2].dist(t22[a2 + 1]), a2++;
        const l22 = [];
        let u22 = 0;
        for (; o2 < r22 / 2; ) {
          const e3 = t22[a2], r3 = t22[a2 + 1];
          if (!r3)
            return false;
          let s3 = t22[a2 - 1].angleTo(e3) - e3.angleTo(r3);
          for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l22.push({ distance: o2, angleDelta: s3 }), u22 += s3; o2 - l22[0].distance > n22; )
            u22 -= l22.shift().angleDelta;
          if (u22 > i2)
            return false;
          a2++, o2 += e3.dist(r3);
        }
        return true;
      }
      function Tf2(t22) {
        let e22 = 0;
        for (let r22 = 0; r22 < t22.length - 1; r22++)
          e22 += t22[r22].dist(t22[r22 + 1]);
        return e22;
      }
      function Ef2(t22, e22, r22) {
        return t22 ? 0.6 * e22 * r22 : 0;
      }
      function Bf2(t22, e22) {
        return Math.max(t22 ? t22.right - t22.left : 0, e22 ? e22.right - e22.left : 0);
      }
      function Vf2(t22, e22, r22, n22, i2, s2) {
        const a2 = Ef2(r22, i2, s2), o2 = Bf2(r22, n22) * s2;
        let l22 = 0;
        const u22 = Tf2(t22) / 2;
        for (let r3 = 0; r3 < t22.length - 1; r3++) {
          const n3 = t22[r3], i3 = t22[r3 + 1], s3 = n3.dist(i3);
          if (l22 + s3 > u22) {
            const c22 = (u22 - l22) / s3, h22 = ke2(n3.x, i3.x, c22), p22 = ke2(n3.y, i3.y, c22), f22 = new zf2(h22, p22, 0, i3.angleTo(n3), r3);
            return !a2 || kf(t22, f22, o2, a2, e22) ? f22 : void 0;
          }
          l22 += s3;
        }
      }
      function Cf2(t22, e22, r22, n22, i2, s2, a2, o2, l22) {
        const u22 = Ef2(n22, s2, a2), c22 = Bf2(n22, i2), h22 = c22 * a2, p22 = 0 === t22[0].x || t22[0].x === l22 || 0 === t22[0].y || t22[0].y === l22;
        return e22 - h22 < e22 / 4 && (e22 = h22 + e22 / 4), Rf2(t22, p22 ? e22 / 2 * o2 % e22 : (c22 / 2 + 2 * s2) * a2 * o2 % e22, e22, u22, r22, h22, p22, false, l22);
      }
      function Rf2(t22, e22, r22, n22, i2, s2, a2, o2, l22) {
        const u22 = s2 / 2, c22 = Tf2(t22);
        let h22 = 0, p22 = e22 - r22, f22 = [];
        for (let e3 = 0; e3 < t22.length - 1; e3++) {
          const a3 = t22[e3], o3 = t22[e3 + 1], d22 = a3.dist(o3), m22 = o3.angleTo(a3);
          for (; p22 + r22 < h22 + d22; ) {
            p22 += r22;
            const y22 = (p22 - h22) / d22, g22 = ke2(a3.x, o3.x, y22), x22 = ke2(a3.y, o3.y, y22);
            if (g22 >= 0 && g22 < l22 && x22 >= 0 && x22 < l22 && p22 - u22 >= 0 && p22 + u22 <= c22) {
              const r3 = new zf2(g22, x22, 0, m22, e3);
              n22 && !kf(t22, r3, s2, n22, i2) || f22.push(r3);
            }
          }
          h22 += d22;
        }
        return o2 || f22.length || a2 || (f22 = Rf2(t22, h22 / 2, r22, n22, i2, s2, a2, true, l22)), f22;
      }
      function Df2(t22, e22, r22, n22, i2) {
        const s2 = [];
        for (let a2 = 0; a2 < t22.length; a2++) {
          const o2 = t22[a2];
          let l22;
          for (let t3 = 0; t3 < o2.length - 1; t3++) {
            let a3 = o2[t3], u22 = o2[t3 + 1];
            a3.x < e22 && u22.x < e22 || (a3.x < e22 ? a3 = new q2(e22, a3.y + (e22 - a3.x) / (u22.x - a3.x) * (u22.y - a3.y))._round() : u22.x < e22 && (u22 = new q2(e22, a3.y + (e22 - a3.x) / (u22.x - a3.x) * (u22.y - a3.y))._round()), a3.y < r22 && u22.y < r22 || (a3.y < r22 ? a3 = new q2(a3.x + (r22 - a3.y) / (u22.y - a3.y) * (u22.x - a3.x), r22)._round() : u22.y < r22 && (u22 = new q2(a3.x + (r22 - a3.y) / (u22.y - a3.y) * (u22.x - a3.x), r22)._round()), a3.x >= n22 && u22.x >= n22 || (a3.x >= n22 ? a3 = new q2(n22, a3.y + (n22 - a3.x) / (u22.x - a3.x) * (u22.y - a3.y))._round() : u22.x >= n22 && (u22 = new q2(n22, a3.y + (n22 - a3.x) / (u22.x - a3.x) * (u22.y - a3.y))._round()), a3.y >= i2 && u22.y >= i2 || (a3.y >= i2 ? a3 = new q2(a3.x + (i2 - a3.y) / (u22.y - a3.y) * (u22.x - a3.x), i2)._round() : u22.y >= i2 && (u22 = new q2(a3.x + (i2 - a3.y) / (u22.y - a3.y) * (u22.x - a3.x), i2)._round()), l22 && a3.equals(l22[l22.length - 1]) || (l22 = [a3], s2.push(l22)), l22.push(u22)))));
          }
        }
        return s2;
      }
      function Lf2(t22) {
        let e22 = 0, r22 = 0;
        for (const n3 of t22)
          e22 += n3.w * n3.h, r22 = Math.max(r22, n3.w);
        t22.sort((t3, e3) => e3.h - t3.h);
        const n22 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e22 / 0.95)), r22), h: 1 / 0 }];
        let i2 = 0, s2 = 0;
        for (const e3 of t22)
          for (let t3 = n22.length - 1; t3 >= 0; t3--) {
            const r3 = n22[t3];
            if (!(e3.w > r3.w || e3.h > r3.h)) {
              if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                const e4 = n22.pop();
                t3 < n22.length && (n22[t3] = e4);
              } else
                e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n22.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
              break;
            }
          }
        return { w: i2, h: s2, fill: e22 / (i2 * s2) || 0 };
      }
      os(zf2, "Anchor");
      const Ff2 = 1;
      class Of2 {
        constructor(t22, { pixelRatio: e22, version: r22, stretchX: n22, stretchY: i2, content: s2 }, a2) {
          this.paddedRect = t22, this.pixelRatio = e22, this.stretchX = n22, this.stretchY = i2, this.content = s2, this.version = r22, this.padding = a2;
        }
        get tl() {
          return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding];
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * this.padding) / this.pixelRatio, (this.paddedRect.h - 2 * this.padding) / this.pixelRatio];
        }
      }
      class Uf2 {
        constructor(t22, e22, r22) {
          const n22 = {}, i2 = {};
          this.haveRenderCallbacks = [];
          const s2 = [];
          this.addImages(t22, n22, Ff2, s2), this.addImages(e22, i2, 2, s2);
          const { w: a2, h: o2 } = Lf2(s2), l22 = new ic2({ width: a2 || 1, height: o2 || 1 });
          for (const e3 in t22) {
            const i3 = t22[e3], s3 = n22[e3].paddedRect;
            ic2.copy(i3.data, l22, { x: 0, y: 0 }, { x: s3.x + Ff2, y: s3.y + Ff2 }, i3.data, r22, i3.sdf);
          }
          for (const t3 in e22) {
            const n3 = e22[t3], s3 = i2[t3].paddedRect;
            let a3 = i2[t3].padding;
            const o3 = s3.x + a3, u22 = s3.y + a3, c22 = n3.data.width, h22 = n3.data.height;
            a3 = a3 > 1 ? a3 - 1 : a3, ic2.copy(n3.data, l22, { x: 0, y: 0 }, { x: o3, y: u22 }, n3.data, r22), ic2.copy(n3.data, l22, { x: 0, y: h22 - a3 }, { x: o3, y: u22 - a3 }, { width: c22, height: a3 }, r22), ic2.copy(n3.data, l22, { x: 0, y: 0 }, { x: o3, y: u22 + h22 }, { width: c22, height: a3 }, r22), ic2.copy(n3.data, l22, { x: c22 - a3, y: 0 }, { x: o3 - a3, y: u22 }, { width: a3, height: h22 }, r22), ic2.copy(n3.data, l22, { x: 0, y: 0 }, { x: o3 + c22, y: u22 }, { width: a3, height: h22 }, r22), ic2.copy(n3.data, l22, { x: c22 - a3, y: h22 - a3 }, { x: o3 - a3, y: u22 - a3 }, { width: a3, height: a3 }, r22), ic2.copy(n3.data, l22, { x: 0, y: h22 - a3 }, { x: o3 + c22, y: u22 - a3 }, { width: a3, height: a3 }, r22), ic2.copy(n3.data, l22, { x: 0, y: 0 }, { x: o3 + c22, y: u22 + h22 }, { width: a3, height: a3 }, r22), ic2.copy(n3.data, l22, { x: c22 - a3, y: 0 }, { x: o3 - a3, y: u22 + h22 }, { width: a3, height: a3 }, r22);
          }
          this.image = l22, this.iconPositions = n22, this.patternPositions = i2;
        }
        addImages(t22, e22, r22, n22) {
          for (const i2 in t22) {
            const s2 = t22[i2], a2 = { x: 0, y: 0, w: s2.data.width + 2 * r22, h: s2.data.height + 2 * r22 };
            n22.push(a2), e22[i2] = new Of2(a2, s2, r22), s2.hasRenderCallback && this.haveRenderCallbacks.push(i2);
          }
        }
        patchUpdatedImages(t22, e22, r22) {
          this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e3) => t22.hasImage(e3, r22)), t22.dispatchRenderCallbacks(this.haveRenderCallbacks, r22);
          for (const n22 in t22.getUpdatedImages(r22))
            this.patchUpdatedImage(this.iconPositions[n22], t22.getImage(n22, r22), e22), this.patchUpdatedImage(this.patternPositions[n22], t22.getImage(n22, r22), e22);
        }
        patchUpdatedImage(t22, e22, r22) {
          if (!t22 || !e22)
            return;
          if (t22.version === e22.version)
            return;
          t22.version = e22.version;
          const [n22, i2] = t22.tl;
          r22.update(e22.data, { position: { x: n22, y: i2 } });
        }
      }
      os(Of2, "ImagePosition"), os(Uf2, "ImageAtlas");
      const jf = 1e20;
      function Nf2(t22, e22, r22, n22, i2, s2, a2, o2, l22) {
        for (let u22 = e22; u22 < e22 + n22; u22++)
          qf2(t22, r22 * s2 + u22, s2, i2, a2, o2, l22);
        for (let u22 = r22; u22 < r22 + i2; u22++)
          qf2(t22, u22 * s2 + e22, 1, n22, a2, o2, l22);
      }
      function qf2(t22, e22, r22, n22, i2, s2, a2) {
        s2[0] = 0, a2[0] = -jf, a2[1] = jf, i2[0] = t22[e22];
        for (let o2 = 1, l22 = 0, u22 = 0; o2 < n22; o2++) {
          i2[o2] = t22[e22 + o2 * r22];
          const n3 = o2 * o2;
          do {
            const t3 = s2[l22];
            u22 = (i2[o2] - i2[t3] + n3 - t3 * t3) / (o2 - t3) / 2;
          } while (u22 <= a2[l22] && --l22 > -1);
          l22++, s2[l22] = o2, a2[l22] = u22, a2[l22 + 1] = jf;
        }
        for (let o2 = 0, l22 = 0; o2 < n22; o2++) {
          for (; a2[l22 + 1] < o2; )
            l22++;
          const n3 = s2[l22], u22 = o2 - n3;
          t22[e22 + o2 * r22] = i2[n3] + u22 * u22;
        }
      }
      const $f2 = 2, Gf2 = { none: 0, ideographs: 1, all: 2 };
      class Xf2 {
        constructor(t22, e22, r22) {
          this.requestManager = t22, this.localGlyphMode = e22, this.localFontFamily = r22, this.urls = {}, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
        }
        setURL(t22, e22) {
          this.urls[e22] = t22;
        }
        getGlyphs(t22, e22, r22) {
          const n22 = [], i2 = this.urls[e22] || It.GLYPHS_URL;
          for (const e3 in t22)
            for (const r3 of t22[e3])
              n22.push({ stack: e3, id: r3 });
          rt(n22, ({ stack: t3, id: e3 }, r3) => {
            let n3 = this.entries[t3];
            n3 || (n3 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
            let s2 = n3.glyphs[e3];
            if (void 0 !== s2)
              return void r3(null, { stack: t3, id: e3, glyph: s2 });
            if (s2 = this._tinySDF(n3, t3, e3), s2)
              return n3.glyphs[e3] = s2, void r3(null, { stack: t3, id: e3, glyph: s2 });
            const a2 = Math.floor(e3 / 256);
            if (256 * a2 > 65535)
              return void r3(new Error("glyphs > 65535 not supported"));
            if (n3.ranges[a2])
              return void r3(null, { stack: t3, id: e3, glyph: s2 });
            let o2 = n3.requests[a2];
            o2 || (o2 = n3.requests[a2] = [], Xf2.loadGlyphRange(t3, a2, i2, this.requestManager, (t4, e4) => {
              if (e4) {
                n3.ascender = e4.ascender, n3.descender = e4.descender;
                for (const t5 in e4.glyphs)
                  this._doesCharSupportLocalGlyph(+t5) || (n3.glyphs[+t5] = e4.glyphs[+t5]);
                n3.ranges[a2] = true;
              }
              for (const r4 of o2)
                r4(t4, e4);
              delete n3.requests[a2];
            })), o2.push((n4, i3) => {
              n4 ? r3(n4) : i3 && r3(null, { stack: t3, id: e3, glyph: i3.glyphs[e3] || null });
            });
          }, (t3, e3) => {
            if (t3)
              r22(t3);
            else if (e3) {
              const t4 = {};
              for (const { stack: r3, id: n3, glyph: i3 } of e3)
                void 0 === t4[r3] && (t4[r3] = {}), void 0 === t4[r3].glyphs && (t4[r3].glyphs = {}), t4[r3].glyphs[n3] = i3 && { id: i3.id, bitmap: i3.bitmap.clone(), metrics: i3.metrics }, t4[r3].ascender = this.entries[r3].ascender, t4[r3].descender = this.entries[r3].descender;
              r22(null, t4);
            }
          });
        }
        _doesCharSupportLocalGlyph(t22) {
          return this.localGlyphMode !== Gf2.none && (this.localGlyphMode === Gf2.all ? !!this.localFontFamily : !!this.localFontFamily && (ps["CJK Unified Ideographs"](t22) || ps["Hangul Syllables"](t22) || ps.Hiragana(t22) || ps.Katakana(t22) || ps["CJK Symbols and Punctuation"](t22) || ps["CJK Unified Ideographs Extension A"](t22) || ps["CJK Unified Ideographs Extension B"](t22)));
        }
        _tinySDF(t22, e22, r22) {
          const n22 = this.localFontFamily;
          if (!n22 || !this._doesCharSupportLocalGlyph(r22))
            return;
          let i2 = t22.tinySDF;
          if (!i2) {
            let r3 = "400";
            /bold/i.test(e22) ? r3 = "900" : /medium/i.test(e22) ? r3 = "500" : /light/i.test(e22) && (r3 = "200"), i2 = t22.tinySDF = new Xf2.TinySDF({ fontFamily: n22, fontWeight: r3, fontSize: 24 * $f2, buffer: 3 * $f2, radius: 8 * $f2 }), i2.fontWeight = r3;
          }
          if (this.localGlyphs[i2.fontWeight][r22])
            return this.localGlyphs[i2.fontWeight][r22];
          const s2 = String.fromCodePoint(r22), { data: a2, width: o2, height: l22, glyphWidth: u22, glyphHeight: c22, glyphLeft: h22, glyphTop: p22, glyphAdvance: f22 } = i2.draw(s2);
          return this.localGlyphs[i2.fontWeight][r22] = { id: r22, bitmap: new nc2({ width: o2, height: l22 }, a2), metrics: { width: u22 / $f2, height: c22 / $f2, left: h22 / $f2, top: p22 / $f2 - 27, advance: f22 / $f2, localGlyph: true } };
        }
      }
      Xf2.loadGlyphRange = function(t22, e22, r22, n22, i2) {
        const s2 = 256 * e22, a2 = s2 + 255, o2 = n22.transformRequest(n22.normalizeGlyphsURL(r22).replace("{fontstack}", t22).replace("{range}", "".concat(s2, "-").concat(a2)), ee2.Glyphs);
        se2(o2, (t3, e3) => {
          if (t3)
            i2(t3);
          else if (e3) {
            const t4 = {}, r3 = function(t5) {
              return new of2(t5).readFields(uf2, {});
            }(e3);
            for (const e4 of r3.glyphs)
              t4[e4.id] = e4;
            i2(null, { glyphs: t4, ascender: r3.ascender, descender: r3.descender });
          }
        });
      }, Xf2.TinySDF = class {
        constructor({ fontSize: t22 = 24, buffer: e22 = 3, radius: r22 = 8, cutoff: n22 = 0.25, fontFamily: i2 = "sans-serif", fontWeight: s2 = "normal", fontStyle: a2 = "normal" } = {}) {
          this.buffer = e22, this.cutoff = n22, this.radius = r22;
          const o2 = this.size = t22 + 4 * e22, l22 = this._createCanvas(o2), u22 = this.ctx = l22.getContext("2d", { willReadFrequently: true });
          u22.font = "".concat(a2, " ").concat(s2, " ").concat(t22, "px ").concat(i2), u22.textBaseline = "alphabetic", u22.textAlign = "left", u22.fillStyle = "black", this.gridOuter = new Float64Array(o2 * o2), this.gridInner = new Float64Array(o2 * o2), this.f = new Float64Array(o2), this.z = new Float64Array(o2 + 1), this.v = new Uint16Array(o2);
        }
        _createCanvas(t22) {
          const e22 = document.createElement("canvas");
          return e22.width = e22.height = t22, e22;
        }
        draw(t22) {
          const { width: e22, actualBoundingBoxAscent: r22, actualBoundingBoxDescent: n22, actualBoundingBoxLeft: i2, actualBoundingBoxRight: s2 } = this.ctx.measureText(t22), a2 = Math.ceil(r22), o2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s2 - i2))), l22 = Math.min(this.size - this.buffer, a2 + Math.ceil(n22)), u22 = o2 + 2 * this.buffer, c22 = l22 + 2 * this.buffer, h22 = Math.max(u22 * c22, 0), p22 = new Uint8ClampedArray(h22), f22 = { data: p22, width: u22, height: c22, glyphWidth: o2, glyphHeight: l22, glyphTop: a2, glyphLeft: 0, glyphAdvance: e22 };
          if (0 === o2 || 0 === l22)
            return f22;
          const { ctx: d22, buffer: m22, gridInner: y22, gridOuter: g22 } = this;
          d22.clearRect(m22, m22, o2, l22), d22.fillText(t22, m22, m22 + a2);
          const x22 = d22.getImageData(m22, m22, o2, l22);
          g22.fill(jf, 0, h22), y22.fill(0, 0, h22);
          for (let t3 = 0; t3 < l22; t3++)
            for (let e3 = 0; e3 < o2; e3++) {
              const r3 = x22.data[4 * (t3 * o2 + e3) + 3] / 255;
              if (0 === r3)
                continue;
              const n3 = (t3 + m22) * u22 + e3 + m22;
              if (1 === r3)
                g22[n3] = 0, y22[n3] = jf;
              else {
                const t4 = 0.5 - r3;
                g22[n3] = t4 > 0 ? t4 * t4 : 0, y22[n3] = t4 < 0 ? t4 * t4 : 0;
              }
            }
          Nf2(g22, 0, 0, u22, c22, u22, this.f, this.v, this.z), Nf2(y22, m22, m22, o2, l22, u22, this.f, this.v, this.z);
          for (let t3 = 0; t3 < h22; t3++) {
            const e3 = Math.sqrt(g22[t3]) - Math.sqrt(y22[t3]);
            p22[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
          }
          return f22;
        }
      };
      const Yf2 = Ff2;
      function Zf2(t22, e22, r22, n22) {
        const i2 = [], s2 = t22.imagePrimary, a2 = s2.pixelRatio, o2 = s2.paddedRect.w - 2 * Yf2, l22 = s2.paddedRect.h - 2 * Yf2, u22 = t22.right - t22.left, c22 = t22.bottom - t22.top, h22 = s2.stretchX || [[0, o2]], p22 = s2.stretchY || [[0, l22]], f22 = (t3, e3) => t3 + e3[1] - e3[0], d22 = h22.reduce(f22, 0), m22 = p22.reduce(f22, 0), y22 = o2 - d22, g22 = l22 - m22;
        let x22 = 0, b22 = d22, v22 = 0, w22 = m22, _2 = 0, M22 = y22, A22 = 0, S22 = g22;
        if (s2.content && n22) {
          const t3 = s2.content;
          x22 = Wf2(h22, 0, t3[0]), v22 = Wf2(p22, 0, t3[1]), b22 = Wf2(h22, t3[0], t3[2]), w22 = Wf2(p22, t3[1], t3[3]), _2 = t3[0] - x22, A22 = t3[1] - v22, M22 = t3[2] - t3[0] - b22, S22 = t3[3] - t3[1] - w22;
        }
        const I22 = (n3, i3, o3, l3) => {
          const h3 = Kf2(n3.stretch - x22, b22, u22, t22.left), p3 = Jf2(n3.fixed - _2, M22, n3.stretch, d22), f3 = Kf2(i3.stretch - v22, w22, c22, t22.top), y3 = Jf2(i3.fixed - A22, S22, i3.stretch, m22), g3 = Kf2(o3.stretch - x22, b22, u22, t22.left), I3 = Jf2(o3.fixed - _2, M22, o3.stretch, d22), P22 = Kf2(l3.stretch - v22, w22, c22, t22.top), z22 = Jf2(l3.fixed - A22, S22, l3.stretch, m22), k22 = new q2(h3, f3), T22 = new q2(g3, f3), E22 = new q2(g3, P22), B22 = new q2(h3, P22), V22 = new q2(p3 / a2, y3 / a2), C22 = new q2(I3 / a2, z22 / a2), R22 = e22 * Math.PI / 180;
          if (R22) {
            const t3 = Math.sin(R22), e3 = Math.cos(R22), r3 = [e3, -t3, t3, e3];
            k22._matMult(r3), T22._matMult(r3), B22._matMult(r3), E22._matMult(r3);
          }
          const D22 = n3.stretch + n3.fixed, L22 = o3.stretch + o3.fixed, F22 = i3.stretch + i3.fixed, O22 = l3.stretch + l3.fixed, U22 = t22.imageSecondary;
          return { tl: k22, tr: T22, bl: B22, br: E22, texPrimary: { x: s2.paddedRect.x + Yf2 + D22, y: s2.paddedRect.y + Yf2 + F22, w: L22 - D22, h: O22 - F22 }, texSecondary: U22 ? { x: U22.paddedRect.x + Yf2 + D22, y: U22.paddedRect.y + Yf2 + F22, w: L22 - D22, h: O22 - F22 } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: V22, pixelOffsetBR: C22, minFontScaleX: M22 / a2 / u22, minFontScaleY: S22 / a2 / c22, isSDF: r22 };
        };
        if (n22 && (s2.stretchX || s2.stretchY)) {
          const t3 = Hf2(h22, y22, d22), e3 = Hf2(p22, g22, m22);
          for (let r3 = 0; r3 < t3.length - 1; r3++) {
            const n3 = t3[r3], s3 = t3[r3 + 1];
            for (let t4 = 0; t4 < e3.length - 1; t4++)
              i2.push(I22(n3, e3[t4], s3, e3[t4 + 1]));
          }
        } else
          i2.push(I22({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o2 + 1 }, { fixed: 0, stretch: l22 + 1 }));
        return i2;
      }
      function Wf2(t22, e22, r22) {
        let n22 = 0;
        for (const i2 of t22)
          n22 += Math.max(e22, Math.min(r22, i2[1])) - Math.max(e22, Math.min(r22, i2[0]));
        return n22;
      }
      function Hf2(t22, e22, r22) {
        const n22 = [{ fixed: -Yf2, stretch: 0 }];
        for (const [e3, r3] of t22) {
          const t3 = n22[n22.length - 1];
          n22.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n22.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
        }
        return n22.push({ fixed: e22 + Yf2, stretch: r22 }), n22;
      }
      function Kf2(t22, e22, r22, n22) {
        return t22 / e22 * r22 + n22;
      }
      function Jf2(t22, e22, r22, n22) {
        return t22 - e22 * r22 / n22;
      }
      function Qf2(t22, e22, r22, n22) {
        const i2 = e22 + t22.positionedLines[n22].lineOffset;
        return 0 === n22 ? r22 + i2 / 2 : r22 + (i2 + (e22 + t22.positionedLines[n22 - 1].lineOffset)) / 2;
      }
      function td2(t22, e22 = 1, r22 = false) {
        let n22 = 1 / 0, i2 = 1 / 0, s2 = -1 / 0, a2 = -1 / 0;
        const o2 = t22[0];
        for (let t3 = 0; t3 < o2.length; t3++) {
          const e3 = o2[t3];
          (!t3 || e3.x < n22) && (n22 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > s2) && (s2 = e3.x), (!t3 || e3.y > a2) && (a2 = e3.y);
        }
        const l22 = Math.min(s2 - n22, a2 - i2);
        let u22 = l22 / 2;
        const c22 = new Wr([], ed2);
        if (0 === l22)
          return new q2(n22, i2);
        for (let e3 = n22; e3 < s2; e3 += l22)
          for (let r3 = i2; r3 < a2; r3 += l22)
            c22.push(new rd2(e3 + u22, r3 + u22, u22, t22));
        let h22 = function(t3) {
          let e3 = 0, r3 = 0, n3 = 0;
          const i3 = t3[0];
          for (let t4 = 0, s3 = i3.length, a3 = s3 - 1; t4 < s3; a3 = t4++) {
            const s4 = i3[t4], o3 = i3[a3], l3 = s4.x * o3.y - o3.x * s4.y;
            r3 += (s4.x + o3.x) * l3, n3 += (s4.y + o3.y) * l3, e3 += 3 * l3;
          }
          return new rd2(r3 / e3, n3 / e3, 0, t3);
        }(t22), p22 = c22.length;
        for (; c22.length; ) {
          const n3 = c22.pop();
          (n3.d > h22.d || !h22.d) && (h22 = n3, r22 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, p22)), n3.max - h22.d <= e22 || (u22 = n3.h / 2, c22.push(new rd2(n3.p.x - u22, n3.p.y - u22, u22, t22)), c22.push(new rd2(n3.p.x + u22, n3.p.y - u22, u22, t22)), c22.push(new rd2(n3.p.x - u22, n3.p.y + u22, u22, t22)), c22.push(new rd2(n3.p.x + u22, n3.p.y + u22, u22, t22)), p22 += 4);
        }
        return r22 && (console.log("num probes: ".concat(p22)), console.log("best distance: ".concat(h22.d))), h22.p;
      }
      function ed2(t22, e22) {
        return e22.max - t22.max;
      }
      class rd2 {
        constructor(t22, e22, r22, n22) {
          this.p = new q2(t22, e22), this.h = r22, this.d = function(t3, e3) {
            let r3 = false, n3 = 1 / 0;
            for (let i2 = 0; i2 < e3.length; i2++) {
              const s2 = e3[i2];
              for (let e4 = 0, i3 = s2.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
                const i4 = s2[e4], o2 = s2[a2];
                i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, Fl(t3, i4, o2));
              }
            }
            return (r3 ? 1 : -1) * Math.sqrt(n3);
          }(this.p, n22), this.max = this.d + this.h * Math.SQRT2;
        }
      }
      const nd2 = Number.POSITIVE_INFINITY, id2 = Math.sqrt(2);
      function sd2(t22, [e22, r22]) {
        let n22 = 0, i2 = 0;
        if (r22 === nd2) {
          e22 < 0 && (e22 = 0);
          const r3 = e22 / id2;
          switch (t22) {
            case "top-right":
            case "top-left":
              i2 = r3 - 7;
              break;
            case "bottom-right":
            case "bottom-left":
              i2 = 7 - r3;
              break;
            case "bottom":
              i2 = 7 - e22;
              break;
            case "top":
              i2 = e22 - 7;
          }
          switch (t22) {
            case "top-right":
            case "bottom-right":
              n22 = -r3;
              break;
            case "top-left":
            case "bottom-left":
              n22 = r3;
              break;
            case "left":
              n22 = e22;
              break;
            case "right":
              n22 = -e22;
          }
        } else {
          switch (e22 = Math.abs(e22), r22 = Math.abs(r22), t22) {
            case "top-right":
            case "top-left":
            case "top":
              i2 = r22 - 7;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              i2 = 7 - r22;
          }
          switch (t22) {
            case "top-right":
            case "bottom-right":
            case "right":
              n22 = -e22;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              n22 = e22;
          }
        }
        return [n22, i2];
      }
      function ad2(t22) {
        switch (t22) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function od2(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22, f22, d22) {
        let m22 = s2.textMaxSize.evaluate(e22, {}, h22);
        void 0 === m22 && (m22 = a2);
        const y22 = t22.layers[0].layout, g22 = y22.get("icon-offset").evaluate(e22, {}, h22), x22 = hd2(r22.horizontal) || r22.vertical, b22 = "globe" === p22.name, v22 = $p, w22 = a2 / v22, _2 = t22.tilePixelRatio * m22 / v22, M22 = (E22 = t22.overscaling, t22.zoom > 18 && E22 > 2 && (E22 >>= 1), Math.max(Hr / (512 * E22), 1) * y22.get("symbol-spacing")), A22 = y22.get("text-padding") * t22.tilePixelRatio, S22 = y22.get("icon-padding") * t22.tilePixelRatio, I22 = Y2(y22.get("text-max-angle")), P22 = "map" === y22.get("text-rotation-alignment") && "point" !== y22.get("symbol-placement"), z22 = "map" === y22.get("icon-rotation-alignment") && "point" !== y22.get("symbol-placement"), k22 = y22.get("symbol-placement"), T22 = M22 / 2;
        var E22;
        const B22 = y22.get("icon-text-fit").evaluate(e22, {}, h22), V22 = y22.get("icon-text-fit-padding").evaluate(e22, {}, h22), C22 = "none" !== B22;
        let R22;
        false === t22.hasAnyIconTextFit && C22 && (t22.hasAnyIconTextFit = true), n22 && C22 && (t22.allowVerticalPlacement && r22.vertical && (R22 = Pf2(n22, r22.vertical, B22, V22, g22, w22)), x22 && (n22 = Pf2(n22, x22, B22, V22, g22, w22)));
        const D22 = (a3, o3, m3) => {
          if (o3.x < 0 || o3.x >= Hr || o3.y < 0 || o3.y >= Hr)
            return;
          let y3 = null;
          if (b22) {
            const { x: t3, y: e3, z: r3 } = p22.projectTilePoint(o3.x, o3.y, m3);
            y3 = { anchor: new zf2(t3, e3, r3, 0, void 0), up: p22.upVector(m3, o3.x, o3.y) };
          }
          !function(t3, e3, r3, n3, i3, s3, a4, o4, l3, u3, c3, h3, p3, f3, d3, m4, y4, g3, x3, b3, v3, w3, _3, M3, A3, S3, I3) {
            const P3 = t3.addToLineVertexArray(e3, n3);
            let z3, k3, T3, E3, B3, V3, C3, R3 = 0, D3 = 0, L22 = 0, F22 = 0, O22 = -1, U22 = -1;
            const j2 = {};
            let N22 = xe("");
            const q22 = r3 ? r3.anchor : e3, $2 = "none" !== l3.layout.get("icon-text-fit").evaluate(v3, {}, A3);
            let G22 = 0, X22 = 0;
            if (void 0 === l3._unevaluatedLayout.getValue("text-radial-offset") ? [G22, X22] = l3.layout.get("text-offset").evaluate(v3, {}, A3).map((t4) => t4 * $p) : (G22 = l3.layout.get("text-radial-offset").evaluate(v3, {}, A3) * $p, X22 = nd2), t3.allowVerticalPlacement && i3.vertical) {
              const t4 = i3.vertical;
              if (d3)
                V3 = fd2(t4), o4 && (C3 = fd2(o4));
              else {
                const r4 = l3.layout.get("text-rotate").evaluate(v3, {}, A3) + 90;
                T3 = pd2(u3, q22, e3, c3, h3, p3, t4, f3, r4, m4), o4 && (E3 = pd2(u3, q22, e3, c3, h3, p3, o4, g3, r4));
              }
            }
            if (s3) {
              const n4 = l3.layout.get("icon-rotate").evaluate(v3, {}, A3), i4 = Zf2(s3, n4, _3, $2), a5 = o4 ? Zf2(o4, n4, _3, $2) : void 0;
              k3 = pd2(u3, q22, e3, c3, h3, p3, s3, g3, n4), R3 = 4 * i4.length;
              const f4 = t3.iconSizeData;
              let d4 = null;
              "source" === f4.kind ? (d4 = [Gp * l3.layout.get("icon-size").evaluate(v3, {}, A3)], d4[0] > ud2 && ft("".concat(t3.layerIds[0], ': Value for "icon-size" is >= ').concat(ld2, '. Reduce your "icon-size".'))) : "composite" === f4.kind && (d4 = [Gp * w3.compositeIconSizes[0].evaluate(v3, {}, A3), Gp * w3.compositeIconSizes[1].evaluate(v3, {}, A3)], (d4[0] > ud2 || d4[1] > ud2) && ft("".concat(t3.layerIds[0], ': Value for "icon-size" is >= ').concat(ld2, '. Reduce your "icon-size".'))), t3.addSymbols(t3.icon, i4, d4, b3, x3, v3, false, r3, e3, P3.lineStartIndex, P3.lineLength, -1, M3, A3, S3, I3), O22 = t3.icon.placedSymbolArray.length - 1, a5 && (D3 = 4 * a5.length, t3.addSymbols(t3.icon, a5, d4, b3, x3, v3, ff2.vertical, r3, e3, P3.lineStartIndex, P3.lineLength, -1, M3, A3, S3, I3), U22 = t3.icon.placedSymbolArray.length - 1);
            }
            for (const n4 in i3.horizontal) {
              const s4 = i3.horizontal[n4];
              z3 || (N22 = xe(s4.text), d3 ? B3 = fd2(s4) : z3 = pd2(u3, q22, e3, c3, h3, p3, s4, f3, l3.layout.get("text-rotate").evaluate(v3, {}, A3), m4));
              const o5 = 1 === s4.positionedLines.length;
              if (L22 += cd2(t3, r3, e3, s4, a4, l3, d3, v3, m4, P3, i3.vertical ? ff2.horizontal : ff2.horizontalOnly, o5 ? Object.keys(i3.horizontal) : [n4], j2, O22, w3, M3, A3, S3), o5)
                break;
            }
            i3.vertical && (F22 += cd2(t3, r3, e3, i3.vertical, a4, l3, d3, v3, m4, P3, ff2.vertical, ["vertical"], j2, U22, w3, M3, A3, S3));
            let Y22 = -1;
            const Z22 = (t4, e4) => t4 ? Math.max(t4, e4) : e4;
            Y22 = Z22(B3, Y22), Y22 = Z22(V3, Y22), Y22 = Z22(C3, Y22);
            const W22 = Y22 > -1 ? 1 : 0;
            t3.glyphOffsetArray.length >= 65535 && ft("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== v3.sortKey && t3.addToSortKeyRanges(t3.symbolInstances.length, v3.sortKey), t3.symbolInstances.emplaceBack(e3.x, e3.y, q22.x, q22.y, q22.z, j2.right >= 0 ? j2.right : -1, j2.center >= 0 ? j2.center : -1, j2.left >= 0 ? j2.left : -1, j2.vertical >= 0 ? j2.vertical : -1, O22, U22, N22, void 0 !== z3 ? z3 : t3.collisionBoxArray.length, void 0 !== z3 ? z3 + 1 : t3.collisionBoxArray.length, void 0 !== T3 ? T3 : t3.collisionBoxArray.length, void 0 !== T3 ? T3 + 1 : t3.collisionBoxArray.length, void 0 !== k3 ? k3 : t3.collisionBoxArray.length, void 0 !== k3 ? k3 + 1 : t3.collisionBoxArray.length, E3 || t3.collisionBoxArray.length, E3 ? E3 + 1 : t3.collisionBoxArray.length, c3, L22, F22, R3, D3, W22, 0, G22, X22, Y22, 0, $2 ? 1 : 0);
          }(t22, o3, y3, a3, r22, n22, i2, R22, t22.layers[0], t22.collisionBoxArray, e22.index, e22.sourceLayerIndex, t22.index, A22, P22, l22, 0, S22, z22, g22, e22, s2, u22, c22, h22, f22, d22);
        };
        if ("line" === k22)
          for (const i3 of Df2(e22.geometry, 0, 0, Hr, Hr)) {
            const e3 = Cf2(i3, M22, I22, r22.vertical || x22, n22, v22, _2, t22.overscaling, Hr);
            for (const r3 of e3)
              x22 && dd2(t22, x22.text, T22, r3) || D22(i3, r3, h22);
          }
        else if ("line-center" === k22) {
          for (const t3 of e22.geometry)
            if (t3.length > 1) {
              const e3 = Vf2(t3, I22, r22.vertical || x22, n22, v22, _2);
              e3 && D22(t3, e3, h22);
            }
        } else if ("Polygon" === e22.type)
          for (const t3 of Cc2(e22.geometry, 0)) {
            const e3 = td2(t3, 16);
            D22(t3[0], new zf2(e3.x, e3.y, 0, 0, void 0), h22);
          }
        else if ("LineString" === e22.type)
          for (const t3 of e22.geometry)
            D22(t3, new zf2(t3[0].x, t3[0].y, 0, 0, void 0), h22);
        else if ("Point" === e22.type)
          for (const t3 of e22.geometry)
            for (const e3 of t3)
              D22([e3], new zf2(e3.x, e3.y, 0, 0, void 0), h22);
      }
      const ld2 = 255, ud2 = ld2 * Gp;
      function cd2(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22, f22, d22, m22, y22, g22) {
        const x22 = function(t3, e3, r3, n3, i3, s3, a3, o3) {
          const l3 = [];
          if (0 === e3.positionedLines.length)
            return l3;
          const u3 = n3.layout.get("text-rotate").evaluate(s3, {}) * Math.PI / 180, c3 = function(t4) {
            const e4 = t4[0], r4 = t4[1], n4 = e4 * r4;
            return n4 > 0 ? [e4, -r4] : n4 < 0 ? [-e4, r4] : 0 === e4 ? [r4, e4] : [r4, -e4];
          }(r3);
          let h3 = Math.abs(e3.top - e3.bottom);
          for (const t4 of e3.positionedLines)
            h3 -= t4.lineOffset;
          const p3 = e3.positionedLines.length, f3 = h3 / p3;
          let d3 = e3.top - r3[1];
          for (let t4 = 0; t4 < p3; ++t4) {
            const n4 = e3.positionedLines[t4];
            d3 = Qf2(e3, f3, d3, t4);
            for (const t5 of n4.positionedGlyphs) {
              if (!t5.rect)
                continue;
              const n5 = t5.rect || {};
              let s4 = pf2 + 1, h4 = true, p4 = 1, f4 = 0;
              if (t5.imageName) {
                const e4 = a3[t5.imageName];
                if (!e4)
                  continue;
                if (e4.sdf) {
                  ft("SDF images are not supported in formatted text and will be ignored.");
                  continue;
                }
                h4 = false, p4 = e4.pixelRatio, s4 = Ff2 / p4;
              }
              const m3 = (i3 || o3) && t5.vertical, y3 = t5.metrics.advance * t5.scale / 2, g3 = t5.metrics, x3 = t5.rect;
              if (null === x3)
                continue;
              o3 && e3.verticalizable && (f4 = t5.imageName ? y3 - t5.metrics.width * t5.scale / 2 : 0);
              const b3 = i3 ? [t5.x + y3, t5.y] : [0, 0];
              let v3 = [0, 0], w22 = [0, 0], _2 = false;
              i3 || (m3 ? (w22 = [t5.x + y3 + c3[0], t5.y + c3[1] - f4], _2 = true) : v3 = [t5.x + y3 + r3[0], t5.y + r3[1] - f4]);
              const M22 = x3.w * t5.scale / (p4 * (t5.localGlyph ? $f2 : 1)), A22 = x3.h * t5.scale / (p4 * (t5.localGlyph ? $f2 : 1));
              let S22, I22, P22, z22;
              if (m3) {
                const e4 = t5.y - d3, r4 = new q2(-y3, y3 - e4), n6 = -Math.PI / 2, i4 = new q2(...w22);
                S22 = new q2(-y3 + v3[0], v3[1]), S22._rotateAround(n6, r4)._add(i4), S22.x += -e4 + y3, S22.y -= (g3.left - s4) * t5.scale;
                const a4 = t5.imageName ? g3.advance * t5.scale : $p * t5.scale, o4 = String.fromCodePoint(t5.glyph);
                Jp(o4) ? S22.x += (1 - s4) * t5.scale : Qp(o4) ? S22.x += a4 - g3.height * t5.scale + (-s4 - 1) * t5.scale : S22.x += t5.imageName || g3.width + 2 * s4 === x3.w && g3.height + 2 * s4 === x3.h ? (a4 - A22) / 2 : (a4 - (g3.height + 2 * s4) * t5.scale) / 2, I22 = new q2(S22.x, S22.y - M22), P22 = new q2(S22.x + A22, S22.y), z22 = new q2(S22.x + A22, S22.y - M22);
              } else {
                const e4 = (g3.left - s4) * t5.scale - y3 + v3[0], r4 = (-g3.top - s4) * t5.scale + v3[1], n6 = e4 + M22, i4 = r4 + A22;
                S22 = new q2(e4, r4), I22 = new q2(n6, r4), P22 = new q2(e4, i4), z22 = new q2(n6, i4);
              }
              if (u3) {
                let t6;
                t6 = i3 ? new q2(0, 0) : _2 ? new q2(c3[0], c3[1]) : new q2(r3[0], r3[1]), S22._rotateAround(u3, t6), I22._rotateAround(u3, t6), P22._rotateAround(u3, t6), z22._rotateAround(u3, t6);
              }
              const k22 = new q2(0, 0), T22 = new q2(0, 0);
              l3.push({ tl: S22, tr: I22, bl: P22, br: z22, texPrimary: n5, texSecondary: void 0, writingMode: e3.writingMode, glyphOffset: b3, sectionIndex: t5.sectionIndex, isSDF: h4, pixelOffsetTL: k22, pixelOffsetBR: T22, minFontScaleX: 0, minFontScaleY: 0 });
            }
          }
          return l3;
        }(0, n22, l22, s2, a2, o2, i2, t22.allowVerticalPlacement), b22 = t22.textSizeData;
        let v22 = null;
        "source" === b22.kind ? (v22 = [Gp * s2.layout.get("text-size").evaluate(o2, {}, y22)], v22[0] > ud2 && ft("".concat(t22.layerIds[0], ': Value for "text-size" is >= ').concat(ld2, '. Reduce your "text-size".'))) : "composite" === b22.kind && (v22 = [Gp * d22.compositeTextSizes[0].evaluate(o2, {}, y22), Gp * d22.compositeTextSizes[1].evaluate(o2, {}, y22)], (v22[0] > ud2 || v22[1] > ud2) && ft("".concat(t22.layerIds[0], ': Value for "text-size" is >= ').concat(ld2, '. Reduce your "text-size".'))), t22.addSymbols(t22.text, x22, v22, l22, a2, o2, c22, e22, r22, u22.lineStartIndex, u22.lineLength, f22, m22, y22, g22, false);
        for (const e3 of h22)
          p22[e3] = t22.text.placedSymbolArray.length - 1;
        return 4 * x22.length;
      }
      function hd2(t22) {
        for (const e22 in t22)
          return t22[e22];
        return null;
      }
      function pd2(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22) {
        let c22 = a2.top, h22 = a2.bottom, p22 = a2.left, f22 = a2.right;
        const d22 = a2.collisionPadding;
        if (d22 && (p22 -= d22[0], c22 -= d22[1], f22 += d22[2], h22 += d22[3]), l22) {
          const t3 = new q2(p22, c22), e3 = new q2(f22, c22), r3 = new q2(p22, h22), n3 = new q2(f22, h22), i3 = Y2(l22);
          let s3 = new q2(0, 0);
          u22 && (s3 = new q2(u22[0], u22[1])), t3._rotateAround(i3, s3), e3._rotateAround(i3, s3), r3._rotateAround(i3, s3), n3._rotateAround(i3, s3), p22 = Math.min(t3.x, e3.x, r3.x, n3.x), f22 = Math.max(t3.x, e3.x, r3.x, n3.x), c22 = Math.min(t3.y, e3.y, r3.y, n3.y), h22 = Math.max(t3.y, e3.y, r3.y, n3.y);
        }
        return t22.emplaceBack(e22.x, e22.y, e22.z, r22.x, r22.y, p22, c22, f22, h22, o2, n22, i2, s2), t22.length - 1;
      }
      function fd2(t22) {
        t22.collisionPadding && (t22.top -= t22.collisionPadding[1], t22.bottom += t22.collisionPadding[3]);
        const e22 = t22.bottom - t22.top;
        return e22 > 0 ? Math.max(10, e22) : null;
      }
      function dd2(t22, e22, r22, n22) {
        const i2 = t22.compareText;
        if (e22 in i2) {
          const t3 = i2[e22];
          for (let e3 = t3.length - 1; e3 >= 0; e3--)
            if (n22.dist(t3[e3]) < r22)
              return true;
        } else
          i2[e22] = [];
        return i2[e22].push(n22), false;
      }
      function md2(t22, e22) {
        const r22 = t22.fovAboveCenter, n22 = t22.elevation ? t22.elevation.getMinElevationBelowMSL() * e22 : 0, i2 = (t22._camera.position[2] * t22.worldSize - n22) / Math.cos(t22._pitch), s2 = Math.sin(r22) * i2 / Math.sin(Math.max(Math.PI / 2 - t22._pitch - r22, 0.01));
        let a2 = Math.sin(t22._pitch) * s2 + i2;
        const o2 = i2 * (1 / t22._horizonShift);
        return t22.elevation && 0 !== t22.elevation.exaggeration() || (a2 *= 1 + Math.max(t22.zoom - 17, 0)), Math.min(1.01 * a2, o2);
      }
      function yd2(t22, e22) {
        if (!e22.isReprojectedInTileSpace)
          return { scale: 1 << t22.z, x: t22.x, y: t22.y, x2: t22.x + 1, y2: t22.y + 1, projection: e22 };
        const r22 = Math.pow(2, -t22.z), n22 = t22.x * r22, i2 = (t22.x + 1) * r22, s2 = t22.y * r22, a2 = (t22.y + 1) * r22, o2 = cl2(n22), l22 = cl2(i2), u22 = hl2(s2), c22 = hl2(a2), h22 = e22.project(o2, u22), p22 = e22.project(l22, u22), f22 = e22.project(l22, c22), d22 = e22.project(o2, c22);
        let m22 = Math.min(h22.x, p22.x, f22.x, d22.x), y22 = Math.min(h22.y, p22.y, f22.y, d22.y), g22 = Math.max(h22.x, p22.x, f22.x, d22.x), x22 = Math.max(h22.y, p22.y, f22.y, d22.y);
        const b22 = r22 / 16;
        function v22(t3, r3, n3, i3, s3, a3) {
          const o3 = (n3 + s3) / 2, l3 = (i3 + a3) / 2, u3 = e22.project(cl2(o3), hl2(l3)), c3 = Math.max(0, m22 - u3.x, y22 - u3.y, u3.x - g22, u3.y - x22);
          m22 = Math.min(m22, u3.x), g22 = Math.max(g22, u3.x), y22 = Math.min(y22, u3.y), x22 = Math.max(x22, u3.y), c3 > b22 && (v22(t3, u3, n3, i3, o3, l3), v22(u3, r3, o3, l3, s3, a3));
        }
        v22(h22, p22, n22, s2, i2, s2), v22(p22, f22, i2, s2, i2, a2), v22(f22, d22, i2, a2, n22, a2), v22(d22, h22, n22, a2, n22, s2), m22 -= b22, y22 -= b22, g22 += b22, x22 += b22;
        const w22 = 1 / Math.max(g22 - m22, x22 - y22);
        return { scale: w22, x: m22 * w22, y: y22 * w22, x2: g22 * w22, y2: x22 * w22, projection: e22 };
      }
      function gd2(t22, { x: e22, y: r22 }, n22 = 0) {
        return new q2(((e22 - n22) * t22.scale - t22.x) * Hr, (r22 * t22.scale - t22.y) * Hr);
      }
      const xd2 = O2.mat4.identity(new Float32Array(16));
      class bd2 {
        constructor(t22) {
          this.spec = t22, this.name = t22.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
        }
        project(t22, e22) {
          return { x: 0, y: 0, z: 0 };
        }
        unproject(t22, e22) {
          return new rl2(0, 0);
        }
        projectTilePoint(t22, e22, r22) {
          return { x: t22, y: e22, z: 0 };
        }
        locationPoint(t22, e22, r22 = true) {
          return t22._coordinatePoint(t22.locationCoordinate(e22), r22);
        }
        pixelsPerMeter(t22, e22) {
          return ul2(1, t22) * e22;
        }
        pixelSpaceConversion(t22, e22, r22) {
          return 1;
        }
        farthestPixelDistance(t22) {
          return md2(t22, t22.pixelsPerMeter);
        }
        pointCoordinate(t22, e22, r22, n22) {
          const i2 = t22.horizonLineFromTop(false), s2 = new q2(e22, Math.max(i2, r22));
          return t22.rayIntersectionCoordinate(t22.pointRayIntersection(s2, n22));
        }
        pointCoordinate3D(t22, e22, r22) {
          const n22 = new q2(e22, r22);
          if (t22.elevation)
            return t22.elevation.pointCoordinate(n22);
          {
            const e3 = this.pointCoordinate(t22, n22.x, n22.y, 0);
            return [e3.x, e3.y, e3.z];
          }
        }
        isPointAboveHorizon(t22, e22) {
          if (t22.elevation && t22.elevation.visibleDemTiles.length)
            return !this.pointCoordinate3D(t22, e22.x, e22.y);
          const r22 = t22.horizonLineFromTop();
          return e22.y < r22;
        }
        createInversionMatrix(t22, e22) {
          return xd2;
        }
        createTileMatrix(t22, e22, r22) {
          let n22, i2, s2;
          const a2 = r22.canonical, o2 = O2.mat4.identity(new Float64Array(16));
          if (this.isReprojectedInTileSpace) {
            const l22 = yd2(a2, this);
            n22 = 1, i2 = l22.x + r22.wrap * l22.scale, s2 = l22.y, O2.mat4.scale(o2, o2, [n22 / l22.scale, n22 / l22.scale, t22.pixelsPerMeter / e22]);
          } else
            n22 = e22 / t22.zoomScale(a2.z), i2 = (a2.x + Math.pow(2, a2.z) * r22.wrap) * n22, s2 = a2.y * n22;
          return O2.mat4.translate(o2, o2, [i2, s2, 0]), O2.mat4.scale(o2, o2, [n22 / Hr, n22 / Hr, 1]), o2;
        }
        upVector(t22, e22, r22) {
          return [0, 0, 1];
        }
        upVectorScale(t22, e22, r22) {
          return { metersToTile: 1 };
        }
      }
      class vd2 extends bd2 {
        constructor(t22) {
          super(t22), this.range = [4, 7], this.center = t22.center || [-96, 37.5];
          const [e22, r22] = this.parallels = t22.parallels || [29.5, 45.5], n22 = Math.sin(Y2(e22));
          this.n = (n22 + Math.sin(Y2(r22))) / 2, this.c = 1 + n22 * (2 * this.n - n22), this.r0 = Math.sqrt(this.c) / this.n;
        }
        project(t22, e22) {
          const { n: r22, c: n22, r0: i2 } = this, s2 = Y2(t22 - this.center[0]), a2 = Y2(e22), o2 = Math.sqrt(n22 - 2 * r22 * Math.sin(a2)) / r22;
          return { x: o2 * Math.sin(s2 * r22), y: o2 * Math.cos(s2 * r22) - i2, z: 0 };
        }
        unproject(t22, e22) {
          const { n: r22, c: n22, r0: i2 } = this, s2 = i2 + e22;
          let a2 = Math.atan2(t22, Math.abs(s2)) * Math.sign(s2);
          s2 * r22 < 0 && (a2 -= Math.PI * Math.sign(t22) * Math.sign(s2));
          const o2 = Y2(this.center[0]) * r22;
          a2 = et(a2, -Math.PI - o2, Math.PI - o2);
          const l22 = Q2(Z2(a2 / r22) + this.center[0], -180, 180), u22 = Math.asin(Q2((n22 - (t22 * t22 + s2 * s2) * r22 * r22) / (2 * r22), -1, 1)), c22 = Q2(Z2(u22), -fl2, fl2);
          return new rl2(l22, c22);
        }
      }
      const wd2 = 1.340264, _d = -0.081106, Md2 = 893e-6, Ad2 = 3796e-6, Sd2 = Math.sqrt(3) / 2;
      class Id2 extends bd2 {
        project(t22, e22) {
          e22 = e22 / 180 * Math.PI, t22 = t22 / 180 * Math.PI;
          const r22 = Math.asin(Sd2 * Math.sin(e22)), n22 = r22 * r22, i2 = n22 * n22 * n22;
          return { x: 0.5 * (t22 * Math.cos(r22) / (Sd2 * (wd2 + 3 * _d * n22 + i2 * (7 * Md2 + 9 * Ad2 * n22))) / Math.PI + 0.5), y: 1 - 0.5 * (r22 * (wd2 + _d * n22 + i2 * (Md2 + Ad2 * n22)) / Math.PI + 1), z: 0 };
        }
        unproject(t22, e22) {
          t22 = (2 * t22 - 0.5) * Math.PI;
          let r22 = e22 = (2 * (1 - e22) - 1) * Math.PI, n22 = r22 * r22, i2 = n22 * n22 * n22;
          for (let t3, s3, a3, o3 = 0; o3 < 12 && (s3 = r22 * (wd2 + _d * n22 + i2 * (Md2 + Ad2 * n22)) - e22, a3 = wd2 + 3 * _d * n22 + i2 * (7 * Md2 + 9 * Ad2 * n22), t3 = s3 / a3, r22 = Q2(r22 - t3, -Math.PI / 3, Math.PI / 3), n22 = r22 * r22, i2 = n22 * n22 * n22, !(Math.abs(t3) < 1e-12)); ++o3)
            ;
          const s2 = Sd2 * t22 * (wd2 + 3 * _d * n22 + i2 * (7 * Md2 + 9 * Ad2 * n22)) / Math.cos(r22), a2 = Math.asin(Math.sin(r22) / Sd2), o2 = Q2(180 * s2 / Math.PI, -180, 180), l22 = Q2(180 * a2 / Math.PI, -fl2, fl2);
          return new rl2(o2, l22);
        }
      }
      class Pd2 extends bd2 {
        constructor(t22) {
          super(t22), this.wrap = true, this.supportsWorldCopies = true;
        }
        project(t22, e22) {
          return { x: 0.5 + t22 / 360, y: 0.5 - e22 / 360, z: 0 };
        }
        unproject(t22, e22) {
          const r22 = 360 * (t22 - 0.5), n22 = Q2(360 * (0.5 - e22), -fl2, fl2);
          return new rl2(r22, n22);
        }
      }
      const zd2 = Math.PI / 2;
      function kd2(t22) {
        return Math.tan((zd2 + t22) / 2);
      }
      class Td2 extends bd2 {
        constructor(t22) {
          super(t22), this.center = t22.center || [0, 30];
          const [e22, r22] = this.parallels = t22.parallels || [30, 30];
          let n22 = Y2(e22), i2 = Y2(r22);
          this.southernCenter = n22 + i2 < 0, this.southernCenter && (n22 = -n22, i2 = -i2);
          const s2 = Math.cos(n22), a2 = kd2(n22);
          this.n = n22 === i2 ? Math.sin(n22) : Math.log(s2 / Math.cos(i2)) / Math.log(kd2(i2) / a2), this.f = s2 * Math.pow(kd2(n22), this.n) / this.n;
        }
        project(t22, e22) {
          e22 = Y2(e22), this.southernCenter && (e22 = -e22), t22 = Y2(t22 - this.center[0]);
          const r22 = 1e-6, { n: n22, f: i2 } = this;
          i2 > 0 ? e22 < -zd2 + r22 && (e22 = -zd2 + r22) : e22 > zd2 - r22 && (e22 = zd2 - r22);
          const s2 = i2 / Math.pow(kd2(e22), n22);
          let a2 = s2 * Math.sin(n22 * t22), o2 = i2 - s2 * Math.cos(n22 * t22);
          return a2 = 0.5 * (a2 / Math.PI + 0.5), o2 = 0.5 * (o2 / Math.PI + 0.5), { x: a2, y: this.southernCenter ? o2 : 1 - o2, z: 0 };
        }
        unproject(t22, e22) {
          t22 = (2 * t22 - 0.5) * Math.PI, this.southernCenter && (e22 = 1 - e22), e22 = (2 * (1 - e22) - 0.5) * Math.PI;
          const { n: r22, f: n22 } = this, i2 = n22 - e22, s2 = Math.sign(i2), a2 = Math.sign(r22) * Math.sqrt(t22 * t22 + i2 * i2);
          let o2 = Math.atan2(t22, Math.abs(i2)) * s2;
          i2 * r22 < 0 && (o2 -= Math.PI * Math.sign(t22) * s2);
          const l22 = Q2(Z2(o2 / r22) + this.center[0], -180, 180), u22 = Q2(Z2(2 * Math.atan(Math.pow(n22 / a2, 1 / r22)) - zd2), -fl2, fl2);
          return new rl2(l22, this.southernCenter ? -u22 : u22);
        }
      }
      class Ed2 extends bd2 {
        constructor(t22) {
          super(t22), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
        }
        project(t22, e22) {
          return { x: ol2(t22), y: ll2(e22), z: 0 };
        }
        unproject(t22, e22) {
          const r22 = cl2(t22), n22 = hl2(e22);
          return new rl2(r22, n22);
        }
      }
      const Bd2 = Y2(fl2);
      class Vd2 extends bd2 {
        project(t22, e22) {
          const r22 = (e22 = Y2(e22)) * e22, n22 = r22 * r22;
          return { x: 0.5 * ((t22 = Y2(t22)) * (0.8707 - 0.131979 * r22 + n22 * (n22 * (3971e-6 * r22 - 1529e-6 * n22) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e22 * (1.007226 + r22 * (0.015085 + n22 * (0.028874 * r22 - 0.044475 - 5916e-6 * n22))) / Math.PI + 1), z: 0 };
        }
        unproject(t22, e22) {
          t22 = (2 * t22 - 0.5) * Math.PI;
          let r22 = e22 = (2 * (1 - e22) - 1) * Math.PI, n22 = 25, i2 = 0, s2 = r22 * r22;
          do {
            s2 = r22 * r22;
            const t3 = s2 * s2;
            i2 = (r22 * (1.007226 + s2 * (0.015085 + t3 * (0.028874 * s2 - 0.044475 - 5916e-6 * t3))) - e22) / (1.007226 + s2 * (0.045255 + t3 * (0.259866 * s2 - 0.311325 - 5916e-6 * 11 * t3))), r22 = Q2(r22 - i2, -Bd2, Bd2);
          } while (Math.abs(i2) > 1e-6 && --n22 > 0);
          s2 = r22 * r22;
          const a2 = Q2(Z2(t22 / (0.8707 + s2 * (s2 * (s2 * s2 * s2 * (3971e-6 - 1529e-6 * s2) - 0.013791) - 0.131979))), -180, 180), o2 = Z2(r22);
          return new rl2(a2, o2);
        }
      }
      const Cd2 = Y2(fl2);
      class Rd2 extends bd2 {
        project(t22, e22) {
          e22 = Y2(e22), t22 = Y2(t22);
          const r22 = Math.cos(e22), n22 = 2 / Math.PI, i2 = Math.acos(r22 * Math.cos(t22 / 2)), s2 = Math.sin(i2) / i2, a2 = 0.5 * (t22 * n22 + 2 * r22 * Math.sin(t22 / 2) / s2) || 0, o2 = 0.5 * (e22 + Math.sin(e22) / s2) || 0;
          return { x: 0.5 * (a2 / Math.PI + 0.5), y: 1 - 0.5 * (o2 / Math.PI + 1), z: 0 };
        }
        unproject(t22, e22) {
          let r22 = t22 = (2 * t22 - 0.5) * Math.PI, n22 = e22 = (2 * (1 - e22) - 1) * Math.PI, i2 = 25;
          const s2 = 1e-6;
          let a2 = 0, o2 = 0;
          do {
            const i3 = Math.cos(n22), s3 = Math.sin(n22), l22 = 2 * s3 * i3, u22 = s3 * s3, c22 = i3 * i3, h22 = Math.cos(r22 / 2), p22 = Math.sin(r22 / 2), f22 = 2 * h22 * p22, d22 = p22 * p22, m22 = 1 - c22 * h22 * h22, y22 = m22 ? 1 / m22 : 0, g22 = m22 ? Math.acos(i3 * h22) * Math.sqrt(1 / m22) : 0, x22 = 0.5 * (2 * g22 * i3 * p22 + 2 * r22 / Math.PI) - t22, b22 = 0.5 * (g22 * s3 + n22) - e22, v22 = 0.5 * y22 * (c22 * d22 + g22 * i3 * h22 * u22) + 1 / Math.PI, w22 = y22 * (f22 * l22 / 4 - g22 * s3 * p22), _2 = 0.125 * y22 * (l22 * p22 - g22 * s3 * c22 * f22), M22 = 0.5 * y22 * (u22 * h22 + g22 * d22 * i3) + 0.5, A22 = w22 * _2 - M22 * v22;
            a2 = (b22 * w22 - x22 * M22) / A22, o2 = (x22 * _2 - b22 * v22) / A22, r22 = Q2(r22 - a2, -Math.PI, Math.PI), n22 = Q2(n22 - o2, -Cd2, Cd2);
          } while ((Math.abs(a2) > s2 || Math.abs(o2) > s2) && --i2 > 0);
          return new rl2(Z2(r22), Z2(n22));
        }
      }
      class Dd2 extends bd2 {
        constructor(t22) {
          super(t22), this.center = t22.center || [0, 0], this.parallels = t22.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(Y2(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
        }
        project(t22, e22) {
          const { scale: r22, cosPhi: n22 } = this;
          return { x: Y2(t22) * n22 * r22 + 0.5, y: -Math.sin(Y2(e22)) / n22 * r22 + 0.5, z: 0 };
        }
        unproject(t22, e22) {
          const { scale: r22, cosPhi: n22 } = this, i2 = -(e22 - 0.5) / r22, s2 = Q2(Z2((t22 - 0.5) / r22) / n22, -180, 180), a2 = Math.asin(Q2(i2 * n22, -1, 1)), o2 = Q2(Z2(a2), -fl2, fl2);
          return new rl2(s2, o2);
        }
      }
      class Ld2 extends Ed2 {
        constructor(t22) {
          super(t22), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
        }
        projectTilePoint(t22, e22, r22) {
          const n22 = zu(t22, e22, r22), i2 = Eu(_u(r22));
          return O2.vec3.transformMat4(n22, n22, i2), { x: n22[0], y: n22[1], z: n22[2] };
        }
        locationPoint(t22, e22) {
          const r22 = Qo(e22.lat, e22.lng), n22 = O2.vec3.normalize([], r22), i2 = t22.elevation ? t22.elevation.getAtPointOrZero(t22.locationCoordinate(e22), t22._centerAltitude) : t22._centerAltitude, s2 = ul2(1, 0) * Hr * i2;
          O2.vec3.scaleAndAdd(r22, r22, n22, s2);
          const a2 = O2.mat4.identity(new Float64Array(16));
          return O2.mat4.multiply(a2, t22.pixelMatrix, t22.globeMatrix), O2.vec3.transformMat4(r22, r22, a2), new q2(r22[0], r22[1]);
        }
        pixelsPerMeter(t22, e22) {
          return ul2(1, 0) * e22;
        }
        pixelSpaceConversion(t22, e22, r22) {
          const n22 = ul2(1, t22) * e22, i2 = ke2(ul2(1, 45) * e22, n22, r22);
          return this.pixelsPerMeter(t22, e22) / i2;
        }
        createTileMatrix(t22, e22, r22) {
          const n22 = Bu(_u(r22.canonical));
          return O2.mat4.multiply(new Float64Array(16), t22.globeMatrix, n22);
        }
        createInversionMatrix(t22, e22) {
          const { center: r22 } = t22, n22 = Eu(_u(e22));
          return O2.mat4.rotateY(n22, n22, Y2(r22.lng)), O2.mat4.rotateX(n22, n22, Y2(r22.lat)), O2.mat4.scale(n22, n22, [t22._pixelsPerMercatorPixel, t22._pixelsPerMercatorPixel, 1]), Float32Array.from(n22);
        }
        pointCoordinate(t22, e22, r22, n22) {
          return bu(t22, e22, r22, true) || new xl(0, 0);
        }
        pointCoordinate3D(t22, e22, r22) {
          const n22 = this.pointCoordinate(t22, e22, r22, 0);
          return [n22.x, n22.y, n22.z];
        }
        isPointAboveHorizon(t22, e22) {
          return !bu(t22, e22.x, e22.y, false);
        }
        farthestPixelDistance(t22) {
          const e22 = function(t3, e3) {
            const r3 = t3.cameraToCenterDistance, n22 = t3._centerAltitude * e3, i2 = t3._camera, s2 = t3._camera.forward(), a2 = O2.vec3.add([], O2.vec3.scale([], s2, -r3), [0, 0, n22]), o2 = t3.worldSize / (2 * Math.PI), l22 = [0, 0, -o2], u22 = t3.width / t3.height, c22 = Math.tan(t3.fovAboveCenter), h22 = O2.vec3.scale([], i2.up(), c22), p22 = O2.vec3.scale([], i2.right(), c22 * u22), f22 = O2.vec3.normalize([], O2.vec3.add([], O2.vec3.add([], s2, h22), p22)), d22 = [];
            let m22;
            if (new uu(a2, f22).closestPointOnSphere(l22, o2, d22)) {
              const e4 = O2.vec3.add([], d22, l22), r4 = O2.vec3.sub([], e4, a2);
              m22 = Math.cos(t3.fovAboveCenter) * O2.vec3.length(r4);
            } else {
              const t4 = O2.vec3.sub([], a2, l22), e4 = O2.vec3.sub([], l22, a2);
              O2.vec3.normalize(e4, e4);
              const r4 = O2.vec3.length(t4) - o2;
              m22 = Math.sqrt(r4 * (r4 + 2 * o2));
              const n3 = Math.acos(m22 / (o2 + r4)) - Math.acos(O2.vec3.dot(s2, e4));
              m22 *= Math.cos(n3);
            }
            return 1.01 * m22;
          }(t22, this.pixelsPerMeter(t22.center.lat, t22.worldSize)), r22 = Du(t22.zoom);
          if (r22 > 0) {
            const n22 = md2(t22, ul2(1, t22.center.lat) * t22.worldSize), i2 = t22.worldSize / (2 * Math.PI), s2 = Math.max(t22.width, t22.height) / t22.worldSize * Math.PI;
            return ke2(e22, n22 + i2 * (1 - Math.cos(s2)), Math.pow(r22, 10));
          }
          return e22;
        }
        upVector(t22, e22, r22) {
          return zu(e22, r22, t22, 1);
        }
        upVectorScale(t22) {
          return { metersToTile: gu(ku(_u(t22))) };
        }
      }
      function Fd2(t22) {
        const e22 = t22.parallels, r22 = !!e22 && Math.abs(e22[0] + e22[1]) < 0.01;
        switch (t22.name) {
          case "mercator":
            return new Ed2(t22);
          case "equirectangular":
            return new Pd2(t22);
          case "naturalEarth":
            return new Vd2(t22);
          case "equalEarth":
            return new Id2(t22);
          case "winkelTripel":
            return new Rd2(t22);
          case "albers":
            return r22 ? new Dd2(t22) : new vd2(t22);
          case "lambertConformalConic":
            return r22 ? new Dd2(t22) : new Td2(t22);
          case "globe":
            return new Ld2(t22);
        }
        throw new Error("Invalid projection name: ".concat(t22.name));
      }
      const Od2 = ch2.VectorTileFeature.types, Ud2 = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function jd2(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22) {
        const f22 = o2 ? Math.min(ud2, Math.round(o2[0])) : 0, d22 = o2 ? Math.min(ud2, Math.round(o2[1])) : 0;
        t22.emplaceBack(e22, r22, Math.round(32 * n22), Math.round(32 * i2), s2, a2, (f22 << 1) + (l22 ? 1 : 0), d22, 16 * u22, 16 * c22, 256 * h22, 256 * p22);
      }
      function Nd2(t22, e22, r22) {
        t22.emplaceBack(e22, r22);
      }
      function qd2(t22, e22, r22, n22, i2, s2, a2) {
        t22.emplaceBack(e22, r22, n22, i2, s2, a2);
      }
      function $d2(t22, e22, r22, n22, i2) {
        t22.emplaceBack(e22, r22, n22, i2), t22.emplaceBack(e22, r22, n22, i2), t22.emplaceBack(e22, r22, n22, i2), t22.emplaceBack(e22, r22, n22, i2);
      }
      function Gd2(t22) {
        for (const e22 of t22.sections)
          if (vs(e22.text))
            return true;
        return false;
      }
      class Xd2 {
        constructor(t22) {
          this.layoutVertexArray = new za2(), this.indexArray = new Da2(), this.programConfigurations = t22, this.segments = new co(), this.dynamicLayoutVertexArray = new Ma2(), this.opacityVertexArray = new Ta2(), this.placedSymbolArray = new Ja2(), this.iconTransitioningVertexArray = new Ea2(), this.globeExtVertexArray = new ka2(), this.zOffsetVertexArray = new Oa2();
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;
        }
        upload(t22, e22, r22, n22, i2) {
          this.isEmpty() || (r22 && (this.layoutVertexBuffer = t22.createVertexBuffer(this.layoutVertexArray, Rp.members), this.indexBuffer = t22.createIndexBuffer(this.indexArray, e22), this.dynamicLayoutVertexBuffer = t22.createVertexBuffer(this.dynamicLayoutVertexArray, Lp.members, true), this.opacityVertexBuffer = t22.createVertexBuffer(this.opacityVertexArray, Ud2, true), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t22.createVertexBuffer(this.iconTransitioningVertexArray, Op.members, true)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t22.createVertexBuffer(this.globeExtVertexArray, Dp.members, true)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i2) && (this.zOffsetVertexBuffer = t22.createVertexBuffer(this.zOffsetVertexArray, Fp.members, true)), this.opacityVertexBuffer.itemSize = 1), (r22 || n22) && this.programConfigurations.upload(t22));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
        }
      }
      os(Xd2, "SymbolBuffers");
      class Yd2 {
        constructor(t22, e22, r22) {
          this.layoutVertexArray = new t22(), this.layoutAttributes = e22, this.indexArray = new r22(), this.segments = new co(), this.collisionVertexArray = new Ra2(), this.collisionVertexArrayExt = new Ma2();
        }
        upload(t22) {
          this.layoutVertexBuffer = t22.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t22.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t22.createVertexBuffer(this.collisionVertexArray, Up.members, true), this.collisionVertexBufferExt = t22.createVertexBuffer(this.collisionVertexArrayExt, jp.members, true);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
        }
      }
      os(Yd2, "CollisionBuffers");
      class Zd2 {
        constructor(t22) {
          this.collisionBoxArray = t22.collisionBoxArray, this.zoom = t22.zoom, this.lut = t22.lut, this.overscaling = t22.overscaling, this.layers = t22.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t22.index, this.pixelRatio = t22.pixelRatio, this.sourceLayerIndex = t22.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.hasAnyIconTextFit = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = O2.mat4.identity([]), this.placementViewportMatrix = O2.mat4.identity([]);
          const e22 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = Xp(this.zoom, e22["text-size"]), this.iconSizeData = Xp(this.zoom, e22["icon-size"]);
          const r22 = this.layers[0].layout, n22 = r22.get("symbol-sort-key"), i2 = r22.get("symbol-z-order");
          this.canOverlap = r22.get("text-allow-overlap") || r22.get("icon-allow-overlap") || r22.get("text-ignore-placement") || r22.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i2 && void 0 !== n22.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i2 || "auto" === i2 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r22.get("text-writing-mode").map((t3) => ff2[t3]), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = t22.sourceID, this.projection = t22.projection, this.hasAnyZOffset = false, this.zOffsetSortDirty = false, this.zOffsetBuffersNeedUpload = r22.get("symbol-z-elevate"), this.activeReplacements = [], this.replacementUpdateTime = 0;
        }
        createArrays() {
          this.text = new Xd2(new Fo(this.layers, { zoom: this.zoom, lut: this.lut }, (t22) => t22.startsWith("text") || t22.startsWith("symbol"))), this.icon = new Xd2(new Fo(this.layers, { zoom: this.zoom, lut: this.lut }, (t22) => t22.startsWith("icon") || t22.startsWith("symbol"))), this.glyphOffsetArray = new eo(), this.lineVertexArray = new ro(), this.symbolInstances = new to();
        }
        calculateGlyphDependencies(t22, e22, r22, n22, i2) {
          for (let r3 = 0; r3 < t22.length; r3++) {
            const s2 = t22.codePointAt(r3);
            if (void 0 === s2)
              break;
            if (e22[s2] = true, n22 && i2 && s2 <= 65535) {
              const n3 = Kp[t22.charAt(r3)];
              n3 && (e22[n3.charCodeAt(0)] = true);
            }
          }
        }
        updateFootprints(t22, e22) {
        }
        updateReplacement(t22, e22) {
          if (e22.updateTime === this.replacementUpdateTime)
            return false;
          this.replacementUpdateTime = e22.updateTime;
          const r22 = e22.getReplacementRegionsForTile(t22.toUnwrapped(), true);
          return !wh2(this.activeReplacements, r22) && (this.activeReplacements = r22, true);
        }
        populate(t22, e22, r22, n22) {
          const i2 = this.layers[0], s2 = i2.layout, a2 = "globe" === this.projection.name, o2 = s2.get("text-font"), l22 = s2.get("text-field"), u22 = s2.get("icon-image"), c22 = ("constant" !== l22.value.kind || l22.value.value instanceof Qe2 && !l22.value.value.isEmpty() || l22.value.value.toString().length > 0) && ("constant" !== o2.value.kind || o2.value.value.length > 0), h22 = "constant" !== u22.value.kind || !!u22.value.value || Object.keys(u22.parameters).length > 0, p22 = s2.get("symbol-sort-key");
          if (this.features = [], !c22 && !h22)
            return;
          const f22 = e22.iconDependencies, d22 = e22.glyphDependencies, m22 = e22.availableImages, y22 = new Vs(this.zoom);
          for (const { feature: e3, id: l3, index: u3, sourceLayerIndex: g22 } of t22) {
            const t3 = i2._featureFilter.needGeometry, x22 = Pl(e3, t3);
            if (!i2._featureFilter.filter(y22, x22, r22))
              continue;
            if (t3 || (x22.geometry = Il(e3, r22, n22)), a2 && 1 !== e3.type && r22.z <= 5) {
              const t4 = x22.geometry, e4 = 0.98078528056, n3 = (t5, n4) => {
                const i3 = zu(t5.x, t5.y, r22, 1), s3 = zu(n4.x, n4.y, r22, 1);
                return O2.vec3.dot(i3, s3) < e4;
              };
              for (let e5 = 0; e5 < t4.length; e5++)
                t4[e5] = _l(t4[e5], n3);
            }
            let b22, v22;
            if (c22) {
              const t4 = i2.getValueAndResolveTokens("text-field", x22, r22, m22), e4 = Qe2.factory(t4);
              Gd2(e4) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === Ts() || this.hasRTLText && Bs.isParsed()) && (b22 = Hp(e4, i2, x22));
            }
            if (h22) {
              const t4 = i2.getValueAndResolveTokens("icon-image", x22, r22, m22);
              v22 = t4 instanceof tr ? t4 : tr.fromString(t4);
            }
            if (!b22 && !v22)
              continue;
            const w22 = this.sortFeaturesByKey ? p22.evaluate(x22, {}, r22) : void 0;
            if (this.features.push({ id: l3, text: b22, icon: v22, index: u3, sourceLayerIndex: g22, geometry: x22.geometry, properties: e3.properties, type: Od2[e3.type], sortKey: w22 }), v22 && (f22[v22.namePrimary] = true, v22.nameSecondary && (f22[v22.nameSecondary] = true)), b22) {
              const t4 = o2.evaluate(x22, {}, r22).join(","), e4 = "map" === s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement");
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(ff2.vertical) >= 0;
              for (const r3 of b22.sections)
                if (r3.image)
                  f22[r3.image.namePrimary] = true;
                else {
                  const n3 = fs(b22.toString()), i3 = r3.fontStack || t4, s3 = d22[i3] = d22[i3] || {};
                  this.calculateGlyphDependencies(r3.text, s3, e4, this.allowVerticalPlacement, n3);
                }
            }
          }
          "line" === s2.get("symbol-placement") && (this.features = function(t3) {
            const e3 = {}, r3 = {}, n3 = [];
            let i3 = 0;
            function s3(e4) {
              n3.push(t3[e4]), i3++;
            }
            function a3(t4, e4, i4) {
              const s4 = r3[t4];
              return delete r3[t4], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
            }
            function o3(t4, r4, i4) {
              const s4 = e3[r4];
              return delete e3[r4], e3[t4] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
            }
            function l3(t4, e4, r4) {
              const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
              return "".concat(t4, ":").concat(n4.x, ":").concat(n4.y);
            }
            for (let u3 = 0; u3 < t3.length; u3++) {
              const c3 = t3[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
              if (!p3) {
                s3(u3);
                continue;
              }
              const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
              if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                const t4 = o3(f3, d3, h3), i4 = a3(f3, d3, n3[t4].geometry);
                delete e3[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t4].geometry = null;
              } else
                f3 in r3 ? a3(f3, d3, h3) : d3 in e3 ? o3(f3, d3, h3) : (s3(u3), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
            }
            return n3.filter((t4) => t4.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((t3, e3) => t3.sortKey - e3.sortKey);
        }
        update(t22, e22, r22, n22, i2) {
          const s2 = 0 !== Object.keys(t22).length;
          if (s2 && !this.stateDependentLayers.length)
            return;
          const a2 = s2 ? this.stateDependentLayers : this.layers;
          this.text.programConfigurations.updatePaintArrays(t22, e22, a2, r22, n22, i2), this.icon.programConfigurations.updatePaintArrays(t22, e22, a2, r22, n22, i2);
        }
        updateZOffset() {
          const t22 = (t3, e3, n3) => {
            r22 += e3, r22 > t3.length && t3.resize(r22);
            for (let i2 = -e3; i2 < 0; i2++)
              t3.emplace(i2 + r22, n3);
          }, e22 = (t3, e3, r3) => {
            n22 += e3, n22 > t3.length && t3.resize(n22);
            for (let i2 = -e3; i2 < 0; i2++)
              t3.emplace(i2 + n22, r3);
          };
          if (!this.zOffsetBuffersNeedUpload)
            return;
          this.zOffsetBuffersNeedUpload = false;
          let r22 = 0, n22 = 0;
          for (let r3 = 0; r3 < this.symbolInstances.length; r3++) {
            const n3 = this.symbolInstances.get(r3), { numHorizontalGlyphVertices: i2, numVerticalGlyphVertices: s2, numIconVertices: a2 } = n3, o2 = n3.zOffset, l22 = a2 > 0;
            if ((i2 > 0 || s2 > 0) && (t22(this.text.zOffsetVertexArray, i2, o2), t22(this.text.zOffsetVertexArray, s2, o2)), l22) {
              const { placedIconSymbolIndex: t3, verticalPlacedIconSymbolIndex: r4 } = n3;
              t3 >= 0 && e22(this.icon.zOffsetVertexArray, a2, o2), r4 >= 0 && e22(this.icon.zOffsetVertexArray, n3.numVerticalIconVertices, o2);
            }
          }
          this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
        }
        isEmpty() {
          return 0 === this.symbolInstances.length && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(t22) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t22), this.iconCollisionBox.upload(t22)), this.text.upload(t22, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(t22, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = true;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        getProjection() {
          return this.projectionInstance || (this.projectionInstance = Fd2(this.projection)), this.projectionInstance;
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t22, e22) {
          const r22 = this.lineVertexArray.length;
          if (void 0 !== t22.segment)
            for (const { x: t3, y: r3 } of e22)
              this.lineVertexArray.emplaceBack(t3, r3);
          return { lineStartIndex: r22, lineLength: this.lineVertexArray.length - r22 };
        }
        addSymbols(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22, h22, p22, f22, d22, m22) {
          const y22 = t22.indexArray, g22 = t22.layoutVertexArray, x22 = t22.globeExtVertexArray, b22 = t22.segments.prepareSegment(4 * e22.length, g22, y22, this.canOverlap ? s2.sortKey : void 0), v22 = this.glyphOffsetArray.length, w22 = b22.vertexLength, _2 = this.allowVerticalPlacement && a2 === ff2.vertical ? Math.PI / 2 : 0, M22 = s2.text && s2.text.sections;
          for (let n3 = 0; n3 < e22.length; n3++) {
            const { tl: i3, tr: a3, bl: u3, br: c3, texPrimary: h3, texSecondary: v3, pixelOffsetTL: w3, pixelOffsetBR: A3, minFontScaleX: S22, minFontScaleY: I22, glyphOffset: P22, isSDF: z22, sectionIndex: k22 } = e22[n3], T22 = b22.vertexLength, E22 = P22[1];
            if (jd2(g22, l22.x, l22.y, i3.x, E22 + i3.y, h3.x, h3.y, r22, z22, w3.x, w3.y, S22, I22), jd2(g22, l22.x, l22.y, a3.x, E22 + a3.y, h3.x + h3.w, h3.y, r22, z22, A3.x, w3.y, S22, I22), jd2(g22, l22.x, l22.y, u3.x, E22 + u3.y, h3.x, h3.y + h3.h, r22, z22, w3.x, A3.y, S22, I22), jd2(g22, l22.x, l22.y, c3.x, E22 + c3.y, h3.x + h3.w, h3.y + h3.h, r22, z22, A3.x, A3.y, S22, I22), o2) {
              const { x: e3, y: r3, z: n4 } = o2.anchor, [i4, s3, a4] = o2.up;
              qd2(x22, e3, r3, n4, i4, s3, a4), qd2(x22, e3, r3, n4, i4, s3, a4), qd2(x22, e3, r3, n4, i4, s3, a4), qd2(x22, e3, r3, n4, i4, s3, a4), $d2(t22.dynamicLayoutVertexArray, e3, r3, n4, _2);
            } else
              $d2(t22.dynamicLayoutVertexArray, l22.x, l22.y, l22.z, _2);
            if (m22) {
              const e3 = v3 || h3;
              Nd2(t22.iconTransitioningVertexArray, e3.x, e3.y), Nd2(t22.iconTransitioningVertexArray, e3.x + e3.w, e3.y), Nd2(t22.iconTransitioningVertexArray, e3.x, e3.y + e3.h), Nd2(t22.iconTransitioningVertexArray, e3.x + e3.w, e3.y + e3.h);
            }
            y22.emplaceBack(T22, T22 + 1, T22 + 2), y22.emplaceBack(T22 + 1, T22 + 2, T22 + 3), b22.vertexLength += 4, b22.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P22[0]), n3 !== e22.length - 1 && k22 === e22[n3 + 1].sectionIndex || t22.programConfigurations.populatePaintArrays(g22.length, s2, s2.index, {}, p22, f22, d22, M22 && M22[k22]);
          }
          const A22 = o2 ? o2.anchor : l22;
          t22.placedSymbolArray.emplaceBack(A22.x, A22.y, A22.z, l22.x, l22.y, v22, this.glyphOffsetArray.length - v22, w22, u22, c22, l22.segment, r22 ? r22[0] : 0, r22 ? r22[1] : 0, n22[0], n22[1], a2, 0, false, 0, h22, 0);
        }
        _commitLayoutVertex(t22, e22, r22, n22, i2, s2, a2) {
          t22.emplaceBack(e22, r22, n22, i2, s2, Math.round(a2.x), Math.round(a2.y));
        }
        _addCollisionDebugVertices(t22, e22, r22, n22, i2, s2, a2) {
          const o2 = r22.segments.prepareSegment(4, r22.layoutVertexArray, r22.indexArray), l22 = o2.vertexLength, u22 = a2.tileAnchorX, c22 = a2.tileAnchorY;
          for (let t3 = 0; t3 < 4; t3++)
            r22.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
          this._commitDebugCollisionVertexUpdate(r22.collisionVertexArrayExt, e22, t22.padding, a2.zOffset), this._commitLayoutVertex(r22.layoutVertexArray, n22, i2, s2, u22, c22, new q2(t22.x1, t22.y1)), this._commitLayoutVertex(r22.layoutVertexArray, n22, i2, s2, u22, c22, new q2(t22.x2, t22.y1)), this._commitLayoutVertex(r22.layoutVertexArray, n22, i2, s2, u22, c22, new q2(t22.x2, t22.y2)), this._commitLayoutVertex(r22.layoutVertexArray, n22, i2, s2, u22, c22, new q2(t22.x1, t22.y2)), o2.vertexLength += 4;
          const h22 = r22.indexArray;
          h22.emplaceBack(l22, l22 + 1), h22.emplaceBack(l22 + 1, l22 + 2), h22.emplaceBack(l22 + 2, l22 + 3), h22.emplaceBack(l22 + 3, l22), o2.primitiveLength += 4;
        }
        _addTextDebugCollisionBoxes(t22, e22, r22, n22, i2, s2) {
          for (let a2 = n22; a2 < i2; a2++) {
            const n3 = r22.get(a2), i3 = this.getSymbolInstanceTextSize(t22, s2, e22, a2);
            this._addCollisionDebugVertices(n3, i3, this.textCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
          }
        }
        _addIconDebugCollisionBoxes(t22, e22, r22, n22, i2, s2) {
          for (let a2 = n22; a2 < i2; a2++) {
            const n3 = r22.get(a2), i3 = this.getSymbolInstanceIconSize(t22, e22, s2.placedIconSymbolIndex);
            this._addCollisionDebugVertices(n3, i3, this.iconCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
          }
        }
        generateCollisionDebugBuffers(t22, e22) {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Yd2(Va2, Np.members, Ea2), this.iconCollisionBox = new Yd2(Va2, Np.members, Ea2);
          const r22 = Zp(this.iconSizeData, t22), n22 = Zp(this.textSizeData, t22);
          for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
            const s2 = this.symbolInstances.get(i2);
            this._addTextDebugCollisionBoxes(n22, t22, e22, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._addTextDebugCollisionBoxes(n22, t22, e22, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r22, t22, e22, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r22, t22, e22, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
          }
        }
        getSymbolInstanceTextSize(t22, e22, r22, n22) {
          const i2 = this.text.placedSymbolArray.get(e22.rightJustifiedTextSymbolIndex >= 0 ? e22.rightJustifiedTextSymbolIndex : e22.centerJustifiedTextSymbolIndex >= 0 ? e22.centerJustifiedTextSymbolIndex : e22.leftJustifiedTextSymbolIndex >= 0 ? e22.leftJustifiedTextSymbolIndex : e22.verticalPlacedTextSymbolIndex >= 0 ? e22.verticalPlacedTextSymbolIndex : n22), s2 = Yp(this.textSizeData, t22, i2) / $p;
          return this.tilePixelRatio * s2;
        }
        getSymbolInstanceIconSize(t22, e22, r22) {
          const n22 = this.icon.placedSymbolArray.get(r22), i2 = Yp(this.iconSizeData, t22, n22);
          return this.tilePixelRatio * i2;
        }
        _commitDebugCollisionVertexUpdate(t22, e22, r22, n22) {
          t22.emplaceBack(e22, -r22, -r22, n22), t22.emplaceBack(e22, r22, -r22, n22), t22.emplaceBack(e22, r22, r22, n22), t22.emplaceBack(e22, -r22, r22, n22);
        }
        _updateTextDebugCollisionBoxes(t22, e22, r22, n22, i2, s2) {
          for (let a2 = n22; a2 < i2; a2++) {
            const n3 = r22.get(a2), i3 = this.getSymbolInstanceTextSize(t22, s2, e22, a2);
            this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i3, n3.padding, s2.zOffset);
          }
        }
        _updateIconDebugCollisionBoxes(t22, e22, r22, n22, i2, s2) {
          for (let a2 = n22; a2 < i2; a2++) {
            const n3 = r22.get(a2), i3 = this.getSymbolInstanceIconSize(t22, e22, s2.placedIconSymbolIndex);
            this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i3, n3.padding, s2.zOffset);
          }
        }
        updateCollisionDebugBuffers(t22, e22) {
          if (!this.hasDebugData())
            return;
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
          const r22 = Zp(this.iconSizeData, t22), n22 = Zp(this.textSizeData, t22);
          for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
            const s2 = this.symbolInstances.get(i2);
            this._updateTextDebugCollisionBoxes(n22, t22, e22, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._updateTextDebugCollisionBoxes(n22, t22, e22, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._updateIconDebugCollisionBoxes(r22, t22, e22, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._updateIconDebugCollisionBoxes(r22, t22, e22, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
          }
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
        }
        _deserializeCollisionBoxesForSymbol(t22, e22, r22, n22, i2, s2, a2, o2, l22) {
          const u22 = {};
          if (e22 < r22) {
            const { x1: r3, y1: n3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22, featureIndex: f22 } = t22.get(e22);
            u22.textBox = { x1: r3, y1: n3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22 }, u22.textFeatureIndex = f22;
          }
          if (n22 < i2) {
            const { x1: e3, y1: r3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22, featureIndex: f22 } = t22.get(n22);
            u22.verticalTextBox = { x1: e3, y1: r3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22 }, u22.verticalTextFeatureIndex = f22;
          }
          if (s2 < a2) {
            const { x1: e3, y1: r3, x2: n3, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22, featureIndex: f22 } = t22.get(s2);
            u22.iconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22 }, u22.iconFeatureIndex = f22;
          }
          if (o2 < l22) {
            const { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22, featureIndex: f22 } = t22.get(o2);
            u22.verticalIconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c22, tileAnchorX: h22, tileAnchorY: p22 }, u22.verticalIconFeatureIndex = f22;
          }
          return u22;
        }
        deserializeCollisionBoxes(t22) {
          this.collisionArrays = [];
          for (let e22 = 0; e22 < this.symbolInstances.length; e22++) {
            const r22 = this.symbolInstances.get(e22);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t22, r22.textBoxStartIndex, r22.textBoxEndIndex, r22.verticalTextBoxStartIndex, r22.verticalTextBoxEndIndex, r22.iconBoxStartIndex, r22.iconBoxEndIndex, r22.verticalIconBoxStartIndex, r22.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        hasIconTextFit() {
          return this.hasAnyIconTextFit;
        }
        addIndicesForPlacedSymbol(t22, e22) {
          const r22 = t22.placedSymbolArray.get(e22), n22 = r22.vertexStartIndex + 4 * r22.numGlyphs;
          for (let e3 = r22.vertexStartIndex; e3 < n22; e3 += 4)
            t22.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t22.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
        }
        getSortedSymbolIndexes(t22) {
          if (this.sortedAngle === t22 && void 0 !== this.symbolInstanceIndexes)
            return this.symbolInstanceIndexes;
          const e22 = Math.sin(t22), r22 = Math.cos(t22), n22 = [], i2 = [], s2 = [];
          for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
            s2.push(t3);
            const a2 = this.symbolInstances.get(t3);
            n22.push(0 | Math.round(e22 * a2.tileAnchorX + r22 * a2.tileAnchorY)), i2.push(a2.featureIndex);
          }
          return s2.sort((t3, e3) => n22[t3] - n22[e3] || i2[e3] - i2[t3]), s2;
        }
        getSortedIndexesByZOffset() {
          if (!this.zOffsetSortDirty)
            return this.symbolInstanceIndexesSortedZOffset;
          if (!this.symbolInstanceIndexesSortedZOffset) {
            this.symbolInstanceIndexesSortedZOffset = [];
            for (let t22 = 0; t22 < this.symbolInstances.length; ++t22)
              this.symbolInstanceIndexesSortedZOffset.push(t22);
          }
          return this.zOffsetSortDirty = false, this.symbolInstanceIndexesSortedZOffset.sort((t22, e22) => this.symbolInstances.get(e22).zOffset - this.symbolInstances.get(t22).zOffset);
        }
        addToSortKeyRanges(t22, e22) {
          const r22 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          r22 && r22.sortKey === e22 ? r22.symbolInstanceEnd = t22 + 1 : this.sortKeyRanges.push({ sortKey: e22, symbolInstanceStart: t22, symbolInstanceEnd: t22 + 1 });
        }
        sortFeatures(t22) {
          if (this.sortFeaturesByY && this.sortedAngle !== t22 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t22), this.sortedAngle = t22, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const t3 of this.symbolInstanceIndexes) {
              const e22 = this.symbolInstances.get(t3);
              this.featureSortOrder.push(e22.featureIndex);
              const { rightJustifiedTextSymbolIndex: r22, centerJustifiedTextSymbolIndex: n22, leftJustifiedTextSymbolIndex: i2, verticalPlacedTextSymbolIndex: s2, placedIconSymbolIndex: a2, verticalPlacedIconSymbolIndex: o2 } = e22;
              r22 >= 0 && this.addIndicesForPlacedSymbol(this.text, r22), n22 >= 0 && n22 !== r22 && this.addIndicesForPlacedSymbol(this.text, n22), i2 >= 0 && i2 !== n22 && i2 !== r22 && this.addIndicesForPlacedSymbol(this.text, i2), s2 >= 0 && this.addIndicesForPlacedSymbol(this.text, s2), a2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a2), o2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o2);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let Wd2, Hd2, Kd2;
      os(Zd2, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Zd2.addDynamicAttributes = $d2;
      class Jd2 {
        constructor(t22) {
          this.type = t22.property.overrides ? t22.property.overrides.runtimeType : Re2, this.defaultValue = t22;
        }
        evaluate(t22) {
          if (t22.formattedSection) {
            const e22 = this.defaultValue.property.overrides;
            if (e22 && e22.hasOverride(t22.formattedSection))
              return e22.getOverride(t22.formattedSection);
          }
          return t22.feature && t22.featureState ? this.defaultValue.evaluate(t22.feature, t22.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(t22) {
          this.defaultValue.isConstant() || t22(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return null;
        }
      }
      os(Jd2, "FormatSectionOverride", { omit: ["defaultValue"] });
      const Qd2 = () => Kd2 || (Kd2 = { layout: Wd2 || (Wd2 = new Gs({ "symbol-placement": new Ns(Xs.layout_symbol["symbol-placement"]), "symbol-spacing": new Ns(Xs.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Ns(Xs.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new qs(Xs.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Ns(Xs.layout_symbol["symbol-z-order"]), "symbol-z-elevate": new Ns(Xs.layout_symbol["symbol-z-elevate"]), "icon-allow-overlap": new Ns(Xs.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Ns(Xs.layout_symbol["icon-ignore-placement"]), "icon-optional": new Ns(Xs.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Ns(Xs.layout_symbol["icon-rotation-alignment"]), "icon-size": new qs(Xs.layout_symbol["icon-size"]), "icon-text-fit": new qs(Xs.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new qs(Xs.layout_symbol["icon-text-fit-padding"]), "icon-image": new qs(Xs.layout_symbol["icon-image"]), "icon-rotate": new qs(Xs.layout_symbol["icon-rotate"]), "icon-padding": new Ns(Xs.layout_symbol["icon-padding"]), "icon-keep-upright": new Ns(Xs.layout_symbol["icon-keep-upright"]), "icon-offset": new qs(Xs.layout_symbol["icon-offset"]), "icon-anchor": new qs(Xs.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Ns(Xs.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Ns(Xs.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Ns(Xs.layout_symbol["text-rotation-alignment"]), "text-field": new qs(Xs.layout_symbol["text-field"]), "text-font": new qs(Xs.layout_symbol["text-font"]), "text-size": new qs(Xs.layout_symbol["text-size"]), "text-max-width": new qs(Xs.layout_symbol["text-max-width"]), "text-line-height": new qs(Xs.layout_symbol["text-line-height"]), "text-letter-spacing": new qs(Xs.layout_symbol["text-letter-spacing"]), "text-justify": new qs(Xs.layout_symbol["text-justify"]), "text-radial-offset": new qs(Xs.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Ns(Xs.layout_symbol["text-variable-anchor"]), "text-anchor": new qs(Xs.layout_symbol["text-anchor"]), "text-max-angle": new Ns(Xs.layout_symbol["text-max-angle"]), "text-writing-mode": new Ns(Xs.layout_symbol["text-writing-mode"]), "text-rotate": new qs(Xs.layout_symbol["text-rotate"]), "text-padding": new Ns(Xs.layout_symbol["text-padding"]), "text-keep-upright": new Ns(Xs.layout_symbol["text-keep-upright"]), "text-transform": new qs(Xs.layout_symbol["text-transform"]), "text-offset": new qs(Xs.layout_symbol["text-offset"]), "text-allow-overlap": new Ns(Xs.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Ns(Xs.layout_symbol["text-ignore-placement"]), "text-optional": new Ns(Xs.layout_symbol["text-optional"]), visibility: new Ns(Xs.layout_symbol.visibility) })), paint: Hd2 || (Hd2 = new Gs({ "icon-opacity": new qs(Xs.paint_symbol["icon-opacity"]), "icon-occlusion-opacity": new qs(Xs.paint_symbol["icon-occlusion-opacity"]), "icon-emissive-strength": new qs(Xs.paint_symbol["icon-emissive-strength"]), "text-emissive-strength": new qs(Xs.paint_symbol["text-emissive-strength"]), "icon-color": new qs(Xs.paint_symbol["icon-color"]), "icon-halo-color": new qs(Xs.paint_symbol["icon-halo-color"]), "icon-halo-width": new qs(Xs.paint_symbol["icon-halo-width"]), "icon-halo-blur": new qs(Xs.paint_symbol["icon-halo-blur"]), "icon-translate": new Ns(Xs.paint_symbol["icon-translate"]), "icon-translate-anchor": new Ns(Xs.paint_symbol["icon-translate-anchor"]), "icon-image-cross-fade": new qs(Xs.paint_symbol["icon-image-cross-fade"]), "text-opacity": new qs(Xs.paint_symbol["text-opacity"]), "text-occlusion-opacity": new qs(Xs.paint_symbol["text-occlusion-opacity"]), "text-color": new qs(Xs.paint_symbol["text-color"], { runtimeType: Oe2, getOverride: (t22) => t22.textColor, hasOverride: (t22) => !!t22.textColor }), "text-halo-color": new qs(Xs.paint_symbol["text-halo-color"]), "text-halo-width": new qs(Xs.paint_symbol["text-halo-width"]), "text-halo-blur": new qs(Xs.paint_symbol["text-halo-blur"]), "text-translate": new Ns(Xs.paint_symbol["text-translate"]), "text-translate-anchor": new Ns(Xs.paint_symbol["text-translate-anchor"]), "icon-color-saturation": new Ns(Xs.paint_symbol["icon-color-saturation"]), "icon-color-contrast": new Ns(Xs.paint_symbol["icon-color-contrast"]), "icon-color-brightness-min": new Ns(Xs.paint_symbol["icon-color-brightness-min"]), "icon-color-brightness-max": new Ns(Xs.paint_symbol["icon-color-brightness-max"]), "symbol-z-offset": new qs(Xs.paint_symbol["symbol-z-offset"]), "symbol-elevation-reference": new Ns(Xs.paint_symbol["symbol-elevation-reference"]) })) }, Kd2);
      class tm extends pa2 {
        constructor(t22, e22, r22, n22) {
          super(t22, Qd2(), e22, r22, n22), this._colorAdjustmentMatrix = O2.mat4.identity([]), this.hasInitialOcclusionOpacityProperties = void 0 !== t22.paint && ("icon-occlusion-opacity" in t22.paint || "text-occlusion-opacity" in t22.paint);
        }
        recalculate(t22, e22) {
          super.recalculate(t22, e22), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
          const r22 = this.layout.get("text-writing-mode");
          if (r22) {
            const t3 = [];
            for (const e3 of r22)
              t3.indexOf(e3) < 0 && t3.push(e3);
            this.layout._values["text-writing-mode"] = t3;
          } else
            this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
          this._setPaintOverrides();
        }
        getColorAdjustmentMatrix(t22, e22, r22, n22) {
          return this._saturation === t22 && this._contrast === e22 && this._brightnessMin === r22 && this._brightnessMax === n22 || (this._colorAdjustmentMatrix = function(t3, e3, r3, n3) {
            t3 = St(t3), e3 = At(e3);
            const i2 = O2.mat4.create(), s2 = t3 / 3, a2 = 1 - 2 * s2, o2 = [a2, s2, s2, 0, s2, a2, s2, 0, s2, s2, a2, 0, 0, 0, 0, 1], l22 = 0.5 - 0.5 * e3, u22 = n3 - r3;
            return O2.mat4.multiply(i2, [u22, 0, 0, 0, 0, u22, 0, 0, 0, 0, u22, 0, r3, r3, r3, 1], [e3, 0, 0, 0, 0, e3, 0, 0, 0, 0, e3, 0, l22, l22, l22, 1]), O2.mat4.multiply(i2, i2, o2), i2;
          }(t22, e22, r22, n22), this._saturation = t22, this._contrast = e22, this._brightnessMin = r22, this._brightnessMax = n22), this._colorAdjustmentMatrix;
        }
        getValueAndResolveTokens(t22, e22, r22, n22) {
          const i2 = this.layout.get(t22).evaluate(e22, {}, r22, n22), s2 = this._unevaluatedLayout._values[t22];
          return s2.isDataDriven() || Wi2(s2.value) || !i2 ? i2 : function(t3, e3) {
            return e3.replace(/{([^{}]+)}/g, (e4, r3) => r3 in t3 ? String(t3[r3]) : "");
          }(e22.properties, i2);
        }
        createBucket(t22) {
          return new Zd2(t22);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        _setPaintOverrides() {
          for (const t22 of Qd2().paint.overridableProperties) {
            if (!tm.hasPaintOverride(this.layout, t22))
              continue;
            const e22 = this.paint.get(t22), r22 = new Jd2(e22), n22 = new Zi2(r22, e22.property.specification, this.scope, this.options);
            let i2 = null;
            i2 = "constant" === e22.value.kind || "source" === e22.value.kind ? new Ki2("source", n22) : new Ji2("composite", n22, e22.value.zoomStops, e22.value._interpolationType), this.paint._values[t22] = new Us(e22.property, i2, e22.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(t22, e22, r22) {
          return !(!this.layout || e22.isDataDriven() || r22.isDataDriven()) && tm.hasPaintOverride(this.layout, t22);
        }
        static hasPaintOverride(t22, e22) {
          const r22 = t22.get("text-field"), n22 = Qd2().paint.properties[e22];
          let i2 = false;
          const s2 = (t3) => {
            for (const e3 of t3)
              if (n22.overrides && n22.overrides.hasOverride(e3))
                return void (i2 = true);
          };
          if ("constant" === r22.value.kind && r22.value.value instanceof Qe2)
            s2(r22.value.value.sections);
          else if ("source" === r22.value.kind) {
            const t3 = (e4) => {
              i2 || (e4 instanceof sr && nr(e4.value) === qe2 ? s2(e4.value.sections) : e4 instanceof ur ? s2(e4.sections) : e4.eachChild(t3));
            }, e3 = r22.value;
            e3._styleExpression && t3(e3._styleExpression.expression);
          }
          return i2;
        }
        getProgramIds() {
          return ["symbol"];
        }
        getDefaultProgramParams(t22, e22, r22) {
          return { config: new Lo(this, { zoom: e22, lut: r22 }), overrideFog: false };
        }
      }
      let em, rm, nm, im;
      var sm = ya2([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      function am(t22) {
        switch (t22) {
          case WebGL2RenderingContext.RGBA8:
            return WebGL2RenderingContext.RGBA;
          case WebGL2RenderingContext.DEPTH_COMPONENT16:
            return WebGL2RenderingContext.DEPTH_COMPONENT;
          case WebGL2RenderingContext.DEPTH24_STENCIL8:
            return WebGL2RenderingContext.DEPTH_STENCIL;
          case WebGL2RenderingContext.R8:
          case WebGL2RenderingContext.R32F:
            return WebGL2RenderingContext.RED;
        }
      }
      function om(t22) {
        switch (t22) {
          case WebGL2RenderingContext.RGBA8:
            return WebGL2RenderingContext.UNSIGNED_BYTE;
          case WebGL2RenderingContext.DEPTH_COMPONENT16:
            return WebGL2RenderingContext.UNSIGNED_SHORT;
          case WebGL2RenderingContext.DEPTH24_STENCIL8:
            return WebGL2RenderingContext.UNSIGNED_INT_24_8;
          case WebGL2RenderingContext.R8:
            return WebGL2RenderingContext.UNSIGNED_BYTE;
          case WebGL2RenderingContext.R32F:
            return WebGL2RenderingContext.FLOAT;
        }
      }
      class lm {
        constructor(t22, e22, r22, n22) {
          this.context = t22, this.format = r22, this.useMipmap = n22 && n22.useMipmap, this.texture = t22.gl.createTexture(), this.update(e22, { premultiply: n22 && n22.premultiply });
        }
        update(t22, e22) {
          const r22 = t22 && t22 instanceof HTMLVideoElement && 0 === t22.width ? t22.videoWidth : t22.width, n22 = t22 && t22 instanceof HTMLVideoElement && 0 === t22.height ? t22.videoHeight : t22.height, { context: i2 } = this, { gl: s2 } = i2, { x: a2, y: o2 } = e22 && e22.position ? e22.position : { x: 0, y: 0 }, l22 = Math.max(a2 + r22, this.size ? this.size[0] : 0), u22 = Math.max(o2 + n22, this.size ? this.size[1] : 0);
          !this.size || this.size[0] === l22 && this.size[1] === u22 || (s2.bindTexture(s2.TEXTURE_2D, null), s2.deleteTexture(this.texture), this.texture = s2.createTexture(), this.size = null), s2.bindTexture(s2.TEXTURE_2D, this.texture), i2.pixelStoreUnpackFlipY.set(false), i2.pixelStoreUnpack.set(1), i2.pixelStoreUnpackPremultiplyAlpha.set(this.format === s2.RGBA8 && (!e22 || false !== e22.premultiply));
          const c22 = t22 instanceof HTMLImageElement || t22 instanceof HTMLCanvasElement || t22 instanceof HTMLVideoElement || t22 instanceof ImageData || ImageBitmap && t22 instanceof ImageBitmap;
          if (!this.size && l22 > 0 && u22 > 0) {
            const t3 = this.useMipmap ? Math.floor(Math.log2(Math.max(l22, u22))) + 1 : 1;
            s2.texStorage2D(s2.TEXTURE_2D, t3, this.format, l22, u22), this.size = [l22, u22];
          }
          if (this.size)
            if (c22)
              s2.texSubImage2D(s2.TEXTURE_2D, 0, a2, o2, am(this.format), om(this.format), t22);
            else {
              const e3 = t22.data;
              e3 && s2.texSubImage2D(s2.TEXTURE_2D, 0, a2, o2, r22, n22, am(this.format), om(this.format), e3);
            }
          this.useMipmap && s2.generateMipmap(s2.TEXTURE_2D);
        }
        bind(t22, e22, r22 = false) {
          const { context: n22 } = this, { gl: i2 } = n22;
          i2.bindTexture(i2.TEXTURE_2D, this.texture), t22 !== this.minFilter && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, t22), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, this.useMipmap && !r22 ? t22 === i2.NEAREST ? i2.NEAREST_MIPMAP_NEAREST : i2.LINEAR_MIPMAP_LINEAR : t22), this.minFilter = t22), e22 !== this.wrapS && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, e22), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, e22), this.wrapS = e22);
        }
        bindExtraParam(t22, e22, r22, n22) {
          const { context: i2 } = this, { gl: s2 } = i2;
          s2.bindTexture(s2.TEXTURE_2D, this.texture), e22 !== this.magFilter && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MAG_FILTER, e22), this.magFilter = e22), t22 !== this.minFilter && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MIN_FILTER, this.useMipmap ? t22 === s2.NEAREST ? s2.NEAREST_MIPMAP_NEAREST : s2.LINEAR_MIPMAP_LINEAR : t22), this.minFilter = t22), r22 !== this.wrapS && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_S, r22), this.wrapS = r22), n22 !== this.wrapT && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_T, n22), this.wrapT = n22);
        }
        destroy() {
          const { gl: t22 } = this.context;
          t22.deleteTexture(this.texture), this.texture = null;
        }
      }
      class um {
        constructor(t22, e22) {
          this.context = t22, this.texture = e22;
        }
        bind(t22, e22) {
          const { context: r22 } = this, { gl: n22 } = r22;
          n22.bindTexture(n22.TEXTURE_2D, this.texture), t22 !== this.minFilter && (n22.texParameteri(n22.TEXTURE_2D, n22.TEXTURE_MAG_FILTER, t22), n22.texParameteri(n22.TEXTURE_2D, n22.TEXTURE_MIN_FILTER, t22), this.minFilter = t22), e22 !== this.wrapS && (n22.texParameteri(n22.TEXTURE_2D, n22.TEXTURE_WRAP_S, e22), n22.texParameteri(n22.TEXTURE_2D, n22.TEXTURE_WRAP_T, e22), this.wrapS = e22);
        }
      }
      function cm(t22, e22, r22, n22, i2, s2, a2, o2) {
        const l22 = [t22, e22, 1, r22, n22, 1, i2, s2, 1], u22 = [a2, o2, 1], c22 = O2.mat3.adjoint([], l22), [h22, p22, f22] = O2.vec3.transformMat3(u22, u22, c22);
        return O2.mat3.multiply(l22, l22, [h22, 0, 0, 0, p22, 0, 0, 0, f22]);
      }
      function hm(t22, e22, r22, n22, i2, s2, a2, o2) {
        const l22 = function(t3, e3, r3, n3, i3, s3, a3, o3) {
          const l3 = cm(0, 0, 1, 0, 1, 1, 0, 1), u22 = cm(t3, e3, r3, n3, i3, s3, a3, o3), c22 = O2.mat3.adjoint([], l3);
          return O2.mat3.multiply(u22, u22, c22);
        }(t22, e22, r22, n22, i2, s2, a2, o2);
        return [l22[2] / l22[8] / Hr, l22[5] / l22[8] / Hr];
      }
      function pm(t22) {
        return [t22[0], Math.min(Math.max(t22[1], -fl2), fl2)];
      }
      class fm extends Me2 {
        constructor(t22, e22, r22, n22) {
          super(), this.id = t22, this.dispatcher = r22, this.coordinates = e22.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.onNorthPole = false, this.onSouthPole = false, this.setEventedParent(n22), this.options = e22, this._dirty = false;
        }
        load(t22, e22) {
          if (this._loaded = e22 || false, this.fire(new be2("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url)
            return t22 && (this.coordinates = t22), this._loaded = true, void this._finishLoading();
          this._imageRequest = ce2(this.map._requestManager.transformRequest(this.url, ee2.Image), (e3, r22) => {
            this._imageRequest = null, this._loaded = true, e3 ? this.fire(new ve2(e3)) : r22 && (this.image = r22 instanceof HTMLImageElement ? Dt.getImageData(r22) : r22, this._dirty = true, this.width = this.image.width, this.height = this.image.height, t22 && (this.coordinates = t22), this._finishLoading());
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(t22) {
          return t22.url ? (this._imageRequest && t22.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t22.url, this.load(t22.coordinates, this._loaded), this) : this;
        }
        setTexture(t22) {
          if (!(t22.handle instanceof WebGLTexture))
            throw new Error("The provided handle is not a WebGLTexture instance");
          return this.texture = new um(this.map.painter.context, t22.handle), this.width = t22.dimensions[0], this.height = t22.dimensions[1], this._dirty = false, this._loaded = true, this._finishLoading(), this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new be2("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(t22) {
          this.map = t22, this.load();
        }
        onRemove(t22) {
          this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof um || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
        }
        setCoordinates(t22) {
          if (this.coordinates = t22, this._boundsArray = void 0, this._unsupportedCoords = false, !t22.length)
            return this;
          this.onNorthPole = false, this.onSouthPole = false;
          let e22 = t22[0][1], r22 = t22[0][1];
          for (const n3 of t22)
            n3[1] > r22 && (r22 = n3[1]), n3[1] < e22 && (e22 = n3[1]);
          const n22 = (r22 + e22) / 2;
          if (n22 > fl2 ? this.onNorthPole = true : n22 < -fl2 && (this.onSouthPole = true), !this.onNorthPole && !this.onSouthPole) {
            const e3 = t22.map(xl.fromLngLat);
            this.tileID = function(t3) {
              let e4 = 1 / 0, r3 = 1 / 0, n3 = -1 / 0, i2 = -1 / 0;
              for (const s3 of t3)
                e4 = Math.min(e4, s3.x), r3 = Math.min(r3, s3.y), n3 = Math.max(n3, s3.x), i2 = Math.max(i2, s3.y);
              const s2 = Math.max(n3 - e4, i2 - r3), a2 = Math.max(0, Math.floor(-Math.log(s2) / Math.LN2)), o2 = Math.pow(2, a2);
              let l22 = Math.floor((e4 + n3) / 2 * o2);
              return l22 > 1 && (l22 -= 1), new tu(a2, l22, Math.floor((r3 + i2) / 2 * o2));
            }(e3), this.minzoom = this.maxzoom = this.tileID.z;
          }
          return this.fire(new be2("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        _clear() {
          this._boundsArray = void 0, this._unsupportedCoords = false;
        }
        _prepareData(t22) {
          for (const t3 in this.tiles) {
            const e3 = this.tiles[t3];
            "loaded" !== e3.state && (e3.state = "loaded", e3.texture = this.texture);
          }
          if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords)
            return;
          const e22 = yd2(new tu(0, 0, 0), this.map.transform.projection), r22 = [e22.projection.project(this.coordinates[0][0], this.coordinates[0][1]), e22.projection.project(this.coordinates[1][0], this.coordinates[1][1]), e22.projection.project(this.coordinates[2][0], this.coordinates[2][1]), e22.projection.project(this.coordinates[3][0], this.coordinates[3][1])];
          if (!function(t3) {
            const e3 = t3[1].x - t3[0].x, r3 = t3[1].y - t3[0].y, n3 = t3[2].x - t3[1].x, i3 = t3[2].y - t3[1].y, s3 = t3[3].x - t3[2].x, a3 = t3[3].y - t3[2].y, o3 = t3[0].x - t3[3].x, l3 = t3[0].y - t3[3].y, u3 = e3 * i3 - n3 * r3, c3 = n3 * a3 - s3 * i3, h3 = s3 * l3 - o3 * a3, p3 = o3 * r3 - e3 * l3;
            return u3 > 0 && c3 > 0 && h3 > 0 && p3 > 0 || u3 < 0 && c3 < 0 && h3 < 0 && p3 < 0;
          }(r22))
            return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = true);
          const n22 = yd2(this.tileID, this.map.transform.projection), [i2, s2, a2, o2] = this.coordinates.map((t3) => {
            const e3 = n22.projection.project(t3[0], t3[1]);
            return gd2(n22, e3)._round();
          });
          this.perspectiveTransform = hm(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, o2.x, o2.y);
          const l22 = this._boundsArray = new va2();
          l22.emplaceBack(i2.x, i2.y, 0, 0), l22.emplaceBack(s2.x, s2.y, Hr, 0), l22.emplaceBack(o2.x, o2.y, 0, Hr), l22.emplaceBack(a2.x, a2.y, Hr, Hr), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = t22.createVertexBuffer(l22, sm.members), this.boundsSegments = co.simpleSegment(0, 0, 4, 2);
          const u22 = [], c22 = [pm((h22 = this.coordinates)[0]), pm(h22[1]), pm(h22[2]), pm(h22[3])];
          var h22;
          const [p22, f22, d22, m22] = function(t3) {
            let e3 = t3[0][0], r3 = e3, n3 = t3[0][1], i3 = n3;
            for (let s3 = 1; s3 < t3.length; s3++)
              t3[s3][0] < e3 ? e3 = t3[s3][0] : t3[s3][0] > r3 && (r3 = t3[s3][0]), t3[s3][1] < n3 ? n3 = t3[s3][1] : t3[s3][1] > i3 && (i3 = t3[s3][1]);
            return [e3, n3, r3 - e3, i3 - n3];
          }(c22);
          {
            const n3 = new va2(), [i3, s3, a3, o3] = function(t3) {
              let e3 = t3[0].x, r3 = e3, n4 = t3[0].y, i4 = n4;
              for (let s4 = 1; s4 < t3.length; s4++)
                t3[s4].x < e3 ? e3 = t3[s4].x : t3[s4].x > r3 && (r3 = t3[s4].x), t3[s4].y < n4 ? n4 = t3[s4].y : t3[s4].y > i4 && (i4 = t3[s4].y);
              return [e3, n4, r3 - e3, i4 - n4];
            }(r22), l3 = (t3) => [(t3.x - i3) / a3, (t3.y - s3) / o3], [c3, h3, y22, g22] = r22.map(l3), x22 = function(t3, e3, r3, n4, i4, s4, a4, o4) {
              const l4 = cm(0, 0, 1, 0, 1, 1, 0, 1), u3 = cm(t3, e3, r3, n4, i4, s4, a4, o4), c4 = O2.mat3.adjoint([], u3);
              return O2.mat3.multiply(l4, l4, c4);
            }(c3[0], c3[1], h3[0], h3[1], y22[0], y22[1], g22[0], g22[1]);
            this.elevatedGlobePerspectiveTransform = hm(c3[0], c3[1], h3[0], h3[1], y22[0], y22[1], g22[0], g22[1]);
            const b22 = (t3, e3) => {
              u22.push(t3.lng);
              const r3 = Math.round((t3.lng - p22) / d22 * Hr), i4 = Math.round((t3.lat - f22) / m22 * Hr), s4 = l3(e3), a4 = O2.vec3.transformMat3([], [s4[0], s4[1], 1], x22), o4 = Math.round(a4[0] / a4[2] * Hr), c4 = Math.round(a4[1] / a4[2] * Hr);
              n3.emplaceBack(r3, i4, o4, c4);
            }, v22 = r22[3].x - r22[0].x, w22 = r22[3].y - r22[0].y, _2 = r22[2].x - r22[1].x, M22 = r22[2].y - r22[1].y;
            for (let t3 = 0; t3 < 65; t3++) {
              const n4 = t3 / 64, i4 = [r22[0].x + n4 * v22, r22[0].y + n4 * w22], s4 = [r22[1].x + n4 * _2, r22[1].y + n4 * M22], a4 = s4[0] - i4[0], o4 = s4[1] - i4[1];
              for (let t4 = 0; t4 < 65; t4++) {
                const r3 = t4 / 64, n5 = { x: i4[0] + a4 * r3, y: i4[1] + o4 * r3, z: 0 };
                b22(e22.projection.unproject(n5.x, n5.y), n5);
              }
            }
            this.elevatedGlobeVertexBuffer = t22.createVertexBuffer(n3, sm.members);
          }
          {
            this.maxLongitudeTriangleSize = 0;
            let e3 = [], r3 = new Da2();
            const n3 = (t3, n4, i3) => {
              r3.emplaceBack(t3, n4, i3);
              const s3 = u22[t3], a3 = u22[n4], o3 = u22[i3], l3 = Math.min(Math.min(s3, a3), o3), c3 = Math.max(Math.max(s3, a3), o3) - l3;
              c3 > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = c3), e3.push(l3 + c3 / 2);
            };
            for (let t3 = 0; t3 < 64; t3++)
              for (let e4 = 0; e4 < 64; e4++) {
                const r4 = 65 * t3 + e4, i3 = r4 + 1, s3 = r4 + 65, a3 = s3 + 1;
                n3(r4, s3, i3), n3(i3, s3, a3);
              }
            [e3, r3] = function(t3, e4) {
              const r4 = Array.from({ length: t3.length }, (t4, e5) => e5);
              r4.sort((e5, r5) => t3[e5] - t3[r5]);
              const n4 = [], i3 = new Da2();
              for (let s3 = 0; s3 < r4.length; s3++) {
                const a3 = r4[s3];
                n4.push(t3[a3]);
                const o3 = 3 * a3, l3 = o3 + 1;
                i3.emplaceBack(e4.uint16[o3], e4.uint16[l3], e4.uint16[l3 + 1]);
              }
              return [n4, i3];
            }(e3, r3), this.elevatedGlobeTrianglesCenterLongitudes = e3, this.elevatedGlobeIndexBuffer = t22.createIndexBuffer(r3);
          }
          this.elevatedGlobeSegments = co.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, d22 / Hr, 0, m22 / Hr, 0, 0, f22, p22, 0]);
        }
        prepare() {
          const t22 = 0 !== Object.keys(this.tiles).length;
          if (this.tileID && !t22)
            return;
          const e22 = this.map.painter.context, r22 = e22.gl;
          !this._dirty || this.texture instanceof um || (this.texture ? this.texture.update(this.image) : (this.texture = new lm(e22, this.image, r22.RGBA8), this.texture.bind(r22.LINEAR, r22.CLAMP_TO_EDGE)), this._dirty = false), t22 && this._prepareData(e22);
        }
        loadTile(t22, e22) {
          this.tileID && this.tileID.equals(t22.tileID.canonical) ? (this.tiles[String(t22.tileID.wrap)] = t22, t22.buckets = {}, e22(null)) : (t22.state = "errored", e22(null));
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return false;
        }
        getSegmentsForLongitude(t22) {
          const e22 = this.elevatedGlobeSegments;
          if (!this.elevatedGlobeTrianglesCenterLongitudes || !e22)
            return null;
          const r22 = this.elevatedGlobeTrianglesCenterLongitudes;
          let n22 = (i2 = t22 + 180) + 360 * Math.round((r22[0] - i2) / 360);
          var i2;
          const s2 = new co(), a2 = (t3, r3) => {
            s2.segments.push({ vertexOffset: 0, primitiveOffset: t3, vertexLength: e22.segments[0].vertexLength, primitiveLength: r3, sortKey: void 0, vaos: {} });
          }, o2 = 0.51 * this.maxLongitudeTriangleSize;
          if (Math.abs(r22[0] - n22) <= o2) {
            const t3 = Mt(r22, 0, r22.length, n22 + o2);
            return t3 === r22.length || a2(t3, _t(r22, t3 + 1, r22.length, n22 + 360 - o2) - t3), s2;
          }
          n22 < r22[0] && (n22 += 360);
          const l22 = _t(r22, 0, r22.length, n22 - o2);
          if (l22 === r22.length)
            return a2(0, r22.length), s2;
          a2(0, l22 - 0);
          const u22 = Mt(r22, l22 + 1, r22.length, n22 + o2);
          return u22 !== r22.length && a2(u22, r22.length - u22), s2;
        }
      }
      const dm = (Math.pow(256, 2) - 1) / 16907520;
      class mm extends pa2 {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: nm || (nm = new Gs({ visibility: new Ns(Xs.layout_raster.visibility) })), paint: im || (im = new Gs({ "raster-opacity": new Ns(Xs.paint_raster["raster-opacity"]), "raster-color": new $s(Xs.paint_raster["raster-color"]), "raster-color-mix": new Ns(Xs.paint_raster["raster-color-mix"]), "raster-color-range": new Ns(Xs.paint_raster["raster-color-range"]), "raster-hue-rotate": new Ns(Xs.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Ns(Xs.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Ns(Xs.paint_raster["raster-brightness-max"]), "raster-saturation": new Ns(Xs.paint_raster["raster-saturation"]), "raster-contrast": new Ns(Xs.paint_raster["raster-contrast"]), "raster-resampling": new Ns(Xs.paint_raster["raster-resampling"]), "raster-fade-duration": new Ns(Xs.paint_raster["raster-fade-duration"]), "raster-emissive-strength": new Ns(Xs.paint_raster["raster-emissive-strength"]), "raster-array-band": new Ns(Xs.paint_raster["raster-array-band"]), "raster-elevation": new Ns(Xs.paint_raster["raster-elevation"]) })) }, e22, r22, n22), this.updateColorRamp(), this._curRampRange = [NaN, NaN];
        }
        getProgramIds() {
          return ["raster"];
        }
        hasColorMap() {
          return !!this._transitionablePaint._values["raster-color"].value.value;
        }
        tileCoverLift() {
          return this.paint.get("raster-elevation");
        }
        isDraped(t22) {
          return !(t22 && t22._source instanceof fm && (t22._source.onNorthPole || t22._source.onSouthPole)) && 0 === this.paint.get("raster-elevation");
        }
        _handleSpecialPaintPropertyUpdate(t22) {
          "raster-color" !== t22 && "raster-color-range" !== t22 || (this._curRampRange = [NaN, NaN], this.updateColorRamp());
        }
        updateColorRamp(t22) {
          if (!this.hasColorMap())
            return;
          if (!this._curRampRange)
            return;
          const e22 = this._transitionablePaint._values["raster-color"].value.expression, [r22, n22] = t22 || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 }) || [NaN, NaN];
          isNaN(r22) && isNaN(n22) || r22 === this._curRampRange[0] && n22 === this._curRampRange[1] || (this.colorRamp = ac2({ expression: e22, evaluationKey: "rasterValue", image: this.colorRamp, clips: [{ start: r22, end: n22 }], resolution: 256 }), this.colorRampTexture = null, this._curRampRange = [r22, n22]);
        }
      }
      let ym, gm, xm, bm, vm;
      class wm extends pa2 {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: ym || (ym = new Gs({ visibility: new Ns(Xs["layout_raster-particle"].visibility) })), paint: gm || (gm = new Gs({ "raster-particle-array-band": new Ns(Xs["paint_raster-particle"]["raster-particle-array-band"]), "raster-particle-count": new Ns(Xs["paint_raster-particle"]["raster-particle-count"]), "raster-particle-color": new $s(Xs["paint_raster-particle"]["raster-particle-color"]), "raster-particle-max-speed": new Ns(Xs["paint_raster-particle"]["raster-particle-max-speed"]), "raster-particle-speed-factor": new Ns(Xs["paint_raster-particle"]["raster-particle-speed-factor"]), "raster-particle-fade-opacity-factor": new Ns(Xs["paint_raster-particle"]["raster-particle-fade-opacity-factor"]), "raster-particle-reset-rate-factor": new Ns(Xs["paint_raster-particle"]["raster-particle-reset-rate-factor"]), "raster-particle-elevation": new Ns(Xs["paint_raster-particle"]["raster-particle-elevation"]) })) }, e22, r22, n22), this._updateColorRamp(), this.lastInvalidatedAt = Dt.now();
        }
        onRemove(t22) {
          this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
        }
        hasColorMap() {
          return !!this._transitionablePaint._values["raster-particle-color"].value.value;
        }
        getProgramIds() {
          return ["rasterParticle"];
        }
        hasOffscreenPass() {
          return "none" !== this.visibility;
        }
        isDraped(t22) {
          return false;
        }
        _handleSpecialPaintPropertyUpdate(t22) {
          "raster-particle-color" !== t22 && "raster-particle-max-speed" !== t22 || (this._updateColorRamp(), this._invalidateAnimationState()), "raster-particle-count" === t22 && this._invalidateAnimationState();
        }
        _updateColorRamp() {
          if (!this.hasColorMap())
            return;
          const t22 = this._transitionablePaint._values["raster-particle-color"].value.expression, e22 = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({ zoom: 0 });
          this.colorRamp = ac2({ expression: t22, evaluationKey: "rasterParticleSpeed", image: this.colorRamp, clips: [{ start: 0, end: e22 }], resolution: 256 }), this.colorRampTexture = null;
        }
        _invalidateAnimationState() {
          this.lastInvalidatedAt = Dt.now();
        }
        tileCoverLift() {
          return this.paint.get("raster-particle-elevation");
        }
      }
      class _m extends pa2 {
        constructor(t22, e22) {
          super(t22, {}, e22, null), this.implementation = t22, t22.slot && (this.slot = t22.slot);
        }
        is3D() {
          return "3d" === this.implementation.renderingMode;
        }
        hasOffscreenPass() {
          return void 0 !== this.implementation.prerender;
        }
        isDraped(t22) {
          return void 0 !== this.implementation.renderToTile;
        }
        shouldRedrape() {
          return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return false;
        }
        serialize() {
        }
        onAdd(t22) {
          this.implementation.onAdd && this.implementation.onAdd(t22, t22.painter.context.gl);
        }
        onRemove(t22) {
          this.implementation.onRemove && this.implementation.onRemove(t22, t22.painter.context.gl);
        }
      }
      function Mm(t22, e22, r22) {
        const n22 = [0, 0, 1], i2 = O2.quat.identity([]);
        return O2.quat.rotateY(i2, i2, r22 ? -Y2(t22) + Math.PI : Y2(t22)), O2.quat.rotateX(i2, i2, -Y2(e22)), O2.vec3.transformQuat(n22, n22, i2), O2.vec3.normalize(n22, n22);
      }
      function Am(t22, e22) {
        const r22 = Im(t22.projection, t22.zoom, t22.width, t22.height), n22 = function(t3, e3, r3, n3, i3) {
          const s2 = new rl2(r3.lng - 180 * Pm, r3.lat), a2 = new rl2(r3.lng + 180 * Pm, r3.lat), o2 = t3.project(s2.lng, s2.lat), l22 = t3.project(a2.lng, a2.lat), u22 = -Math.atan2(l22.y - o2.y, l22.x - o2.x), c22 = xl.fromLngLat(r3);
          c22.y = Q2(c22.y, -1 + Pm, 1 - Pm);
          const h22 = c22.toLngLat(), p22 = t3.project(h22.lng, h22.lat), f22 = xl.fromLngLat(h22);
          f22.x += Pm;
          const d22 = f22.toLngLat(), m22 = t3.project(d22.lng, d22.lat), y22 = km(m22.x - p22.x, m22.y - p22.y, u22), g22 = xl.fromLngLat(h22);
          g22.y += Pm;
          const x22 = g22.toLngLat(), b22 = t3.project(x22.lng, x22.lat), v22 = km(b22.x - p22.x, b22.y - p22.y, u22), w22 = Math.abs(y22.x) / Math.abs(v22.y), _2 = O2.mat4.identity([]);
          O2.mat4.rotateZ(_2, _2, -u22 * (1 - (i3 ? 0 : n3)));
          const M22 = O2.mat4.identity([]);
          return O2.mat4.scale(M22, M22, [1, 1 - (1 - w22) * n3, 1]), M22[4] = -v22.x / v22.y * n3, O2.mat4.rotateZ(M22, M22, u22), O2.mat4.multiply(M22, _2, M22), M22;
        }(t22.projection, 0, t22.center, r22, e22), i2 = Sm(t22);
        return O2.mat4.scale(n22, n22, [i2, i2, 1]), n22;
      }
      function Sm(t22) {
        const e22 = t22.projection, r22 = Im(t22.projection, t22.zoom, t22.width, t22.height), n22 = zm(e22, t22.center), i2 = zm(e22, rl2.convert(e22.center));
        return Math.pow(2, n22 * r22 + (1 - r22) * i2);
      }
      function Im(t22, e22, r22, n22, i2 = 1 / 0) {
        const s2 = t22.range;
        if (!s2)
          return 0;
        const a2 = Math.min(i2, Math.max(r22, n22)), o2 = Math.log(a2 / 1024) / Math.LN2;
        return tt(s2[0] + o2, s2[1] + o2, e22);
      }
      const Pm = 1 / 4e4;
      function zm(t22, e22) {
        const r22 = Q2(e22.lat, -fl2, fl2), n22 = new rl2(e22.lng - 180 * Pm, r22), i2 = new rl2(e22.lng + 180 * Pm, r22), s2 = t22.project(n22.lng, r22), a2 = t22.project(i2.lng, r22), o2 = xl.fromLngLat(n22), l22 = xl.fromLngLat(i2), u22 = a2.x - s2.x, c22 = a2.y - s2.y, h22 = l22.x - o2.x, p22 = l22.y - o2.y, f22 = Math.sqrt((h22 * h22 + p22 * p22) / (u22 * u22 + c22 * c22));
        return Math.log(f22) / Math.LN2;
      }
      function km(t22, e22, r22) {
        const n22 = Math.cos(r22), i2 = Math.sin(r22);
        return { x: t22 * n22 - e22 * i2, y: t22 * i2 + e22 * n22 };
      }
      function Tm(t22, e22, r22) {
        O2.mat4.identity(t22), O2.mat4.rotateZ(t22, t22, Y2(e22[2])), O2.mat4.rotateX(t22, t22, Y2(e22[0])), O2.mat4.rotateY(t22, t22, Y2(e22[1])), O2.mat4.scale(t22, t22, r22), O2.mat4.multiply(t22, t22, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
      }
      function Em(t22, e22, r22, n22, i2, s2, a2, o2) {
        const l22 = [r22[0] - e22[0], r22[1] - e22[1], 0], u22 = [n22[0] - e22[0], n22[1] - e22[1], 0];
        if (O2.vec3.length(l22) < 1e-12 || O2.vec3.length(u22) < 1e-12)
          return O2.quat.identity(t22);
        const c22 = O2.vec3.cross([], l22, u22);
        O2.vec3.normalize(c22, c22), O2.vec3.subtract(u22, n22, e22), l22[2] = (s2 - i2) * o2, u22[2] = (a2 - i2) * o2;
        const h22 = l22;
        return O2.vec3.cross(h22, l22, u22), O2.vec3.normalize(h22, h22), O2.quat.rotationTo(t22, c22, h22);
      }
      function Bm(t22, e22, r22 = false) {
        const n22 = Du(e22.zoom), i2 = function(t3, e3, r3) {
          const n3 = e3.worldSize, i3 = [t3[12], t3[13], t3[14]], s2 = hl2(i3[1] / n3), a2 = cl2(i3[0] / n3), o2 = O2.mat4.identity([]), l22 = ul2(1, s2) * n3, u22 = ul2(1, 0) * n3 * ml2(s2, e3.zoom), c22 = 1 / Vu(n3);
          let h22 = u22 * c22;
          if (r3) {
            const t4 = Im(e3.projection, e3.zoom, e3.width, e3.height, 1024);
            h22 = c22 * e3.projection.pixelSpaceConversion(e3.center.lat, n3, t4);
          }
          const p22 = Qo(s2, a2);
          O2.vec3.add(p22, p22, O2.vec3.scale([], O2.vec3.normalize([], p22), l22 * h22 * i3[2]));
          const f22 = function(t4) {
            const e4 = [t4[0], t4[1], t4[2]];
            let r4 = [0, 1, 0];
            const n4 = O2.vec3.cross([], r4, e4);
            return O2.vec3.cross(r4, e4, n4), 0 === O2.vec3.squaredLength(r4) && (r4 = [0, 1, 0], O2.vec3.cross(n4, e4, r4)), O2.vec3.normalize(n4, n4), O2.vec3.normalize(r4, r4), O2.vec3.normalize(e4, e4), [n4[0], n4[1], n4[2], 0, r4[0], r4[1], r4[2], 0, e4[0], e4[1], e4[2], 0, t4[0], t4[1], t4[2], 1];
          }(p22);
          O2.mat4.scale(o2, o2, [h22, h22, h22 * l22]), O2.mat4.translate(o2, o2, [-i3[0], -i3[1], -i3[2]]);
          const d22 = O2.mat4.multiply([], e3.globeMatrix, f22);
          return O2.mat4.multiply(d22, d22, o2), O2.mat4.multiply(d22, d22, t3), d22;
        }(t22, e22, r22);
        if (n22 > 0) {
          const r3 = function(t3, e3) {
            const r4 = e3.worldSize, n3 = ul2(1, 0) * r4 * ml2(e3.center.lat, e3.zoom) / Vu(r4), i3 = ul2(1, e3.center.lat) * r4, s2 = O2.mat4.identity([]);
            return O2.mat4.rotateY(s2, s2, Y2(e3.center.lng)), O2.mat4.rotateX(s2, s2, Y2(e3.center.lat)), O2.mat4.translate(s2, s2, [0, 0, $o]), O2.mat4.scale(s2, s2, [n3, n3, n3 * i3]), O2.mat4.translate(s2, s2, [e3.point.x - 0.5 * r4, e3.point.y - 0.5 * r4, 0]), O2.mat4.multiply(s2, s2, t3), O2.mat4.multiply(s2, e3.globeMatrix, s2);
          }(t22, e22);
          return function(t3, e3, r4) {
            const n3 = (t4, e4, r5) => {
              const n4 = O2.vec3.length(t4), i4 = O2.vec3.length(e4), s3 = Mu(t4, e4, r5);
              return O2.vec3.scale(s3, s3, 1 / O2.vec3.length(s3) * ke2(n4, i4, r5));
            }, i3 = n3([t3[0], t3[1], t3[2]], [e3[0], e3[1], e3[2]], r4), s2 = n3([t3[4], t3[5], t3[6]], [e3[4], e3[5], e3[6]], r4), a2 = n3([t3[8], t3[9], t3[10]], [e3[8], e3[9], e3[10]], r4), o2 = Mu([t3[12], t3[13], t3[14]], [e3[12], e3[13], e3[14]], r4);
            return [i3[0], i3[1], i3[2], 0, s2[0], s2[1], s2[2], 0, a2[0], a2[1], a2[2], 0, o2[0], o2[1], o2[2], 1];
          }(i2, r3, n22);
        }
        return i2;
      }
      function Vm(t22, e22, r22, n22) {
        const i2 = yu.projectAabbCorners(n22, r22);
        let s2 = Number.MAX_VALUE, a2 = -1;
        for (let t3 = 0; t3 < i2.length; ++t3) {
          const r3 = i2[t3];
          r3[0] = (0.5 * r3[0] + 0.5) * e22.width, r3[1] = (0.5 - 0.5 * r3[1]) * e22.height, r3[2] < s2 && (a2 = t3, s2 = r3[2]);
        }
        const o2 = (t3) => new q2(i2[t3][0], i2[t3][1]);
        let l22;
        switch (a2) {
          case 0:
          case 6:
            l22 = [o2(1), o2(5), o2(4), o2(7), o2(3), o2(2), o2(1)];
            break;
          case 1:
          case 7:
            l22 = [o2(0), o2(4), o2(5), o2(6), o2(2), o2(3), o2(0)];
            break;
          case 3:
          case 5:
            l22 = [o2(1), o2(0), o2(4), o2(7), o2(6), o2(2), o2(1)];
            break;
          default:
            l22 = [o2(1), o2(5), o2(6), o2(7), o2(3), o2(0), o2(1)];
        }
        if (El(t22, l22))
          return s2;
      }
      const Cm = ya2([{ name: "a_pos_3f", components: 3, type: "Float32" }]), Rm = ya2([{ name: "a_color_3f", components: 3, type: "Float32" }]), Dm = ya2([{ name: "a_color_4f", components: 4, type: "Float32" }]), Lm = ya2([{ name: "a_uv_2f", components: 2, type: "Float32" }]), Fm = ya2([{ name: "a_normal_3f", components: 3, type: "Float32" }]), Om = ya2([{ name: "a_normal_matrix0", components: 4, type: "Float32" }, { name: "a_normal_matrix1", components: 4, type: "Float32" }, { name: "a_normal_matrix2", components: 4, type: "Float32" }, { name: "a_normal_matrix3", components: 4, type: "Float32" }]), Um = ya2([{ name: "a_pbr", components: 4, type: "Uint16" }, { name: "a_heightBasedEmissiveStrength", components: 3, type: "Float32" }]), jm = { None: 0, Model: 1, Symbol: 2, FillExtrusion: 4, All: 7 };
      class Nm {
        constructor(t22, e22, r22, n22) {
          this.message = (t22 ? "".concat(t22, ": ") : "") + r22, n22 && (this.identifier = n22), null != e22 && e22.__line__ && (this.line = e22.__line__);
        }
      }
      function qm(t22, e22) {
        const r22 = -1 === t22.indexOf("://");
        try {
          return new URL(t22, r22 && e22 ? "http://example.com" : void 0), true;
        } catch (t3) {
          return false;
        }
      }
      class $m {
        constructor(t22, e22) {
          this.feature = t22, this.instancedDataOffset = e22, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];
        }
      }
      class Gm {
        constructor() {
          this.instancedDataArray = new Ga2(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
        }
      }
      class Xm {
        constructor(t22) {
          this.zoom = t22.zoom, this.canonical = t22.canonical, this.layers = t22.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.projection = t22.projection, this.index = t22.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.hasPattern = false, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = { id: null, timestamp: 0 }, this.modelUris = [], this.modelsRequested = false, this.activeReplacements = [], this.replacementUpdateTime = 0;
        }
        updateFootprints(t22, e22) {
        }
        populate(t22, e22, r22, n22) {
          this.tileToMeter = gl2(r22);
          const i2 = this.layers[0]._featureFilter.needGeometry;
          this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
          for (const { feature: s2, id: a2, index: o2, sourceLayerIndex: l22 } of t22) {
            const t3 = null != a2 ? a2 : s2.properties && s2.properties.hasOwnProperty("id") ? s2.properties.id : void 0, u22 = Pl(s2, i2);
            if (!this.layers[0]._featureFilter.filter(new Vs(this.zoom), u22, r22))
              continue;
            const c22 = { id: t3, sourceLayerIndex: l22, index: o2, geometry: i2 ? u22.geometry : Il(s2, r22, n22), properties: s2.properties, type: s2.type, patterns: {} }, h22 = this.addFeature(c22, c22.geometry, u22);
            h22 && e22.featureIndex.insert(s2, c22.geometry, o2, l22, this.index, this.instancesPerModel[h22].instancedDataArray.length, Hr / 32);
          }
          this.lookup = null;
        }
        update(t22, e22, r22, n22) {
          for (const e3 in this.instancesPerModel) {
            const r3 = this.instancesPerModel[e3];
            for (const e4 in t22)
              r3.idToFeaturesIndex.hasOwnProperty(e4) && (this.evaluate(r3.features[r3.idToFeaturesIndex[e4]], t22[e4], r3, true), this.uploaded = false);
          }
          this.maxHeight = 0;
        }
        updateZoomBasedPaintProperties() {
          if (!this.hasZoomDependentProperties)
            return false;
          let t22 = false;
          for (const e22 in this.instancesPerModel) {
            const r22 = this.instancesPerModel[e22];
            for (const e3 of r22.features) {
              const n22 = this.layers[0], i2 = e3.feature, s2 = this.canonical, a2 = n22.paint.get("model-rotation").evaluate(i2, {}, s2), o2 = n22.paint.get("model-scale").evaluate(i2, {}, s2), l22 = n22.paint.get("model-translation").evaluate(i2, {}, s2);
              O2.vec3.exactEquals(e3.rotation, a2) && O2.vec3.exactEquals(e3.scale, o2) && O2.vec3.exactEquals(e3.translation, l22) || (this.evaluate(e3, e3.featureStates, r22, true), t22 = true);
            }
          }
          return t22;
        }
        updateReplacement(t22, e22, r22, n22) {
          if (e22.updateTime === this.replacementUpdateTime)
            return false;
          this.replacementUpdateTime = e22.updateTime;
          const i2 = e22.getReplacementRegionsForTile(t22.toUnwrapped(), true);
          if (wh2(this.activeReplacements, i2))
            return false;
          this.activeReplacements = i2;
          let s2 = false;
          for (const e3 in this.instancesPerModel) {
            const i3 = this.instancesPerModel[e3], a2 = i3.instancedDataArray;
            for (const e4 of i3.features) {
              const i4 = e4.instancedDataOffset, o2 = e4.instancedDataCount;
              for (let e5 = 0; e5 < o2; e5++) {
                const o3 = 16 * (e5 + i4);
                let l22 = a2.float32[o3 + 0];
                const u22 = l22 > Hr;
                l22 = u22 ? l22 - Hr : l22;
                const c22 = Math.floor(l22), h22 = a2.float32[o3 + 1];
                let p22 = false;
                for (const e6 of this.activeReplacements)
                  if (!gh2(e6, r22, jm.Model, n22) && !(e6.min.x > c22 || c22 > e6.max.x || e6.min.y > h22 || h22 > e6.max.y) && (p22 = Ph2(Ih2(c22, h22, t22.canonical, e6.footprintTileId.canonical), e6.footprint), p22))
                    break;
                a2.float32[o3] = p22 ? l22 + Hr : l22, s2 = s2 || p22 !== u22;
              }
            }
          }
          return s2;
        }
        isEmpty() {
          for (const t22 in this.instancesPerModel)
            if (0 !== this.instancesPerModel[t22].instancedDataArray.length)
              return false;
          return true;
        }
        uploadPending() {
          return !this.uploaded;
        }
        upload(t22) {
          if (!this.uploaded)
            for (const e22 in this.instancesPerModel) {
              const r22 = this.instancesPerModel[e22];
              r22.instancedDataArray.length < 0 || 0 === r22.instancedDataArray.length || (r22.instancedDataBuffer ? r22.instancedDataBuffer.updateData(r22.instancedDataArray) : r22.instancedDataBuffer = t22.createVertexBuffer(r22.instancedDataArray, Om.members, true, void 0, this.instanceCount));
            }
          this.uploaded = true;
        }
        destroy() {
          for (const t3 in this.instancesPerModel) {
            const e22 = this.instancesPerModel[t3];
            0 !== e22.instancedDataArray.length && e22.instancedDataBuffer && e22.instancedDataBuffer.destroy();
          }
          const t22 = this.layers[0].modelManager;
          if (t22 && this.modelUris)
            for (const e22 of this.modelUris)
              t22.removeModel(e22, "");
        }
        addFeature(t22, e22, r22) {
          const n22 = this.layers[0], i2 = n22.layout.get("model-id").evaluate(r22, {}, this.canonical);
          if (!i2)
            return ft("modelId is not evaluated for layer ".concat(n22.id, " and it is not going to get rendered.")), i2;
          qm(i2, false) && (this.modelUris.includes(i2) || this.modelUris.push(i2)), this.instancesPerModel[i2] || (this.instancesPerModel[i2] = new Gm());
          const s2 = this.instancesPerModel[i2], a2 = s2.instancedDataArray, o2 = new $m(r22, a2.length);
          for (const t3 of e22)
            for (const e3 of t3) {
              if (e3.x < 0 || e3.x >= Hr || e3.y < 0 || e3.y >= Hr)
                continue;
              const t4 = (this.lookupDim - 1) / Hr, r3 = this.lookupDim * (e3.y * t4 | 0) + e3.x * t4 | 0;
              if (this.lookup) {
                if (0 !== this.lookup[r3])
                  continue;
                this.lookup[r3] = 1;
              }
              this.instanceCount++;
              const n3 = a2.length;
              a2.resize(n3 + 1), s2.instancesEvaluatedElevation.push(0), a2.float32[16 * n3] = e3.x, a2.float32[16 * n3 + 1] = e3.y;
            }
          return o2.instancedDataCount = s2.instancedDataArray.length - o2.instancedDataOffset, o2.instancedDataCount > 0 && (t22.id && (s2.idToFeaturesIndex[t22.id] = s2.features.length), s2.features.push(o2), this.evaluate(o2, {}, s2, false)), i2;
        }
        getModelUris() {
          return this.modelUris;
        }
        evaluate(t22, e22, r22, n22) {
          const i2 = this.layers[0], s2 = t22.feature, a2 = this.canonical, o2 = t22.rotation = i2.paint.get("model-rotation").evaluate(s2, e22, a2), l22 = t22.scale = i2.paint.get("model-scale").evaluate(s2, e22, a2), u22 = t22.translation = i2.paint.get("model-translation").evaluate(s2, e22, a2), c22 = i2.paint.get("model-color").evaluate(s2, e22, a2);
          c22.a = i2.paint.get("model-color-mix-intensity").evaluate(s2, e22, a2);
          const h22 = [];
          this.maxVerticalOffset < u22[2] && (this.maxVerticalOffset = u22[2]), this.maxScale = Math.max(Math.max(this.maxScale, l22[0]), Math.max(l22[1], l22[2])), Tm(h22, o2, l22);
          const p22 = Math.round(100 * c22.a) + c22.b / 1.05;
          for (let e3 = 0; e3 < t22.instancedDataCount; ++e3) {
            const i3 = t22.instancedDataOffset + e3, s3 = 16 * i3, o3 = r22.instancedDataArray.float32;
            let l3 = 0;
            n22 && (l3 = o3[s3 + 6] - r22.instancesEvaluatedElevation[i3]);
            const f22 = 0 | o3[s3 + 1];
            o3[s3] = (0 | o3[s3]) + c22.r / 1.05, o3[s3 + 1] = f22 + c22.g / 1.05, o3[s3 + 2] = p22, o3[s3 + 3] = 1 / (a2.z > 10 ? this.tileToMeter : gl2(a2, f22)), o3[s3 + 4] = u22[0], o3[s3 + 5] = u22[1], o3[s3 + 6] = u22[2] + l3, o3[s3 + 7] = h22[0], o3[s3 + 8] = h22[1], o3[s3 + 9] = h22[2], o3[s3 + 10] = h22[4], o3[s3 + 11] = h22[5], o3[s3 + 12] = h22[6], o3[s3 + 13] = h22[8], o3[s3 + 14] = h22[9], o3[s3 + 15] = h22[10], r22.instancesEvaluatedElevation[i3] = u22[2];
          }
        }
      }
      let Ym, Zm;
      os(Xm, "ModelBucket", { omit: ["layers"] }), os(Gm, "PerModelAttributes"), os($m, "ModelFeature");
      const Wm = 64, Hm = { CoordinateSpaceTile: 1, CoordinateSpaceYUp: 2, HasMapboxMeshFeatures: 4, HasMeshoptCompression: 8 };
      function Km(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22 = false) {
        const c22 = r22.zoom, h22 = r22.project(n22), p22 = ml2(n22.lat, c22), f22 = 1 / p22;
        O2.mat4.identity(t22), O2.mat4.translate(t22, t22, [h22.x + a2[0] * f22, h22.y + a2[1] * f22, a2[2]]);
        let d22 = 1, m22 = 1;
        const y22 = r22.worldSize;
        if (u22) {
          if ("mercator" === r22.projection.name) {
            let t3 = 0;
            r22.elevation && (t3 = r22.elevation.getAtPointOrZero(new xl(h22.x / y22, h22.y / y22), 0));
            const e3 = O2.vec4.transformMat4([], [h22.x, h22.y, t3, 1], r22.projMatrix)[3] / r22.cameraToCenterDistance;
            d22 = e3, m22 = e3 * ml2(r22.center.lat, c22);
          } else if ("globe" === r22.projection.name) {
            const e3 = Bm(t22, r22), i3 = O2.mat4.multiply([], r22.projMatrix, e3), s3 = [0, 0, 0, 1];
            O2.vec4.transformMat4(s3, s3, i3);
            const a3 = s3[3] / r22.cameraToCenterDistance, o3 = Du(c22), l3 = r22.projection.pixelsPerMeter(n22.lat, y22) * ml2(n22.lat, c22), u3 = r22.projection.pixelsPerMeter(r22.center.lat, y22) * ml2(r22.center.lat, c22);
            d22 = a3 / ke2(l3, dl2(r22.center.lat), o3), m22 = a3 * p22 / l3, d22 *= u3, m22 *= u3;
          }
        } else
          d22 = f22;
        O2.mat4.scale(t22, t22, [d22, d22, m22]);
        const g22 = [...t22], x22 = e22.orientation, b22 = [];
        if (Tm(b22, [x22[0] + i2[0], x22[1] + i2[1], x22[2] + i2[2]], s2), O2.mat4.multiply(t22, g22, b22), o2 && r22.elevation) {
          let i3 = 0;
          const s3 = [];
          if (l22 && r22.elevation) {
            i3 = function(t3, e3, r3, n3, i4) {
              const s4 = e3.elevation;
              if (!s4)
                return 0;
              const a4 = yu.projectAabbCorners(r3, n3), o4 = ul2(1, i4.lat) * e3.worldSize, l3 = function(t4, e4) {
                const r4 = [0, 0, 1], n4 = [{ corners: [0, 1, 3, 2], dotProductWithUp: 0 }, { corners: [1, 5, 2, 6], dotProductWithUp: 0 }, { corners: [0, 4, 1, 5], dotProductWithUp: 0 }, { corners: [2, 6, 3, 7], dotProductWithUp: 0 }, { corners: [4, 7, 5, 6], dotProductWithUp: 0 }, { corners: [0, 3, 4, 7], dotProductWithUp: 0 }];
                for (const i5 of n4) {
                  const n5 = t4[i5.corners[0]], s5 = t4[i5.corners[1]], a5 = t4[i5.corners[2]], o5 = [s5[0] - n5[0], s5[1] - n5[1], e4 * (s5[2] - n5[2])], l4 = O2.vec3.cross(o5, o5, [a5[0] - n5[0], a5[1] - n5[1], e4 * (a5[2] - n5[2])]);
                  O2.vec3.normalize(l4, l4), i5.dotProductWithUp = O2.vec3.dot(l4, r4);
                }
                return n4.sort((t5, e5) => t5.dotProductWithUp - e5.dotProductWithUp), n4[0].corners;
              }(a4, o4), u3 = a4[l3[0]], c3 = a4[l3[1]], h3 = a4[l3[2]], p3 = a4[l3[3]], f3 = s4.getAtPointOrZero(new xl(u3[0] / e3.worldSize, u3[1] / e3.worldSize), 0), d3 = s4.getAtPointOrZero(new xl(c3[0] / e3.worldSize, c3[1] / e3.worldSize), 0), m3 = s4.getAtPointOrZero(new xl(h3[0] / e3.worldSize, h3[1] / e3.worldSize), 0), y3 = s4.getAtPointOrZero(new xl(p3[0] / e3.worldSize, p3[1] / e3.worldSize), 0), g3 = (f3 + y3) / 2, x3 = (d3 + m3) / 2;
              return g3 > x3 ? d3 < m3 ? Em(t3, c3, p3, u3, d3, y3, f3, o4) : Em(t3, h3, u3, p3, m3, f3, y3, o4) : f3 < y3 ? Em(t3, u3, c3, h3, f3, d3, m3, o4) : Em(t3, p3, h3, c3, y3, m3, d3, o4), Math.max(g3, x3);
            }(s3, r22, e22.aabb, t22, n22);
            const a3 = O2.mat4.fromQuat([], s3), o3 = O2.mat4.multiply([], a3, b22);
            O2.mat4.multiply(t22, g22, o3);
          } else
            i3 = r22.elevation.getAtPointOrZero(new xl(h22.x / y22, h22.y / y22), 0);
          0 !== i3 && (t22[14] += i3);
        }
      }
      function Jm(t22, e22, r22 = false) {
        t22.uploaded || (t22.gfxTexture = new lm(e22, t22.image, r22 ? e22.gl.R8 : e22.gl.RGBA8, { useMipmap: t22.sampler.minFilter >= e22.gl.NEAREST_MIPMAP_NEAREST }), t22.uploaded = true, t22.image = null);
      }
      function Qm(t22, e22, r22) {
        t22.indexBuffer = e22.createIndexBuffer(t22.indexArray, false, true), t22.vertexBuffer = e22.createVertexBuffer(t22.vertexArray, Cm.members, false, true), t22.normalArray && (t22.normalBuffer = e22.createVertexBuffer(t22.normalArray, Fm.members, false, true)), t22.texcoordArray && (t22.texcoordBuffer = e22.createVertexBuffer(t22.texcoordArray, Lm.members, false, true)), t22.colorArray && (t22.colorBuffer = e22.createVertexBuffer(t22.colorArray, (12 === t22.colorArray.bytesPerElement ? Rm : Dm).members, false, true)), t22.featureArray && (t22.pbrBuffer = e22.createVertexBuffer(t22.featureArray, Um.members, true)), t22.segments = co.simpleSegment(0, 0, t22.vertexArray.length, t22.indexArray.length);
        const n22 = t22.material;
        n22.pbrMetallicRoughness.baseColorTexture && Jm(n22.pbrMetallicRoughness.baseColorTexture, e22), n22.pbrMetallicRoughness.metallicRoughnessTexture && Jm(n22.pbrMetallicRoughness.metallicRoughnessTexture, e22), n22.normalTexture && Jm(n22.normalTexture, e22), n22.occlusionTexture && Jm(n22.occlusionTexture, e22, r22), n22.emissionTexture && Jm(n22.emissionTexture, e22);
      }
      function ty(t22, e22, r22) {
        if (t22.meshes)
          for (const n22 of t22.meshes)
            Qm(n22, e22, r22);
        if (t22.children)
          for (const n22 of t22.children)
            ty(n22, e22, r22);
      }
      function ey(t22) {
        if (t22.meshes)
          for (const e22 of t22.meshes)
            e22.indexArray.destroy(), e22.vertexArray.destroy(), e22.colorArray && e22.colorArray.destroy(), e22.normalArray && e22.normalArray.destroy(), e22.texcoordArray && e22.texcoordArray.destroy(), e22.featureArray && e22.featureArray.destroy();
        if (t22.children)
          for (const e22 of t22.children)
            ey(e22);
      }
      function ry(t22) {
        if (t22.meshes)
          for (const r22 of t22.meshes)
            r22.vertexBuffer && (r22.vertexBuffer.destroy(), r22.indexBuffer.destroy(), r22.normalBuffer && r22.normalBuffer.destroy(), r22.texcoordBuffer && r22.texcoordBuffer.destroy(), r22.colorBuffer && r22.colorBuffer.destroy(), r22.pbrBuffer && r22.pbrBuffer.destroy(), r22.segments.destroy(), r22.material && ((e22 = r22.material).pbrMetallicRoughness.baseColorTexture && e22.pbrMetallicRoughness.baseColorTexture.gfxTexture && e22.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e22.pbrMetallicRoughness.metallicRoughnessTexture && e22.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e22.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e22.normalTexture && e22.normalTexture.gfxTexture && e22.normalTexture.gfxTexture.destroy(), e22.emissionTexture && e22.emissionTexture.gfxTexture && e22.emissionTexture.gfxTexture.destroy(), e22.occlusionTexture && e22.occlusionTexture.gfxTexture && e22.occlusionTexture.gfxTexture.destroy()));
        var e22;
        if (t22.children)
          for (const e3 of t22.children)
            ry(e3);
      }
      class ny {
        constructor(t22, e22, r22) {
          this._demTile = t22, this._dem = this._demTile.dem, this._scale = e22, this._offset = r22;
        }
        static create(t22, e22, r22) {
          const n22 = r22 || t22.findDEMTileFor(e22);
          if (!n22 || !n22.dem)
            return;
          const i2 = n22.dem, s2 = n22.tileID, a2 = 1 << e22.canonical.z - s2.canonical.z;
          return new ny(n22, i2.dim / Hr / a2, [(e22.canonical.x / a2 - s2.canonical.x) * i2.dim, (e22.canonical.y / a2 - s2.canonical.y) * i2.dim]);
        }
        tileCoordToPixel(t22, e22) {
          const r22 = e22 * this._scale + this._offset[1], n22 = Math.floor(t22 * this._scale + this._offset[0]), i2 = Math.floor(r22);
          return new q2(n22, i2);
        }
        getElevationAt(t22, e22, r22, n22) {
          const i2 = t22 * this._scale + this._offset[0], s2 = e22 * this._scale + this._offset[1], a2 = Math.floor(i2), o2 = Math.floor(s2), l22 = this._dem;
          return n22 = !!n22, r22 ? ke2(ke2(l22.get(a2, o2, n22), l22.get(a2, o2 + 1, n22), s2 - o2), ke2(l22.get(a2 + 1, o2, n22), l22.get(a2 + 1, o2 + 1, n22), s2 - o2), i2 - a2) : l22.get(a2, o2, n22);
        }
        getElevationAtPixel(t22, e22, r22) {
          return this._dem.get(t22, e22, !!r22);
        }
        getMeterToDEM(t22) {
          return (1 << this._demTile.tileID.canonical.z) * ul2(1, t22) * this._dem.stride;
        }
      }
      const iy = new Float32Array(262144), sy = new Uint8Array(262144);
      function ay(t22) {
        let e22 = 0;
        if (t22.meshes)
          for (const r22 of t22.meshes)
            e22 = Math.max(e22, r22.aabb.max[2]);
        if (t22.children)
          for (const r22 of t22.children)
            e22 = Math.max(e22, ay(r22));
        return e22;
      }
      function oy(t22, e22, r22) {
        if (t22.meshes)
          for (const n22 of t22.meshes)
            n22.aabb.min[0] !== 1 / 0 && r22.insert(e22, n22.aabb.min[0], n22.aabb.min[1], n22.aabb.max[0], n22.aabb.max[1]);
        if (t22.children)
          for (const n22 of t22.children)
            oy(n22, e22, r22);
      }
      const ly = ["", "wall", "door", "roof", "window", "lamp", "logo"];
      class uy {
        constructor(t22) {
          this.node = t22, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [0.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = false, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = { type: "Point", id: t22.id, geometry: [], properties: { height: ay(t22) } }, this.aabb = this._getLocalBounds();
        }
        _getLocalBounds() {
          if (!this.node.meshes)
            return new yu([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
          if (!this.aabb) {
            let t22 = 0;
            const e22 = new yu([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
            for (const r22 of this.node.meshes)
              this.node.lightMeshIndex !== t22 && (r22.transformedAabb = yu.applyTransformFast(r22.aabb, this.node.matrix), e22.encapsulate(r22.transformedAabb)), t22++;
            this.aabb = e22;
          }
          return this.aabb;
        }
      }
      class cy {
        constructor(t22, e22, r22, n22, i2, s2) {
          this.id = e22, this.modelTraits |= Hm.CoordinateSpaceTile, this.uploaded = false, this.hasPattern = false, r22 && (this.modelTraits |= Hm.HasMapboxMeshFeatures), n22 && (this.modelTraits |= Hm.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = i2, this.dirty = true, this.needsUpload = false, this.nodesInfo = [];
          for (const e3 of t22)
            this.nodesInfo.push(new uy(e3)), oy(e3, s2.featureIndexArray.length, s2.grid), s2.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, s2.bucketLayerIDs.length - 1, 0);
        }
        updateFootprints(t22, e22) {
          for (const r22 of this.getNodesInfo()) {
            const n22 = r22.node;
            n22.footprint && e22.push({ footprint: n22.footprint, id: t22 });
          }
        }
        update() {
          console.log("Update 3D model bucket");
        }
        populate() {
          console.log("populate 3D model bucket");
        }
        uploadPending() {
          return !this.uploaded || this.needsUpload;
        }
        upload(t22) {
          if (!this.needsUpload)
            return;
          const e22 = this.getNodesInfo();
          for (const r22 of e22) {
            const e3 = r22.node;
            this.uploaded ? this.updatePbrBuffer(e3) : ty(e3, t22, true);
          }
          for (const t3 of e22)
            ey(t3.node);
          this.uploaded = true, this.needsUpload = false;
        }
        updatePbrBuffer(t22) {
          let e22 = false;
          if (!t22.meshes)
            return e22;
          for (const r22 of t22.meshes)
            r22.pbrBuffer && (r22.pbrBuffer.updateData(r22.featureArray), e22 = true);
          return e22;
        }
        needsReEvaluation(t22, e22, r22) {
          const n22 = t22.transform.projectionOptions, i2 = t22.style.getBrightness(), s2 = this.brightness !== i2;
          return !!(!this.uploaded || this.dirty || n22.name !== this.projection.name || hy(r22.paint.get("model-color").value, s2) || hy(r22.paint.get("model-color-mix-intensity").value, s2) || hy(r22.paint.get("model-roughness").value, s2) || hy(r22.paint.get("model-emissive-strength").value, s2) || hy(r22.paint.get("model-height-based-emissive-strength-multiplier").value, s2)) && (this.projection = n22, this.brightness = i2, true);
        }
        evaluateScale(t22, e22) {
          if (t22.transform.zoom === this.zoom)
            return;
          this.zoom = t22.transform.zoom;
          const r22 = this.getNodesInfo(), n22 = this.id.canonical;
          for (const t3 of r22) {
            const r3 = t3.feature;
            t3.evaluatedScale = e22.paint.get("model-scale").evaluate(r3, {}, n22);
          }
        }
        evaluate(t22) {
          const e22 = this.getNodesInfo();
          for (const r22 of e22) {
            if (!r22.node.meshes)
              continue;
            const e3 = r22.feature, n22 = r22.node.meshes && r22.node.meshes[0].featureData, i2 = r22.evaluatedColor[2], s2 = r22.evaluatedRMEA[2], a2 = this.id.canonical;
            if (r22.hasTranslucentParts = false, n22) {
              for (let n3 = 0; n3 < ly.length; n3++) {
                const i3 = ly[n3];
                i3.length && (e3.properties.part = i3);
                const s3 = t22.paint.get("model-color").evaluate(e3, {}, a2).toRenderColor(null), o2 = t22.paint.get("model-color-mix-intensity").evaluate(e3, {}, a2);
                r22.evaluatedColor[n3] = [s3.r, s3.g, s3.b, o2], r22.evaluatedRMEA[n3][0] = t22.paint.get("model-roughness").evaluate(e3, {}, a2), r22.evaluatedRMEA[n3][2] = t22.paint.get("model-emissive-strength").evaluate(e3, {}, a2), r22.evaluatedRMEA[n3][3] = s3.a, r22.emissionHeightBasedParams[n3] = t22.paint.get("model-height-based-emissive-strength-multiplier").evaluate(e3, {}, a2), !r22.hasTranslucentParts && s3.a < 1 && (r22.hasTranslucentParts = true);
              }
              delete e3.properties.part, fy(r22, i2 !== r22.evaluatedColor[2] || s2 !== r22.evaluatedRMEA[2], this.modelTraits);
            } else
              r22.evaluatedRMEA[0][2] = t22.paint.get("model-emissive-strength").evaluate(e3, {}, a2);
            r22.evaluatedScale = t22.paint.get("model-scale").evaluate(e3, {}, a2), this.updatePbrBuffer(r22.node) || (this.needsUpload = true);
          }
          this.dirty = false;
        }
        elevationUpdate(t22, e22, r22, n22) {
          const i2 = t22.findDEMTileFor(r22);
          if (i2 && (i2.tileID.canonical !== this.terrainTile || e22 !== this.terrainExaggeration)) {
            if (i2.dem && i2.tileID.overscaledZ !== this.elevationReadFromZ) {
              this.elevationReadFromZ = i2.tileID.overscaledZ;
              const e3 = ny.create(t22, r22, i2);
              if (!e3)
                return;
              this.modelTraits & Hm.HasMapboxMeshFeatures && this.updateDEM(t22, e3, r22, n22);
              for (const t3 of this.getNodesInfo()) {
                const r3 = t3.node;
                if (!r3.footprint || !r3.footprint.vertices || !r3.footprint.vertices.length)
                  continue;
                const n3 = r3.footprint.vertices;
                let i3 = e3.getElevationAt(n3[0].x, n3[0].y, true, true);
                for (let t4 = 1; t4 < n3.length; t4++)
                  i3 = Math.min(i3, e3.getElevationAt(n3[t4].x, n3[t4].y, true, true));
                r3.elevation = i3;
              }
            }
            this.terrainTile = i2.tileID.canonical, this.terrainExaggeration = e22;
          }
        }
        updateDEM(t22, e22, r22, n22) {
          let i2 = e22._dem._modifiedForSources[n22];
          if (void 0 === i2 && (e22._dem._modifiedForSources[n22] = [], i2 = e22._dem._modifiedForSources[n22]), i2.includes(r22.canonical))
            return;
          const s2 = e22._dem.dim;
          i2.push(r22.canonical);
          let a2 = false;
          for (const t3 of this.getNodesInfo()) {
            const r3 = t3.node;
            if (!r3.footprint || !r3.footprint.grid)
              continue;
            const n3 = r3.footprint.grid, i3 = e22.tileCoordToPixel(n3.min.x, n3.min.y), o2 = e22.tileCoordToPixel(n3.max.x, n3.max.y), l22 = Math.min(Math.min(s2 - o2.y, i3.x), Math.min(i3.y, s2 - o2.x));
            if (l22 < 0)
              continue;
            const u22 = Q2(l22, 2, 5);
            let c22 = Math.max(0, i3.x - u22), h22 = Math.max(0, i3.y - u22), p22 = Math.min(o2.x + u22, s2 - 1), f22 = Math.min(o2.y + u22, s2 - 1);
            for (let t4 = h22; t4 <= f22; ++t4)
              for (let e3 = c22; e3 <= p22; ++e3)
                sy[t4 * s2 + e3] = 255;
            let d22 = 0, m22 = 0;
            for (let t4 = 0; t4 < n3.cellsY; ++t4)
              for (let r4 = 0; r4 < n3.cellsX; ++r4) {
                if (!n3.cells[t4 * n3.cellsX + r4])
                  continue;
                const i4 = e22.tileCoordToPixel(n3.min.x + r4 / n3.xScale, n3.min.y + t4 / n3.yScale), a3 = e22.tileCoordToPixel(n3.min.x + (r4 + 1) / n3.xScale, n3.min.y + (t4 + 1) / n3.yScale);
                for (let t5 = i4.y; t5 <= Math.min(a3.y + 1, s2 - 1); ++t5)
                  for (let r5 = i4.x; r5 <= Math.min(a3.x + 1, s2 - 1); ++r5)
                    255 === sy[t5 * s2 + r5] && (sy[t5 * s2 + r5] = 0, d22 += e22.getElevationAtPixel(r5, t5), m22++);
              }
            const y22 = d22 / m22;
            c22 = Math.max(1, i3.x - u22), h22 = Math.max(1, i3.y - u22), p22 = Math.min(o2.x + u22, s2 - 2), f22 = Math.min(o2.y + u22, s2 - 2), a2 = true;
            for (let t4 = h22; t4 <= f22; ++t4)
              for (let r4 = c22; r4 <= p22; ++r4)
                0 === sy[t4 * s2 + r4] && (iy[t4 * s2 + r4] = e22._dem.set(r4, t4, y22));
            for (let t4 = 1; t4 < u22; ++t4) {
              c22 = Math.max(1, i3.x - t4), h22 = Math.max(1, i3.y - t4), p22 = Math.min(o2.x + t4, s2 - 2), f22 = Math.min(o2.y + t4, s2 - 2);
              for (let r4 = h22; r4 <= f22; ++r4)
                for (let n4 = c22; n4 <= p22; ++n4) {
                  const i4 = r4 * s2 + n4;
                  if (255 === sy[i4]) {
                    let a3 = 0, o3 = 0, l3 = -1, c3 = -1;
                    for (let e3 = -1; e3 <= 1; ++e3)
                      for (let i5 = -1; i5 <= 1; ++i5) {
                        const u3 = (r4 + e3) * s2 + n4 + i5;
                        if (sy[u3] >= t4)
                          continue;
                        const h3 = iy[u3], p3 = Math.abs(h3);
                        p3 > o3 && (a3 = h3, o3 = p3, l3 = i5, c3 = e3);
                      }
                    if (o3 > 0.1) {
                      const s3 = 1 - (t4 + 0.5 * Math.abs(l3 * c3)) / u22;
                      let o4 = e22._dem.get(n4, r4) + a3 * s3;
                      const h3 = e22._dem.get(n4 + l3, r4 + c3), p3 = e22._dem.get(n4 - l3, r4 - c3, true);
                      (o4 - h3) * (o4 - p3) > 0 && (o4 = (h3 + p3) / 2), iy[i4] = e22._dem.set(n4, r4, o4), sy[i4] = t4;
                    }
                  }
                }
            }
          }
          a2 && (e22._demTile.needsDEMTextureUpload = true, e22._dem._timestamp = Dt.now());
        }
        getNodesInfo() {
          return this.nodesInfo;
        }
        destroy() {
          const t22 = this.getNodesInfo();
          for (const e22 of t22)
            ey(e22.node), ry(e22.node);
        }
        isEmpty() {
          return !this.nodesInfo.length;
        }
        updateReplacement(t22, e22) {
          if (e22.updateTime === this.replacementUpdateTime)
            return;
          this.replacementUpdateTime = e22.updateTime;
          const r22 = e22.getReplacementRegionsForTile(t22.toUnwrapped()), n22 = this.getNodesInfo();
          for (let t3 = 0; t3 < this.nodesInfo.length; t3++) {
            const e3 = n22[t3].node;
            n22[t3].hiddenByReplacement = !!e3.footprint && !r22.find((t4) => t4.footprint === e3.footprint);
          }
        }
        getHeightAtTileCoord(t22, e22) {
          const r22 = this.getNodesInfo(), n22 = [], i2 = [0, 0, 0], s2 = O2.mat4.identity([]);
          for (let a2 = 0; a2 < this.nodesInfo.length; a2++) {
            const o2 = r22[a2], l22 = o2.node.meshes[0], u22 = l22.transformedAabb;
            if (t22 < u22.min[0] || e22 < u22.min[1] || t22 > u22.max[0] || e22 > u22.max[1])
              continue;
            if (true === o2.node.hidden)
              return { height: 1 / 0, maxHeight: o2.feature.properties.height, hidden: false, verticalScale: o2.evaluatedScale[2] };
            O2.mat4.invert(s2, o2.node.matrix), i2[0] = t22, i2[1] = e22, O2.vec3.transformMat4(i2, i2, s2);
            const c22 = (i2[0] - l22.aabb.min[0]) / (l22.aabb.max[0] - l22.aabb.min[0]) * Wm | 0, h22 = Math.min(63, (i2[1] - l22.aabb.min[1]) / (l22.aabb.max[1] - l22.aabb.min[1]) * Wm | 0) * Wm + Math.min(63, c22), p22 = l22.heightmap[h22];
            if (!(p22 < 0 && o2.node.footprint)) {
              if (o2.hiddenByReplacement)
                return;
              return { height: p22, maxHeight: o2.feature.properties.height, hidden: false, verticalScale: o2.evaluatedScale[2] };
            }
            if (o2.node.footprint.grid.query(new q2(t22, e22), new q2(t22, e22), n22), n22.length > 0)
              return { height: void 0, maxHeight: o2.feature.properties.height, hidden: o2.hiddenByReplacement, verticalScale: o2.evaluatedScale[2] };
          }
        }
      }
      function hy(t22, e22) {
        return !t22.isLightConstant && e22;
      }
      function py(t22, e22, r22, n22, i2, s2, a2, o2) {
        let l22 = (61440 & e22 | (61440 & e22) >> 4) >> 8, u22 = (3840 & e22 | (3840 & e22) >> 4) >> 4, c22 = 240 & e22 | (240 & e22) >> 4;
        r22[3] > 0 && (l22 = ke2(l22, 255 * r22[0], r22[3]), u22 = ke2(u22, 255 * r22[1], r22[3]), c22 = ke2(c22, 255 * r22[2], r22[3]));
        const h22 = l22 << 8 | u22, p22 = c22 << 8 | Math.floor(255 * n22[3]), f22 = function(t3) {
          const e3 = Q2(t3, 0, 2);
          return Math.min(Math.round(0.5 * e3 * 255), 255);
        }(n22[2]) << 8 | 15 * n22[0] << 4 | 15 * n22[1], d22 = Q2(i2[0], 0, 1), m22 = Q2(i2[1], 0, 1), y22 = Q2(i2[2], 0, 1), g22 = Q2(i2[3], 0, 1);
        let x22, b22, v22, w22;
        if (d22 !== m22 && a2 !== s2 && m22 !== d22) {
          const t3 = a2 - s2;
          b22 = 1 / (t3 * (m22 - d22)), v22 = -(s2 + t3 * d22) / (t3 * (m22 - d22));
          const e3 = Q2(i2[4], -1, 1);
          w22 = Math.pow(10, e3), x22 = 255 * y22 << 8 | 255 * g22;
        } else
          x22 = 65535, b22 = 0, v22 = 1, w22 = 1;
        if (t22.emplaceBack(h22, p22, f22, x22, b22, v22, w22), o2) {
          const t3 = o2.length;
          o2.clear();
          for (let e3 = 0; e3 < t3; e3++)
            o2.emplaceBack(h22, p22, f22, x22, b22, v22, w22);
        }
      }
      function fy(t22, e22, r22) {
        const n22 = t22.node;
        let i2 = 0;
        const s2 = r22 & Hm.HasMeshoptCompression;
        for (const r3 of n22.meshes) {
          if (n22.lights && n22.lightMeshIndex === i2)
            continue;
          if (!r3.featureData)
            continue;
          r3.featureArray = new Xa2(), r3.featureArray.reserve(r3.featureData.length);
          let a2 = e22;
          for (const e3 of r3.featureData) {
            const i3 = s2 ? 65535 & e3 : e3 >> 16 & 65535, o2 = s2 ? e3 >> 16 & 65535 : 65535 & e3, l22 = (15 & o2) < 8 ? 15 & o2 : 0, u22 = t22.evaluatedRMEA[l22], c22 = t22.evaluatedColor[l22], h22 = t22.emissionHeightBasedParams[l22];
            let p22;
            if (a2 && 2 === l22 && n22.lights && (p22 = new Xa2(), p22.resize(10 * n22.lights.length)), py(r3.featureArray, i3, c22, u22, h22, r3.aabb.min[2], r3.aabb.max[2], p22), p22 && a2) {
              a2 = false;
              const t3 = n22.meshes[n22.lightMeshIndex];
              t3.featureArray = p22, t3.featureArray._trim();
            }
          }
          r3.featureArray._trim(), i2++;
        }
      }
      function dy(t22, e22, r22, n22) {
        const i2 = 1 << t22.z;
        e22.lat = hl2((n22 / Hr + t22.y) / i2), e22.lng = cl2((r22 / Hr + t22.x) / i2);
      }
      os(cy, "Tiled3dModelBucket", { omit: ["layers"] }), os(uy, "Tiled3dModelFeature");
      const my = { circle: class extends pa2 {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: Wl || (Wl = new Gs({ "circle-sort-key": new qs(Xs.layout_circle["circle-sort-key"]), visibility: new Ns(Xs.layout_circle.visibility) })), paint: Hl || (Hl = new Gs({ "circle-radius": new qs(Xs.paint_circle["circle-radius"]), "circle-color": new qs(Xs.paint_circle["circle-color"]), "circle-blur": new qs(Xs.paint_circle["circle-blur"]), "circle-opacity": new qs(Xs.paint_circle["circle-opacity"]), "circle-translate": new Ns(Xs.paint_circle["circle-translate"]), "circle-translate-anchor": new Ns(Xs.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Ns(Xs.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Ns(Xs.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new qs(Xs.paint_circle["circle-stroke-width"]), "circle-stroke-color": new qs(Xs.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new qs(Xs.paint_circle["circle-stroke-opacity"]), "circle-emissive-strength": new Ns(Xs.paint_circle["circle-emissive-strength"]) })) }, e22, r22, n22);
        }
        createBucket(t22) {
          return new Tl(t22);
        }
        queryRadius(t22) {
          const e22 = t22;
          return Gl("circle-radius", this, e22) + Gl("circle-stroke-width", this, e22) + Xl(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(t22, e22, r22, n22, i2, s2, a2, o2) {
          const l22 = Zl(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, t22.pixelToTileUnitsFactor), u22 = this.paint.get("circle-radius").evaluate(e22, r22) + this.paint.get("circle-stroke-width").evaluate(e22, r22);
          return $u(t22, n22, s2, a2, o2, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l22, u22);
        }
        getProgramIds() {
          return ["circle"];
        }
        getDefaultProgramParams(t22, e22, r22) {
          const n22 = qu(this);
          return { config: new Lo(this, { zoom: e22, lut: r22 }), defines: n22, overrideFog: false };
        }
      }, heatmap: class extends pa2 {
        createBucket(t22) {
          return new Wu(t22);
        }
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: Hu || (Hu = new Gs({ visibility: new Ns(Xs.layout_heatmap.visibility) })), paint: Ku || (Ku = new Gs({ "heatmap-radius": new qs(Xs.paint_heatmap["heatmap-radius"]), "heatmap-weight": new qs(Xs.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Ns(Xs.paint_heatmap["heatmap-intensity"]), "heatmap-color": new $s(Xs.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Ns(Xs.paint_heatmap["heatmap-opacity"]) })) }, e22, r22, n22), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t22) {
          "heatmap-color" === t22 && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = ac2({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius(t22) {
          return Gl("heatmap-radius", this, t22);
        }
        queryIntersectsFeature(t22, e22, r22, n22, i2, s2, a2, o2) {
          const l22 = this.paint.get("heatmap-radius").evaluate(e22, r22);
          return $u(t22, n22, s2, a2, o2, true, true, new q2(0, 0), l22);
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
        }
        getProgramIds() {
          return ["heatmap", "heatmapTexture"];
        }
        getDefaultProgramParams(t22, e22, r22) {
          return "heatmap" === t22 ? { config: new Lo(this, { zoom: e22, lut: r22 }), overrideFog: false } : {};
        }
      }, hillshade: class extends pa2 {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: Ju || (Ju = new Gs({ visibility: new Ns(Xs.layout_hillshade.visibility) })), paint: Qu || (Qu = new Gs({ "hillshade-illumination-direction": new Ns(Xs.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Ns(Xs.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Ns(Xs.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Ns(Xs.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Ns(Xs.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Ns(Xs.paint_hillshade["hillshade-accent-color"]), "hillshade-emissive-strength": new Ns(Xs.paint_hillshade["hillshade-emissive-strength"]) })) }, e22, r22, n22);
        }
        shouldRedrape() {
          return this.hasOffscreenPass() && "viewport" === this.paint.get("hillshade-illumination-anchor");
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
        }
        getProgramIds() {
          return ["hillshade", "hillshadePrepare"];
        }
        getDefaultProgramParams(t22, e22, r22) {
          return { overrideFog: false };
        }
      }, fill: class extends pa2 {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: Oc2 || (Oc2 = new Gs({ "fill-sort-key": new qs(Xs.layout_fill["fill-sort-key"]), visibility: new Ns(Xs.layout_fill.visibility) })), paint: Uc2 || (Uc2 = new Gs({ "fill-antialias": new Ns(Xs.paint_fill["fill-antialias"]), "fill-opacity": new qs(Xs.paint_fill["fill-opacity"]), "fill-color": new qs(Xs.paint_fill["fill-color"]), "fill-outline-color": new qs(Xs.paint_fill["fill-outline-color"]), "fill-translate": new Ns(Xs.paint_fill["fill-translate"]), "fill-translate-anchor": new Ns(Xs.paint_fill["fill-translate-anchor"]), "fill-pattern": new qs(Xs.paint_fill["fill-pattern"]), "fill-emissive-strength": new Ns(Xs.paint_fill["fill-emissive-strength"]), "fill-z-offset": new qs(Xs.paint_fill["fill-z-offset"]) })) }, e22, r22, n22);
        }
        getProgramIds() {
          const t22 = this.paint.get("fill-pattern"), e22 = t22 && t22.constantOr(1), r22 = [e22 ? "fillPattern" : "fill"];
          return this.paint.get("fill-antialias") && r22.push(e22 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r22;
        }
        getDefaultProgramParams(t22, e22, r22) {
          return { config: new Lo(this, { zoom: e22, lut: r22 }), overrideFog: false };
        }
        recalculate(t22, e22) {
          super.recalculate(t22, e22);
          const r22 = this.paint._values["fill-outline-color"];
          "constant" === r22.value.kind && void 0 === r22.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t22) {
          return new Fc2(t22);
        }
        queryRadius() {
          return Xl(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(t22, e22, r22, n22, i2, s2) {
          return !t22.queryGeometry.isAboveHorizon && Vl(Yl(t22.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, t22.pixelToTileUnitsFactor), n22);
        }
        isTileClipped() {
          return true;
        }
        is3D() {
          return 0 !== this.paint.get("fill-z-offset").constantOr(1);
        }
      }, "fill-extrusion": class extends pa2 {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: sp || (sp = new Gs({ visibility: new Ns(Xs["layout_fill-extrusion"].visibility), "fill-extrusion-edge-radius": new Ns(Xs["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) })), paint: ap || (ap = new Gs({ "fill-extrusion-opacity": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-ambient-occlusion-wall-radius": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]), "fill-extrusion-ambient-occlusion-ground-radius": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]), "fill-extrusion-ambient-occlusion-ground-attenuation": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]), "fill-extrusion-flood-light-color": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]), "fill-extrusion-flood-light-intensity": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]), "fill-extrusion-flood-light-wall-radius": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]), "fill-extrusion-flood-light-ground-radius": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]), "fill-extrusion-flood-light-ground-attenuation": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]), "fill-extrusion-vertical-scale": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]), "fill-extrusion-rounded-roof": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]), "fill-extrusion-cutoff-fade-range": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]), "fill-extrusion-emissive-strength": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]), "fill-extrusion-line-width": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-line-width"]), "fill-extrusion-cast-shadows": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]) })) }, e22, r22, n22), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
        }
        createBucket(t22) {
          return new Zh2(t22);
        }
        queryRadius() {
          return Xl(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return true;
        }
        hasShadowPass() {
          return this.paint.get("fill-extrusion-cast-shadows");
        }
        cutoffRange() {
          return this.paint.get("fill-extrusion-cutoff-fade-range");
        }
        canCastShadows() {
          return true;
        }
        getProgramIds() {
          return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
        }
        queryIntersectsFeature(t22, e22, r22, n22, i2, s2, a2, o2, l22) {
          const u22 = Zl(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s2.angle, t22.pixelToTileUnitsFactor), c22 = this.paint.get("fill-extrusion-height").evaluate(e22, r22), h22 = this.paint.get("fill-extrusion-base").evaluate(e22, r22), p22 = [0, 0], f22 = o2 && s2.elevation, d22 = s2.elevation ? s2.elevation.exaggeration() : 1, m22 = t22.tile.getBucket(this);
          if (f22 && m22 instanceof Zh2) {
            const t3 = m22.centroidVertexArray, e3 = l22 + 1;
            e3 < t3.length && (p22[0] = t3.geta_centroid_pos0(e3), p22[1] = t3.geta_centroid_pos1(e3));
          }
          if (0 === p22[0] && 1 === p22[1])
            return false;
          "globe" === s2.projection.name && (n22 = np([n22], [new q2(0, 0), new q2(Hr, Hr)], t22.tileID.canonical).map((t3) => t3.polygon).flat());
          const y22 = f22 ? o2 : null, [g22, x22] = function(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3) {
            return "globe" === t3.projection.name ? function(t4, e4, r4, n4, i4, s4, a4, o4, l4, u4, c4) {
              const h3 = [], p3 = [], f3 = t4.projection.upVectorScale(c4, t4.center.lat, t4.worldSize).metersToTile, d3 = [0, 0, 0, 1], m3 = [0, 0, 0, 1], y3 = (t5, e5, r5, n5) => {
                t5[0] = e5, t5[1] = r5, t5[2] = n5, t5[3] = 1;
              }, g3 = rp();
              r4 > 0 && (r4 += g3), n4 += g3;
              for (const g4 of e4) {
                const e5 = [], x3 = [];
                for (const h4 of g4) {
                  const p4 = h4.x + i4.x, g5 = h4.y + i4.y, b3 = t4.projection.projectTilePoint(p4, g5, c4), v22 = t4.projection.upVector(c4, h4.x, h4.y);
                  let w22 = r4, _2 = n4;
                  if (a4) {
                    const t5 = up(p4, g5, r4, n4, a4, o4, l4, u4);
                    w22 += t5.base, _2 += t5.top;
                  }
                  0 !== r4 ? y3(d3, b3.x + v22[0] * f3 * w22, b3.y + v22[1] * f3 * w22, b3.z + v22[2] * f3 * w22) : y3(d3, b3.x, b3.y, b3.z), y3(m3, b3.x + v22[0] * f3 * _2, b3.y + v22[1] * f3 * _2, b3.z + v22[2] * f3 * _2), O2.vec3.transformMat4(d3, d3, s4), O2.vec3.transformMat4(m3, m3, s4), e5.push(new hh2(d3[0], d3[1], d3[2])), x3.push(new hh2(m3[0], m3[1], m3[2]));
                }
                h3.push(e5), p3.push(x3);
              }
              return [h3, p3];
            }(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3) : a3 ? function(t4, e4, r4, n4, i4, s4, a4, o4, l4) {
              const u4 = [], c4 = [], h3 = [0, 0, 0, 1];
              for (const p3 of t4) {
                const t5 = [], f3 = [];
                for (const u5 of p3) {
                  const c5 = u5.x + n4.x, p4 = u5.y + n4.y, d3 = up(c5, p4, e4, r4, s4, a4, o4, l4);
                  h3[0] = c5, h3[1] = p4, h3[2] = d3.base, h3[3] = 1, O2.vec4.transformMat4(h3, h3, i4), h3[3] = Math.max(h3[3], 1e-5);
                  const m3 = new hh2(h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]);
                  h3[0] = c5, h3[1] = p4, h3[2] = d3.top, h3[3] = 1, O2.vec4.transformMat4(h3, h3, i4), h3[3] = Math.max(h3[3], 1e-5);
                  const y3 = new hh2(h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]);
                  t5.push(m3), f3.push(y3);
                }
                u4.push(t5), c4.push(f3);
              }
              return [u4, c4];
            }(e3, r3, n3, i3, s3, a3, o3, l3, u3) : function(t4, e4, r4, n4, i4) {
              const s4 = [], a4 = [], o4 = i4[8] * e4, l4 = i4[9] * e4, u4 = i4[10] * e4, c4 = i4[11] * e4, h3 = i4[8] * r4, p3 = i4[9] * r4, f3 = i4[10] * r4, d3 = i4[11] * r4;
              for (const e5 of t4) {
                const t5 = [], r5 = [];
                for (const s5 of e5) {
                  const e6 = s5.x + n4.x, a5 = s5.y + n4.y, m3 = i4[0] * e6 + i4[4] * a5 + i4[12], y3 = i4[1] * e6 + i4[5] * a5 + i4[13], g3 = i4[2] * e6 + i4[6] * a5 + i4[14], x3 = i4[3] * e6 + i4[7] * a5 + i4[15], b3 = m3 + o4, v22 = y3 + l4, w22 = g3 + u4, _2 = Math.max(x3 + c4, 1e-5), M22 = m3 + h3, A22 = y3 + p3, S22 = g3 + f3, I22 = Math.max(x3 + d3, 1e-5);
                  t5.push(new hh2(b3 / _2, v22 / _2, w22 / _2)), r5.push(new hh2(M22 / I22, A22 / I22, S22 / I22));
                }
                s4.push(t5), a4.push(r5);
              }
              return [s4, a4];
            }(e3, r3, n3, i3, s3);
          }(s2, n22, h22, c22, u22, a2, y22, p22, d22, s2.center.lat, t22.tileID.canonical), b22 = t22.queryGeometry;
          return function(t3, e3, r3) {
            let n3 = 1 / 0;
            Vl(r3, e3) && (n3 = lp(r3, e3[0]));
            for (let i3 = 0; i3 < e3.length; i3++) {
              const s3 = e3[i3], a3 = t3[i3];
              for (let t4 = 0; t4 < s3.length - 1; t4++) {
                const e4 = s3[t4], i4 = [e4, s3[t4 + 1], a3[t4 + 1], a3[t4], e4];
                El(r3, i4) && (n3 = Math.min(n3, lp(r3, i4)));
              }
            }
            return n3 !== 1 / 0 && n3;
          }(g22, x22, b22.isPointQuery() ? b22.screenBounds : b22.screenGeometry);
        }
      }, line: class extends pa2 {
        constructor(t22, e22, r22, n22) {
          const i2 = Ep();
          super(t22, i2, e22, r22, n22), i2.layout && (this.layout = new js(i2.layout)), this.gradientVersion = 0;
        }
        _handleSpecialPaintPropertyUpdate(t22) {
          if ("line-gradient" === t22) {
            const t3 = this._transitionablePaint._values["line-gradient"].value.expression;
            this.stepInterpolant = t3._styleExpression && t3._styleExpression.expression instanceof Un, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        widthExpression() {
          return this._transitionablePaint._values["line-width"].value.expression;
        }
        recalculate(t22, e22) {
          super.recalculate(t22, e22), this.paint._values["line-floorwidth"] = (() => {
            if (Vp)
              return Vp;
            const t3 = Ep();
            return Vp = new Bp(t3.paint.properties["line-width"].specification), Vp.useIntegerZoom = true, Vp;
          })().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t22);
        }
        createBucket(t22) {
          return new wp(t22);
        }
        getProgramIds() {
          return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
        }
        getDefaultProgramParams(t22, e22, r22) {
          const n22 = zp(this);
          return { config: new Lo(this, { zoom: e22, lut: r22 }), defines: n22, overrideFog: false };
        }
        queryRadius(t22) {
          const e22 = t22, r22 = Cp(Gl("line-width", this, e22), Gl("line-gap-width", this, e22)), n22 = Gl("line-offset", this, e22);
          return r22 / 2 + Math.abs(n22) + Xl(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(t22, e22, r22, n22, i2, s2) {
          if (t22.queryGeometry.isAboveHorizon)
            return false;
          const a2 = Yl(t22.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s2.angle, t22.pixelToTileUnitsFactor), o2 = t22.pixelToTileUnitsFactor / 2 * Cp(this.paint.get("line-width").evaluate(e22, r22), this.paint.get("line-gap-width").evaluate(e22, r22)), l22 = this.paint.get("line-offset").evaluate(e22, r22);
          return l22 && (n22 = function(t3, e3) {
            const r3 = [], n3 = new q2(0, 0);
            for (let i3 = 0; i3 < t3.length; i3++) {
              const s3 = t3[i3], a3 = [];
              for (let t4 = 0; t4 < s3.length; t4++) {
                const r4 = s3[t4], i4 = s3[t4 + 1], o3 = 0 === t4 ? n3 : r4.sub(s3[t4 - 1])._unit()._perp(), l3 = t4 === s3.length - 1 ? n3 : i4.sub(r4)._unit()._perp(), u22 = o3._add(l3)._unit();
                u22._mult(1 / (u22.x * l3.x + u22.y * l3.y)), a3.push(u22._mult(e3)._add(r4));
              }
              r3.push(a3);
            }
            return r3;
          }(n22, l22 * t22.pixelToTileUnitsFactor)), function(t3, e3, r3) {
            for (let n3 = 0; n3 < e3.length; n3++) {
              const i3 = e3[n3];
              if (t3.length >= 3) {
                for (let e4 = 0; e4 < i3.length; e4++)
                  if (Ul(t3, i3[e4]))
                    return true;
              }
              if (Cl(t3, i3, r3))
                return true;
            }
            return false;
          }(a2, n22, o2);
        }
        isTileClipped() {
          return true;
        }
        isDraped(t22) {
          const e22 = this.layout.get("line-z-offset");
          return e22.isConstant() && !e22.constantOr(0);
        }
      }, symbol: tm, background: class extends pa2 {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: em || (em = new Gs({ visibility: new Ns(Xs.layout_background.visibility) })), paint: rm || (rm = new Gs({ "background-pitch-alignment": new Ns(Xs.paint_background["background-pitch-alignment"]), "background-color": new Ns(Xs.paint_background["background-color"]), "background-pattern": new Ns(Xs.paint_background["background-pattern"]), "background-opacity": new Ns(Xs.paint_background["background-opacity"]), "background-emissive-strength": new Ns(Xs.paint_background["background-emissive-strength"]) })) }, e22, r22, n22);
        }
        getProgramIds() {
          return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
        }
        getDefaultProgramParams(t22, e22, r22) {
          return { overrideFog: false };
        }
        is3D() {
          return "viewport" === this.paint.get("background-pitch-alignment");
        }
      }, raster: mm, "raster-particle": wm, sky: class extends pa2 {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: xm || (xm = new Gs({ visibility: new Ns(Xs.layout_sky.visibility) })), paint: bm || (bm = new Gs({ "sky-type": new Ns(Xs.paint_sky["sky-type"]), "sky-atmosphere-sun": new Ns(Xs.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Ns(Xs.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Ns(Xs.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Ns(Xs.paint_sky["sky-gradient-radius"]), "sky-gradient": new $s(Xs.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Ns(Xs.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Ns(Xs.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Ns(Xs.paint_sky["sky-opacity"]) })) }, e22, r22, n22), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t22) {
          "sky-gradient" === t22 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t22 && "sky-atmosphere-halo-color" !== t22 && "sky-atmosphere-color" !== t22 && "sky-atmosphere-sun-intensity" !== t22 || (this._skyboxInvalidated = true);
        }
        _updateColorRamp() {
          this.colorRamp = ac2({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
        }
        needsSkyboxCapture(t22) {
          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
            return true;
          if (!this.paint.get("sky-atmosphere-sun")) {
            const e22 = t22.style.light.properties.get("position");
            return this._lightPosition.azimuthal !== e22.azimuthal || this._lightPosition.polar !== e22.polar;
          }
          return false;
        }
        getCenter(t22, e22) {
          if ("atmosphere" === this.paint.get("sky-type")) {
            const r3 = this.paint.get("sky-atmosphere-sun"), n22 = !r3, i2 = t22.style.light, s2 = i2.properties.get("position");
            return n22 && "viewport" === i2.properties.get("anchor") && ft("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n22 ? Mm(s2.azimuthal, 90 - s2.polar, e22) : Mm(r3[0], 90 - r3[1], e22);
          }
          const r22 = this.paint.get("sky-gradient-center");
          return Mm(r22[0], 90 - r22[1], e22);
        }
        isSky() {
          return true;
        }
        markSkyboxValid(t22) {
          this._skyboxInvalidated = false, this._lightPosition = t22.style.light.properties.get("position");
        }
        hasOffscreenPass() {
          return true;
        }
        getProgramIds() {
          const t22 = this.paint.get("sky-type");
          return "atmosphere" === t22 ? ["skyboxCapture", "skybox"] : "gradient" === t22 ? ["skyboxGradient"] : null;
        }
      }, slot: class extends pa2 {
        constructor(t22, e22, r22, n22) {
          super(t22, { paint: vm || (vm = new Gs({})) }, e22, null);
        }
      }, model: class extends pa2 {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: Ym || (Ym = new Gs({ visibility: new Ns(Xs.layout_model.visibility), "model-id": new qs(Xs.layout_model["model-id"]) })), paint: Zm || (Zm = new Gs({ "model-opacity": new Ns(Xs.paint_model["model-opacity"]), "model-rotation": new qs(Xs.paint_model["model-rotation"]), "model-scale": new qs(Xs.paint_model["model-scale"]), "model-translation": new qs(Xs.paint_model["model-translation"]), "model-color": new qs(Xs.paint_model["model-color"]), "model-color-mix-intensity": new qs(Xs.paint_model["model-color-mix-intensity"]), "model-type": new Ns(Xs.paint_model["model-type"]), "model-cast-shadows": new Ns(Xs.paint_model["model-cast-shadows"]), "model-receive-shadows": new Ns(Xs.paint_model["model-receive-shadows"]), "model-ambient-occlusion-intensity": new Ns(Xs.paint_model["model-ambient-occlusion-intensity"]), "model-emissive-strength": new qs(Xs.paint_model["model-emissive-strength"]), "model-roughness": new qs(Xs.paint_model["model-roughness"]), "model-height-based-emissive-strength-multiplier": new qs(Xs.paint_model["model-height-based-emissive-strength-multiplier"]), "model-cutoff-fade-range": new Ns(Xs.paint_model["model-cutoff-fade-range"]), "model-front-cutoff": new Ns(Xs.paint_model["model-front-cutoff"]) })) }, e22, r22, n22), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
        }
        createBucket(t22) {
          return new Xm(t22);
        }
        getProgramIds() {
          return ["model"];
        }
        is3D() {
          return true;
        }
        hasShadowPass() {
          return true;
        }
        canCastShadows() {
          return true;
        }
        hasLightBeamPass() {
          return true;
        }
        cutoffRange() {
          return this.paint.get("model-cutoff-fade-range");
        }
        queryRadius(t22) {
          return t22 instanceof cy ? Hr - 1 : 0;
        }
        queryIntersectsFeature(t22, e22, r22, n22, i2, s2) {
          if (!this.modelManager)
            return false;
          const a2 = this.modelManager, o2 = t22.tile.getBucket(this);
          if (!(o2 && o2 instanceof Xm))
            return false;
          const l22 = o2;
          for (const r3 in l22.instancesPerModel) {
            const n3 = l22.instancesPerModel[r3], i3 = void 0 !== e22.id ? e22.id : e22.properties && e22.properties.hasOwnProperty("id") ? e22.properties.id : void 0;
            if (n3.idToFeaturesIndex.hasOwnProperty(i3)) {
              const e3 = n3.features[n3.idToFeaturesIndex[i3]], o3 = a2.getModel(r3, this.scope);
              if (!o3)
                return false;
              let u22 = O2.mat4.create();
              const c22 = new rl2(0, 0), h22 = l22.canonical;
              let p22 = Number.MAX_VALUE;
              for (let r4 = 0; r4 < e3.instancedDataCount; ++r4) {
                const i4 = 16 * (e3.instancedDataOffset + r4), a3 = n3.instancedDataArray.float32, l3 = [a3[i4 + 4], a3[i4 + 5], a3[i4 + 6]];
                dy(h22, c22, a3[i4], 0 | a3[i4 + 1]), Km(u22, o3, s2, c22, e3.rotation, e3.scale, l3, false, false, false), "globe" === s2.projection.name && (u22 = Bm(u22, s2));
                const f22 = O2.mat4.multiply([], s2.projMatrix, u22), d22 = t22.queryGeometry, m22 = Vm(d22.isPointQuery() ? d22.screenBounds : d22.screenGeometry, s2, f22, o3.aabb);
                null != m22 && (p22 = Math.min(m22, p22));
              }
              return p22 !== Number.MAX_VALUE && p22;
            }
          }
          return false;
        }
        _handleOverridablePaintPropertyUpdate(t22, e22, r22) {
          return !(!this.layout || e22.isDataDriven() || r22.isDataDriven() || "model-color" !== t22 && "model-color-mix-intensity" !== t22 && "model-rotation" !== t22 && "model-scale" !== t22 && "model-translation" !== t22 && "model-emissive-strength" !== t22);
        }
        _isPropertyZoomDependent(t22) {
          const e22 = this._transitionablePaint._values[t22];
          return null != e22 && null != e22.value && null != e22.value.expression && e22.value.expression instanceof Ji2;
        }
        isZoomDependent() {
          return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
        }
        queryIntersectsMatchingFeature(t22, e22, r22, n22) {
          const i2 = t22.tile, s2 = i2.getBucket(this);
          let a2 = null, o2 = Number.MAX_VALUE;
          if (!(s2 && s2 instanceof cy))
            return { queryFeature: a2, intersectionZ: o2 };
          const l22 = s2.getNodesInfo()[e22];
          if (l22.hiddenByReplacement || !l22.node.meshes || !r22.filter(new Vs(i2.tileID.overscaledZ), l22.feature, i2.tileID.canonical))
            return { queryFeature: a2, intersectionZ: o2 };
          const u22 = l22.node, c22 = n22.calculatePosMatrix(i2.tileID.toUnwrapped(), n22.worldSize), h22 = l22.evaluatedScale;
          let p22 = 0;
          n22.elevation && u22.elevation && (p22 = u22.elevation * n22.elevation.exaggeration()), O2.mat4.translate(c22, c22, [(u22.anchor ? u22.anchor[0] : 0) * (h22[0] - 1), (u22.anchor ? u22.anchor[1] : 0) * (h22[1] - 1), p22]), O2.mat4.scale(c22, c22, h22), O2.mat4.multiply(c22, c22, u22.matrix);
          const f22 = t22.queryGeometry, d22 = f22.isPointQuery() ? f22.screenBounds : f22.screenGeometry, m22 = function(t3) {
            const e3 = O2.mat4.multiply([], c22, t3.matrix), r3 = O2.mat4.multiply(e3, n22.expandedFarZProjMatrix, e3);
            for (let e4 = 0; e4 < t3.meshes.length; ++e4) {
              const i3 = t3.meshes[e4];
              if (e4 === t3.lightMeshIndex)
                continue;
              const s3 = Vm(d22, n22, r3, i3.aabb);
              null != s3 && (o2 = Math.min(s3, o2));
            }
            if (t3.children)
              for (const e4 of t3.children)
                m22(e4);
          };
          if (m22(u22), o2 === Number.MAX_VALUE)
            return { queryFeature: a2, intersectionZ: o2 };
          const y22 = new rl2(0, 0);
          return dy(i2.tileID.canonical, y22, l22.node.anchor[0], l22.node.anchor[1]), a2 = { type: "Feature", geometry: { type: "Point", coordinates: [y22.lng, y22.lat] }, properties: l22.feature.properties, id: l22.feature.id, state: {}, layer: this.serialize() }, { queryFeature: a2, intersectionZ: o2 };
        }
      }, clip: class extends pa2 {
        constructor(t22, e22, r22, n22) {
          super(t22, { layout: jc2 || (jc2 = new Gs({ "clip-layer-types": new Ns(Xs.layout_clip["clip-layer-types"]), "clip-layer-scope": new Ns(Xs.layout_clip["clip-layer-scope"]) })), paint: Nc2 || (Nc2 = new Gs({})) }, e22, r22, n22);
        }
        recalculate(t22, e22) {
          super.recalculate(t22, e22);
        }
        createBucket(t22) {
          return new Gc2(t22);
        }
        isTileClipped() {
          return true;
        }
        is3D() {
          return true;
        }
      } };
      class yy {
        constructor(t22) {
          this._callback = t22, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = false, this._callback();
          });
        }
        trigger() {
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
            this._triggered = false, this._callback();
          }, 0));
        }
        remove() {
          this._channel = void 0, this._callback = () => {
          };
        }
      }
      class gy {
        constructor() {
          this.tasks = {}, this.taskQueue = [], ot(["process"], this), this.invoker = new yy(this.process), this.nextId = 0;
        }
        add(t22, e22) {
          const r22 = this.nextId++, n22 = function({ type: t3, isSymbolTile: e3, zoom: r3 }) {
            return r3 = r3 || 0, "message" === t3 ? 0 : "maybePrepare" !== t3 || e3 ? "parseTile" !== t3 || e3 ? "parseTile" === t3 && e3 ? 300 - r3 : "maybePrepare" === t3 && e3 ? 400 - r3 : 500 : 200 - r3 : 100 - r3;
          }(e22);
          if (0 === n22) {
            try {
              t22();
            } finally {
            }
            return null;
          }
          return this.tasks[r22] = { fn: t22, metadata: e22, priority: n22, id: r22 }, this.taskQueue.push(r22), this.invoker.trigger(), { cancel: () => {
            delete this.tasks[r22];
          } };
        }
        process() {
          try {
            if (this.taskQueue = this.taskQueue.filter((t3) => !!this.tasks[t3]), !this.taskQueue.length)
              return;
            const t22 = this.pick();
            if (null === t22)
              return;
            const e22 = this.tasks[t22];
            if (delete this.tasks[t22], this.taskQueue.length && this.invoker.trigger(), !e22)
              return;
            e22.fn();
          } finally {
          }
        }
        pick() {
          let t22 = null, e22 = 1 / 0;
          for (let r3 = 0; r3 < this.taskQueue.length; r3++) {
            const n22 = this.tasks[this.taskQueue[r3]];
            n22.priority < e22 && (e22 = n22.priority, t22 = r3);
          }
          if (null === t22)
            return null;
          const r22 = this.taskQueue[t22];
          return this.taskQueue.splice(t22, 1), r22;
        }
        remove() {
          this.invoker.remove();
        }
      }
      class xy {
        constructor(t22, e22, r22) {
          this.target = t22, this.parent = e22, this.mapId = r22, this.callbacks = {}, this.cancelCallbacks = {}, ot(["receive"], this), this.target.addEventListener("message", this.receive, false), this.scheduler = new gy();
        }
        send(t22, e22, r22, n22, i2 = false, s2) {
          const a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          r22 && (r22.metadata = s2, this.callbacks[a2] = r22);
          const o2 = /* @__PURE__ */ new Set();
          return this.target.postMessage({ id: a2, type: t22, hasCallback: !!r22, targetMapId: n22, mustQueue: i2, sourceMapId: this.mapId, data: cs(e22, o2) }, o2), { cancel: () => {
            r22 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n22, sourceMapId: this.mapId });
          } };
        }
        receive(t22) {
          const e22 = t22.data, r22 = e22.id;
          if (r22 && (!e22.targetMapId || this.mapId === e22.targetMapId))
            if ("<cancel>" === e22.type) {
              const t3 = this.cancelCallbacks[r22];
              delete this.cancelCallbacks[r22], t3 && t3.cancel();
            } else if (e22.mustQueue || gt()) {
              const t3 = this.callbacks[r22], n22 = this.scheduler.add(() => this.processTask(r22, e22), t3 && t3.metadata || { type: "message" });
              n22 && (this.cancelCallbacks[r22] = n22);
            } else
              this.processTask(r22, e22);
        }
        processTask(t22, e22) {
          if (delete this.cancelCallbacks[t22], "<response>" === e22.type) {
            const r22 = this.callbacks[t22];
            delete this.callbacks[t22], r22 && (e22.error ? r22(hs(e22.error)) : r22(null, hs(e22.data)));
          } else {
            const r22 = /* @__PURE__ */ new Set(), n22 = e22.hasCallback ? (e3, n3) => {
              this.target.postMessage({ id: t22, type: "<response>", sourceMapId: this.mapId, error: e3 ? cs(e3) : null, data: cs(n3, r22) }, r22);
            } : (t3) => {
            }, i2 = hs(e22.data);
            if (this.parent[e22.type])
              this.parent[e22.type](e22.sourceMapId, i2, n22);
            else if (this.parent.getWorkerSource) {
              const t3 = e22.type.split(".");
              this.parent.getWorkerSource(e22.sourceMapId, t3[0], i2.source, i2.scope)[t3[1]](i2, n22);
            } else
              n22(new Error("Could not find function ".concat(e22.type)));
          }
        }
        remove() {
          this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
        }
      }
      class by {
        constructor(t22, e22) {
          this.workerPool = t22, this.actors = [], this.currentActor = 0, this.id = st();
          const r22 = this.workerPool.acquire(this.id);
          for (let t3 = 0; t3 < r22.length; t3++) {
            const n22 = new by.Actor(r22[t3], e22, this.id);
            n22.name = "Worker ".concat(t3), this.actors.push(n22);
          }
          this.ready = false, this.broadcast("checkIfReady", null, () => {
            this.ready = true;
          });
        }
        broadcast(t22, e22, r22) {
          rt(this.actors, (r3, n22) => {
            r3.send(t22, e22, n22);
          }, r22 = r22 || function() {
          });
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          this.actors.forEach((t22) => {
            t22.remove();
          }), this.actors = [], this.workerPool.release(this.id);
        }
      }
      by.Actor = xy;
      class vy {
        constructor(t22) {
          this.size = t22, this.minimums = [], this.maximums = [], this.leaves = [];
        }
        getElevation(t22, e22) {
          const r22 = this.toIdx(t22, e22);
          return { min: this.minimums[r22], max: this.maximums[r22] };
        }
        isLeaf(t22, e22) {
          return this.leaves[this.toIdx(t22, e22)];
        }
        toIdx(t22, e22) {
          return e22 * this.size + t22;
        }
      }
      function wy(t22, e22, r22, n22) {
        let i2 = 0, s2 = Number.MAX_VALUE;
        for (let a2 = 0; a2 < 3; a2++)
          if (Math.abs(n22[a2]) < 1e-15) {
            if (r22[a2] < t22[a2] || r22[a2] > e22[a2])
              return null;
          } else {
            const o2 = 1 / n22[a2];
            let l22 = (t22[a2] - r22[a2]) * o2, u22 = (e22[a2] - r22[a2]) * o2;
            if (l22 > u22) {
              const t3 = l22;
              l22 = u22, u22 = t3;
            }
            if (l22 > i2 && (i2 = l22), u22 < s2 && (s2 = u22), i2 > s2)
              return null;
          }
        return i2;
      }
      function _y(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22) {
        const h22 = n22 - t22, p22 = i2 - e22, f22 = s2 - r22, d22 = a2 - t22, m22 = o2 - e22, y22 = l22 - r22, g22 = c22[1] * y22 - c22[2] * m22, x22 = c22[2] * d22 - c22[0] * y22, b22 = c22[0] * m22 - c22[1] * d22, v22 = h22 * g22 + p22 * x22 + f22 * b22;
        if (Math.abs(v22) < 1e-15)
          return null;
        const w22 = 1 / v22, _2 = u22[0] - t22, M22 = u22[1] - e22, A22 = u22[2] - r22, S22 = (_2 * g22 + M22 * x22 + A22 * b22) * w22;
        if (S22 < 0 || S22 > 1)
          return null;
        const I22 = M22 * f22 - A22 * p22, P22 = A22 * h22 - _2 * f22, z22 = _2 * p22 - M22 * h22, k22 = (c22[0] * I22 + c22[1] * P22 + c22[2] * z22) * w22;
        return k22 < 0 || S22 + k22 > 1 ? null : (d22 * I22 + m22 * P22 + y22 * z22) * w22;
      }
      function My(t22, e22, r22) {
        return (t22 - e22) / (r22 - e22);
      }
      function Ay(t22, e22, r22, n22, i2, s2, a2, o2, l22) {
        const u22 = 1 << r22, c22 = s2 - n22, h22 = a2 - i2, p22 = (t22 + 1) / u22 * c22 + n22, f22 = (e22 + 0) / u22 * h22 + i2, d22 = (e22 + 1) / u22 * h22 + i2;
        o2[0] = (t22 + 0) / u22 * c22 + n22, o2[1] = f22, l22[0] = p22, l22[1] = d22;
      }
      class Sy {
        constructor(t22) {
          if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t22, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
            return;
          const e22 = function(t3) {
            const e3 = Math.ceil(Math.log2(t3.dim / 8)), r3 = [];
            let n3 = Math.ceil(Math.pow(2, e3));
            const i2 = 1 / n3, s2 = (t4, e4, r4, n4, i3) => {
              const s3 = n4 ? 1 : 0, a3 = (t4 + 1) * r4 - s3, o3 = e4 * r4, l22 = (e4 + 1) * r4 - s3;
              i3[0] = t4 * r4, i3[1] = o3, i3[2] = a3, i3[3] = l22;
            };
            let a2 = new vy(n3);
            const o2 = [];
            for (let e4 = 0; e4 < n3 * n3; e4++) {
              s2(e4 % n3, Math.floor(e4 / n3), i2, false, o2);
              const r4 = Py(o2[0], o2[1], t3), l22 = Py(o2[2], o2[1], t3), u22 = Py(o2[2], o2[3], t3), c22 = Py(o2[0], o2[3], t3);
              a2.minimums.push(Math.min(r4, l22, u22, c22)), a2.maximums.push(Math.max(r4, l22, u22, c22)), a2.leaves.push(1);
            }
            for (r3.push(a2), n3 /= 2; n3 >= 1; n3 /= 2) {
              const t4 = r3[r3.length - 1];
              a2 = new vy(n3);
              for (let e4 = 0; e4 < n3 * n3; e4++) {
                s2(e4 % n3, Math.floor(e4 / n3), 2, true, o2);
                const r4 = t4.getElevation(o2[0], o2[1]), i3 = t4.getElevation(o2[2], o2[1]), l22 = t4.getElevation(o2[2], o2[3]), u22 = t4.getElevation(o2[0], o2[3]), c22 = t4.isLeaf(o2[0], o2[1]), h22 = t4.isLeaf(o2[2], o2[1]), p22 = t4.isLeaf(o2[2], o2[3]), f22 = t4.isLeaf(o2[0], o2[3]), d22 = Math.min(r4.min, i3.min, l22.min, u22.min), m22 = Math.max(r4.max, i3.max, l22.max, u22.max), y22 = c22 && h22 && p22 && f22;
                a2.maximums.push(m22), a2.minimums.push(d22), a2.leaves.push(m22 - d22 <= 5 && y22 ? 1 : 0);
              }
              r3.push(a2);
            }
            return r3;
          }(this.dem), r22 = e22.length - 1, n22 = e22[r22];
          this._addNode(n22.minimums[0], n22.maximums[0], n22.leaves[0]), this._construct(e22, 0, 0, r22, 0);
        }
        raycastRoot(t22, e22, r22, n22, i2, s2, a2 = 1) {
          return wy([t22, e22, -100], [r22, n22, this.maximums[0] * a2], i2, s2);
        }
        raycast(t22, e22, r22, n22, i2, s2, a2 = 1) {
          if (!this.nodeCount)
            return null;
          const o2 = this.raycastRoot(t22, e22, r22, n22, i2, s2, a2);
          if (null == o2)
            return null;
          const l22 = [], u22 = [], c22 = [], h22 = [], p22 = [{ idx: 0, t: o2, nodex: 0, nodey: 0, depth: 0 }];
          for (; p22.length > 0; ) {
            const { idx: o3, t: f22, nodex: d22, nodey: m22, depth: y22 } = p22.pop();
            if (this.leaves[o3]) {
              Ay(d22, m22, y22, t22, e22, r22, n22, c22, h22);
              const o4 = 1 << y22, l3 = (d22 + 0) / o4, u3 = (d22 + 1) / o4, p3 = (m22 + 0) / o4, g3 = (m22 + 1) / o4, x22 = Py(l3, p3, this.dem) * a2, b22 = Py(u3, p3, this.dem) * a2, v22 = Py(u3, g3, this.dem) * a2, w22 = Py(l3, g3, this.dem) * a2, _2 = _y(c22[0], c22[1], x22, h22[0], c22[1], b22, h22[0], h22[1], v22, i2, s2), M22 = _y(h22[0], h22[1], v22, c22[0], h22[1], w22, c22[0], c22[1], x22, i2, s2), A22 = Math.min(null !== _2 ? _2 : Number.MAX_VALUE, null !== M22 ? M22 : Number.MAX_VALUE);
              if (A22 !== Number.MAX_VALUE)
                return A22;
              {
                const t3 = O2.vec3.scaleAndAdd([], i2, s2, f22);
                if (Iy(x22, b22, w22, v22, My(t3[0], c22[0], h22[0]), My(t3[1], c22[1], h22[1])) >= t3[2])
                  return f22;
              }
              continue;
            }
            let g22 = 0;
            for (let p3 = 0; p3 < this._siblingOffset.length; p3++) {
              Ay((d22 << 1) + this._siblingOffset[p3][0], (m22 << 1) + this._siblingOffset[p3][1], y22 + 1, t22, e22, r22, n22, c22, h22), c22[2] = -100, h22[2] = this.maximums[this.childOffsets[o3] + p3] * a2;
              const f3 = wy(c22, h22, i2, s2);
              if (null != f3) {
                const t3 = f3;
                l22[p3] = t3;
                let e3 = false;
                for (let r3 = 0; r3 < g22 && !e3; r3++)
                  t3 >= l22[u22[r3]] && (u22.splice(r3, 0, p3), e3 = true);
                e3 || (u22[g22] = p3), g22++;
              }
            }
            for (let t3 = 0; t3 < g22; t3++) {
              const e3 = u22[t3];
              p22.push({ idx: this.childOffsets[o3] + e3, t: l22[e3], nodex: (d22 << 1) + this._siblingOffset[e3][0], nodey: (m22 << 1) + this._siblingOffset[e3][1], depth: y22 + 1 });
            }
          }
          return null;
        }
        _addNode(t22, e22, r22) {
          return this.minimums.push(t22), this.maximums.push(e22), this.leaves.push(r22), this.childOffsets.push(0), this.nodeCount++;
        }
        _construct(t22, e22, r22, n22, i2) {
          if (1 === t22[n22].isLeaf(e22, r22))
            return;
          this.childOffsets[i2] || (this.childOffsets[i2] = this.nodeCount);
          const s2 = n22 - 1, a2 = t22[s2];
          let o2 = 0, l22 = 0;
          for (let t3 = 0; t3 < this._siblingOffset.length; t3++) {
            const n3 = 2 * e22 + this._siblingOffset[t3][0], i3 = 2 * r22 + this._siblingOffset[t3][1], s3 = a2.getElevation(n3, i3), u22 = a2.isLeaf(n3, i3), c22 = this._addNode(s3.min, s3.max, u22);
            u22 && (o2 |= 1 << t3), l22 || (l22 = c22);
          }
          for (let n3 = 0; n3 < this._siblingOffset.length; n3++)
            o2 & 1 << n3 || this._construct(t22, 2 * e22 + this._siblingOffset[n3][0], 2 * r22 + this._siblingOffset[n3][1], s2, l22 + n3);
        }
      }
      function Iy(t22, e22, r22, n22, i2, s2) {
        return ke2(ke2(t22, r22, s2), ke2(e22, n22, s2), i2);
      }
      function Py(t22, e22, r22) {
        const n22 = r22.dim, i2 = Q2(t22 * n22 - 0.5, 0, n22 - 1), s2 = Q2(e22 * n22 - 0.5, 0, n22 - 1), a2 = Math.floor(i2), o2 = Math.floor(s2), l22 = Math.min(a2 + 1, n22 - 1), u22 = Math.min(o2 + 1, n22 - 1);
        return Iy(r22.get(a2, o2), r22.get(l22, o2), r22.get(a2, u22), r22.get(l22, u22), i2 - a2, s2 - o2);
      }
      const zy = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
      function ky(t22, e22, r22) {
        return (256 * t22 * 256 + 256 * e22 + r22) / 10 - 1e4;
      }
      function Ty(t22, e22, r22) {
        return 256 * t22 + e22 + r22 / 256 - 32768;
      }
      class Ey {
        get tree() {
          return this._tree || this._buildQuadTree(), this._tree;
        }
        constructor(t22, e22, r22, n22 = false) {
          if (this.uid = t22, e22.height !== e22.width)
            throw new RangeError("DEM tiles must be square");
          if (r22 && "mapbox" !== r22 && "terrarium" !== r22)
            return void ft('"'.concat(r22, '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".'));
          this.stride = e22.height;
          const i2 = this.dim = e22.height - 2, s2 = new Uint32Array(e22.data.buffer);
          if (this.pixels = new Uint8Array(e22.data.buffer), this.floatView = new Float32Array(e22.data.buffer), this.borderReady = n22, this._modifiedForSources = {}, !n22) {
            for (let t3 = 0; t3 < i2; t3++)
              s2[this._idx(-1, t3)] = s2[this._idx(0, t3)], s2[this._idx(i2, t3)] = s2[this._idx(i2 - 1, t3)], s2[this._idx(t3, -1)] = s2[this._idx(t3, 0)], s2[this._idx(t3, i2)] = s2[this._idx(t3, i2 - 1)];
            s2[this._idx(-1, -1)] = s2[this._idx(0, 0)], s2[this._idx(i2, -1)] = s2[this._idx(i2 - 1, 0)], s2[this._idx(-1, i2)] = s2[this._idx(0, i2 - 1)], s2[this._idx(i2, i2)] = s2[this._idx(i2 - 1, i2 - 1)];
          }
          const a2 = "terrarium" === r22 ? Ty : ky;
          for (let t3 = 0; t3 < s2.length; ++t3) {
            const e3 = 4 * t3;
            this.floatView[t3] = a2(this.pixels[e3], this.pixels[e3 + 1], this.pixels[e3 + 2]);
          }
          this._timestamp = Dt.now();
        }
        _buildQuadTree() {
          this._tree = new Sy(this);
        }
        get(t22, e22, r22 = false) {
          r22 && (t22 = Q2(t22, -1, this.dim), e22 = Q2(e22, -1, this.dim));
          const n22 = this._idx(t22, e22);
          return this.floatView[n22];
        }
        set(t22, e22, r22) {
          const n22 = this._idx(t22, e22), i2 = this.floatView[n22];
          return this.floatView[n22] = r22, r22 - i2;
        }
        static getUnpackVector(t22) {
          return zy[t22];
        }
        _idx(t22, e22) {
          if (t22 < -1 || t22 >= this.dim + 1 || e22 < -1 || e22 >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (e22 + 1) * this.stride + (t22 + 1);
        }
        static pack(t22, e22) {
          const r22 = [0, 0, 0, 0], n22 = Ey.getUnpackVector(e22);
          let i2 = Math.floor((t22 + n22[3]) / n22[2]);
          return r22[2] = i2 % 256, i2 = Math.floor(i2 / 256), r22[1] = i2 % 256, i2 = Math.floor(i2 / 256), r22[0] = i2, r22;
        }
        getPixels() {
          return new sc2({ width: this.stride, height: this.stride }, this.pixels);
        }
        backfillBorder(t22, e22, r22) {
          if (this.dim !== t22.dim)
            throw new Error("dem dimension mismatch");
          let n22 = e22 * this.dim, i2 = e22 * this.dim + this.dim, s2 = r22 * this.dim, a2 = r22 * this.dim + this.dim;
          switch (e22) {
            case -1:
              n22 = i2 - 1;
              break;
            case 1:
              i2 = n22 + 1;
          }
          switch (r22) {
            case -1:
              s2 = a2 - 1;
              break;
            case 1:
              a2 = s2 + 1;
          }
          const o2 = -e22 * this.dim, l22 = -r22 * this.dim;
          for (let e3 = s2; e3 < a2; e3++)
            for (let r3 = n22; r3 < i2; r3++) {
              const n3 = 4 * this._idx(r3, e3), i3 = 4 * this._idx(r3 + o2, e3 + l22);
              this.pixels[n3 + 0] = t22.pixels[i3 + 0], this.pixels[n3 + 1] = t22.pixels[i3 + 1], this.pixels[n3 + 2] = t22.pixels[i3 + 2], this.pixels[n3 + 3] = t22.pixels[i3 + 3];
            }
        }
        onDeserialize() {
          this._tree && (this._tree.dem = this);
        }
      }
      function By(t22, e22, r22) {
        1 === t22 ? e22.header_length = r22.readFixed32() : 2 === t22 ? e22.x = r22.readVarint() : 3 === t22 ? e22.y = r22.readVarint() : 4 === t22 ? e22.z = r22.readVarint() : 5 === t22 && e22.layers.push(function(t3, e3) {
          return t3.readFields(Ly, { version: 0, name: "", units: "", tilesize: 0, buffer: 0, pixel_format: 0, data_index: [] }, e3);
        }(r22, r22.readVarint() + r22.pos));
      }
      function Vy(t22, e22, r22) {
        1 === t22 ? (e22.delta_filter = function(t3, e3) {
          return t3.readFields(Cy, { block_size: 0 }, e3);
        }(r22, r22.readVarint() + r22.pos), e22.filter = "delta_filter") : 2 === t22 ? (r22.readVarint(), e22.filter = "zigzag_filter") : 3 === t22 ? (r22.readVarint(), e22.filter = "bitshuffle_filter") : 4 === t22 && (r22.readVarint(), e22.filter = "byteshuffle_filter");
      }
      function Cy(t22, e22, r22) {
        1 === t22 && (e22.block_size = r22.readVarint());
      }
      function Ry(t22, e22, r22) {
        1 === t22 ? (r22.readVarint(), e22.codec = "gzip_data") : 2 === t22 ? (r22.readVarint(), e22.codec = "jpeg_image") : 3 === t22 ? (r22.readVarint(), e22.codec = "webp_image") : 4 === t22 && (r22.readVarint(), e22.codec = "png_image");
      }
      function Dy(t22, e22, r22) {
        1 === t22 ? e22.first_byte = r22.readFixed64() : 2 === t22 ? e22.last_byte = r22.readFixed64() : 3 === t22 ? e22.filters.push(function(t3, e3) {
          return t3.readFields(Vy, {}, e3);
        }(r22, r22.readVarint() + r22.pos)) : 4 === t22 ? e22.codec = function(t3, e3) {
          return t3.readFields(Ry, {}, e3);
        }(r22, r22.readVarint() + r22.pos) : 5 === t22 ? e22.deprecated_offset = r22.readFloat() : 6 === t22 ? e22.deprecated_scale = r22.readFloat() : 7 === t22 ? e22.bands.push(r22.readString()) : 8 === t22 ? e22.offset = r22.readDouble() : 9 === t22 && (e22.scale = r22.readDouble());
      }
      function Ly(t22, e22, r22) {
        1 === t22 ? e22.version = r22.readVarint() : 2 === t22 ? e22.name = r22.readString() : 3 === t22 ? e22.units = r22.readString() : 4 === t22 ? e22.tilesize = r22.readVarint() : 5 === t22 ? e22.buffer = r22.readVarint() : 6 === t22 ? e22.pixel_format = r22.readVarint() : 7 === t22 && e22.data_index.push(function(t3, e3) {
          return t3.readFields(Dy, { first_byte: 0, last_byte: 0, filters: [], codec: null, offset: 0, scale: 0, deprecated_offset: 0, deprecated_scale: 0, bands: [] }, e3);
        }(r22, r22.readVarint() + r22.pos));
      }
      function Fy(t22, e22, r22) {
        if (2 === t22)
          !function(t3, e3, r3) {
            t3.readFields(Oy, r3, e3);
          }(r22, r22.readVarint() + r22.pos, e22);
        else if (3 === t22)
          throw new Error("Not implemented");
      }
      function Oy(t22, e22, r22) {
        if (1 === t22) {
          let t3 = 0;
          const n22 = r22.readVarint() + r22.pos;
          for (; r22.pos < n22; )
            e22[t3++] = r22.readVarint();
        }
      }
      os(Ey, "DEMData"), os(Sy, "DemMinMaxQuadTree", { omit: ["dem"] });
      class Uy {
        constructor(t22) {
          this.capacity = t22, this.cache = /* @__PURE__ */ new Map();
        }
        get(t22) {
          if (!this.cache.has(t22))
            return;
          const e22 = this.cache.get(t22);
          return this.cache.delete(t22), this.cache.set(t22, e22), e22;
        }
        put(t22, e22) {
          this.cache.has(t22) ? this.cache.delete(t22) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(t22, e22);
        }
      }
      function jy(t22, e22) {
        if (4 !== e22.length)
          throw new Error("Expected data of dimension 4 but got ".concat(e22.length, "."));
        let r22 = e22[3];
        for (let n22 = 2; n22 >= 1; n22--) {
          const i2 = 1 === n22 ? 1 : 0, s2 = 2 === n22 ? 1 : 0;
          for (let n3 = 0; n3 < e22[0]; n3++) {
            const a2 = e22[1] * n3;
            for (let n4 = i2; n4 < e22[1]; n4++) {
              const i3 = e22[2] * (n4 + a2);
              for (let n5 = s2; n5 < e22[2]; n5++) {
                const s3 = e22[3] * (n5 + i3);
                for (let n6 = 0; n6 < e22[3]; n6++) {
                  const e3 = s3 + n6;
                  t22[e3] += t22[e3 - r22];
                }
              }
            }
          }
          r22 *= e22[n22];
        }
        return t22;
      }
      function Ny(t22) {
        for (let e22 = 0, r22 = t22.length; e22 < r22; e22++)
          t22[e22] = t22[e22] >>> 1 ^ -(1 & t22[e22]);
        return t22;
      }
      function qy(t22, e22) {
        switch (e22) {
          case "uint32":
            return t22;
          case "uint16":
            for (let e3 = 0; e3 < t22.length; e3 += 2) {
              const r22 = t22[e3], n22 = t22[e3 + 1];
              t22[e3] = (240 & r22) >> 4 | (61440 & r22) >> 8 | (240 & n22) << 4 | 61440 & n22, t22[e3 + 1] = 15 & r22 | (3840 & r22) >> 4 | (15 & n22) << 8 | (3840 & n22) << 4;
            }
            return t22;
          case "uint8":
            for (let e3 = 0; e3 < t22.length; e3 += 4) {
              const r22 = t22[e3], n22 = t22[e3 + 1], i2 = t22[e3 + 2], s2 = t22[e3 + 3];
              t22[e3 + 0] = (192 & r22) >> 6 | (192 & n22) >> 4 | (192 & i2) >> 2 | 192 & s2, t22[e3 + 1] = (48 & r22) >> 4 | (48 & n22) >> 2 | 48 & i2 | (48 & s2) << 2, t22[e3 + 2] = (12 & r22) >> 2 | 12 & n22 | (12 & i2) << 2 | (12 & s2) << 4, t22[e3 + 3] = 3 & r22 | (3 & n22) << 2 | (3 & i2) << 4 | (3 & s2) << 6;
            }
            return t22;
          default:
            throw new Error('Invalid pixel format, "'.concat(e22, '"'));
        }
      }
      var $y = Uint8Array, Gy = Uint16Array, Xy = Int32Array, Yy = new $y([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), Zy = new $y([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), Wy = new $y([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Hy = function(t22, e22) {
        for (var r22 = new Gy(31), n22 = 0; n22 < 31; ++n22)
          r22[n22] = e22 += 1 << t22[n22 - 1];
        var i2 = new Xy(r22[30]);
        for (n22 = 1; n22 < 30; ++n22)
          for (var s2 = r22[n22]; s2 < r22[n22 + 1]; ++s2)
            i2[s2] = s2 - r22[n22] << 5 | n22;
        return { b: r22, r: i2 };
      }, Ky = Hy(Yy, 2), Jy = Ky.b, Qy = Ky.r;
      Jy[28] = 258, Qy[258] = 28;
      for (var tg2 = Hy(Zy, 0).b, eg2 = new Gy(32768), rg2 = 0; rg2 < 32768; ++rg2) {
        var ng2 = (43690 & rg2) >> 1 | (21845 & rg2) << 1;
        eg2[rg2] = ((65280 & (ng2 = (61680 & (ng2 = (52428 & ng2) >> 2 | (13107 & ng2) << 2)) >> 4 | (3855 & ng2) << 4)) >> 8 | (255 & ng2) << 8) >> 1;
      }
      var ig2 = function(t22, e22, r22) {
        for (var n22 = t22.length, i2 = 0, s2 = new Gy(e22); i2 < n22; ++i2)
          t22[i2] && ++s2[t22[i2] - 1];
        var a2, o2 = new Gy(e22);
        for (i2 = 1; i2 < e22; ++i2)
          o2[i2] = o2[i2 - 1] + s2[i2 - 1] << 1;
        a2 = new Gy(1 << e22);
        var l22 = 15 - e22;
        for (i2 = 0; i2 < n22; ++i2)
          if (t22[i2])
            for (var u22 = i2 << 4 | t22[i2], c22 = e22 - t22[i2], h22 = o2[t22[i2] - 1]++ << c22, p22 = h22 | (1 << c22) - 1; h22 <= p22; ++h22)
              a2[eg2[h22] >> l22] = u22;
        return a2;
      }, sg2 = new $y(288);
      for (rg2 = 0; rg2 < 144; ++rg2)
        sg2[rg2] = 8;
      for (rg2 = 144; rg2 < 256; ++rg2)
        sg2[rg2] = 9;
      for (rg2 = 256; rg2 < 280; ++rg2)
        sg2[rg2] = 7;
      for (rg2 = 280; rg2 < 288; ++rg2)
        sg2[rg2] = 8;
      var ag2 = new $y(32);
      for (rg2 = 0; rg2 < 32; ++rg2)
        ag2[rg2] = 5;
      var og2 = ig2(sg2, 9), lg2 = ig2(ag2, 5), ug2 = function(t22) {
        for (var e22 = t22[0], r22 = 1; r22 < t22.length; ++r22)
          t22[r22] > e22 && (e22 = t22[r22]);
        return e22;
      }, cg2 = function(t22, e22, r22) {
        var n22 = e22 / 8 | 0;
        return (t22[n22] | t22[n22 + 1] << 8) >> (7 & e22) & r22;
      }, hg2 = function(t22, e22) {
        var r22 = e22 / 8 | 0;
        return (t22[r22] | t22[r22 + 1] << 8 | t22[r22 + 2] << 16) >> (7 & e22);
      }, pg2 = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], fg2 = function(t22, e22, r22) {
        var n22 = new Error(e22 || pg2[t22]);
        if (n22.code = t22, Error.captureStackTrace && Error.captureStackTrace(n22, fg2), !r22)
          throw n22;
        return n22;
      }, dg2 = new $y(0), mg2 = "undefined" != typeof TextDecoder && new TextDecoder();
      try {
        mg2.decode(dg2, { stream: true });
      } catch (t22) {
      }
      const yg2 = { gzip_data: "gzip" };
      class gg2 extends Error {
        constructor(t22) {
          super(t22), this.name = "MRTError";
        }
      }
      const xg2 = { 0: "uint32", 1: "uint32", 2: "uint16", 3: "uint8" }, bg2 = { uint32: 1, uint16: 2, uint8: 4 }, vg2 = { uint32: Uint32Array, uint16: Uint16Array, uint8: Uint8Array };
      let wg2;
      class _g {
        constructor(t22 = 5) {
          this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t22;
        }
        getLayer(t22) {
          const e22 = this.layers[t22];
          if (!e22)
            throw new gg2("Layer '".concat(t22, "' not found"));
          return e22;
        }
        getHeaderLength(t22) {
          const e22 = new Uint8Array(t22), r22 = new DataView(t22);
          if (13 !== e22[0])
            throw new gg2("File is not a valid MRT.");
          return r22.getUint32(1, true);
        }
        parseHeader(t22) {
          const e22 = new Uint8Array(t22), r22 = this.getHeaderLength(t22);
          if (e22.length < r22)
            throw new gg2("Expected header with length >= ".concat(r22, " but got buffer of length ").concat(e22.length));
          const n22 = function(t3, e3) {
            return t3.readFields(By, { header_length: 0, x: 0, y: 0, z: 0, layers: [] }, void 0);
          }(new wg2(e22.subarray(0, r22)));
          if (!isNaN(this.x) && (this.x !== n22.x || this.y !== n22.y || this.z !== n22.z))
            throw new gg2("Invalid attempt to parse header ".concat(n22.z, "/").concat(n22.x, "/").concat(n22.y, " for tile ").concat(this.z, "/").concat(this.x, "/").concat(this.y));
          this.x = n22.x, this.y = n22.y, this.z = n22.z;
          for (const t3 of n22.layers)
            this.layers[t3.name] = new Mg2(t3, { cacheSize: this._cacheSize });
          return this;
        }
        createDecodingTask(t22) {
          const e22 = [], r22 = this.getLayer(t22.layerName);
          for (let n22 of t22.blockIndices) {
            const i2 = r22.dataIndex[n22], s2 = i2.first_byte - t22.firstByte, a2 = i2.last_byte - t22.firstByte;
            if (r22._blocksInProgress.has(n22))
              continue;
            const o2 = { layerName: r22.name, firstByte: s2, lastByte: a2, pixelFormat: r22.pixelFormat, blockIndex: n22, blockShape: [i2.bands.length].concat(r22.bandShape), buffer: r22.buffer, codec: i2.codec.codec, filters: i2.filters.map((t3) => t3.filter) };
            r22._blocksInProgress.add(n22), e22.push(o2);
          }
          return new Ag2(e22, () => {
            e22.forEach((t3) => r22._blocksInProgress.delete(t3.blockIndex));
          }, (t3, n22) => {
            if (e22.forEach((t4) => r22._blocksInProgress.delete(t4.blockIndex)), t3)
              throw t3;
            n22.forEach((t4) => {
              this.getLayer(t4.layerName).processDecodedData(t4);
            });
          });
        }
      }
      class Mg2 {
        constructor({ version: t22, name: e22, units: r22, tilesize: n22, pixel_format: i2, buffer: s2, data_index: a2 }, o2) {
          if (this.version = t22, 1 !== this.version)
            throw new gg2("Cannot parse raster layer encoded with MRT version ".concat(t22));
          this.name = e22, this.units = r22, this.tileSize = n22, this.buffer = s2, this.pixelFormat = xg2[i2], this.dataIndex = a2, this.bandShape = [n22 + 2 * s2, n22 + 2 * s2, bg2[this.pixelFormat]], this._decodedBlocks = new Uy(o2 ? o2.cacheSize : 5), this._blocksInProgress = /* @__PURE__ */ new Set();
        }
        get dimension() {
          return bg2[this.pixelFormat];
        }
        get cacheSize() {
          return this._decodedBlocks.capacity;
        }
        getBandList() {
          return this.dataIndex.map(({ bands: t22 }) => t22).flat();
        }
        processDecodedData(t22) {
          const e22 = t22.blockIndex.toString();
          this._decodedBlocks.get(e22) || this._decodedBlocks.put(e22, t22.data);
        }
        getBlockForBand(t22) {
          let e22 = 0;
          switch (typeof t22) {
            case "string":
              for (const [r22, n22] of this.dataIndex.entries()) {
                for (const [i2, s2] of n22.bands.entries())
                  if (s2 === t22)
                    return { bandIndex: e22 + i2, blockIndex: r22, blockBandIndex: i2 };
                e22 += n22.bands.length;
              }
              break;
            case "number":
              for (const [r22, n22] of this.dataIndex.entries()) {
                if (t22 >= e22 && t22 < e22 + n22.bands.length)
                  return { bandIndex: t22, blockIndex: r22, blockBandIndex: t22 - e22 };
                e22 += n22.bands.length;
              }
              break;
            default:
              throw new gg2("Invalid band `".concat(JSON.stringify(t22), "`. Expected string or integer."));
          }
          throw new gg2("Band not found: ".concat(JSON.stringify(t22)));
        }
        getDataRange(t22) {
          let e22 = 1 / 0, r22 = -1 / 0;
          const n22 = [], i2 = /* @__PURE__ */ new Set();
          for (const s2 of t22) {
            const { blockIndex: t3 } = this.getBlockForBand(s2);
            if (t3 < 0)
              throw new gg2("Invalid band: ".concat(JSON.stringify(s2)));
            const a2 = this.dataIndex[t3];
            n22.includes(t3) || n22.push(t3), i2.add(t3), e22 = Math.min(e22, a2.first_byte), r22 = Math.max(r22, a2.last_byte);
          }
          if (i2.size > this.cacheSize)
            throw new gg2("Number of blocks to decode (".concat(i2.size, ") exceeds cache size (").concat(this.cacheSize, ")."));
          return { layerName: this.name, firstByte: e22, lastByte: r22, blockIndices: n22 };
        }
        hasBand(t22) {
          const { blockIndex: e22 } = this.getBlockForBand(t22);
          return e22 >= 0;
        }
        hasDataForBand(t22) {
          const { blockIndex: e22 } = this.getBlockForBand(t22);
          return e22 >= 0 && !!this._decodedBlocks.get(e22.toString());
        }
        getBandView(t22) {
          const { blockIndex: e22, blockBandIndex: r22 } = this.getBlockForBand(t22), n22 = this._decodedBlocks.get(e22.toString());
          if (!n22)
            throw new gg2("Data for band ".concat(JSON.stringify(t22), ' of layer "').concat(this.name, '" not decoded.'));
          const i2 = this.dataIndex[e22], s2 = this.bandShape.reduce((t3, e3) => t3 * e3, 1), a2 = r22 * s2, o2 = n22.subarray(a2, a2 + s2);
          return { data: o2, bytes: new Uint8Array(o2.buffer).subarray(o2.byteOffset, o2.byteOffset + o2.byteLength), tileSize: this.tileSize, buffer: this.buffer, pixelFormat: this.pixelFormat, dimension: this.dimension, offset: 0 !== i2.offset ? i2.offset : i2.deprecated_offset, scale: 0 !== i2.scale ? i2.scale : i2.deprecated_scale };
        }
      }
      _g.setPbf = function(t22) {
        wg2 = t22;
      };
      class Ag2 {
        constructor(t22, e22, r22) {
          this.tasks = t22, this._onCancel = e22, this._onComplete = r22, this._finalized = false;
        }
        cancel() {
          this._finalized || (this._onCancel(), this._finalized = true);
        }
        complete(t22, e22) {
          this._finalized || (this._onComplete(t22, e22), this._finalized = true);
        }
      }
      _g.performDecoding = function(t22, e22) {
        const r22 = new Uint8Array(t22);
        return Promise.all(e22.tasks.map((t3) => {
          const { layerName: e3, firstByte: n22, lastByte: i2, pixelFormat: s2, blockShape: a2, blockIndex: o2, filters: l22, codec: u22 } = t3, c22 = r22.subarray(n22, i2 + 1), h22 = new Uint32Array(a2[0] * a2[1] * a2[2]);
          let p22;
          if ("gzip_data" !== u22)
            throw new gg2("Unhandled codec: ".concat(u22));
          return p22 = function(t4, e4) {
            if (!globalThis.DecompressionStream && "gzip_data" === e4)
              return Promise.resolve(((s3 = function(t5) {
                31 == t5[0] && 139 == t5[1] && 8 == t5[2] || fg2(6, "invalid gzip data");
                var e5 = t5[3], r4 = 10;
                4 & e5 && (r4 += 2 + (t5[10] | t5[11] << 8));
                for (var n4 = (e5 >> 3 & 1) + (e5 >> 4 & 1); n4 > 0; n4 -= !t5[r4++])
                  ;
                return r4 + (2 & e5);
              }(i3 = t4)) + 8 > i3.length && fg2(6, "invalid gzip data"), function(t5, e5, r4, n4) {
                var i4 = t5.length;
                if (!i4 || e5.f && !e5.l)
                  return r4 || new $y(0);
                var s4 = !r4, a4 = s4 || 2 != e5.i, o4 = e5.i;
                s4 && (r4 = new $y(3 * i4));
                var l3, u3, c3 = function(t6) {
                  var e6 = r4.length;
                  if (t6 > e6) {
                    var n5 = new $y(Math.max(2 * e6, t6));
                    n5.set(r4), r4 = n5;
                  }
                }, h3 = e5.f || 0, p3 = e5.p || 0, f22 = e5.b || 0, d22 = e5.l, m22 = e5.d, y22 = e5.m, g22 = e5.n, x22 = 8 * i4;
                do {
                  if (!d22) {
                    h3 = cg2(t5, p3, 1);
                    var b22 = cg2(t5, p3 + 1, 3);
                    if (p3 += 3, !b22) {
                      var v22 = t5[(E22 = 4 + ((p3 + 7) / 8 | 0)) - 4] | t5[E22 - 3] << 8, w22 = E22 + v22;
                      if (w22 > i4) {
                        o4 && fg2(0);
                        break;
                      }
                      a4 && c3(f22 + v22), r4.set(t5.subarray(E22, w22), f22), e5.b = f22 += v22, e5.p = p3 = 8 * w22, e5.f = h3;
                      continue;
                    }
                    if (1 == b22)
                      d22 = og2, m22 = lg2, y22 = 9, g22 = 5;
                    else if (2 == b22) {
                      var _2 = cg2(t5, p3, 31) + 257, M22 = cg2(t5, p3 + 10, 15) + 4, A22 = _2 + cg2(t5, p3 + 5, 31) + 1;
                      p3 += 14;
                      for (var S22 = new $y(A22), I22 = new $y(19), P22 = 0; P22 < M22; ++P22)
                        I22[Wy[P22]] = cg2(t5, p3 + 3 * P22, 7);
                      p3 += 3 * M22;
                      var z22 = ug2(I22), k22 = (1 << z22) - 1, T22 = ig2(I22, z22);
                      for (P22 = 0; P22 < A22; ) {
                        var E22, B22 = T22[cg2(t5, p3, k22)];
                        if (p3 += 15 & B22, (E22 = B22 >> 4) < 16)
                          S22[P22++] = E22;
                        else {
                          var V22 = 0, C22 = 0;
                          for (16 == E22 ? (C22 = 3 + cg2(t5, p3, 3), p3 += 2, V22 = S22[P22 - 1]) : 17 == E22 ? (C22 = 3 + cg2(t5, p3, 7), p3 += 3) : 18 == E22 && (C22 = 11 + cg2(t5, p3, 127), p3 += 7); C22--; )
                            S22[P22++] = V22;
                        }
                      }
                      var R22 = S22.subarray(0, _2), D22 = S22.subarray(_2);
                      y22 = ug2(R22), g22 = ug2(D22), d22 = ig2(R22, y22), m22 = ig2(D22, g22);
                    } else
                      fg2(1);
                    if (p3 > x22) {
                      o4 && fg2(0);
                      break;
                    }
                  }
                  a4 && c3(f22 + 131072);
                  for (var L22 = (1 << y22) - 1, F22 = (1 << g22) - 1, O22 = p3; ; O22 = p3) {
                    var U22 = (V22 = d22[hg2(t5, p3) & L22]) >> 4;
                    if ((p3 += 15 & V22) > x22) {
                      o4 && fg2(0);
                      break;
                    }
                    if (V22 || fg2(2), U22 < 256)
                      r4[f22++] = U22;
                    else {
                      if (256 == U22) {
                        O22 = p3, d22 = null;
                        break;
                      }
                      var j2 = U22 - 254;
                      U22 > 264 && (j2 = cg2(t5, p3, (1 << ($2 = Yy[P22 = U22 - 257])) - 1) + Jy[P22], p3 += $2);
                      var N22 = m22[hg2(t5, p3) & F22], q22 = N22 >> 4;
                      if (N22 || fg2(3), p3 += 15 & N22, D22 = tg2[q22], q22 > 3) {
                        var $2 = Zy[q22];
                        D22 += hg2(t5, p3) & (1 << $2) - 1, p3 += $2;
                      }
                      if (p3 > x22) {
                        o4 && fg2(0);
                        break;
                      }
                      a4 && c3(f22 + 131072);
                      var G22 = f22 + j2;
                      if (f22 < D22) {
                        var X22 = 0 - D22, Y22 = Math.min(D22, G22);
                        for (X22 + f22 < 0 && fg2(3); f22 < Y22; ++f22)
                          r4[f22] = (void 0)[X22 + f22];
                      }
                      for (; f22 < G22; ++f22)
                        r4[f22] = r4[f22 - D22];
                    }
                  }
                  e5.l = d22, e5.p = O22, e5.b = f22, e5.f = h3, d22 && (h3 = 1, e5.m = y22, e5.d = m22, e5.n = g22);
                } while (!h3);
                return f22 != r4.length && s4 ? (l3 = r4, (null == (u3 = f22) || u3 > l3.length) && (u3 = l3.length), new $y(l3.subarray(0, u3))) : r4.subarray(0, f22);
              }(i3.subarray(s3, -8), { i: 2 }, new $y(((r3 = i3)[(n3 = r3.length) - 4] | r3[n3 - 3] << 8 | r3[n3 - 2] << 16 | r3[n3 - 1] << 24) >>> 0))));
            var r3, n3, i3, s3;
            const a3 = yg2[e4];
            if (!a3)
              throw new Error("Unhandled codec: ".concat(e4));
            const o3 = new globalThis.DecompressionStream(a3);
            return new Response(new Blob([t4]).stream().pipeThrough(o3)).arrayBuffer().then((t5) => new Uint8Array(t5));
          }(c22, u22).then((t4) => (function(t5, e4) {
            t5.readFields(Fy, e4);
          }(new wg2(t4), h22), new vg2[s2](h22.buffer))), p22.then((t4) => {
            for (let e4 = l22.length - 1; e4 >= 0; e4--)
              switch (l22[e4]) {
                case "delta_filter":
                  jy(t4, a2);
                  break;
                case "zigzag_filter":
                  Ny(t4);
                  break;
                case "bitshuffle_filter":
                  qy(t4, s2);
                  break;
                default:
                  throw new gg2('Unhandled filter "'.concat(l22[e4], '"'));
              }
            return { layerName: e3, blockIndex: o2, data: t4 };
          }).catch((t4) => {
            throw t4;
          });
        }));
      }, os(Ag2, "MRTDecodingBatch", { omit: ["_onCancel", "_onComplete"] });
      var Sg2 = { workerUrl: "", workerClass: null, workerParams: void 0 };
      const Ig2 = "mapboxgl_preloaded_worker_pool";
      class Pg2 {
        constructor() {
          this.active = {};
        }
        acquire(t22) {
          if (!this.workers)
            for (this.workers = []; this.workers.length < Pg2.workerCount; )
              this.workers.push(null != Sg2.workerClass ? new Sg2.workerClass() : new self.Worker(Sg2.workerUrl, Sg2.workerParams));
          return this.active[t22] = true, this.workers.slice();
        }
        release(t22) {
          delete this.active[t22], this.workers && 0 === this.numActive() && (this.workers.forEach((t3) => {
            t3.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[Ig2];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      let zg2;
      function kg2() {
        return zg2 || (zg2 = new Pg2()), zg2;
      }
      Pg2.workerCount = 2;
      let Tg2, Eg2, Bg2, Vg2, Cg2, Rg2 = null;
      function Dg2() {
        return gt() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : Eg2 || It.DRACO_URL;
      }
      function Lg2() {
        if (gt() && self.worker && self.worker.meshoptUrl)
          return self.worker.meshoptUrl;
        if (Vg2)
          return Vg2;
        const t22 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
        if ("object" != typeof WebAssembly)
          throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
        return Vg2 = WebAssembly.validate(t22) ? It.MESHOPT_SIMD_URL : It.MESHOPT_URL, Vg2;
      }
      const Fg2 = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, Og2 = { 5120: "DT_INT8", 5121: "DT_UINT8", 5122: "DT_INT16", 5123: "DT_UINT16", 5125: "DT_UINT32", 5126: "DT_FLOAT32" }, Ug2 = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
      function jg2(t22, e22, r22) {
        const n22 = r22.json.bufferViews.length, i2 = r22.buffers.length;
        e22.bufferView = n22, r22.json.bufferViews[n22] = { buffer: i2, byteLength: t22.byteLength }, r22.buffers[i2] = t22;
      }
      const Ng2 = "KHR_draco_mesh_compression";
      function qg2(t22, e22) {
        const r22 = t22.extensions && t22.extensions[Ng2];
        if (!r22)
          return;
        const n22 = new Bg2.Decoder(), i2 = Hg2(e22, r22.bufferView), s2 = new Bg2.Mesh();
        if (!n22.DecodeArrayToMesh(i2, i2.byteLength, s2))
          throw new Error("Failed to decode Draco mesh");
        const a2 = e22.json.accessors[t22.indices], o2 = Fg2[a2.componentType], l22 = a2.count * o2.BYTES_PER_ELEMENT, u22 = Bg2._malloc(l22);
        o2 === Uint16Array ? n22.GetTrianglesUInt16Array(s2, l22, u22) : n22.GetTrianglesUInt32Array(s2, l22, u22), jg2(Bg2.memory.buffer.slice(u22, u22 + l22), a2, e22), Bg2._free(u22);
        for (const i3 of Object.keys(r22.attributes)) {
          const a3 = n22.GetAttributeByUniqueId(s2, r22.attributes[i3]), o3 = e22.json.accessors[t22.attributes[i3]], l3 = Og2[o3.componentType], u3 = o3.count * Ug2[o3.type] * Fg2[o3.componentType].BYTES_PER_ELEMENT, c22 = Bg2._malloc(u3);
          n22.GetAttributeDataArrayForAllPoints(s2, a3, Bg2[l3], u3, c22), jg2(Bg2.memory.buffer.slice(c22, c22 + u3), o3, e22), Bg2._free(c22);
        }
        n22.destroy(), s2.destroy(), delete t22.extensions[Ng2];
      }
      const $g2 = "EXT_meshopt_compression";
      function Gg2(t22, e22) {
        if (!t22.extensions || !t22.extensions[$g2])
          return;
        const r22 = t22.extensions[$g2], n22 = new Uint8Array(e22.buffers[r22.buffer], r22.byteOffset || 0, r22.byteLength || 0), i2 = new Uint8Array(r22.count * r22.byteStride);
        Cg2.decodeGltfBuffer(i2, r22.count, r22.byteStride, n22, r22.mode, r22.filter), t22.buffer = e22.buffers.length, t22.byteOffset = 0, e22.buffers[t22.buffer] = i2.buffer, delete t22.extensions[$g2];
      }
      const Xg2 = 1179937895, Yg2 = new TextDecoder("utf8");
      function Zg2(t22, e22) {
        return new URL(t22, e22).href;
      }
      function Wg2(t22, e22, r22, n22) {
        return fetch(Zg2(t22.uri, n22)).then((t3) => t3.arrayBuffer()).then((t3) => {
          e22.buffers[r22] = t3;
        });
      }
      function Hg2(t22, e22) {
        const r22 = t22.json.bufferViews[e22];
        return new Uint8Array(t22.buffers[r22.buffer], r22.byteOffset || 0, r22.byteLength);
      }
      function Kg2(t22, e22, r22, n22) {
        if (t22.uri) {
          const i2 = Zg2(t22.uri, n22);
          return fetch(i2).then((t3) => t3.blob()).then((t3) => createImageBitmap(t3)).then((t3) => {
            e22.images[r22] = t3;
          });
        }
        if (void 0 !== t22.bufferView) {
          const n3 = Hg2(e22, t22.bufferView), i2 = new Blob([n3], { type: t22.mimeType });
          return createImageBitmap(i2).then((t3) => {
            e22.images[r22] = t3;
          });
        }
      }
      function Jg2(t22, e22 = 0, r22) {
        const n22 = { json: null, images: [], buffers: [] };
        if (new Uint32Array(t22, e22, 1)[0] === Xg2) {
          const r3 = new Uint32Array(t22, e22);
          let i3 = 2;
          const s3 = (r3[i3++] >> 2) - 3, a3 = r3[i3++] >> 2;
          if (i3++, n22.json = JSON.parse(Yg2.decode(r3.subarray(i3, i3 + a3))), i3 += a3, i3 < s3) {
            const s4 = r3[i3++];
            i3++;
            const a4 = e22 + (i3 << 2);
            n22.buffers[0] = t22.slice(a4, a4 + s4);
          }
        } else
          n22.json = JSON.parse(Yg2.decode(new Uint8Array(t22, e22)));
        const { buffers: i2, images: s2, meshes: a2, extensionsUsed: o2, bufferViews: l22 } = n22.json;
        let u22 = Promise.resolve();
        if (i2) {
          const t3 = [];
          for (let e3 = 0; e3 < i2.length; e3++) {
            const s3 = i2[e3];
            s3.uri ? t3.push(Wg2(s3, n22, e3, r22)) : n22.buffers[e3] || (n22.buffers[e3] = null);
          }
          u22 = Promise.all(t3);
        }
        return u22.then(() => {
          const t3 = [], e3 = o2 && o2.includes(Ng2), i3 = o2 && o2.includes($g2);
          if (e3 && t3.push(function() {
            if (!Bg2)
              return null != Tg2 ? Tg2 : (Tg2 = function(t4) {
                let e4, r3 = null;
                function n3() {
                  e4 = new Uint8Array(r3.buffer);
                }
                function i4() {
                  throw new Error("Unexpected Draco error.");
                }
                const s3 = { a: { a: i4, d: function(t5, r4, n4) {
                  return e4.copyWithin(t5, r4, r4 + n4);
                }, c: function(t5) {
                  const i5 = e4.length, s4 = Math.max(t5 >>> 0, Math.ceil(1.2 * i5)), a3 = Math.ceil((s4 - i5) / 65536);
                  try {
                    return r3.grow(a3), n3(), true;
                  } catch (t6) {
                    return false;
                  }
                }, b: i4 } };
                return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t4, s3) : t4.then((t5) => t5.arrayBuffer()).then((t5) => WebAssembly.instantiate(t5, s3))).then((t5) => {
                  const { Rb: i5, Qb: s4, P: a3, T: o3, X: l3, Ja: u3, La: c22, Qa: h22, Va: p22, Wa: f22, eb: d22, jb: m22, f: y22, e: g22, yb: x22, zb: b22, Ab: v22, Bb: w22, Db: _2, Gb: M22 } = t5.instance.exports;
                  r3 = g22;
                  const A22 = /* @__PURE__ */ (() => {
                    let t6 = 0, r4 = 0, n4 = 0, a4 = 0;
                    return (o4) => {
                      n4 && (i5(a4), i5(t6), r4 += n4, n4 = t6 = 0), t6 || (r4 += 128, t6 = s4(r4));
                      const l4 = o4.length + 7 & -8;
                      let u4 = t6;
                      l4 >= r4 && (n4 = l4, u4 = a4 = s4(l4));
                      for (let t7 = 0; t7 < o4.length; t7++)
                        e4[u4 + t7] = o4[t7];
                      return u4;
                    };
                  })();
                  return n3(), y22(), { memory: g22, _free: i5, _malloc: s4, Mesh: class {
                    constructor() {
                      this.ptr = a3();
                    }
                    destroy() {
                      o3(this.ptr);
                    }
                  }, Decoder: class {
                    constructor() {
                      this.ptr = u3();
                    }
                    destroy() {
                      m22(this.ptr);
                    }
                    DecodeArrayToMesh(t6, e5, r4) {
                      const n4 = A22(t6), i6 = c22(this.ptr, n4, e5, r4.ptr);
                      return !!l3(i6);
                    }
                    GetAttributeByUniqueId(t6, e5) {
                      return { ptr: h22(this.ptr, t6.ptr, e5) };
                    }
                    GetTrianglesUInt16Array(t6, e5, r4) {
                      p22(this.ptr, t6.ptr, e5, r4);
                    }
                    GetTrianglesUInt32Array(t6, e5, r4) {
                      f22(this.ptr, t6.ptr, e5, r4);
                    }
                    GetAttributeDataArrayForAllPoints(t6, e5, r4, n4, i6) {
                      d22(this.ptr, t6.ptr, e5.ptr, r4, n4, i6);
                    }
                  }, DT_INT8: x22(), DT_UINT8: b22(), DT_INT16: v22(), DT_UINT16: w22(), DT_UINT32: _2(), DT_FLOAT32: M22() };
                });
              }(fetch(Dg2())), Tg2.then((t4) => {
                Bg2 = t4, Tg2 = void 0;
              }));
          }()), i3 && t3.push(function() {
            if (Cg2)
              return;
            const t4 = function(t5) {
              let e4;
              const r3 = WebAssembly.instantiateStreaming(t5, {}).then((t6) => {
                e4 = t6.instance, e4.exports.__wasm_call_ctors();
              }), n3 = { NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, i4 = { ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" };
              return { ready: r3, supported: true, decodeGltfBuffer(t6, r4, s3, a3, o3, l3) {
                !function(t7, e5, r5, n4, i5, s4, a4) {
                  const o4 = t7.exports.sbrk, l4 = n4 + 3 & -4, u3 = o4(l4 * i5), c22 = o4(s4.length), h22 = new Uint8Array(t7.exports.memory.buffer);
                  h22.set(s4, c22);
                  const p22 = e5(u3, n4, i5, c22, s4.length);
                  if (0 === p22 && a4 && a4(u3, l4, i5), r5.set(h22.subarray(u3, u3 + n4 * i5)), o4(u3 - o4(0)), 0 !== p22)
                    throw new Error("Malformed buffer data: ".concat(p22));
                }(e4, e4.exports[i4[o3]], t6, r4, s3, a3, e4.exports[n3[l3]]);
              } };
            }(fetch(Lg2()));
            return t4.ready.then(() => {
              Cg2 = t4;
            });
          }()), s2)
            for (let e4 = 0; e4 < s2.length; e4++)
              t3.push(Kg2(s2[e4], n22, e4, r22));
          return (t3.length ? Promise.all(t3) : Promise.resolve()).then(() => {
            if (e3 && a2)
              for (const { primitives: t4 } of a2)
                for (const e4 of t4)
                  qg2(e4, n22);
            if (i3 && a2 && l22)
              for (const t4 of l22)
                Gg2(t4, n22);
            return n22;
          });
        });
      }
      function Qg2(t22, e22) {
        const r22 = t22.json.bufferViews[e22.bufferView], n22 = Fg2[e22.componentType];
        return new n22(t22.buffers[r22.buffer], (e22.byteOffset || 0) + (r22.byteOffset || 0), e22.count * (r22.byteStride && r22.byteStride !== Ug2[e22.type] * n22.BYTES_PER_ELEMENT ? r22.byteStride / n22.BYTES_PER_ELEMENT : Ug2[e22.type]));
      }
      function tx(t22, e22, r22, n22) {
        const i2 = Fg2[e22.componentType], s2 = function(t3) {
          switch (t3) {
            case Int8Array:
              return 1 / 127;
            case Uint8Array:
              return 1 / 255;
            case Int16Array:
              return 1 / 32767;
            case Uint16Array:
              return 1 / 65535;
            default:
              return 1;
          }
        }(i2), a2 = t22.json.bufferViews[e22.bufferView], o2 = a2.byteStride ? a2.byteStride / i2.BYTES_PER_ELEMENT : Ug2[e22.type], l22 = r22.float32, u22 = l22.length / r22.capacity;
        for (let t3 = 0, r3 = 0; t3 < e22.count * o2; t3 += o2, r3 += u22)
          for (let e3 = 0; e3 < u22; e3++)
            l22[r3 + e3] = n22[t3 + e3] * s2;
        r22._trim();
      }
      function ex(t22, e22, r22) {
        const n22 = t22.indices, i2 = t22.attributes, s2 = {};
        s2.indexArray = new Da2();
        const a2 = e22.json.accessors[n22], o2 = a2.count / 3;
        s2.indexArray.reserve(o2);
        const l22 = Qg2(e22, a2);
        for (let t3 = 0; t3 < o2; t3++)
          s2.indexArray.emplaceBack(l22[3 * t3], l22[3 * t3 + 1], l22[3 * t3 + 2]);
        s2.indexArray._trim(), s2.vertexArray = new Aa2();
        const u22 = e22.json.accessors[i2.POSITION];
        s2.vertexArray.reserve(u22.count);
        const c22 = Qg2(e22, u22);
        for (let t3 = 0; t3 < u22.count; t3++)
          s2.vertexArray.emplaceBack(c22[3 * t3], c22[3 * t3 + 1], c22[3 * t3 + 2]);
        if (s2.vertexArray._trim(), s2.aabb = new yu(u22.min, u22.max), s2.centroid = function(t3, e3) {
          const r3 = [0, 0, 0], n3 = t3.length;
          if (n3 > 0) {
            for (let i3 = 0; i3 < n3; i3++) {
              const n4 = 3 * t3[i3];
              r3[0] += e3[n4], r3[1] += e3[n4 + 1], r3[2] += e3[n4 + 2];
            }
            r3[0] /= n3, r3[1] /= n3, r3[2] /= n3;
          }
          return r3;
        }(l22, c22), void 0 !== i2.COLOR_0) {
          const t3 = e22.json.accessors[i2.COLOR_0], r3 = Ug2[t3.type], n3 = Qg2(e22, t3);
          s2.colorArray = 3 === r3 ? new Aa2() : new Ma2(), s2.colorArray.resize(t3.count), tx(e22, t3, s2.colorArray, n3);
        }
        if (void 0 !== i2.NORMAL) {
          s2.normalArray = new Aa2();
          const t3 = e22.json.accessors[i2.NORMAL];
          s2.normalArray.resize(t3.count);
          const r3 = Qg2(e22, t3);
          tx(e22, t3, s2.normalArray, r3);
        }
        if (void 0 !== i2.TEXCOORD_0 && r22.length > 0) {
          s2.texcoordArray = new $a();
          const t3 = e22.json.accessors[i2.TEXCOORD_0];
          s2.texcoordArray.resize(t3.count);
          const r3 = Qg2(e22, t3);
          tx(e22, t3, s2.texcoordArray, r3);
        }
        if (void 0 !== i2._FEATURE_ID_RGBA4444) {
          const t3 = e22.json.accessors[i2._FEATURE_ID_RGBA4444];
          e22.json.extensionsUsed && e22.json.extensionsUsed.includes("EXT_meshopt_compression") && (s2.featureData = Qg2(e22, t3));
        }
        void 0 !== i2._FEATURE_RGBA4444 && (s2.featureData = new Uint32Array(Qg2(e22, e22.json.accessors[i2._FEATURE_RGBA4444]).buffer));
        const h22 = t22.material;
        return s2.material = function(t3, e3) {
          const { emissiveFactor: r3 = [0, 0, 0], alphaMode: n3 = "OPAQUE", alphaCutoff: i3 = 0.5, normalTexture: s3, occlusionTexture: a3, emissiveTexture: o3, doubleSided: l3 } = t3, { baseColorFactor: u3 = [1, 1, 1, 1], metallicFactor: c3 = 1, roughnessFactor: h3 = 1, baseColorTexture: p22, metallicRoughnessTexture: f22 } = t3.pbrMetallicRoughness || {}, d22 = a3 ? e3[a3.index] : void 0;
          if (a3 && a3.extensions && a3.extensions.KHR_texture_transform && d22) {
            const t4 = a3.extensions.KHR_texture_transform;
            d22.offsetScale = [t4.offset[0], t4.offset[1], t4.scale[0], t4.scale[1]];
          }
          return { pbrMetallicRoughness: { baseColorFactor: new Pe2(...u3), metallicFactor: c3, roughnessFactor: h3, baseColorTexture: p22 ? e3[p22.index] : void 0, metallicRoughnessTexture: f22 ? e3[f22.index] : void 0 }, doubleSided: l3, emissiveFactor: r3, alphaMode: n3, alphaCutoff: i3, normalTexture: s3 ? e3[s3.index] : void 0, occlusionTexture: d22, emissionTexture: o3 ? e3[o3.index] : void 0, defined: void 0 === t3.defined };
        }(void 0 !== h22 ? e22.json.materials[h22] : { defined: false }, r22), s2;
      }
      function rx(t22, e22, r22) {
        const { matrix: n22, rotation: i2, translation: s2, scale: a2, mesh: o2, extras: l22, children: u22 } = t22, c22 = {};
        if (c22.matrix = n22 || O2.mat4.fromRotationTranslationScale([], i2 || [0, 0, 0, 1], s2 || [0, 0, 0], a2 || [1, 1, 1]), void 0 !== o2) {
          c22.meshes = r22[o2];
          const t3 = c22.anchor = [0, 0];
          for (const e3 of c22.meshes) {
            const { min: r3, max: n3 } = e3.aabb;
            t3[0] += r3[0] + n3[0], t3[1] += r3[1] + n3[1];
          }
          t3[0] = Math.floor(t3[0] / c22.meshes.length / 2), t3[1] = Math.floor(t3[1] / c22.meshes.length / 2);
        }
        if (l22 && (l22.id && (c22.id = l22.id), l22.lights && (c22.lights = function(t3) {
          if (!t3.length)
            return [];
          const e3 = function(t4) {
            const e4 = atob(t4), r4 = new Uint8Array(e4.length);
            for (let t5 = 0; t5 < e4.length; t5++)
              r4[t5] = e4.codePointAt(t5);
            return r4;
          }(t3), r3 = [], n3 = e3.length / 24, i3 = new Uint16Array(e3.buffer), s3 = new Float32Array(e3.buffer);
          for (let t4 = 0; t4 < n3; t4++) {
            const e4 = i3[2 * t4 * 6] / 30, n4 = i3[2 * t4 * 6 + 1] / 30, a3 = i3[2 * t4 * 6 + 10] / 100, o3 = s3[6 * t4 + 1], l3 = s3[6 * t4 + 2], u3 = s3[6 * t4 + 3], c3 = s3[6 * t4 + 4], h22 = u3 - o3, p22 = c3 - l3, f22 = Math.hypot(h22, p22);
            r3.push({ pos: [o3 + 0.5 * h22, l3 + 0.5 * p22, n4], normal: [p22 / f22, -h22 / f22, 0], width: f22, height: e4, depth: a3, points: [o3, l3, u3, c3] });
          }
          return r3;
        }(l22.lights))), u22) {
          const t3 = [];
          for (const n3 of u22)
            t3.push(rx(e22.json.nodes[n3], e22, r22));
          c22.children = t3;
        }
        return c22;
      }
      function nx(t22) {
        if (0 === t22.vertices.length || 0 === t22.indices.length)
          return null;
        const e22 = new qc2(t22.vertices, t22.indices, 8, 256), [r22, n22] = [e22.min.clone(), e22.max.clone()];
        return { vertices: t22.vertices, indices: t22.indices, grid: e22, min: r22, max: n22 };
      }
      function ix(t22) {
        if (!t22.extras || !t22.extras.ground)
          return null;
        const e22 = t22.extras.ground;
        if (!e22 || !Array.isArray(e22) || 0 === e22.length)
          return null;
        const r22 = e22[0];
        if (!r22 || !Array.isArray(r22) || 0 === r22.length)
          return null;
        const n22 = [];
        for (const t3 of r22) {
          if (!Array.isArray(t3) || 2 !== t3.length)
            continue;
          const e3 = t3[0], r3 = t3[1];
          "number" == typeof e3 && "number" == typeof r3 && n22.push(new q2(e3, r3));
        }
        if (n22.length < 3)
          return null;
        n22.length > 1 && n22[n22.length - 1].equals(n22[0]) && n22.pop();
        let i2 = 0;
        for (let t3 = 0; t3 < n22.length; t3++) {
          const e3 = n22[t3], r3 = n22[(t3 + 1) % n22.length], s3 = n22[(t3 + 2) % n22.length];
          i2 += (e3.x - r3.x) * (s3.y - r3.y) - (s3.x - r3.x) * (e3.y - r3.y);
        }
        i2 > 0 && n22.reverse();
        const s2 = uc2(n22.flatMap((t3) => [t3.x, t3.y]), []);
        return 0 === s2.length ? null : { vertices: n22, indices: s2 };
      }
      function sx(t22, e22) {
        const r22 = [], n22 = [];
        let i2 = 0;
        const s2 = [];
        for (const a2 of t22) {
          i2 = r22.length;
          const t3 = a2.vertexArray.float32, o2 = a2.indexArray.uint16;
          for (let n3 = 0; n3 < a2.vertexArray.length; n3++)
            s2[0] = t3[3 * n3 + 0], s2[1] = t3[3 * n3 + 1], s2[2] = t3[3 * n3 + 2], O2.vec3.transformMat4(s2, s2, e22), r22.push(new q2(s2[0], s2[1]));
          for (let t4 = 0; t4 < 3 * a2.indexArray.length; t4++)
            n22.push(o2[t4] + i2);
        }
        if (n22.length % 3 != 0)
          return null;
        for (let t3 = 0; t3 < n22.length; t3 += 3) {
          const e3 = r22[n22[t3 + 0]], i3 = r22[n22[t3 + 1]], s3 = r22[n22[t3 + 2]];
          (e3.x - i3.x) * (s3.y - i3.y) - (s3.x - i3.x) * (e3.y - i3.y) > 0 && ([n22[t3 + 1], n22[t3 + 2]] = [n22[t3 + 2], n22[t3 + 1]]);
        }
        return { vertices: r22, indices: n22 };
      }
      function ax(t22) {
        const e22 = function(t3, e3) {
          const r3 = [], n3 = WebGL2RenderingContext;
          if (t3.json.textures)
            for (const i3 of t3.json.textures) {
              const s3 = { magFilter: n3.LINEAR, minFilter: n3.NEAREST, wrapS: n3.REPEAT, wrapT: n3.REPEAT };
              void 0 !== i3.sampler && Object.assign(s3, t3.json.samplers[i3.sampler]), r3.push({ image: e3[i3.source], sampler: s3, uploaded: false });
            }
          return r3;
        }(t22, t22.images), r22 = function(t3, e3) {
          const r3 = [];
          for (const n3 of t3.json.meshes) {
            const i3 = [];
            for (const r4 of n3.primitives)
              i3.push(ex(r4, t3, e3));
            r3.push(i3);
          }
          return r3;
        }(t22, e22), { scenes: n22, scene: i2, nodes: s2 } = t22.json, a2 = n22 ? n22[i2 || 0].nodes : s2, o2 = [];
        for (const e3 of a2)
          o2.push(rx(s2[e3], t22, r22));
        return function(t3, e3, r3) {
          const n3 = {}, i3 = /* @__PURE__ */ new Set();
          for (let s3 = 0; s3 < t3.length; s3++) {
            const t4 = r3[e3[s3]];
            if (!t4.extras)
              continue;
            const a3 = t4.extras["mapbox:footprint:version"], o3 = t4.extras["mapbox:footprint:id"];
            (a3 || o3) && i3.add(s3), "1.0.0" === a3 && o3 && (n3[o3] = s3);
          }
          for (let s3 = 0; s3 < t3.length; s3++) {
            if (i3.has(s3))
              continue;
            const a3 = t3[s3], o3 = r3[e3[s3]];
            if (!o3.extras)
              continue;
            let l22 = null;
            a3.id in n3 && (l22 = sx(t3[n3[a3.id]].meshes, a3.matrix)), l22 || (l22 = ix(o3)), l22 && (a3.footprint = nx(l22));
          }
          if (i3.size > 0) {
            const e4 = Array.from(i3.values()).sort((t4, e5) => t4 - e5);
            for (let r4 = e4.length - 1; r4 >= 0; r4--)
              t3.splice(e4[r4], 1);
          }
        }(o2, a2, t22.json.nodes), o2;
      }
      function ox(t22) {
        t22.heightmap = new Float32Array(4096), t22.heightmap.fill(-1);
        const e22 = t22.vertexArray.float32, r22 = t22.aabb.min[0] - 1, n22 = t22.aabb.min[1] - 1, i2 = Wm / (t22.aabb.max[0] - r22 + 2), s2 = Wm / (t22.aabb.max[1] - n22 + 2);
        for (let a2 = 0; a2 < e22.length; a2 += 3) {
          const o2 = e22[a2 + 2], l22 = (e22[a2 + 0] - r22) * i2 | 0, u22 = (e22[a2 + 1] - n22) * s2 | 0;
          o2 > t22.heightmap[u22 * Wm + l22] && (t22.heightmap[u22 * Wm + l22] = o2);
        }
      }
      function lx(t22, e22) {
        const r22 = {};
        r22.indexArray = new Da2(), r22.indexArray.reserve(4 * t22.length), r22.vertexArray = new Aa2(), r22.vertexArray.reserve(10 * t22.length), r22.colorArray = new Ma2(), r22.vertexArray.reserve(10 * t22.length);
        let n22 = 0;
        for (const i3 of t22) {
          const t3 = Math.min(10, Math.max(4, 1.3 * i3.height)) * e22, s3 = [-i3.normal[1], i3.normal[0], 0], a2 = Math.min(0.29, 0.1 * i3.width / i3.depth), o2 = i3.width - 2 * i3.depth * e22 * (a2 + 0.01), l22 = O2.vec3.scaleAndAdd([], i3.pos, s3, o2 / 2), u22 = O2.vec3.scaleAndAdd([], i3.pos, s3, -o2 / 2), c22 = [l22[0], l22[1], l22[2] + i3.height], h22 = [u22[0], u22[1], u22[2] + i3.height], p22 = O2.vec3.scaleAndAdd([], i3.normal, s3, a2);
          O2.vec3.scale(p22, p22, t3);
          const f22 = O2.vec3.scaleAndAdd([], i3.normal, s3, -a2);
          O2.vec3.scale(f22, f22, t3), O2.vec3.add(p22, l22, p22), O2.vec3.add(f22, u22, f22), l22[2] += 0.1, u22[2] += 0.1, r22.vertexArray.emplaceBack(p22[0], p22[1], p22[2]), r22.vertexArray.emplaceBack(f22[0], f22[1], f22[2]), r22.vertexArray.emplaceBack(l22[0], l22[1], l22[2]), r22.vertexArray.emplaceBack(u22[0], u22[1], u22[2]), r22.vertexArray.emplaceBack(c22[0], c22[1], c22[2]), r22.vertexArray.emplaceBack(h22[0], h22[1], h22[2]), r22.vertexArray.emplaceBack(l22[0], l22[1], l22[2]), r22.vertexArray.emplaceBack(u22[0], u22[1], u22[2]), r22.vertexArray.emplaceBack(p22[0], p22[1], p22[2]), r22.vertexArray.emplaceBack(f22[0], f22[1], f22[2]);
          const d22 = o2 / t3 / 2;
          r22.colorArray.emplaceBack(-d22 - a2, -1, d22, 0.8), r22.colorArray.emplaceBack(d22 + a2, -1, d22, 0.8), r22.colorArray.emplaceBack(-d22, 0, d22, 1.3), r22.colorArray.emplaceBack(d22, 0, d22, 1.3), r22.colorArray.emplaceBack(d22 + a2, -0.8, d22, 0.7), r22.colorArray.emplaceBack(d22 + a2, -0.8, d22, 0.7), r22.colorArray.emplaceBack(0, 0, d22, 1.3), r22.colorArray.emplaceBack(0, 0, d22, 1.3), r22.colorArray.emplaceBack(d22 + a2, -1.2, d22, 0.8), r22.colorArray.emplaceBack(d22 + a2, -1.2, d22, 0.8), r22.indexArray.emplaceBack(6 + n22, 4 + n22, 8 + n22), r22.indexArray.emplaceBack(7 + n22, 9 + n22, 5 + n22), r22.indexArray.emplaceBack(0 + n22, 1 + n22, 2 + n22), r22.indexArray.emplaceBack(1 + n22, 3 + n22, 2 + n22), n22 += 10;
        }
        const i2 = { defined: true, emissiveFactor: [0, 0, 0] }, s2 = {};
        return s2.baseColorFactor = Pe2.white, i2.pbrMetallicRoughness = s2, r22.material = i2, r22.aabb = new yu([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), r22;
      }
      class ux {
        constructor(t22) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let e22 = 0; e22 < t22.length; e22++) {
            const r22 = t22[e22];
            this._stringToNumber[r22] = e22, this._numberToString[e22] = r22;
          }
        }
        encode(t22) {
          return this._stringToNumber[t22];
        }
        decode(t22) {
          return this._numberToString[t22];
        }
      }
      const cx = ["id", "tile", "layer", "source", "sourceLayer", "state"];
      class hx {
        constructor(t22, e22, r22, n22, i2) {
          this.type = "Feature", this._vectorTileFeature = t22, this._z = e22, this._x = r22, this._y = n22, this.properties = t22.properties, this.id = i2;
        }
        get geometry() {
          return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
        }
        set geometry(t22) {
          this._geometry = t22;
        }
        toJSON() {
          const t22 = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
          for (const e22 of cx)
            void 0 !== this[e22] && (t22[e22] = this[e22]);
          return t22;
        }
      }
      class px {
        constructor(t22, e22) {
          this.tileID = t22, this.x = t22.canonical.x, this.y = t22.canonical.y, this.z = t22.canonical.z, this.grid = new ss(Hr, 16, 0), this.featureIndexArray = new io(), this.promoteId = e22, this.is3DTile = false;
        }
        insert(t22, e22, r22, n22, i2, s2 = 0, a2 = 0) {
          const o2 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(r22, n22, i2, s2);
          const l22 = this.grid;
          for (let t3 = 0; t3 < e22.length; t3++) {
            const r3 = e22[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let t4 = 0; t4 < r3.length; t4++) {
              const e3 = r3[t4];
              n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
            }
            0 !== a2 && (n3[0] -= a2, n3[1] -= a2, n3[2] += a2, n3[3] += a2), n3[0] < Hr && n3[1] < Hr && n3[2] >= 0 && n3[3] >= 0 && l22.insert(o2, n3[0], n3[1], n3[2], n3[3]);
          }
        }
        loadVTLayers() {
          if (!this.vtLayers) {
            this.vtLayers = new ch2.VectorTile(new of2(this.rawTileData)).layers, this.sourceLayerCoder = new ux(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
            for (const t22 in this.vtLayers)
              this.vtFeatures[t22] = [];
          }
          return this.vtLayers;
        }
        query(t22, e22, r22, n22) {
          this.loadVTLayers();
          const i2 = t22.params || {}, s2 = Hs(i2.filter), a2 = t22.tileResult, o2 = t22.transform, l22 = a2.bufferedTilespaceBounds, u22 = this.grid.query(l22.min.x, l22.min.y, l22.max.x, l22.max.y, (t3, e3, r3, n3) => jl2(a2.bufferedTilespaceGeometry, t3, e3, r3, n3));
          u22.sort(dx);
          let c22 = null;
          o2.elevation && u22.length > 0 && (c22 = ny.create(o2.elevation, this.tileID));
          const h22 = {};
          let p22;
          for (let l3 = 0; l3 < u22.length; l3++) {
            const f22 = u22[l3];
            if (f22 === p22)
              continue;
            p22 = f22;
            const d22 = this.featureIndexArray.get(f22);
            let m22 = null;
            if (this.is3DTile) {
              const t3 = this.bucketLayerIDs[0][0], r3 = e22[t3];
              if ("model" !== r3.type)
                continue;
              const { queryFeature: n3, intersectionZ: i3 } = r3.queryIntersectsMatchingFeature(a2, d22.featureIndex, s2, o2);
              n3 && this.appendToResult(h22, t3, d22.featureIndex, n3, i3);
            } else
              this.loadMatchingFeature(h22, d22, s2, i2.layers, i2.availableImages, e22, r22, n22, (e3, r3, n3, i3 = 0) => (m22 || (m22 = Il(e3, this.tileID.canonical, t22.tileTransform)), r3.queryIntersectsFeature(a2, e3, n3, m22, this.z, t22.transform, t22.pixelPosMatrix, c22, i3)));
          }
          return h22;
        }
        loadMatchingFeature(t22, e22, r22, n22, i2, s2, a2, o2, l22) {
          const { featureIndex: u22, bucketIndex: c22, sourceLayerIndex: h22, layoutVertexArrayOffset: p22 } = e22, f22 = this.bucketLayerIDs[c22];
          if (n22 && !function(t3, e3) {
            for (let r3 = 0; r3 < t3.length; r3++)
              if (e3.indexOf(t3[r3]) >= 0)
                return true;
            return false;
          }(n22, f22))
            return;
          const d22 = this.sourceLayerCoder.decode(h22), m22 = this.vtLayers[d22].feature(u22);
          if (r22.needGeometry) {
            const t3 = Pl(m22, true);
            if (!r22.filter(new Vs(this.tileID.overscaledZ), t3, this.tileID.canonical))
              return;
          } else if (!r22.filter(new Vs(this.tileID.overscaledZ), m22))
            return;
          const y22 = this.getId(m22, d22);
          for (let e3 = 0; e3 < f22.length; e3++) {
            const r3 = f22[e3];
            if (n22 && n22.indexOf(r3) < 0)
              continue;
            const c3 = s2[r3];
            if (!c3)
              continue;
            let h3 = {};
            void 0 !== y22 && o2 && (h3 = o2.getState(c3.sourceLayer || "_geojsonTileLayer", y22));
            const d3 = !l22 || l22(m22, c3, h3, p22);
            if (!d3)
              continue;
            const g22 = new hx(m22, this.z, this.x, this.y, y22), x22 = nt({}, a2[r3]);
            x22.paint = fx(x22.paint, c3.paint, m22, h3, i2), x22.layout = fx(x22.layout, c3.layout, m22, h3, i2), g22.layer = x22, this.appendToResult(t22, r3, u22, g22, d3);
          }
        }
        appendToResult(t22, e22, r22, n22, i2) {
          let s2 = t22[e22];
          void 0 === s2 && (s2 = t22[e22] = []), s2.push({ featureIndex: r22, feature: n22, intersectionZ: i2 });
        }
        lookupSymbolFeatures(t22, e22, r22, n22, i2, s2, a2, o2) {
          const l22 = {};
          this.loadVTLayers();
          const u22 = Hs(i2);
          for (const i3 of t22)
            this.loadMatchingFeature(l22, { bucketIndex: r22, sourceLayerIndex: n22, featureIndex: i3, layoutVertexArrayOffset: 0 }, u22, s2, a2, o2, e22);
          return l22;
        }
        loadFeature(t22) {
          const { featureIndex: e22, sourceLayerIndex: r22 } = t22;
          this.loadVTLayers();
          const n22 = this.sourceLayerCoder.decode(r22), i2 = this.vtFeatures[n22];
          if (i2[e22])
            return i2[e22];
          const s2 = this.vtLayers[n22].feature(e22);
          return i2[e22] = s2, s2;
        }
        hasLayer(t22) {
          for (const e22 of this.bucketLayerIDs)
            for (const r22 of e22)
              if (t22 === r22)
                return true;
          return false;
        }
        getId(t22, e22) {
          let r22 = t22.id;
          if (this.promoteId) {
            const n22 = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e22];
            null != n22 && (r22 = t22.properties[n22]), "boolean" == typeof r22 && (r22 = Number(r22));
          }
          return r22;
        }
      }
      function fx(t22, e22, r22, n22, i2) {
        return ut(t22, (t3, s2) => {
          const a2 = e22 instanceof js ? e22.get(s2) : null;
          return a2 && a2.evaluate ? a2.evaluate(r22, n22, i2) : a2;
        });
      }
      function dx(t22, e22) {
        return e22 - t22;
      }
      os(px, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
      const mx = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class yx {
        static from(t22) {
          if (!(t22 instanceof ArrayBuffer))
            throw new Error("Data must be an instance of ArrayBuffer.");
          const [e22, r22] = new Uint8Array(t22, 0, 2);
          if (219 !== e22)
            throw new Error("Data does not appear to be in a KDBush format.");
          const n22 = r22 >> 4;
          if (1 !== n22)
            throw new Error("Got v".concat(n22, " data when expected v1."));
          const i2 = mx[15 & r22];
          if (!i2)
            throw new Error("Unrecognized array type.");
          const [s2] = new Uint16Array(t22, 2, 1), [a2] = new Uint32Array(t22, 4, 1);
          return new yx(a2, s2, i2, t22);
        }
        constructor(t22, e22 = 64, r22 = Float64Array, n22) {
          if (isNaN(t22) || t22 < 0)
            throw new Error("Unpexpected numItems value: ".concat(t22, "."));
          this.numItems = +t22, this.nodeSize = Math.min(Math.max(+e22, 2), 65535), this.ArrayType = r22, this.IndexArrayType = t22 < 65536 ? Uint16Array : Uint32Array;
          const i2 = mx.indexOf(this.ArrayType), s2 = 2 * t22 * this.ArrayType.BYTES_PER_ELEMENT, a2 = t22 * this.IndexArrayType.BYTES_PER_ELEMENT, o2 = (8 - a2 % 8) % 8;
          if (i2 < 0)
            throw new Error("Unexpected typed array class: ".concat(r22, "."));
          n22 && n22 instanceof ArrayBuffer ? (this.data = n22, this.ids = new this.IndexArrayType(this.data, 8, t22), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t22), this._pos = 2 * t22, this._finished = true) : (this.data = new ArrayBuffer(8 + s2 + a2 + o2), this.ids = new this.IndexArrayType(this.data, 8, t22), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t22), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i2]), new Uint16Array(this.data, 2, 1)[0] = e22, new Uint32Array(this.data, 4, 1)[0] = t22);
        }
        add(t22, e22) {
          const r22 = this._pos >> 1;
          return this.ids[r22] = r22, this.coords[this._pos++] = t22, this.coords[this._pos++] = e22, r22;
        }
        finish() {
          const t22 = this._pos >> 1;
          if (t22 !== this.numItems)
            throw new Error("Added ".concat(t22, " items when expected ").concat(this.numItems, "."));
          return gx(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
        }
        range(t22, e22, r22, n22) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: i2, coords: s2, nodeSize: a2 } = this, o2 = [0, i2.length - 1, 0], l22 = [];
          for (; o2.length; ) {
            const u22 = o2.pop() || 0, c22 = o2.pop() || 0, h22 = o2.pop() || 0;
            if (c22 - h22 <= a2) {
              for (let a3 = h22; a3 <= c22; a3++) {
                const o3 = s2[2 * a3], u3 = s2[2 * a3 + 1];
                o3 >= t22 && o3 <= r22 && u3 >= e22 && u3 <= n22 && l22.push(i2[a3]);
              }
              continue;
            }
            const p22 = h22 + c22 >> 1, f22 = s2[2 * p22], d22 = s2[2 * p22 + 1];
            f22 >= t22 && f22 <= r22 && d22 >= e22 && d22 <= n22 && l22.push(i2[p22]), (0 === u22 ? t22 <= f22 : e22 <= d22) && (o2.push(h22), o2.push(p22 - 1), o2.push(1 - u22)), (0 === u22 ? r22 >= f22 : n22 >= d22) && (o2.push(p22 + 1), o2.push(c22), o2.push(1 - u22));
          }
          return l22;
        }
        within(t22, e22, r22) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: n22, coords: i2, nodeSize: s2 } = this, a2 = [0, n22.length - 1, 0], o2 = [], l22 = r22 * r22;
          for (; a2.length; ) {
            const u22 = a2.pop() || 0, c22 = a2.pop() || 0, h22 = a2.pop() || 0;
            if (c22 - h22 <= s2) {
              for (let r3 = h22; r3 <= c22; r3++)
                wx(i2[2 * r3], i2[2 * r3 + 1], t22, e22) <= l22 && o2.push(n22[r3]);
              continue;
            }
            const p22 = h22 + c22 >> 1, f22 = i2[2 * p22], d22 = i2[2 * p22 + 1];
            wx(f22, d22, t22, e22) <= l22 && o2.push(n22[p22]), (0 === u22 ? t22 - r22 <= f22 : e22 - r22 <= d22) && (a2.push(h22), a2.push(p22 - 1), a2.push(1 - u22)), (0 === u22 ? t22 + r22 >= f22 : e22 + r22 >= d22) && (a2.push(p22 + 1), a2.push(c22), a2.push(1 - u22));
          }
          return o2;
        }
      }
      function gx(t22, e22, r22, n22, i2, s2) {
        if (i2 - n22 <= r22)
          return;
        const a2 = n22 + i2 >> 1;
        xx(t22, e22, a2, n22, i2, s2), gx(t22, e22, r22, n22, a2 - 1, 1 - s2), gx(t22, e22, r22, a2 + 1, i2, 1 - s2);
      }
      function xx(t22, e22, r22, n22, i2, s2) {
        for (; i2 > n22; ) {
          if (i2 - n22 > 600) {
            const a3 = i2 - n22 + 1, o3 = r22 - n22 + 1, l3 = Math.log(a3), u22 = 0.5 * Math.exp(2 * l3 / 3), c22 = 0.5 * Math.sqrt(l3 * u22 * (a3 - u22) / a3) * (o3 - a3 / 2 < 0 ? -1 : 1);
            xx(t22, e22, r22, Math.max(n22, Math.floor(r22 - o3 * u22 / a3 + c22)), Math.min(i2, Math.floor(r22 + (a3 - o3) * u22 / a3 + c22)), s2);
          }
          const a2 = e22[2 * r22 + s2];
          let o2 = n22, l22 = i2;
          for (bx(t22, e22, n22, r22), e22[2 * i2 + s2] > a2 && bx(t22, e22, n22, i2); o2 < l22; ) {
            for (bx(t22, e22, o2, l22), o2++, l22--; e22[2 * o2 + s2] < a2; )
              o2++;
            for (; e22[2 * l22 + s2] > a2; )
              l22--;
          }
          e22[2 * n22 + s2] === a2 ? bx(t22, e22, n22, l22) : (l22++, bx(t22, e22, l22, i2)), l22 <= r22 && (n22 = l22 + 1), r22 <= l22 && (i2 = l22 - 1);
        }
      }
      function bx(t22, e22, r22, n22) {
        vx(t22, r22, n22), vx(e22, 2 * r22, 2 * n22), vx(e22, 2 * r22 + 1, 2 * n22 + 1);
      }
      function vx(t22, e22, r22) {
        const n22 = t22[e22];
        t22[e22] = t22[r22], t22[r22] = n22;
      }
      function wx(t22, e22, r22, n22) {
        const i2 = t22 - r22, s2 = e22 - n22;
        return i2 * i2 + s2 * s2;
      }
      t2.$ = Ds, t2.A = class extends Nm {
      }, t2.B = hr, t2.C = Be2, t2.D = Ys, t2.E = Me2, t2.F = Oi2, t2.G = Di2, t2.H = Fi2, t2.I = Of2, t2.J = Wi2, t2.K = Zs, t2.L = Qi2, t2.M = Hi2, t2.N = Bn, t2.O = Cn, t2.P = q2, t2.Q = En, t2.R = ee2, t2.S = yr, t2.T = lm, t2.U = Ie2, t2.V = Nm, t2.W = Ws, t2.X = Ui2, t2.Y = Li2, t2.Z = function(t22) {
        const e22 = t22.value;
        let r22 = [];
        if (!e22)
          return r22;
        const n22 = hr(e22);
        return "string" !== n22 ? (r22 = r22.concat([new Nm(t22.key, e22, 'string expected, "'.concat(n22, '" found'))]), r22) : (qm(e22, true) || (r22 = r22.concat([new Nm(t22.key, e22, 'invalid url "'.concat(e22, '"'))])), r22);
      }, t2._ = Xs, t2.a = function(t22) {
        return It.API_CDN_URL_REGEX.test(t22);
      }, t2.a$ = qa2, t2.a0 = Gs, t2.a1 = Ns, t2.a2 = class {
        constructor(t22) {
          this.specification = t22;
        }
        possiblyEvaluate(t22, e22) {
          return yt(t22.expression.evaluate(e22));
        }
        interpolate(t22, e22, r22) {
          return { x: ke2(t22.x, e22.x, r22), y: ke2(t22.y, e22.y, r22), z: ke2(t22.z, e22.z, r22), azimuthal: ke2(t22.azimuthal, e22.azimuthal, r22), polar: ke2(t22.polar, e22.polar, r22) };
        }
      }, t2.a3 = Vs, t2.a4 = Ji2, t2.a5 = xl, t2.a6 = O2, t2.a7 = tt, t2.a8 = js, t2.a9 = Du, t2.aA = ru, t2.aB = mm, t2.aC = wm, t2.aD = fm, t2.aE = function(t22, e22) {
        const r22 = document.createElement("video");
        r22.muted = true, r22.onloadstart = function() {
          e22(null, r22);
        };
        for (let e3 = 0; e3 < t22.length; e3++) {
          const n22 = document.createElement("source");
          ae2(t22[e3]) || (r22.crossOrigin = "Anonymous"), n22.src = t22[e3], r22.appendChild(n22);
        }
        return { cancel: () => {
        } };
      }, t2.aF = um, t2.aG = function(t22) {
        return fetch(t22).then((t3) => t3.arrayBuffer()).then((e22) => Jg2(e22, 0, t22));
      }, t2.aH = ax, t2.aI = class {
        constructor(t22, e22, r22, n22) {
          this.id = t22, this.position = null != e22 ? new rl2(e22[0], e22[1]) : new rl2(0, 0), this.orientation = null != r22 ? r22 : [0, 0, 0], this.nodes = n22, this.uploaded = false, this.aabb = new yu([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];
        }
        _applyTransformations(t22, e22) {
          if (O2.mat4.multiply(t22.matrix, e22, t22.matrix), t22.meshes)
            for (const e3 of t22.meshes) {
              const r22 = yu.applyTransformFast(e3.aabb, t22.matrix);
              this.aabb.encapsulate(r22);
            }
          if (t22.children)
            for (const e3 of t22.children)
              this._applyTransformations(e3, t22.matrix);
        }
        computeBoundsAndApplyParent() {
          const t22 = O2.mat4.identity([]);
          for (const e22 of this.nodes)
            this._applyTransformations(e22, t22);
        }
        computeModelMatrix(t22, e22, r22, n22, i2, s2, a2 = false) {
          Km(this.matrix, this, t22.transform, this.position, e22, r22, n22, i2, s2, a2);
        }
        upload(t22) {
          if (!this.uploaded) {
            for (const e22 of this.nodes)
              ty(e22, t22);
            for (const t3 of this.nodes)
              ey(t3);
            this.uploaded = true;
          }
        }
        destroy() {
          for (const t22 of this.nodes)
            ry(t22);
        }
      }, t2.aJ = ot, t2.aK = yd2, t2.aL = cl2, t2.aM = hl2, t2.aN = va2, t2.aO = Da2, t2.aP = st, t2.aQ = Ha2, t2.aR = Zd2, t2.aS = function() {
        Bs.isLoading() || Bs.isLoaded() || "deferred" !== Ts() || Es();
      }, t2.aT = Hs, t2.aU = Pl, t2.aV = hx, t2.aW = xt, t2.aX = wp, t2.aY = Fc2, t2.aZ = Il, t2.a_ = xa, t2.aa = ke2, t2.ab = Hr, t2.ac = Te2, t2.ad = class {
        constructor(t22) {
          this.specification = t22;
        }
        possiblyEvaluate(t22, e22) {
          return function([t3, e3]) {
            const r22 = yt([1, t3, e3]);
            return { x: r22.x, y: r22.y, z: r22.z };
          }(t22.expression.evaluate(e22));
        }
        interpolate(t22, e22, r22) {
          return { x: ke2(t22.x, e22.x, r22), y: ke2(t22.y, e22.y, r22), z: ke2(t22.z, e22.z, r22) };
        }
      }, t2.ae = function(t22, e22, r22 = 0, n22 = true) {
        const i2 = new q2(r22, r22), s2 = t22.sub(i2), a2 = e22.add(i2), o2 = [s2, new q2(a2.x, s2.y), a2, new q2(s2.x, a2.y)];
        return n22 && o2.push(s2.clone()), o2;
      }, t2.af = function(t22, e22) {
        const r22 = [];
        for (let n22 = 0; n22 < t22.length; n22++) {
          const i2 = et(n22 - 1, -1, t22.length - 1), s2 = et(n22 + 1, -1, t22.length - 1), a2 = t22[n22], o2 = t22[s2], l22 = t22[i2].sub(a2).unit(), u22 = o2.sub(a2).unit(), c22 = u22.angleWithSep(l22.x, l22.y), h22 = l22.add(u22).unit().mult(-1 * e22 / Math.sin(c22 / 2));
          r22.push(a2.add(h22));
        }
        return r22;
      }, t2.ag = gd2, t2.ah = jl2, t2.ai = function(t22, e22, r22 = 0) {
        return O2.vec3.fromValues(((e22.x - r22) * t22.scale - t22.x) * Hr, (e22.y * t22.scale - t22.y) * Hr, pl2(e22.z, e22.y));
      }, t2.aj = uu, t2.ak = Sp, t2.al = function(t22) {
        let e22 = 1 / 0, r22 = 1 / 0, n22 = -1 / 0, i2 = -1 / 0;
        for (const s2 of t22)
          e22 = Math.min(e22, s2.x), r22 = Math.min(r22, s2.y), n22 = Math.max(n22, s2.x), i2 = Math.max(i2, s2.y);
        return { min: new q2(e22, r22), max: new q2(n22, i2) };
      }, t2.am = ol2, t2.an = Ul, t2.ao = vl, t2.ap = Q2, t2.aq = $o, t2.ar = function(t22, e22) {
        const r22 = {};
        for (let n22 = 0; n22 < e22.length; n22++) {
          const i2 = e22[n22];
          i2 in t22 && (r22[i2] = t22[i2]);
        }
        return r22;
      }, t2.as = nl2, t2.at = ll2, t2.au = class {
        constructor(t22) {
          this.entries = {}, this.scheduler = t22;
        }
        request(t22, e22, r22, n22) {
          const i2 = this.entries[t22] = this.entries[t22] || { callbacks: [] };
          if (i2.result) {
            const [t3, r3] = i2.result;
            return this.scheduler ? this.scheduler.add(() => {
              n22(t3, r3);
            }, e22) : n22(t3, r3), () => {
            };
          }
          return i2.callbacks.push(n22), i2.cancel || (i2.cancel = r22((r3, n3) => {
            i2.result = [r3, n3];
            for (const t3 of i2.callbacks)
              this.scheduler ? this.scheduler.add(() => {
                t3(r3, n3);
              }, e22) : t3(r3, n3);
            setTimeout(() => delete this.entries[t22], 3e3);
          })), () => {
            i2.result || (i2.callbacks = i2.callbacks.filter((t3) => t3 !== n22), i2.callbacks.length || (i2.cancel(), delete this.entries[t22]));
          };
        }
      }, t2.av = ua2, t2.aw = function(t22, e22, r22) {
        const n22 = JSON.stringify(t22.request);
        return t22.data && (this.deduped.entries[n22] = { result: [null, t22.data] }), this.deduped.request(n22, { type: "parseTile", isSymbolTile: t22.isSymbolTile, zoom: t22.tileZoom }, (e3) => {
          const n3 = se2(t22.request, (t3, n4, i2, s2) => {
            t3 ? e3(t3) : n4 && e3(null, { vectorTile: r22 ? void 0 : new ch2.VectorTile(new of2(n4)), rawData: n4, cacheControl: i2, expires: s2 });
          });
          return () => {
            n3.cancel(), e3();
          };
        }, e22);
      }, t2.ax = function(t22) {
        Yt++, Yt > jt && (t22.getActor().send("enforceCacheSizeLimit", Ut), Yt = 0);
      }, t2.ay = Rt, t2.az = function(t22) {
        return t22 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t22) / Math.LN2));
      }, t2.b = function(t22) {
        return It.API_FONTS_REGEX.test(t22);
      }, t2.b$ = function(t22) {
        const { x: e22, y: r22 } = t22.point, { lng: n22, lat: i2 } = t22._center;
        return Ru(e22, r22, t22.worldSize, n22, i2);
      }, t2.b0 = lu, t2.b1 = co, t2.b2 = uc2, t2.b3 = sm, t2.b4 = function(t22, e22) {
        const r22 = Du(e22.zoom);
        if (0 === r22)
          return _u(t22);
        const n22 = Iu(t22), i2 = Pu(n22), s2 = ol2(n22.getWest()) * e22.worldSize, a2 = ol2(n22.getEast()) * e22.worldSize, o2 = ll2(n22.getNorth()) * e22.worldSize, l22 = ll2(n22.getSouth()) * e22.worldSize, u22 = [s2, o2, 0], c22 = [a2, o2, 0], h22 = [s2, l22, 0], p22 = [a2, l22, 0], f22 = O2.mat4.invert([], e22.globeMatrix);
        return O2.vec3.transformMat4(u22, u22, f22), O2.vec3.transformMat4(c22, c22, f22), O2.vec3.transformMat4(h22, h22, f22), O2.vec3.transformMat4(p22, p22, f22), i2[0] = Mu(i2[0], h22, r22), i2[1] = Mu(i2[1], p22, r22), i2[2] = Mu(i2[2], c22, r22), i2[3] = Mu(i2[3], u22, r22), yu.fromPoints(i2);
      }, t2.b5 = Eu, t2.b6 = zu, t2.b7 = Mu, t2.b8 = ba, t2.b9 = ou, t2.bA = et, t2.bB = Y2, t2.bC = wt, t2.bD = ul2, t2.bE = function(t22, e22, r22) {
        t22[4 * e22 + 0] = r22[0], t22[4 * e22 + 1] = r22[1], t22[4 * e22 + 2] = r22[2], t22[4 * e22 + 3] = r22[3];
      }, t2.bF = Po, t2.bG = _o, t2.bH = Mo, t2.bI = wo, t2.bJ = vo, t2.bK = rl2, t2.bL = Fd2, t2.bM = eu, t2.bN = mu, t2.bO = Sm, t2.bP = tu, t2.bQ = Su, t2.bR = function(t22, e22, r22, n22, i2, s2, a2, o2, l22) {
        if ("globe" === l22.name)
          return Su(t22, e22, new tu(r22, n22, i2), false);
        const u22 = yd2({ z: r22, x: n22, y: i2 }, l22);
        return new yu([(s2 + u22.x / u22.scale) * e22, e22 * (u22.y / u22.scale), a2], [(s2 + u22.x2 / u22.scale) * e22, e22 * (u22.y2 / u22.scale), o2]);
      }, t2.bS = function(t22, e22, r22) {
        let n22 = 0;
        for (let r3 = 0; r3 < 2; ++r3) {
          const i2 = 0;
          t22[r3] > i2 && (n22 += (t22[r3] - i2) * (t22[r3] - i2)), e22[r3] < i2 && (n22 += (i2 - e22[r3]) * (i2 - e22[r3]));
        }
        return n22;
      }, t2.bT = fl2, t2.bU = Xo, t2.bV = function(t22) {
        const e22 = O2.mat4.identity(new Float64Array(16));
        O2.mat4.multiply(e22, t22.pixelMatrix, t22.globeMatrix);
        const r22 = [0, Ho, 0], n22 = [0, Ko, 0];
        return O2.vec3.transformMat4(r22, r22, e22), O2.vec3.transformMat4(n22, n22, e22), [r22[0] > 0 && r22[0] <= t22.width && r22[1] > 0 && r22[1] <= t22.height && !Fu(t22, new rl2(t22.center.lat, 90)), n22[0] > 0 && n22[0] <= t22.width && n22[1] > 0 && n22[1] <= t22.height && !Fu(t22, new rl2(t22.center.lat, -90))];
      }, t2.bW = function(t22, e22) {
        const { scale: r22 } = t22.tileTransform, n22 = r22 * Hr / (t22.tileSize * Math.pow(2, e22.zoom - t22.tileID.overscaledZ + t22.tileID.canonical.z));
        return O2.mat2.scale(new Float32Array(4), e22.inverseAdjustmentMatrix, [n22, n22]);
      }, t2.bX = Im, t2.bY = Am, t2.bZ = function(t22) {
        const e22 = Am(t22, true);
        return O2.mat2.invert([], [e22[0], e22[1], e22[4], e22[5]]);
      }, t2.b_ = cu, t2.ba = _g, t2.bb = of2, t2.bc = se2, t2.bd = function(t22) {
        const e22 = [];
        for (const r22 in t22)
          e22.push(t22[r22]);
        return e22;
      }, t2.be = function(t22, e22) {
        const r22 = [];
        for (const n22 in t22)
          n22 in e22 || r22.push(n22);
        return r22;
      }, t2.bf = rt, t2.bg = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t2.bh = $, t2.bi = function(t22, e22) {
        const { x: r22, y: n22 } = t22.point, i2 = Ru(r22, n22, t22.worldSize / t22._pixelsPerMercatorPixel, 0, 0);
        return O2.mat4.multiply(i2, i2, Bu(_u(e22)));
      }, t2.bj = Zp, t2.bk = ff2, t2.bl = Yp, t2.bm = function(t22, e22, r22, n22, i2) {
        const s2 = 5 * e22 + 2;
        t22.float32[s2 + 0] = r22, t22.float32[s2 + 1] = n22, t22.float32[s2 + 2] = i2;
      }, t2.bn = $d2, t2.bo = Df2, t2.bp = El, t2.bq = $p, t2.br = gh2, t2.bs = jm, t2.bt = Ih2, t2.bu = Ph2, t2.bv = ad2, t2.bw = sd2, t2.bx = Af2, t2.by = yx, t2.bz = Pe2, t2.c = zt, t2.c$ = iu, t2.c0 = Z2, t2.c1 = nu, t2.c2 = Go, t2.c3 = function(t22) {
        const e22 = Math.round((t22 + 45 + 360) % 360 / 90) % 4;
        return W2[e22];
      }, t2.c4 = 45, t2.c5 = al2, t2.c6 = Ao, t2.c7 = function(t22, e22, r22) {
        const n22 = Math.sqrt(t22 * t22 + e22 * e22 + r22 * r22), i2 = n22 > 0 ? Math.acos(r22 / n22) * X2 : 0;
        let s2 = 0 !== t22 || 0 !== e22 ? Math.atan2(-e22, -t22) * X2 + 90 : 0;
        return s2 < 0 && (s2 += 360), [n22, s2, i2];
      }, t2.c8 = gl2, t2.c9 = yu, t2.cA = function(t22) {
        const e22 = fl2 - 5;
        t22 = Q2(t22, -e22, e22) / e22 * 90;
        const r22 = Math.pow(Math.abs(Math.sin(Y2(t22))), 3);
        return Math.round(r22 * (Wo.length - 1));
      }, t2.cB = function(t22, e22, r22, n22) {
        const i2 = e22.getNorth(), s2 = e22.getSouth(), a2 = e22.getWest(), o2 = e22.getEast(), l22 = 1 << t22.z, u22 = o2 - a2, c22 = i2 - s2, h22 = u22 / Zo, p22 = -c22 / Wo[r22], f22 = [0, h22, 0, p22, 0, 0, i2, a2, 0];
        if (t22.z > 0) {
          const t3 = 180 / n22;
          O2.mat3.multiply(f22, f22, [t3 / u22 + 1, 0, 0, 0, t3 / c22 + 1, 0, -0.5 * t3 / h22, 0.5 * t3 / p22, 1]);
        }
        return f22[2] = l22, f22[5] = t22.x, f22[8] = t22.y, f22;
      }, t2.cC = _u, t2.cD = function(t22, e22, r22) {
        const n22 = O2.mat4.identity(new Float64Array(16)), i2 = (e22 / (1 << t22) - 0.5) * Math.PI * 2;
        return O2.mat4.rotateY(n22, r22.globeMatrix, i2), Float32Array.from(n22);
      }, t2.cE = class {
        isDataAvailableAtPoint(t22) {
          const e22 = this._source();
          if (this.isUsingMockSource() || !e22 || t22.y < 0 || t22.y > 1)
            return false;
          const r22 = e22.getSource().maxzoom, n22 = 1 << r22, i2 = Math.floor(t22.x), s2 = Math.floor((t22.x - i2) * n22), a2 = Math.floor(t22.y * n22), o2 = this.findDEMTileFor(new ru(r22, i2, r22, s2, a2));
          return !(!o2 || !o2.dem);
        }
        getAtPointOrZero(t22, e22 = 0) {
          return this.getAtPoint(t22, e22) || 0;
        }
        getAtPoint(t22, e22, r22 = true) {
          if (this.isUsingMockSource())
            return null;
          null == e22 && (e22 = null);
          const n22 = this._source();
          if (!n22)
            return e22;
          if (t22.y < 0 || t22.y > 1)
            return e22;
          const i2 = n22.getSource().maxzoom, s2 = 1 << i2, a2 = Math.floor(t22.x), o2 = t22.x - a2, l22 = new ru(i2, a2, i2, Math.floor(o2 * s2), Math.floor(t22.y * s2)), u22 = this.findDEMTileFor(l22);
          if (!u22 || !u22.dem)
            return e22;
          const c22 = u22.dem, h22 = 1 << u22.tileID.canonical.z, p22 = (o2 * h22 - u22.tileID.canonical.x) * c22.dim, f22 = (t22.y * h22 - u22.tileID.canonical.y) * c22.dim, d22 = Math.floor(p22), m22 = Math.floor(f22);
          return (r22 ? this.exaggeration() : 1) * ke2(ke2(c22.get(d22, m22), c22.get(d22, m22 + 1), f22 - m22), ke2(c22.get(d22 + 1, m22), c22.get(d22 + 1, m22 + 1), f22 - m22), p22 - d22);
        }
        getAtTileOffset(t22, e22, r22) {
          const n22 = 1 << t22.canonical.z;
          return this.getAtPointOrZero(new xl(t22.wrap + (t22.canonical.x + e22 / Hr) / n22, (t22.canonical.y + r22 / Hr) / n22));
        }
        getAtTileOffsetFunc(t22, e22, r22, n22) {
          return (i2) => {
            const s2 = this.getAtTileOffset(t22, i2.x, i2.y), a2 = n22.upVector(t22.canonical, i2.x, i2.y), o2 = n22.upVectorScale(t22.canonical, e22, r22).metersToTile;
            return O2.vec3.scale(a2, a2, s2 * o2), a2;
          };
        }
        getForTilePoints(t22, e22, r22, n22) {
          if (this.isUsingMockSource())
            return false;
          const i2 = ny.create(this, t22, n22);
          return !!i2 && (e22.forEach((t3) => {
            t3[2] = this.exaggeration() * i2.getElevationAt(t3[0], t3[1], r22);
          }), true);
        }
        getMinMaxForTile(t22) {
          if (this.isUsingMockSource())
            return null;
          const e22 = this.findDEMTileFor(t22);
          if (!e22 || !e22.dem)
            return null;
          const r22 = e22.dem.tree, n22 = e22.tileID, i2 = 1 << t22.canonical.z - n22.canonical.z;
          let s2 = t22.canonical.x / i2 - n22.canonical.x, a2 = t22.canonical.y / i2 - n22.canonical.y, o2 = 0;
          for (let e3 = 0; e3 < t22.canonical.z - n22.canonical.z && !r22.leaves[o2]; e3++) {
            s2 *= 2, a2 *= 2;
            const t3 = 2 * Math.floor(a2) + Math.floor(s2);
            o2 = r22.childOffsets[o2] + t3, s2 %= 1, a2 %= 1;
          }
          return { min: this.exaggeration() * r22.minimums[o2], max: this.exaggeration() * r22.maximums[o2] };
        }
        getMinElevationBelowMSL() {
          throw new Error("Pure virtual method called.");
        }
        raycast(t22, e22, r22) {
          throw new Error("Pure virtual method called.");
        }
        pointCoordinate(t22) {
          throw new Error("Pure virtual method called.");
        }
        _source() {
          throw new Error("Pure virtual method called.");
        }
        isUsingMockSource() {
          throw new Error("Pure virtual method called.");
        }
        exaggeration() {
          throw new Error("Pure virtual method called.");
        }
        findDEMTileFor(t22) {
          throw new Error("Pure virtual method called.");
        }
        get visibleDemTiles() {
          throw new Error("Getter must be implemented in subclass.");
        }
        getMinMaxForVisibleTiles() {
          const t22 = this.visibleDemTiles;
          if (0 === t22.length)
            return null;
          let e22 = false, r22 = Number.MAX_VALUE, n22 = Number.MIN_VALUE;
          for (const i2 of t22) {
            const t3 = this.getMinMaxForTile(i2.tileID);
            t3 && (r22 = Math.min(r22, t3.min), n22 = Math.max(n22, t3.max), e22 = true);
          }
          return e22 ? { min: r22, max: n22 } : null;
        }
      }, t2.cF = sc2, t2.cG = gu, t2.cH = function(t22, e22) {
        return [Math.pow(t22[0], 2.2) * e22, Math.pow(t22[1], 2.2) * e22, Math.pow(t22[2], 2.2) * e22];
      }, t2.cI = Cu, t2.cJ = St, t2.cK = At, t2.cL = 256, t2.cM = function(t22, e22) {
        const r22 = [0, 0, 0], n22 = Eu(_u(e22.canonical));
        return O2.vec3.transformMat4(r22, r22, n22), O2.vec3.transformMat4(r22, r22, t22), r22;
      }, t2.cN = (t22) => ({ u_camera_to_center_distance: new wo(t22), u_extrude_scale: new To(t22), u_device_pixel_ratio: new wo(t22), u_matrix: new Po(t22), u_inv_rot_matrix: new Po(t22), u_merc_center: new _o(t22), u_tile_id: new Mo(t22), u_zoom_transition: new wo(t22), u_up_dir: new Mo(t22), u_emissive_strength: new wo(t22) }), t2.cO = (t22) => ({ u_matrix: new Po(t22), u_pixels_to_tile_units: new To(t22), u_device_pixel_ratio: new wo(t22), u_units_to_pixels: new _o(t22), u_dash_image: new vo(t22), u_gradient_image: new vo(t22), u_image_height: new wo(t22), u_texsize: new _o(t22), u_tile_units_to_pixels: new wo(t22), u_alpha_discard_threshold: new wo(t22), u_trim_offset: new _o(t22), u_trim_fade_range: new _o(t22), u_trim_color: new Ao(t22), u_emissive_strength: new wo(t22) }), t2.cP = (t22) => ({ u_matrix: new Po(t22), u_texsize: new _o(t22), u_pixels_to_tile_units: new To(t22), u_device_pixel_ratio: new wo(t22), u_image: new vo(t22), u_units_to_pixels: new _o(t22), u_tile_units_to_pixels: new wo(t22), u_alpha_discard_threshold: new wo(t22), u_trim_offset: new _o(t22) }), t2.cQ = Ca2, t2.cR = qp, t2.cS = Wp, t2.cT = qu, t2.cU = (t22, e22, r22, n22, i2, s2) => {
        const a2 = t22.transform, o2 = "globe" === a2.projection.name;
        let l22;
        if ("map" === s2.paint.get("circle-pitch-alignment"))
          if (o2) {
            const t3 = Cu(a2.zoom, e22.canonical) * a2._pixelsPerMercatorPixel;
            l22 = Float32Array.from([t3, 0, 0, t3]);
          } else
            l22 = a2.calculatePixelsToTileUnitsMatrix(r22);
        else
          l22 = new Float32Array([a2.pixelsToGLUnits[0], 0, 0, a2.pixelsToGLUnits[1]]);
        const u22 = { u_camera_to_center_distance: t22.transform.getCameraToCenterDistance(a2.projection), u_matrix: t22.translatePosMatrix(e22.projMatrix, r22, s2.paint.get("circle-translate"), s2.paint.get("circle-translate-anchor")), u_device_pixel_ratio: Dt.devicePixelRatio, u_extrude_scale: l22, u_inv_rot_matrix: Nu, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: s2.paint.get("circle-emissive-strength") };
        if (o2) {
          u22.u_inv_rot_matrix = n22, u22.u_merc_center = i2, u22.u_tile_id = [e22.canonical.x, e22.canonical.y, 1 << e22.canonical.z], u22.u_zoom_transition = Du(a2.zoom);
          const t3 = i2[0] * Hr, r3 = i2[1] * Hr;
          u22.u_up_dir = a2.projection.upVector(new tu(0, 0, 0), t3, r3);
        }
        return u22;
      }, t2.cV = zp, t2.cW = (t22, e22, r22, n22, i2, s2) => {
        const a2 = t22.transform;
        return { u_matrix: Pp(t22, e22, r22, n22), u_texsize: e22.imageAtlasTexture ? e22.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: a2.calculatePixelsToTileUnitsMatrix(e22), u_device_pixel_ratio: i2, u_image: 0, u_tile_units_to_pixels: Ip(e22, a2), u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0, u_trim_offset: s2 };
      }, t2.cX = (t22, e22, r22, n22, i2, s2, a2) => {
        const o2 = t22.transform, l22 = o2.calculatePixelsToTileUnitsMatrix(e22);
        return { u_matrix: Pp(t22, e22, r22, n22), u_pixels_to_tile_units: l22, u_device_pixel_ratio: s2, u_units_to_pixels: [1 / o2.pixelsToGLUnits[0], 1 / o2.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: i2, u_texsize: kp(r22) && e22.lineAtlasTexture ? e22.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: Ip(e22, t22.transform), u_alpha_discard_threshold: 0, u_trim_offset: a2, u_trim_fade_range: r22.paint.get("line-trim-fade-range"), u_trim_color: r22.paint.get("line-trim-color").toRenderColor(r22.lut).toArray01(), u_emissive_strength: r22.paint.get("line-emissive-strength") };
      }, t2.cY = at, t2.cZ = ac2, t2.c_ = rp, t2.ca = yt, t2.cb = function(t22) {
        return [Math.pow(t22[0], 1 / 2.2), Math.pow(t22[1], 1 / 2.2), Math.pow(t22[2], 1 / 2.2)];
      }, t2.cc = function(t22) {
        return t22({ pluginStatus: Ss, pluginURL: Is }), ks.on("pluginStateChange", t22), t22;
      }, t2.cd = by, t2.ce = kg2, t2.cf = Xf2, t2.cg = Gf2, t2.ch = ne2, t2.ci = Ps, t2.cj = Ft, t2.ck = xe, t2.cl = ht, t2.cm = function(t22) {
        const e22 = t22.indexOf(la2);
        return e22 >= 0 ? t22.slice(0, e22) : t22;
      }, t2.cn = function(t22) {
        return t22.indexOf(la2) >= 0;
      }, t2.co = function(t22) {
        const e22 = t22.indexOf(la2);
        return e22 >= 0 ? t22.slice(e22 + 1) : "";
      }, t2.cp = function(t22) {
        const e22 = [], r22 = t22.id;
        return void 0 === r22 && e22.push({ message: "layers.".concat(r22, ': missing required property "id"') }), void 0 === t22.render && e22.push({ message: "layers.".concat(r22, ': missing required method "render"') }), t22.renderingMode && "2d" !== t22.renderingMode && "3d" !== t22.renderingMode && e22.push({ message: "layers.".concat(r22, ': property "renderingMode" must be either "2d" or "3d"') }), e22;
      }, t2.cq = function(t22, e22, r22, n22) {
        return "custom" === t22.type ? new _m(t22, e22) : new my[t22.type](t22, e22, r22, n22);
      }, t2.cr = ct, t2.cs = ks, t2.ct = ie2, t2.cu = So, t2.cv = class extends bo {
        constructor(t22) {
          super(t22), this.current = zo;
        }
        set(t22, e22, r22) {
          if (this.fetchUniformLocation(t22, e22)) {
            for (let t3 = 0; t3 < 9; t3++)
              if (r22[t3] !== this.current[t3]) {
                this.current = r22, this.gl.uniformMatrix3fv(this.location, false, r22);
                break;
              }
          }
        }
      }, t2.cw = H2, t2.cx = function(t22, e22, r22) {
        const n22 = Du(r22.zoom), i2 = t22.style.map._antialias, s2 = e22.options.extStandardDerivativesForceOff || t22.terrain && t22.terrain.exaggeration() > 0;
        return 0 === n22 && !i2 && !s2;
      }, t2.cy = function(t22) {
        const e22 = t22.pixelsPerMeter, r22 = e22 / ul2(1, t22.center.lat), n22 = O2.mat4.identity(new Float64Array(16));
        return O2.mat4.translate(n22, n22, [t22.point.x, t22.point.y, 0]), O2.mat4.scale(n22, n22, [r22, r22, e22]), Float32Array.from(n22);
      }, t2.cz = Iu, t2.d = function(t22) {
        return It.API_TILEJSON_REGEX.test(t22);
      }, t2.d$ = e2, t2.d0 = Zh2, t2.d1 = Dh2, t2.d2 = 450, t2.d3 = 7, t2.d4 = dm, t2.d5 = ya2, t2.d6 = Ya2, t2.d7 = 256, t2.d8 = Bu, t2.d9 = Aa2, t2.dA = Lu, t2.dB = function(t22) {
        const e22 = [0, 0, 0], r22 = O2.mat4.identity(new Float64Array(16));
        return O2.mat4.multiply(r22, t22.pixelMatrix, t22.globeMatrix), O2.vec3.transformMat4(e22, e22, r22), new q2(e22[0], e22[1]);
      }, t2.dC = function(t22, e22, r22 = false) {
        if (Ss === ws || Ss === _s || Ss === Ms)
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        Is = Dt.resolveURL(t22), Ss = ws, As = e22, zs(), r22 || Es();
      }, t2.dD = Ts, t2.dE = function() {
        kg2().acquire(Ig2);
      }, t2.dF = function() {
        const t22 = zg2;
        t22 && (t22.isPreloaded() && 1 === t22.numActive() ? (t22.release(Ig2), zg2 = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, t2.dG = Pg2, t2.dH = function(t22) {
        const e22 = Gt();
        if (!e22)
          return;
        const r22 = e22.delete(Ot);
        t22 && r22.catch(t22).then(() => t22());
      }, t2.dI = Sg2, t2.dJ = Dg2, t2.dK = function(t22) {
        Eg2 = Dt.resolveURL(t22), Rg2 || (Rg2 = new by(kg2(), new Me2())), Rg2.broadcast("setDracoUrl", Eg2);
      }, t2.dL = Lg2, t2.dM = function(t22) {
        Vg2 = Dt.resolveURL(t22), Rg2 || (Rg2 = new by(kg2(), new Me2())), Rg2.broadcast("setMeshoptUrl", Vg2);
      }, t2.dN = os, t2.dO = nc2, t2.dP = $f2, t2.dQ = ux, t2.dR = px, t2.dS = gp, t2.dT = ut, t2.dU = Uf2, t2.dV = function(t22, e22, r22, n22, i2, s2, a2, o2, l22, u22, c22) {
        t22.createArrays(), t22.tilePixelRatio = Hr / (512 * t22.overscaling), t22.compareText = {}, t22.iconsNeedLinear = false;
        const h22 = t22.layers[0].layout, p22 = t22.layers[0]._unevaluatedLayout._values, f22 = {};
        if ("composite" === t22.textSizeData.kind) {
          const { minZoom: e3, maxZoom: r3 } = t22.textSizeData;
          f22.compositeTextSizes = [p22["text-size"].possiblyEvaluate(new Vs(e3), o2), p22["text-size"].possiblyEvaluate(new Vs(r3), o2)];
        }
        if ("composite" === t22.iconSizeData.kind) {
          const { minZoom: e3, maxZoom: r3 } = t22.iconSizeData;
          f22.compositeIconSizes = [p22["icon-size"].possiblyEvaluate(new Vs(e3), o2), p22["icon-size"].possiblyEvaluate(new Vs(r3), o2)];
        }
        f22.layoutTextSize = p22["text-size"].possiblyEvaluate(new Vs(l22 + 1), o2), f22.layoutIconSize = p22["icon-size"].possiblyEvaluate(new Vs(l22 + 1), o2), f22.textMaxSize = p22["text-size"].possiblyEvaluate(new Vs(18), o2);
        const d22 = "map" === h22.get("text-rotation-alignment") && "point" !== h22.get("symbol-placement"), m22 = h22.get("text-size");
        let y22 = false;
        for (const e3 of t22.features)
          if (e3.icon && e3.icon.nameSecondary) {
            y22 = true;
            break;
          }
        for (const s3 of t22.features) {
          const l3 = h22.get("text-font").evaluate(s3, {}, o2).join(","), p3 = m22.evaluate(s3, {}, o2), g22 = f22.layoutTextSize.evaluate(s3, {}, o2), x22 = (f22.layoutIconSize.evaluate(s3, {}, o2), { horizontal: {}, vertical: void 0 }), b22 = s3.text;
          let v22, w22 = [0, 0];
          if (b22) {
            const n3 = b22.toString(), a3 = h22.get("text-letter-spacing").evaluate(s3, {}, o2) * $p, u3 = h22.get("text-line-height").evaluate(s3, {}, o2) * $p, c3 = ds(n3) ? a3 : 0, f3 = h22.get("text-anchor").evaluate(s3, {}, o2), m3 = h22.get("text-variable-anchor");
            if (!m3) {
              const t3 = h22.get("text-radial-offset").evaluate(s3, {}, o2);
              w22 = t3 ? sd2(f3, [t3 * $p, nd2]) : h22.get("text-offset").evaluate(s3, {}, o2).map((t4) => t4 * $p);
            }
            let y3 = d22 ? "center" : h22.get("text-justify").evaluate(s3, {}, o2);
            const v3 = "point" === h22.get("symbol-placement"), _3 = v3 ? h22.get("text-max-width").evaluate(s3, {}, o2) * $p : 1 / 0, M3 = (s4) => {
              t22.allowVerticalPlacement && fs(n3) && (x22.vertical = yf2(b22, e22, r22, i2, l3, _3, u3, f3, s4, c3, w22, ff2.vertical, true, g22, p3));
            };
            if (!d22 && m3) {
              const t3 = "auto" === y3 ? m3.map((t4) => ad2(t4)) : [y3];
              let n4 = false;
              for (let s4 = 0; s4 < t3.length; s4++) {
                const a4 = t3[s4];
                if (!x22.horizontal[a4])
                  if (n4)
                    x22.horizontal[a4] = x22.horizontal[0];
                  else {
                    const t4 = yf2(b22, e22, r22, i2, l3, _3, u3, "center", a4, c3, w22, ff2.horizontal, false, g22, p3);
                    t4 && (x22.horizontal[a4] = t4, n4 = 1 === t4.positionedLines.length);
                  }
              }
              M3("left");
            } else {
              if ("auto" === y3 && (y3 = ad2(f3)), v3 || h22.get("text-writing-mode").indexOf("horizontal") >= 0 || !fs(n3)) {
                const t3 = yf2(b22, e22, r22, i2, l3, _3, u3, f3, y3, c3, w22, ff2.horizontal, false, g22, p3);
                t3 && (x22.horizontal[y3] = t3);
              }
              M3(v3 ? "left" : y3);
            }
          }
          let _2 = false;
          if (s3.icon && s3.icon.namePrimary) {
            const e3 = n22[s3.icon.namePrimary];
            e3 && (v22 = If2(i2[s3.icon.namePrimary], s3.icon.nameSecondary ? i2[s3.icon.nameSecondary] : void 0, h22.get("icon-offset").evaluate(s3, {}, o2), h22.get("icon-anchor").evaluate(s3, {}, o2)), _2 = e3.sdf, void 0 === t22.sdfIcons ? t22.sdfIcons = e3.sdf : t22.sdfIcons !== e3.sdf && ft("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e3.pixelRatio !== t22.pixelRatio || 0 !== h22.get("icon-rotate").constantOr(1)) && (t22.iconsNeedLinear = true));
          }
          const M22 = hd2(x22.horizontal) || x22.vertical;
          t22.iconsInText || (t22.iconsInText = !!M22 && M22.iconsInText), (M22 || v22) && od2(t22, s3, x22, v22, n22, f22, g22, 0, w22, _2, a2, o2, u22, c22, y22);
        }
        s2 && t22.generateCollisionDebugBuffers(l22, t22.collisionBoxArray);
      }, t2.dW = ch2, t2.dX = Ey, t2.dY = N2, t2.dZ = uh2, t2.d_ = af2, t2.da = Ua2, t2.db = ja2, t2.dc = function(t22, e22, r22, n22, i2) {
        return Q2((t22 - e22) / (r22 - e22) * (i2 - n22) + n22, n22, i2);
      }, t2.dd = Ii2, t2.de = ml2, t2.df = class {
        constructor(t22, e22, r22, n22) {
          this.context = t22, this.format = n22, this.size = r22, this.texture = t22.gl.createTexture();
          const [i2, s2, a2] = this.size, { gl: o2 } = t22;
          o2.bindTexture(o2.TEXTURE_3D, this.texture), t22.pixelStoreUnpackFlipY.set(false), t22.pixelStoreUnpack.set(1), t22.pixelStoreUnpackPremultiplyAlpha.set(false), o2.texImage3D(o2.TEXTURE_3D, 0, this.format, i2, s2, a2, 0, am(this.format), om(this.format), e22.data);
        }
        bind(t22, e22) {
          const { context: r22 } = this, { gl: n22 } = r22;
          n22.bindTexture(n22.TEXTURE_3D, this.texture), t22 !== this.minFilter && (n22.texParameteri(n22.TEXTURE_3D, n22.TEXTURE_MAG_FILTER, t22), n22.texParameteri(n22.TEXTURE_3D, n22.TEXTURE_MIN_FILTER, t22), this.minFilter = t22), e22 !== this.wrapS && (n22.texParameteri(n22.TEXTURE_3D, n22.TEXTURE_WRAP_S, e22), n22.texParameteri(n22.TEXTURE_3D, n22.TEXTURE_WRAP_T, e22), this.wrapS = e22);
        }
        destroy() {
          const { gl: t22 } = this.context;
          t22.deleteTexture(this.texture), this.texture = null;
        }
      }, t2.dg = Bm, t2.dh = [1, 1, 1], t2.di = ny, t2.dj = Hm, t2.dk = Ea2, t2.dl = class {
        constructor() {
          this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = { min: new q2(1 / 0, 1 / 0), max: new q2(-1 / 0, -1 / 0) };
        }
        clear() {
          this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
        }
        get updateTime() {
          return this._updateTime;
        }
        getReplacementRegionsForTile(t22, e22 = false) {
          const r22 = _h(new q2(0, 0), new q2(Hr, Hr), t22), n22 = [];
          if (e22 && !vh2(r22, this._globalClipBounds))
            return n22;
          for (const e3 of this._activeRegions) {
            if (e3.hiddenByOverlap)
              continue;
            if (!vh2(r22, e3))
              continue;
            const i2 = Mh2(e3.min, e3.max, t22);
            n22.push({ min: i2.min, max: i2.max, sourceId: this._sourceIds[e3.priority], footprint: e3.footprint, footprintTileId: e3.tileId, order: e3.order, clipMask: e3.clipMask, clipScope: e3.clipScope });
          }
          return n22;
        }
        setSources(t22) {
          this._setSources(t22.map((t3) => ({ getSourceId: () => t3.cache.id, getFootprints: () => {
            const e22 = [];
            for (const r22 of t3.cache.getVisibleCoordinates()) {
              const n22 = t3.cache.getTile(r22).buckets[t3.layer];
              n22 && n22.updateFootprints(r22.toUnwrapped(), e22);
            }
            return e22;
          }, getOrder: () => t3.order, getClipMask: () => t3.clipMask, getClipScope: () => t3.clipScope })));
        }
        _addSource(t22) {
          const e22 = t22.getFootprints();
          if (0 === e22.length)
            return;
          const r22 = t22.getOrder(), n22 = t22.getClipMask(), i2 = t22.getClipScope();
          for (const t3 of e22) {
            if (!t3.footprint)
              continue;
            const e3 = _h(t3.footprint.min, t3.footprint.max, t3.id);
            this._activeRegions.push({ min: e3.min, max: e3.max, hiddenByOverlap: false, priority: this._sourceIds.length, tileId: t3.id, footprint: t3.footprint, order: r22, clipMask: n22, clipScope: i2 });
          }
          this._sourceIds.push(t22.getSourceId());
        }
        _computeReplacement() {
          this._activeRegions.sort((t3, e22) => t3.priority - e22.priority || xh2(t3.min, e22.min) || xh2(t3.max, e22.max) || t3.order - e22.order || t3.clipMask - e22.clipMask || function(t4, e3) {
            const r22 = (t5, e4) => t5 + e4;
            return t4.length - e3.length || t4.reduce(r22, "").localeCompare(e3.reduce(r22, ""));
          }(t3.clipScope, e22.clipScope));
          let t22 = this._activeRegions.length !== this._prevRegions.length;
          if (!t22) {
            let e22 = 0;
            for (; !t22 && e22 !== this._activeRegions.length; ) {
              const r22 = this._activeRegions[e22], n22 = this._prevRegions[e22];
              t22 = r22.priority !== n22.priority || !bh2(r22, n22) || r22.order !== n22.order || r22.clipMask !== n22.clipMask || !$(r22.clipScope, n22.clipScope), ++e22;
            }
          }
          if (t22) {
            ++this._updateTime;
            for (const t4 of this._activeRegions)
              t4.order !== yh2 && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, t4.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, t4.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, t4.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, t4.max.y));
            const t3 = (t4) => {
              const e22 = this._activeRegions;
              if (t4 >= e22.length)
                return t4;
              const r22 = e22[t4].priority;
              for (; t4 < e22.length && e22[t4].priority === r22; )
                ++t4;
              return t4;
            };
            if (this._sourceIds.length > 1) {
              let e22 = 0, r22 = t3(e22);
              for (; e22 !== r22; ) {
                let n22 = e22;
                const i2 = e22;
                for (; n22 !== r22; ) {
                  const t4 = this._activeRegions[n22];
                  t4.hiddenByOverlap = false;
                  for (let e3 = 0; e3 < i2; e3++) {
                    const r3 = this._activeRegions[e3];
                    if (!r3.hiddenByOverlap && t4.order === yh2 && vh2(t4, r3) && (t4.hiddenByOverlap = Sh2(t4.footprint, t4.tileId, r3.footprint, r3.tileId), t4.hiddenByOverlap))
                      break;
                  }
                  ++n22;
                }
                e22 = r22, r22 = t3(e22);
              }
            }
          }
        }
        _setSources(t22) {
          [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
          for (let e22 = t22.length - 1; e22 >= 0; e22--)
            this._addSource(t22[e22]);
          this._computeReplacement();
        }
      }, t2.dm = class {
        constructor(t22) {
          this._createGrid(t22), this._createPoles(t22);
        }
        destroy() {
          this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
          for (const t22 of this._poleSegments)
            t22.destroy();
          for (const t22 of this._gridSegments)
            t22.withSkirts.destroy(), t22.withoutSkirts.destroy();
        }
        _fillGridMeshWithLods(t22, e22) {
          const r22 = new xa(), n22 = new Da2(), i2 = [], s2 = t22 + 1 + 2, a2 = e22[0] + 1, o2 = e22[0] + 1 + (1 + e22.length), l22 = (t3, e3, r3) => {
            let n3 = t3 === s2 - 1 ? t3 - 2 : 0 === t3 ? t3 : t3 - 1;
            return n3 += r3 ? 24575 : 0, [n3, e3];
          };
          for (let t3 = 0; t3 < s2; ++t3)
            r22.emplaceBack(...l22(t3, 0, true));
          for (let t3 = 0; t3 < a2; ++t3)
            for (let e3 = 0; e3 < s2; ++e3)
              r22.emplaceBack(...l22(e3, t3, (0 === e3 || e3 === s2 - 1) && true));
          for (let t3 = 0; t3 < e22.length; ++t3) {
            const n3 = e22[t3];
            for (let t4 = 0; t4 < s2; ++t4)
              r22.emplaceBack(...l22(t4, n3, true));
          }
          for (let t3 = 0; t3 < e22.length; ++t3) {
            const a3 = n22.length, l3 = e22[t3] + 1 + 2, u22 = new Da2();
            for (let r3 = 0; r3 < l3 - 1; r3++) {
              const i3 = r3 === l3 - 2, a4 = i3 ? s2 * (o2 - e22.length + t3 - r3) : s2;
              for (let t4 = 0; t4 < s2 - 1; t4++) {
                const e3 = r3 * s2 + t4;
                0 === r3 || i3 || 0 === t4 || t4 === s2 - 2 ? (u22.emplaceBack(e3 + 1, e3, e3 + a4), u22.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1)) : (n22.emplaceBack(e3 + 1, e3, e3 + a4), n22.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1));
              }
            }
            const c22 = co.simpleSegment(0, a3, r22.length, n22.length - a3);
            for (let t4 = 0; t4 < u22.uint16.length; t4 += 3)
              n22.emplaceBack(u22.uint16[t4], u22.uint16[t4 + 1], u22.uint16[t4 + 2]);
            const h22 = co.simpleSegment(0, a3, r22.length, n22.length - a3);
            i2.push({ withoutSkirts: c22, withSkirts: h22 });
          }
          return { vertices: r22, indices: n22, segments: i2 };
        }
        _createGrid(t22) {
          const e22 = this._fillGridMeshWithLods(Zo, Wo);
          this._gridSegments = e22.segments, this._gridBuffer = t22.createVertexBuffer(e22.vertices, lu.members), this._gridIndexBuffer = t22.createIndexBuffer(e22.indices, true);
        }
        _createPoles(t22) {
          const e22 = new Da2();
          for (let t3 = 0; t3 <= Zo; t3++)
            e22.emplaceBack(0, t3 + 1, t3 + 2);
          this._poleIndexBuffer = t22.createIndexBuffer(e22, true);
          const r22 = new Ua2(), n22 = new Ua2(), i2 = new Ua2(), s2 = new Ua2();
          this._poleSegments = [];
          for (let t3 = 0, e3 = 0; t3 < Go; t3++) {
            const a2 = 360 / (1 << t3);
            r22.emplaceBack(0, -$o, 0, 0.5, 0), n22.emplaceBack(0, -$o, 0, 0.5, 1), i2.emplaceBack(0, -$o, 0, 0.5, 0.5), s2.emplaceBack(0, -$o, 0, 0.5, 0.5);
            for (let t4 = 0; t4 <= Zo; t4++) {
              let e4 = t4 / Zo, o2 = 0;
              const l22 = ke2(0, a2, e4), [u22, c22, h22] = Jo(Uu, ju, l22, $o);
              r22.emplaceBack(u22, c22, h22, e4, o2), n22.emplaceBack(u22, c22, h22, e4, 1 - o2);
              const p22 = Y2(l22);
              e4 = 0.5 + 0.5 * Math.sin(p22), o2 = 0.5 + 0.5 * Math.cos(p22), i2.emplaceBack(u22, c22, h22, e4, o2), s2.emplaceBack(u22, c22, h22, e4, 1 - o2);
            }
            this._poleSegments.push(co.simpleSegment(e3, 0, 66, 64)), e3 += 66;
          }
          this._poleNorthVertexBuffer = t22.createVertexBuffer(r22, au, false), this._poleSouthVertexBuffer = t22.createVertexBuffer(n22, au, false), this._texturedPoleNorthVertexBuffer = t22.createVertexBuffer(i2, au, false), this._texturedPoleSouthVertexBuffer = t22.createVertexBuffer(s2, au, false);
        }
        getGridBuffers(t22, e22) {
          return [this._gridBuffer, this._gridIndexBuffer, e22 ? this._gridSegments[t22].withSkirts : this._gridSegments[t22].withoutSkirts];
        }
        getPoleBuffers(t22, e22) {
          return [e22 ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e22 ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t22]];
        }
      }, t2.dn = yh2, t2.dp = K2, t2.dq = function() {
        return !!document.fullscreenElement || !!document.webkitFullscreenElement;
      }, t2.dr = J2, t2.ds = yl, t2.dt = Qo, t2.du = function([t22, e22, r22]) {
        const n22 = Math.hypot(t22, e22, r22), i2 = Math.atan2(t22, r22), s2 = 0.5 * Math.PI - Math.acos(-e22 / n22);
        return new rl2(Z2(i2), Z2(s2));
      }, t2.dv = zm, t2.dw = tl2, t2.dx = function(t22) {
        const e22 = t22.navigator ? t22.navigator.userAgent : null;
        return !!function(t3) {
          if (null == vt) {
            const e3 = t3.navigator ? t3.navigator.userAgent : null;
            vt = !!t3.safari || !(!e3 || !(/\b(iPad|iPhone|iPod)\b/.test(e3) || e3.match("Safari") && !e3.match("Chrome")));
          }
          return vt;
        }(t22) && e22 && (e22.match("Version/15.4") || e22.match("Version/15.5") || e22.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
      }, t2.dy = function(t22, e22) {
        Ut = t22, jt = e22;
      }, t2.dz = Fu, t2.e = It, t2.e0 = function(t22) {
        let e22 = 0;
        if (new Uint32Array(t22, 0, 1)[0] !== Xg2) {
          const r22 = new Uint32Array(t22, 0, 7), [, , n22, i2, s2, a2] = r22;
          e22 = r22.byteLength + i2 + s2 + a2 + s2, (n22 !== t22.byteLength || e22 >= t22.byteLength) && ft("Invalid b3dm header information.");
        }
        return Jg2(t22, e22);
      }, t2.e1 = function(t22, e22) {
        const r22 = ax(t22);
        for (const t3 of r22) {
          for (const e3 of t3.meshes)
            ox(e3);
          t3.lights && (t3.lightMeshIndex = t3.meshes.length, t3.meshes.push(lx(t3.lights, e22)));
        }
        return r22;
      }, t2.e2 = cy, t2.e3 = xy, t2.e4 = Bs, t2.e5 = function(t22) {
        Xt(), null != qt && qt.then((e22) => {
          e22.keys().then((r22) => {
            for (let n22 = 0; n22 < r22.length - t22; n22++)
              e22.delete(r22[n22]);
          });
        });
      }, t2.f = function(t22) {
        return 0 === t22.indexOf("mapbox:");
      }, t2.g = function(t22, e22) {
        return ie2(nt(t22, { method: "GET" }), e22);
      }, t2.h = Pt, t2.i = function(t22) {
        return It.API_STYLE_REGEX.test(t22) && !zt(t22);
      }, t2.j = function(t22) {
        return decodeURIComponent(atob(t22).split("").map((t3) => "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2)).join(""));
      }, t2.k = function(t22) {
        return btoa(encodeURIComponent(t22).replace(/%([0-9A-F]{2})/g, (t3, e22) => String.fromCharCode(Number("0x" + e22))));
      }, t2.l = nt, t2.m = Zt, t2.n = function(t22, e22) {
        return ie2(nt(t22, { type: "json" }), e22);
      }, t2.o = ce2, t2.p = function(t22, e22) {
        return ie2(nt(t22, { method: "POST" }), e22);
      }, t2.q = Dt, t2.r = ic2, t2.s = function(t22) {
        try {
          const e22 = self[t22];
          return e22.setItem("_mapbox_test_", 1), e22.removeItem("_mapbox_test_"), true;
        } catch (t3) {
          return false;
        }
      }, t2.t = ve2, t2.u = function() {
        return function t22(e22) {
          return e22 ? (e22 ^ Math.random() * (16 >> e22 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t22);
        }();
      }, t2.v = function(t22) {
        return !!t22 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t22);
      }, t2.w = ft, t2.x = be2, t2.y = 2, t2.z = Lf2;
    });
    define2(["./shared"], function(e2) {
      function t2(e22) {
        const t22 = e22 ? e22.url.toString() : void 0;
        return t22 ? performance.getEntriesByName(t22) : [];
      }
      function o(e22) {
        if ("number" == typeof e22 || "boolean" == typeof e22 || "string" == typeof e22 || null == e22)
          return JSON.stringify(e22);
        if (Array.isArray(e22)) {
          let t3 = "[";
          for (const s2 of e22)
            t3 += "".concat(o(s2), ",");
          return "".concat(t3, "]");
        }
        let t22 = "{";
        for (const s2 of Object.keys(e22).sort())
          t22 += "".concat(s2, ":").concat(o(e22[s2]), ",");
        return "".concat(t22, "}");
      }
      function s(t22) {
        let s2 = "";
        for (const i2 of e2.bg)
          s2 += "/".concat(o(t22[i2]));
        return s2;
      }
      class i {
        constructor(e22) {
          this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e22 && this.replace(e22);
        }
        replace(e22, t22) {
          this._layerConfigs = {}, this._layers = {}, this.update(e22, [], t22);
        }
        update(t22, o2, i2) {
          this._options = i2;
          for (const o3 of t22)
            this._layerConfigs[o3.id] = o3, (this._layers[o3.id] = e2.cq(o3, this.scope, null, this._options)).compileFilter(i2), this.keyCache[o3.id] && delete this.keyCache[o3.id];
          for (const e22 of o2)
            delete this.keyCache[e22], delete this._layerConfigs[e22], delete this._layers[e22];
          this.familiesBySource = {};
          const n22 = function(e22, t3) {
            const o3 = {};
            for (let i4 = 0; i4 < e22.length; i4++) {
              const n3 = t3 && t3[e22[i4].id] || s(e22[i4]);
              t3 && (t3[e22[i4].id] = n3);
              let r22 = o3[n3];
              r22 || (r22 = o3[n3] = []), r22.push(e22[i4]);
            }
            const i3 = [];
            for (const e3 in o3)
              i3.push(o3[e3]);
            return i3;
          }(e2.bd(this._layerConfigs), this.keyCache);
          for (const e22 of n22) {
            const t3 = e22.map((e3) => this._layers[e3.id]), o3 = t3[0];
            if ("none" === o3.visibility)
              continue;
            const s2 = o3.source || "";
            let i3 = this.familiesBySource[s2];
            i3 || (i3 = this.familiesBySource[s2] = {});
            const n3 = o3.sourceLayer || "_geojsonTileLayer";
            let r22 = i3[n3];
            r22 || (r22 = i3[n3] = []), r22.push(t3);
          }
        }
      }
      const n2 = 1 * e2.dP;
      class r2 {
        constructor(t22) {
          const o2 = {}, s2 = [];
          for (const e22 in t22) {
            const i3 = t22[e22], r3 = o2[e22] = {};
            for (const e3 in i3.glyphs) {
              const t3 = i3.glyphs[+e3];
              if (!t3 || 0 === t3.bitmap.width || 0 === t3.bitmap.height)
                continue;
              const o3 = t3.metrics.localGlyph ? n2 : 1, a3 = { x: 0, y: 0, w: t3.bitmap.width + 2 * o3, h: t3.bitmap.height + 2 * o3 };
              s2.push(a3), r3[e3] = a3;
            }
          }
          const { w: i2, h: r22 } = e2.z(s2), a2 = new e2.dO({ width: i2 || 1, height: r22 || 1 });
          for (const s3 in t22) {
            const i3 = t22[s3];
            for (const t3 in i3.glyphs) {
              const r3 = i3.glyphs[+t3];
              if (!r3 || 0 === r3.bitmap.width || 0 === r3.bitmap.height)
                continue;
              const l22 = o2[s3][t3], c22 = r3.metrics.localGlyph ? n2 : 1;
              e2.dO.copy(r3.bitmap, a2, { x: 0, y: 0 }, { x: l22.x + c22, y: l22.y + c22 }, r3.bitmap);
            }
          }
          this.image = a2, this.positions = o2;
        }
      }
      e2.dN(r2, "GlyphAtlas");
      class a {
        constructor(t22) {
          this.tileID = new e2.aA(t22.tileID.overscaledZ, t22.tileID.wrap, t22.tileID.canonical.z, t22.tileID.canonical.x, t22.tileID.canonical.y), this.tileZoom = t22.tileZoom, this.uid = t22.uid, this.zoom = t22.zoom, this.lut = t22.lut, this.canonical = t22.tileID.canonical, this.pixelRatio = t22.pixelRatio, this.tileSize = t22.tileSize, this.source = t22.source, this.scope = t22.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t22.showCollisionBoxes, this.collectResourceTiming = !!t22.collectResourceTiming, this.promoteId = t22.promoteId, this.isSymbolTile = t22.isSymbolTile, this.tileTransform = e2.aK(t22.tileID.canonical, t22.projection), this.projection = t22.projection, this.brightness = t22.brightness, this.extraShadowCaster = !!t22.extraShadowCaster, this.tessellationStep = t22.tessellationStep;
        }
        parse(t22, o2, s2, i2, n22) {
          this.status = "parsing", this.data = t22, this.collisionBoxArray = new e2.aQ();
          const a2 = new e2.dQ(Object.keys(t22.layers).sort()), c22 = new e2.dR(this.tileID, this.promoteId);
          c22.bucketLayerIDs = [];
          const h22 = {}, u22 = new e2.dS(256, 256), d22 = { featureIndex: c22, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: u22, availableImages: s2, brightness: this.brightness }, f22 = o2.familiesBySource[this.source];
          for (const o3 in f22) {
            const i3 = t22.layers[o3];
            if (!i3)
              continue;
            let n3 = false, r22 = false, u3 = false;
            for (const e22 of f22[o3])
              "symbol" === e22[0].type ? n3 = true : r22 = true, e22[0].is3D() && "model" !== e22[0].type && (u3 = true);
            if (this.extraShadowCaster && !u3)
              continue;
            if (true === this.isSymbolTile && !n3)
              continue;
            if (false === this.isSymbolTile && !r22)
              continue;
            1 === i3.version && e2.w('Vector tile source "'.concat(this.source, '" layer "').concat(o3, '" does not use vector tile spec v2 and therefore may have some rendering errors.'));
            const p3 = a2.encode(o3), g3 = [];
            for (let e22 = 0; e22 < i3.length; e22++) {
              const t3 = i3.feature(e22), s3 = c22.getId(t3, o3);
              g3.push({ feature: t3, id: s3, index: e22, sourceLayerIndex: p3 });
            }
            for (const e22 of f22[o3]) {
              const t3 = e22[0];
              (!this.extraShadowCaster || t3.is3D() && "model" !== t3.type) && (void 0 !== this.isSymbolTile && "symbol" === t3.type !== this.isSymbolTile || t3.minzoom && this.zoom < Math.floor(t3.minzoom) || t3.maxzoom && this.zoom >= t3.maxzoom || "none" !== t3.visibility && (l2(e22, this.zoom, d22.brightness, s2), (h22[t3.id] = t3.createBucket({ index: c22.bucketLayerIDs.length, layers: e22, zoom: this.zoom, lut: this.lut, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: p3, sourceID: this.source, projection: this.projection.spec, tessellationStep: this.tessellationStep })).populate(g3, d22, this.tileID.canonical, this.tileTransform), c22.bucketLayerIDs.push(e22.map((e3) => e3.id))));
            }
          }
          let p22, g22, m22, y22;
          u22.trim();
          const x22 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, w22 = () => {
            if (p22)
              return this.status = "done", n22(p22);
            if (this.extraShadowCaster)
              this.status = "done", n22(null, { buckets: e2.bd(h22).filter((e22) => !e22.isEmpty()), featureIndex: c22, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: d22.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
            else if (g22 && m22 && y22) {
              const t3 = new r2(g22), o3 = new e2.dU(m22, y22, this.lut);
              for (const i3 in h22) {
                const n3 = h22[i3];
                n3 instanceof e2.aR ? (l2(n3.layers, this.zoom, d22.brightness, s2), e2.dV(n3, g22, t3.positions, m22, o3.iconPositions, this.showCollisionBoxes, s2, this.tileID.canonical, this.tileZoom, this.projection, this.brightness)) : n3.hasPattern && (n3 instanceof e2.aX || n3 instanceof e2.aY || n3 instanceof e2.d0) && (l2(n3.layers, this.zoom, d22.brightness, s2), n3.addFeatures(d22, this.tileID.canonical, o3.patternPositions, s2, this.tileTransform, this.brightness));
              }
              this.status = "done", n22(null, { buckets: e2.bd(h22).filter((e22) => !e22.isEmpty()), featureIndex: c22, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, lineAtlas: u22, imageAtlas: o3, brightness: d22.brightness });
            }
          };
          if (!this.extraShadowCaster) {
            const t3 = e2.dT(d22.glyphDependencies, (e22) => Object.keys(e22).map(Number));
            Object.keys(t3).length ? i2.send("getGlyphs", { uid: this.uid, stacks: t3, scope: this.scope }, (e22, t4) => {
              p22 || (p22 = e22, g22 = t4, w22());
            }, void 0, false, x22) : g22 = {};
            const o3 = Object.keys(d22.iconDependencies);
            o3.length ? i2.send("getImages", { icons: o3, source: this.source, scope: this.scope, tileID: this.tileID, type: "icons" }, (e22, t4) => {
              p22 || (p22 = e22, m22 = t4, w22());
            }, void 0, false, x22) : m22 = {};
            const s3 = Object.keys(d22.patternDependencies);
            s3.length ? i2.send("getImages", { icons: s3, source: this.source, scope: this.scope, tileID: this.tileID, type: "patterns" }, (e22, t4) => {
              p22 || (p22 = e22, y22 = t4, w22());
            }, void 0, false, x22) : y22 = {};
          }
          w22();
        }
      }
      function l2(t22, o2, s2, i2) {
        const n22 = new e2.a3(o2, { brightness: s2 });
        for (const e22 of t22)
          e22.recalculate(n22, i2);
      }
      class c2 extends e2.E {
        constructor(t22, o2, s2, i2, n22, r22) {
          super(), this.actor = t22, this.layerIndex = o2, this.availableImages = s2, this.loadVectorData = n22 || e2.aw, this.loading = {}, this.loaded = {}, this.deduped = new e2.au(t22.scheduler), this.isSpriteLoaded = i2, this.scheduler = t22.scheduler, this.brightness = r22;
        }
        loadTile(o2, s2) {
          const i2 = o2.uid, n22 = o2 && o2.request, r22 = n22 && n22.collectResourceTiming, l22 = this.loading[i2] = new a(o2);
          l22.abort = this.loadVectorData(o2, (a2, c22) => {
            const h22 = !this.loading[i2];
            if (delete this.loading[i2], h22 || a2 || !c22)
              return l22.status = "done", h22 || (this.loaded[i2] = l22), s2(a2);
            const u22 = c22.rawData, d22 = {};
            c22.expires && (d22.expires = c22.expires), c22.cacheControl && (d22.cacheControl = c22.cacheControl), l22.vectorTile = c22.vectorTile || new e2.dW.VectorTile(new e2.bb(u22));
            const f22 = () => {
              l22.parse(l22.vectorTile, this.layerIndex, this.availableImages, this.actor, (o3, i3) => {
                if (o3 || !i3)
                  return s2(o3);
                const a3 = {};
                if (r22) {
                  const e22 = t2(n22);
                  e22.length > 0 && (a3.resourceTiming = JSON.parse(JSON.stringify(e22)));
                }
                s2(null, e2.l({ rawTileData: u22.slice(0) }, i3, d22, a3));
              });
            };
            this.isSpriteLoaded ? f22() : this.once("isSpriteLoaded", () => {
              this.scheduler ? this.scheduler.add(f22, { type: "parseTile", isSymbolTile: o2.isSymbolTile, zoom: o2.tileZoom }) : f22();
            }), this.loaded = this.loaded || {}, this.loaded[i2] = l22;
          });
        }
        reloadTile(t22, o2) {
          const s2 = this.loaded, i2 = t22.uid;
          if (s2 && s2[i2]) {
            const n22 = s2[i2];
            n22.showCollisionBoxes = t22.showCollisionBoxes, n22.projection = t22.projection, n22.brightness = t22.brightness, n22.tileTransform = e2.aK(t22.tileID.canonical, t22.projection), n22.extraShadowCaster = t22.extraShadowCaster, n22.lut = t22.lut;
            const r22 = (e22, t3) => {
              const s3 = n22.reloadCallback;
              s3 && (delete n22.reloadCallback, n22.parse(n22.vectorTile, this.layerIndex, this.availableImages, this.actor, s3)), o2(e22, t3);
            };
            "parsing" === n22.status ? n22.reloadCallback = r22 : "done" === n22.status && (n22.vectorTile ? n22.parse(n22.vectorTile, this.layerIndex, this.availableImages, this.actor, r22) : r22());
          } else
            o2(null, void 0);
        }
        abortTile(e22, t22) {
          const o2 = e22.uid, s2 = this.loading[o2];
          s2 && (s2.abort && s2.abort(), delete this.loading[o2]), t22();
        }
        removeTile(e22, t22) {
          const o2 = this.loaded, s2 = e22.uid;
          o2 && o2[s2] && delete o2[s2], t22();
        }
      }
      class h2 {
        loadTile(t22, o2) {
          const { uid: s2, encoding: i2, rawImageData: n22, padding: r22 } = t22, a2 = ImageBitmap && n22 instanceof ImageBitmap ? this.getImageData(n22, r22) : n22;
          o2(null, new e2.dX(s2, a2, i2, r22 < 1));
        }
        getImageData(e22, t22) {
          this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e22.width, e22.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = e22.width, this.offscreenCanvas.height = e22.height, this.offscreenCanvasContext.drawImage(e22, 0, 0, e22.width, e22.height);
          const o2 = this.offscreenCanvasContext.getImageData(-t22, -t22, e22.width + 2 * t22, e22.height + 2 * t22);
          return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), o2;
        }
      }
      e2.ba.setPbf(e2.bb);
      class u2 {
        decodeRasterArray({ task: t22, buffer: o2 }, s2) {
          e2.ba.performDecoding(o2, t22).then((e22) => {
            s2(null, e22);
          }, (e22) => {
            s2(e22);
          });
        }
      }
      const d2 = e2.dW.VectorTileFeature.prototype.toGeoJSON;
      class f2 {
        constructor(t22) {
          this._feature = t22, this.extent = e2.ab, this.type = t22.type, this.properties = t22.tags, "id" in t22 && !isNaN(t22.id) && (this.id = parseInt(t22.id, 10));
        }
        loadGeometry() {
          if (1 === this._feature.type) {
            const t22 = [];
            for (const o2 of this._feature.geometry)
              t22.push([new e2.P(o2[0], o2[1])]);
            return t22;
          }
          {
            const t22 = [];
            for (const o2 of this._feature.geometry) {
              const s2 = [];
              for (const t3 of o2)
                s2.push(new e2.P(t3[0], t3[1]));
              t22.push(s2);
            }
            return t22;
          }
        }
        toGeoJSON(e22, t22, o2) {
          return d2.call(this, e22, t22, o2);
        }
      }
      class p2 {
        constructor(t22) {
          this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e2.ab, this.length = t22.length, this._features = t22;
        }
        feature(e22) {
          return new f2(this._features[e22]);
        }
      }
      const g2 = 64 / 4096, m2 = 128;
      class y2 {
        constructor() {
          this.features = /* @__PURE__ */ new Map();
        }
        clear() {
          this.features.clear();
        }
        load(e22 = [], t22) {
          for (const o2 of e22) {
            const e3 = o2.id;
            if (null == e3)
              continue;
            let s2 = this.features.get(e3);
            s2 && this.updateCache(s2, t22), o2.geometry ? (s2 = w2(o2), this.updateCache(s2, t22), this.features.set(e3, s2)) : this.features.delete(e3), this.updateCache(s2, t22);
          }
        }
        updateCache(e22, t22) {
          for (const { canonical: o2, uid: s2 } of Object.values(t22)) {
            const { z: i2, x: n22, y: r22 } = o2;
            x2(e22, Math.pow(2, i2), n22, r22) && delete t22[s2];
          }
        }
        getTile(e22, t22, o2) {
          const s2 = Math.pow(2, e22), i2 = [];
          for (const e3 of this.features.values())
            x2(e3, s2, t22, o2) && i2.push(I2(e3, s2, t22, o2));
          return { features: i2 };
        }
        getFeatures() {
          return [...this.features.values()];
        }
      }
      function x2({ minX: e22, minY: t22, maxX: o2, maxY: s2 }, i2, n22, r22) {
        return e22 < (n22 + 1 + g2) / i2 && t22 < (r22 + 1 + g2) / i2 && o2 > (n22 - g2) / i2 && s2 > (r22 - g2) / i2;
      }
      function w2(e22) {
        const { id: t22, geometry: o2, properties: s2 } = e22;
        if (!o2)
          return;
        if ("GeometryCollection" === o2.type)
          throw new Error("GeometryCollection not supported in dynamic mode.");
        const { type: i2, coordinates: n22 } = o2, r22 = { id: t22, type: 1, geometry: [], tags: s2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }, a2 = r22.geometry;
        if ("Point" === i2)
          b2(n22, a2, r22);
        else if ("MultiPoint" === i2)
          for (const e3 of n22)
            b2(e3, a2, r22);
        else if ("LineString" === i2)
          r22.type = 2, S2(n22, a2, r22);
        else if ("MultiLineString" === i2)
          r22.type = 2, v2(n22, a2, r22);
        else if ("Polygon" === i2)
          r22.type = 3, v2(n22, a2, r22, true);
        else {
          if ("MultiPolygon" !== i2)
            throw new Error("Input data is not a valid GeoJSON object.");
          r22.type = 3;
          for (const e3 of n22)
            v2(e3, a2, r22, true);
        }
        return r22;
      }
      function b2([t22, o2], s2, i2) {
        const n22 = e2.am(t22);
        let r22 = e2.at(o2);
        r22 = r22 < 0 ? 0 : r22 > 1 ? 1 : r22, s2.push(n22, r22), i2.minX = Math.min(i2.minX, n22), i2.minY = Math.min(i2.minY, r22), i2.maxX = Math.max(i2.maxX, n22), i2.maxY = Math.max(i2.maxY, r22);
      }
      function S2(e22, t22, o2, s2 = false, i2 = false) {
        const n22 = [];
        for (const t3 of e22)
          b2(t3, n22, o2);
        t22.push(n22), s2 && function(e3, t3) {
          let o3 = 0;
          for (let t4 = 0, s3 = e3.length, i3 = s3 - 2; t4 < s3; i3 = t4, t4 += 2)
            o3 += (e3[t4] - e3[i3]) * (e3[t4 + 1] + e3[i3 + 1]);
          if (o3 > 0 === t3)
            for (let t4 = 0, o4 = e3.length; t4 < o4 / 2; t4 += 2) {
              const s3 = e3[t4], i3 = e3[t4 + 1];
              e3[t4] = e3[o4 - 2 - t4], e3[t4 + 1] = e3[o4 - 1 - t4], e3[o4 - 2 - t4] = s3, e3[o4 - 1 - t4] = i3;
            }
        }(n22, i2);
      }
      function v2(e22, t22, o2, s2 = false) {
        for (let i2 = 0; i2 < e22.length; i2++)
          S2(e22[i2], t22, o2, s2, 0 === i2);
      }
      function I2(t22, o2, s2, i2) {
        const { id: n22, type: r22, geometry: a2, tags: l22 } = t22, c22 = [];
        if (1 === r22)
          !function(t3, o3, s3, i3, n3) {
            for (let r3 = 0; r3 < t3.length; r3 += 2) {
              const a3 = Math.round(e2.ab * (t3[r3 + 0] * o3 - s3)), l3 = Math.round(e2.ab * (t3[r3 + 1] * o3 - i3));
              n3.push([a3, l3]);
            }
          }(a2, o2, s2, i2, c22);
        else
          for (const e22 of a2)
            M2(e22, o2, s2, i2, c22);
        return { id: n22, type: r22, geometry: c22, tags: l22 };
      }
      function M2(t22, o2, s2, i2, n22) {
        const r22 = -m2, a2 = e2.ab + m2;
        let l22;
        for (let c22 = 0; c22 < t22.length - 2; c22 += 2) {
          let h22 = Math.round(e2.ab * (t22[c22 + 0] * o2 - s2)), u22 = Math.round(e2.ab * (t22[c22 + 1] * o2 - i2)), d22 = Math.round(e2.ab * (t22[c22 + 2] * o2 - s2)), f22 = Math.round(e2.ab * (t22[c22 + 3] * o2 - i2));
          const p22 = d22 - h22, g22 = f22 - u22;
          h22 < r22 && d22 < r22 || (h22 < r22 ? (u22 += Math.round(g22 * ((r22 - h22) / p22)), h22 = r22) : d22 < r22 && (f22 = u22 + Math.round(g22 * ((r22 - h22) / p22)), d22 = r22), u22 < r22 && f22 < r22 || (u22 < r22 ? (h22 += Math.round(p22 * ((r22 - u22) / g22)), u22 = r22) : f22 < r22 && (d22 = h22 + Math.round(p22 * ((r22 - u22) / g22)), f22 = r22), h22 >= a2 && d22 >= a2 || (h22 >= a2 ? (u22 += Math.round(g22 * ((a2 - h22) / p22)), h22 = a2) : d22 >= a2 && (f22 = u22 + Math.round(g22 * ((a2 - h22) / p22)), d22 = a2), u22 >= a2 && f22 >= a2 || (u22 >= a2 ? (h22 += Math.round(p22 * ((a2 - u22) / g22)), u22 = a2) : f22 >= a2 && (d22 = h22 + Math.round(p22 * ((a2 - u22) / g22)), f22 = a2), l22 && h22 === l22[l22.length - 1][0] && u22 === l22[l22.length - 1][1] || (l22 = [[h22, u22]], n22.push(l22)), l22.push([d22, f22])))));
        }
      }
      var k2, T2, P2, C2 = { exports: {} }, _ = function() {
        if (P2)
          return C2.exports;
        P2 = 1;
        var t22 = e2.d_(), o2 = function() {
          if (T2)
            return k2;
          T2 = 1;
          var t3 = e2.dY(), o3 = e2.dZ().VectorTileFeature;
          function s3(e22, t4) {
            this.options = t4 || {}, this.features = e22, this.length = e22.length;
          }
          function i3(e22, t4) {
            this.id = "number" == typeof e22.id ? e22.id : void 0, this.type = e22.type, this.rawGeometry = 1 === e22.type ? [e22.geometry] : e22.geometry, this.properties = e22.tags, this.extent = t4 || 4096;
          }
          return k2 = s3, s3.prototype.feature = function(e22) {
            return new i3(this.features[e22], this.options.extent);
          }, i3.prototype.loadGeometry = function() {
            var e22 = this.rawGeometry;
            this.geometry = [];
            for (var o4 = 0; o4 < e22.length; o4++) {
              for (var s4 = e22[o4], i4 = [], n3 = 0; n3 < s4.length; n3++)
                i4.push(new t3(s4[n3][0], s4[n3][1]));
              this.geometry.push(i4);
            }
            return this.geometry;
          }, i3.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var e22 = this.geometry, t4 = 1 / 0, o4 = -1 / 0, s4 = 1 / 0, i4 = -1 / 0, n3 = 0; n3 < e22.length; n3++)
              for (var r3 = e22[n3], a3 = 0; a3 < r3.length; a3++) {
                var l3 = r3[a3];
                t4 = Math.min(t4, l3.x), o4 = Math.max(o4, l3.x), s4 = Math.min(s4, l3.y), i4 = Math.max(i4, l3.y);
              }
            return [t4, s4, o4, i4];
          }, i3.prototype.toGeoJSON = o3.prototype.toGeoJSON, k2;
        }();
        function s2(e22) {
          var o3 = new t22();
          return function(e3, t3) {
            for (var o4 in e3.layers)
              t3.writeMessage(3, i2, e3.layers[o4]);
          }(e22, o3), o3.finish();
        }
        function i2(e22, t3) {
          var o3;
          t3.writeVarintField(15, e22.version || 1), t3.writeStringField(1, e22.name || ""), t3.writeVarintField(5, e22.extent || 4096);
          var s3 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (o3 = 0; o3 < e22.length; o3++)
            s3.feature = e22.feature(o3), t3.writeMessage(2, n22, s3);
          var i3 = s3.keys;
          for (o3 = 0; o3 < i3.length; o3++)
            t3.writeStringField(3, i3[o3]);
          var r3 = s3.values;
          for (o3 = 0; o3 < r3.length; o3++)
            t3.writeMessage(4, h22, r3[o3]);
        }
        function n22(e22, t3) {
          var o3 = e22.feature;
          void 0 !== o3.id && t3.writeVarintField(1, o3.id), t3.writeMessage(2, r22, e22), t3.writeVarintField(3, o3.type), t3.writeMessage(4, c22, o3);
        }
        function r22(e22, t3) {
          var o3 = e22.feature, s3 = e22.keys, i3 = e22.values, n3 = e22.keycache, r3 = e22.valuecache;
          for (var a3 in o3.properties) {
            var l3 = o3.properties[a3], c3 = n3[a3];
            if (null !== l3) {
              void 0 === c3 && (s3.push(a3), n3[a3] = c3 = s3.length - 1), t3.writeVarint(c3);
              var h3 = typeof l3;
              "string" !== h3 && "boolean" !== h3 && "number" !== h3 && (l3 = JSON.stringify(l3));
              var u22 = h3 + ":" + l3, d22 = r3[u22];
              void 0 === d22 && (i3.push(l3), r3[u22] = d22 = i3.length - 1), t3.writeVarint(d22);
            }
          }
        }
        function a2(e22, t3) {
          return (t3 << 3) + (7 & e22);
        }
        function l22(e22) {
          return e22 << 1 ^ e22 >> 31;
        }
        function c22(e22, t3) {
          for (var o3 = e22.loadGeometry(), s3 = e22.type, i3 = 0, n3 = 0, r3 = o3.length, c3 = 0; c3 < r3; c3++) {
            var h3 = o3[c3], u22 = 1;
            1 === s3 && (u22 = h3.length), t3.writeVarint(a2(1, u22));
            for (var d22 = 3 === s3 ? h3.length - 1 : h3.length, f22 = 0; f22 < d22; f22++) {
              1 === f22 && 1 !== s3 && t3.writeVarint(a2(2, d22 - 1));
              var p22 = h3[f22].x - i3, g22 = h3[f22].y - n3;
              t3.writeVarint(l22(p22)), t3.writeVarint(l22(g22)), i3 += p22, n3 += g22;
            }
            3 === s3 && t3.writeVarint(a2(7, 1));
          }
        }
        function h22(e22, t3) {
          var o3 = typeof e22;
          "string" === o3 ? t3.writeStringField(1, e22) : "boolean" === o3 ? t3.writeBooleanField(7, e22) : "number" === o3 && (e22 % 1 != 0 ? t3.writeDoubleField(3, e22) : e22 < 0 ? t3.writeSVarintField(6, e22) : t3.writeVarintField(5, e22));
        }
        return C2.exports = s2, C2.exports.fromVectorTileJs = s2, C2.exports.fromGeojsonVt = function(e22, t3) {
          t3 = t3 || {};
          var i3 = {};
          for (var n3 in e22)
            i3[n3] = new o2(e22[n3].features, t3), i3[n3].name = n3, i3[n3].version = t3.version, i3[n3].extent = t3.extent;
          return s2({ layers: i3 });
        }, C2.exports.GeoJSONWrapper = o2, C2.exports;
      }(), L2 = e2.d$(_);
      const D2 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e22) => e22 }, j = Math.fround || (O2 = new Float32Array(1), (e22) => (O2[0] = +e22, O2[0]));
      var O2;
      const z2 = 3, A2 = 5, Z2 = 6;
      class E2 {
        constructor(e22) {
          this.options = Object.assign(Object.create(D2), e22), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(e22) {
          const { log: t22, minZoom: o2, maxZoom: s2 } = this.options;
          t22 && console.time("total time");
          const i2 = "prepare ".concat(e22.length, " points");
          t22 && console.time(i2), this.points = e22;
          const n22 = [];
          for (let t3 = 0; t3 < e22.length; t3++) {
            const o3 = e22[t3];
            if (!o3.geometry)
              continue;
            const [s3, i3] = o3.geometry.coordinates, r3 = j(N2(s3)), a2 = j(X2(i3));
            n22.push(r3, a2, 1 / 0, t3, -1, 1), this.options.reduce && n22.push(0);
          }
          let r22 = this.trees[s2 + 1] = this._createTree(n22);
          t22 && console.timeEnd(i2);
          for (let e3 = s2; e3 >= o2; e3--) {
            const o3 = +Date.now();
            r22 = this.trees[e3] = this._createTree(this._cluster(r22, e3)), t22 && console.log("z%d: %d clusters in %dms", e3, r22.numItems, +Date.now() - o3);
          }
          return t22 && console.timeEnd("total time"), this;
        }
        getClusters(e22, t22) {
          let o2 = ((e22[0] + 180) % 360 + 360) % 360 - 180;
          const s2 = Math.max(-90, Math.min(90, e22[1]));
          let i2 = 180 === e22[2] ? 180 : ((e22[2] + 180) % 360 + 360) % 360 - 180;
          const n22 = Math.max(-90, Math.min(90, e22[3]));
          if (e22[2] - e22[0] >= 360)
            o2 = -180, i2 = 180;
          else if (o2 > i2) {
            const e3 = this.getClusters([o2, s2, 180, n22], t22), r3 = this.getClusters([-180, s2, i2, n22], t22);
            return e3.concat(r3);
          }
          const r22 = this.trees[this._limitZoom(t22)], a2 = r22.range(N2(o2), X2(n22), N2(i2), X2(s2)), l22 = r22.data, c22 = [];
          for (const e3 of a2) {
            const t3 = this.stride * e3;
            c22.push(l22[t3 + A2] > 1 ? F2(l22, t3, this.clusterProps) : this.points[l22[t3 + z2]]);
          }
          return c22;
        }
        getChildren(e22) {
          const t22 = this._getOriginId(e22), o2 = this._getOriginZoom(e22), s2 = "No cluster with the specified id.", i2 = this.trees[o2];
          if (!i2)
            throw new Error(s2);
          const n22 = i2.data;
          if (t22 * this.stride >= n22.length)
            throw new Error(s2);
          const r22 = this.options.radius / (this.options.extent * Math.pow(2, o2 - 1)), a2 = i2.within(n22[t22 * this.stride], n22[t22 * this.stride + 1], r22), l22 = [];
          for (const t3 of a2) {
            const o3 = t3 * this.stride;
            n22[o3 + 4] === e22 && l22.push(n22[o3 + A2] > 1 ? F2(n22, o3, this.clusterProps) : this.points[n22[o3 + z2]]);
          }
          if (0 === l22.length)
            throw new Error(s2);
          return l22;
        }
        getLeaves(e22, t22, o2) {
          const s2 = [];
          return this._appendLeaves(s2, e22, t22 = t22 || 10, o2 = o2 || 0, 0), s2;
        }
        getTile(e22, t22, o2) {
          const s2 = this.trees[this._limitZoom(e22)], i2 = Math.pow(2, e22), { extent: n22, radius: r22 } = this.options, a2 = r22 / n22, l22 = (o2 - a2) / i2, c22 = (o2 + 1 + a2) / i2, h22 = { features: [] };
          return this._addTileFeatures(s2.range((t22 - a2) / i2, l22, (t22 + 1 + a2) / i2, c22), s2.data, t22, o2, i2, h22), 0 === t22 && this._addTileFeatures(s2.range(1 - a2 / i2, l22, 1, c22), s2.data, i2, o2, i2, h22), t22 === i2 - 1 && this._addTileFeatures(s2.range(0, l22, a2 / i2, c22), s2.data, -1, o2, i2, h22), h22.features.length ? h22 : null;
        }
        getClusterExpansionZoom(e22) {
          let t22 = this._getOriginZoom(e22) - 1;
          for (; t22 <= this.options.maxZoom; ) {
            const o2 = this.getChildren(e22);
            if (t22++, 1 !== o2.length)
              break;
            e22 = o2[0].properties.cluster_id;
          }
          return t22;
        }
        _appendLeaves(e22, t22, o2, s2, i2) {
          const n22 = this.getChildren(t22);
          for (const t3 of n22) {
            const n3 = t3.properties;
            if (n3 && n3.cluster ? i2 + n3.point_count <= s2 ? i2 += n3.point_count : i2 = this._appendLeaves(e22, n3.cluster_id, o2, s2, i2) : i2 < s2 ? i2++ : e22.push(t3), e22.length === o2)
              break;
          }
          return i2;
        }
        _createTree(t22) {
          const o2 = new e2.by(t22.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let e22 = 0; e22 < t22.length; e22 += this.stride)
            o2.add(t22[e22], t22[e22 + 1]);
          return o2.finish(), o2.data = t22, o2;
        }
        _addTileFeatures(e22, t22, o2, s2, i2, n22) {
          for (const r22 of e22) {
            const e3 = r22 * this.stride, a2 = t22[e3 + A2] > 1;
            let l22, c22, h22;
            if (a2)
              l22 = Y2(t22, e3, this.clusterProps), c22 = t22[e3], h22 = t22[e3 + 1];
            else {
              const o3 = this.points[t22[e3 + z2]];
              l22 = o3.properties;
              const [s3, i3] = o3.geometry.coordinates;
              c22 = N2(s3), h22 = X2(i3);
            }
            const u22 = { type: 1, geometry: [[Math.round(this.options.extent * (c22 * i2 - o2)), Math.round(this.options.extent * (h22 * i2 - s2))]], tags: l22 };
            let d22;
            d22 = a2 || this.options.generateId ? t22[e3 + z2] : this.points[t22[e3 + z2]].id, void 0 !== d22 && (u22.id = d22), n22.features.push(u22);
          }
        }
        _limitZoom(e22) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+e22), this.options.maxZoom + 1));
        }
        _cluster(e22, t22) {
          const { radius: o2, extent: s2, reduce: i2, minPoints: n22 } = this.options, r22 = o2 / (s2 * Math.pow(2, t22)), a2 = e22.data, l22 = [], c22 = this.stride;
          for (let o3 = 0; o3 < a2.length; o3 += c22) {
            if (a2[o3 + 2] <= t22)
              continue;
            a2[o3 + 2] = t22;
            const s3 = a2[o3], h22 = a2[o3 + 1], u22 = e22.within(a2[o3], a2[o3 + 1], r22), d22 = a2[o3 + A2];
            let f22 = d22;
            for (const e3 of u22) {
              const o4 = e3 * c22;
              a2[o4 + 2] > t22 && (f22 += a2[o4 + A2]);
            }
            if (f22 > d22 && f22 >= n22) {
              let e3, n3 = s3 * d22, r3 = h22 * d22, p22 = -1;
              const g22 = (o3 / c22 << 5) + (t22 + 1) + this.points.length;
              for (const s4 of u22) {
                const l3 = s4 * c22;
                if (a2[l3 + 2] <= t22)
                  continue;
                a2[l3 + 2] = t22;
                const h3 = a2[l3 + A2];
                n3 += a2[l3] * h3, r3 += a2[l3 + 1] * h3, a2[l3 + 4] = g22, i2 && (e3 || (e3 = this._map(a2, o3, true), p22 = this.clusterProps.length, this.clusterProps.push(e3)), i2(e3, this._map(a2, l3)));
              }
              a2[o3 + 4] = g22, l22.push(n3 / f22, r3 / f22, 1 / 0, g22, -1, f22), i2 && l22.push(p22);
            } else {
              for (let e3 = 0; e3 < c22; e3++)
                l22.push(a2[o3 + e3]);
              if (f22 > 1)
                for (const e3 of u22) {
                  const o4 = e3 * c22;
                  if (!(a2[o4 + 2] <= t22)) {
                    a2[o4 + 2] = t22;
                    for (let e4 = 0; e4 < c22; e4++)
                      l22.push(a2[o4 + e4]);
                  }
                }
            }
          }
          return l22;
        }
        _getOriginId(e22) {
          return e22 - this.points.length >> 5;
        }
        _getOriginZoom(e22) {
          return (e22 - this.points.length) % 32;
        }
        _map(e22, t22, o2) {
          if (e22[t22 + A2] > 1) {
            const s3 = this.clusterProps[e22[t22 + Z2]];
            return o2 ? Object.assign({}, s3) : s3;
          }
          const s2 = this.points[e22[t22 + z2]].properties, i2 = this.options.map(s2);
          return o2 && i2 === s2 ? Object.assign({}, i2) : i2;
        }
      }
      function F2(e22, t22, o2) {
        return { type: "Feature", id: e22[t22 + z2], properties: Y2(e22, t22, o2), geometry: { type: "Point", coordinates: [(s2 = e22[t22], 360 * (s2 - 0.5)), W2(e22[t22 + 1])] } };
        var s2;
      }
      function Y2(e22, t22, o2) {
        const s2 = e22[t22 + A2], i2 = s2 >= 1e4 ? "".concat(Math.round(s2 / 1e3), "k") : s2 >= 1e3 ? Math.round(s2 / 100) / 10 + "k" : s2, n22 = e22[t22 + Z2], r22 = -1 === n22 ? {} : Object.assign({}, o2[n22]);
        return Object.assign(r22, { cluster: true, cluster_id: e22[t22 + z2], point_count: s2, point_count_abbreviated: i2 });
      }
      function N2(e22) {
        return e22 / 360 + 0.5;
      }
      function X2(e22) {
        const t22 = Math.sin(e22 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t22) / (1 - t22)) / Math.PI;
        return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
      }
      function W2(e22) {
        const t22 = (180 - 360 * e22) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t22)) / Math.PI - 90;
      }
      function G2(e22, t22, o2, s2) {
        let i2 = s2;
        const n22 = t22 + (o2 - t22 >> 1);
        let r22, a2 = o2 - t22;
        const l22 = e22[t22], c22 = e22[t22 + 1], h22 = e22[o2], u22 = e22[o2 + 1];
        for (let s3 = t22 + 3; s3 < o2; s3 += 3) {
          const t3 = B2(e22[s3], e22[s3 + 1], l22, c22, h22, u22);
          if (t3 > i2)
            r22 = s3, i2 = t3;
          else if (t3 === i2) {
            const e3 = Math.abs(s3 - n22);
            e3 < a2 && (r22 = s3, a2 = e3);
          }
        }
        i2 > s2 && (r22 - t22 > 3 && G2(e22, t22, r22, s2), e22[r22 + 2] = i2, o2 - r22 > 3 && G2(e22, r22, o2, s2));
      }
      function B2(e22, t22, o2, s2, i2, n22) {
        let r22 = i2 - o2, a2 = n22 - s2;
        if (0 !== r22 || 0 !== a2) {
          const l22 = ((e22 - o2) * r22 + (t22 - s2) * a2) / (r22 * r22 + a2 * a2);
          l22 > 1 ? (o2 = i2, s2 = n22) : l22 > 0 && (o2 += r22 * l22, s2 += a2 * l22);
        }
        return r22 = e22 - o2, a2 = t22 - s2, r22 * r22 + a2 * a2;
      }
      function J2(e22, t22, o2, s2) {
        const i2 = { id: e22 != null ? e22 : null, type: t22, geometry: o2, tags: s2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if ("Point" === t22 || "MultiPoint" === t22 || "LineString" === t22)
          R2(i2, o2);
        else if ("Polygon" === t22)
          R2(i2, o2[0]);
        else if ("MultiLineString" === t22)
          for (const e3 of o2)
            R2(i2, e3);
        else if ("MultiPolygon" === t22)
          for (const e3 of o2)
            R2(i2, e3[0]);
        return i2;
      }
      function R2(e22, t22) {
        for (let o2 = 0; o2 < t22.length; o2 += 3)
          e22.minX = Math.min(e22.minX, t22[o2]), e22.minY = Math.min(e22.minY, t22[o2 + 1]), e22.maxX = Math.max(e22.maxX, t22[o2]), e22.maxY = Math.max(e22.maxY, t22[o2 + 1]);
      }
      function V2(e22, t22, o2, s2) {
        if (!t22.geometry)
          return;
        const i2 = t22.geometry.coordinates;
        if (i2 && 0 === i2.length)
          return;
        const n22 = t22.geometry.type, r22 = Math.pow(o2.tolerance / ((1 << o2.maxZoom) * o2.extent), 2);
        let a2 = [], l22 = t22.id;
        if (o2.promoteId ? l22 = t22.properties[o2.promoteId] : o2.generateId && (l22 = s2 || 0), "Point" === n22)
          $(i2, a2);
        else if ("MultiPoint" === n22)
          for (const e3 of i2)
            $(e3, a2);
        else if ("LineString" === n22)
          q2(i2, a2, r22, false);
        else if ("MultiLineString" === n22) {
          if (o2.lineMetrics) {
            for (const o3 of i2)
              a2 = [], q2(o3, a2, r22, false), e22.push(J2(l22, "LineString", a2, t22.properties));
            return;
          }
          U2(i2, a2, r22, false);
        } else if ("Polygon" === n22)
          U2(i2, a2, r22, true);
        else {
          if ("MultiPolygon" !== n22) {
            if ("GeometryCollection" === n22) {
              for (const i3 of t22.geometry.geometries)
                V2(e22, { id: l22, geometry: i3, properties: t22.properties }, o2, s2);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const e3 of i2) {
            const t3 = [];
            U2(e3, t3, r22, true), a2.push(t3);
          }
        }
        e22.push(J2(l22, n22, a2, t22.properties));
      }
      function $(e22, t22) {
        t22.push(K2(e22[0]), Q2(e22[1]), 0);
      }
      function q2(e22, t22, o2, s2) {
        let i2, n22, r22 = 0;
        for (let o3 = 0; o3 < e22.length; o3++) {
          const a3 = K2(e22[o3][0]), l22 = Q2(e22[o3][1]);
          t22.push(a3, l22, 0), o3 > 0 && (r22 += s2 ? (i2 * l22 - a3 * n22) / 2 : Math.sqrt(Math.pow(a3 - i2, 2) + Math.pow(l22 - n22, 2))), i2 = a3, n22 = l22;
        }
        const a2 = t22.length - 3;
        t22[2] = 1, G2(t22, 0, a2, o2), t22[a2 + 2] = 1, t22.size = Math.abs(r22), t22.start = 0, t22.end = t22.size;
      }
      function U2(e22, t22, o2, s2) {
        for (let i2 = 0; i2 < e22.length; i2++) {
          const n22 = [];
          q2(e22[i2], n22, o2, s2), t22.push(n22);
        }
      }
      function K2(e22) {
        return e22 / 360 + 0.5;
      }
      function Q2(e22) {
        const t22 = Math.sin(e22 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t22) / (1 - t22)) / Math.PI;
        return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
      }
      function H2(e22, t22, o2, s2, i2, n22, r22, a2) {
        if (s2 /= t22, n22 >= (o2 /= t22) && r22 < s2)
          return e22;
        if (r22 < o2 || n22 >= s2)
          return null;
        const l22 = [];
        for (const t3 of e22) {
          const e3 = t3.geometry;
          let n3 = t3.type;
          const r3 = 0 === i2 ? t3.minX : t3.minY, c22 = 0 === i2 ? t3.maxX : t3.maxY;
          if (r3 >= o2 && c22 < s2) {
            l22.push(t3);
            continue;
          }
          if (c22 < o2 || r3 >= s2)
            continue;
          let h22 = [];
          if ("Point" === n3 || "MultiPoint" === n3)
            ee2(e3, h22, o2, s2, i2);
          else if ("LineString" === n3)
            te2(e3, h22, o2, s2, i2, false, a2.lineMetrics);
          else if ("MultiLineString" === n3)
            se2(e3, h22, o2, s2, i2, false);
          else if ("Polygon" === n3)
            se2(e3, h22, o2, s2, i2, true);
          else if ("MultiPolygon" === n3)
            for (const t4 of e3) {
              const e4 = [];
              se2(t4, e4, o2, s2, i2, true), e4.length && h22.push(e4);
            }
          if (h22.length) {
            if (a2.lineMetrics && "LineString" === n3) {
              for (const e4 of h22)
                l22.push(J2(t3.id, n3, e4, t3.tags));
              continue;
            }
            "LineString" !== n3 && "MultiLineString" !== n3 || (1 === h22.length ? (n3 = "LineString", h22 = h22[0]) : n3 = "MultiLineString"), "Point" !== n3 && "MultiPoint" !== n3 || (n3 = 3 === h22.length ? "Point" : "MultiPoint"), l22.push(J2(t3.id, n3, h22, t3.tags));
          }
        }
        return l22.length ? l22 : null;
      }
      function ee2(e22, t22, o2, s2, i2) {
        for (let n22 = 0; n22 < e22.length; n22 += 3) {
          const r22 = e22[n22 + i2];
          r22 >= o2 && r22 <= s2 && ie2(t22, e22[n22], e22[n22 + 1], e22[n22 + 2]);
        }
      }
      function te2(e22, t22, o2, s2, i2, n22, r22) {
        let a2 = oe2(e22);
        const l22 = 0 === i2 ? ne2 : re2;
        let c22, h22, u22 = e22.start;
        for (let d3 = 0; d3 < e22.length - 3; d3 += 3) {
          const f3 = e22[d3], p3 = e22[d3 + 1], g3 = e22[d3 + 2], m22 = e22[d3 + 3], y22 = e22[d3 + 4], x22 = 0 === i2 ? f3 : p3, w22 = 0 === i2 ? m22 : y22;
          let b22 = false;
          r22 && (c22 = Math.sqrt(Math.pow(f3 - m22, 2) + Math.pow(p3 - y22, 2))), x22 < o2 ? w22 > o2 && (h22 = l22(a2, f3, p3, m22, y22, o2), r22 && (a2.start = u22 + c22 * h22)) : x22 > s2 ? w22 < s2 && (h22 = l22(a2, f3, p3, m22, y22, s2), r22 && (a2.start = u22 + c22 * h22)) : ie2(a2, f3, p3, g3), w22 < o2 && x22 >= o2 && (h22 = l22(a2, f3, p3, m22, y22, o2), b22 = true), w22 > s2 && x22 <= s2 && (h22 = l22(a2, f3, p3, m22, y22, s2), b22 = true), !n22 && b22 && (r22 && (a2.end = u22 + c22 * h22), t22.push(a2), a2 = oe2(e22)), r22 && (u22 += c22);
        }
        let d22 = e22.length - 3;
        const f22 = e22[d22], p22 = e22[d22 + 1], g22 = 0 === i2 ? f22 : p22;
        g22 >= o2 && g22 <= s2 && ie2(a2, f22, p22, e22[d22 + 2]), d22 = a2.length - 3, n22 && d22 >= 3 && (a2[d22] !== a2[0] || a2[d22 + 1] !== a2[1]) && ie2(a2, a2[0], a2[1], a2[2]), a2.length && t22.push(a2);
      }
      function oe2(e22) {
        const t22 = [];
        return t22.size = e22.size, t22.start = e22.start, t22.end = e22.end, t22;
      }
      function se2(e22, t22, o2, s2, i2, n22) {
        for (const r22 of e22)
          te2(r22, t22, o2, s2, i2, n22, false);
      }
      function ie2(e22, t22, o2, s2) {
        e22.push(t22, o2, s2);
      }
      function ne2(e22, t22, o2, s2, i2, n22) {
        const r22 = (n22 - t22) / (s2 - t22);
        return ie2(e22, n22, o2 + (i2 - o2) * r22, 1), r22;
      }
      function re2(e22, t22, o2, s2, i2, n22) {
        const r22 = (n22 - o2) / (i2 - o2);
        return ie2(e22, t22 + (s2 - t22) * r22, n22, 1), r22;
      }
      function ae2(e22, t22) {
        const o2 = [];
        for (let s2 = 0; s2 < e22.length; s2++) {
          const i2 = e22[s2], n22 = i2.type;
          let r22;
          if ("Point" === n22 || "MultiPoint" === n22 || "LineString" === n22)
            r22 = le2(i2.geometry, t22);
          else if ("MultiLineString" === n22 || "Polygon" === n22) {
            r22 = [];
            for (const e3 of i2.geometry)
              r22.push(le2(e3, t22));
          } else if ("MultiPolygon" === n22) {
            r22 = [];
            for (const e3 of i2.geometry) {
              const o3 = [];
              for (const s3 of e3)
                o3.push(le2(s3, t22));
              r22.push(o3);
            }
          }
          o2.push(J2(i2.id, n22, r22, i2.tags));
        }
        return o2;
      }
      function le2(e22, t22) {
        const o2 = [];
        o2.size = e22.size, void 0 !== e22.start && (o2.start = e22.start, o2.end = e22.end);
        for (let s2 = 0; s2 < e22.length; s2 += 3)
          o2.push(e22[s2] + t22, e22[s2 + 1], e22[s2 + 2]);
        return o2;
      }
      function ce2(e22, t22) {
        if (e22.transformed)
          return e22;
        const o2 = 1 << e22.z, s2 = e22.x, i2 = e22.y;
        for (const n22 of e22.features) {
          const e3 = n22.geometry, r22 = n22.type;
          if (n22.geometry = [], 1 === r22)
            for (let r3 = 0; r3 < e3.length; r3 += 2)
              n22.geometry.push(he2(e3[r3], e3[r3 + 1], t22, o2, s2, i2));
          else
            for (let r3 = 0; r3 < e3.length; r3++) {
              const a2 = [];
              for (let n3 = 0; n3 < e3[r3].length; n3 += 2)
                a2.push(he2(e3[r3][n3], e3[r3][n3 + 1], t22, o2, s2, i2));
              n22.geometry.push(a2);
            }
        }
        return e22.transformed = true, e22;
      }
      function he2(e22, t22, o2, s2, i2, n22) {
        return [Math.round(o2 * (e22 * s2 - i2)), Math.round(o2 * (t22 * s2 - n22))];
      }
      function ue2(e22, t22, o2, s2, i2) {
        const n22 = t22 === i2.maxZoom ? 0 : i2.tolerance / ((1 << t22) * i2.extent), r22 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e22.length, source: null, x: o2, y: s2, z: t22, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const t3 of e22)
          de2(r22, t3, n22, i2);
        return r22;
      }
      function de2(e22, t22, o2, s2) {
        const i2 = t22.geometry, n22 = t22.type, r22 = [];
        if (e22.minX = Math.min(e22.minX, t22.minX), e22.minY = Math.min(e22.minY, t22.minY), e22.maxX = Math.max(e22.maxX, t22.maxX), e22.maxY = Math.max(e22.maxY, t22.maxY), "Point" === n22 || "MultiPoint" === n22)
          for (let t3 = 0; t3 < i2.length; t3 += 3)
            r22.push(i2[t3], i2[t3 + 1]), e22.numPoints++, e22.numSimplified++;
        else if ("LineString" === n22)
          fe2(r22, i2, e22, o2, false, false);
        else if ("MultiLineString" === n22 || "Polygon" === n22)
          for (let t3 = 0; t3 < i2.length; t3++)
            fe2(r22, i2[t3], e22, o2, "Polygon" === n22, 0 === t3);
        else if ("MultiPolygon" === n22)
          for (let t3 = 0; t3 < i2.length; t3++) {
            const s3 = i2[t3];
            for (let t4 = 0; t4 < s3.length; t4++)
              fe2(r22, s3[t4], e22, o2, true, 0 === t4);
          }
        if (r22.length) {
          let o3 = t22.tags || null;
          if ("LineString" === n22 && s2.lineMetrics) {
            o3 = {};
            for (const e3 in t22.tags)
              o3[e3] = t22.tags[e3];
            o3.mapbox_clip_start = i2.start / i2.size, o3.mapbox_clip_end = i2.end / i2.size;
          }
          const a2 = { geometry: r22, type: "Polygon" === n22 || "MultiPolygon" === n22 ? 3 : "LineString" === n22 || "MultiLineString" === n22 ? 2 : 1, tags: o3 };
          null !== t22.id && (a2.id = t22.id), e22.features.push(a2);
        }
      }
      function fe2(e22, t22, o2, s2, i2, n22) {
        const r22 = s2 * s2;
        if (s2 > 0 && t22.size < (i2 ? r22 : s2))
          return void (o2.numPoints += t22.length / 3);
        const a2 = [];
        for (let e3 = 0; e3 < t22.length; e3 += 3)
          (0 === s2 || t22[e3 + 2] > r22) && (o2.numSimplified++, a2.push(t22[e3], t22[e3 + 1])), o2.numPoints++;
        i2 && function(e3, t3) {
          let o3 = 0;
          for (let t4 = 0, s3 = e3.length, i3 = s3 - 2; t4 < s3; i3 = t4, t4 += 2)
            o3 += (e3[t4] - e3[i3]) * (e3[t4 + 1] + e3[i3 + 1]);
          if (o3 > 0 === t3)
            for (let t4 = 0, o4 = e3.length; t4 < o4 / 2; t4 += 2) {
              const s3 = e3[t4], i3 = e3[t4 + 1];
              e3[t4] = e3[o4 - 2 - t4], e3[t4 + 1] = e3[o4 - 1 - t4], e3[o4 - 2 - t4] = s3, e3[o4 - 1 - t4] = i3;
            }
        }(a2, n22), e22.push(a2);
      }
      const pe2 = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
      class ge2 {
        constructor(e22, t22) {
          const o2 = (t22 = this.options = function(e3, t3) {
            for (const o3 in t3)
              e3[o3] = t3[o3];
            return e3;
          }(Object.create(pe2), t22)).debug;
          if (o2 && console.time("preprocess data"), t22.maxZoom < 0 || t22.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t22.promoteId && t22.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          let s2 = function(e3, t3) {
            const o3 = [];
            if ("FeatureCollection" === e3.type)
              for (let s3 = 0; s3 < e3.features.length; s3++)
                V2(o3, e3.features[s3], t3, s3);
            else
              V2(o3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
            return o3;
          }(e22, t22);
          this.tiles = {}, this.tileCoords = [], o2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t22.indexMaxZoom, t22.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), s2 = function(e3, t3) {
            const o3 = t3.buffer / t3.extent;
            let s3 = e3;
            const i2 = H2(e3, 1, -1 - o3, o3, 0, -1, 2, t3), n22 = H2(e3, 1, 1 - o3, 2 + o3, 0, -1, 2, t3);
            return (i2 || n22) && (s3 = H2(e3, 1, -o3, 1 + o3, 0, -1, 2, t3) || [], i2 && (s3 = ae2(i2, 1).concat(s3)), n22 && (s3 = s3.concat(ae2(n22, -1)))), s3;
          }(s2, t22), s2.length && this.splitTile(s2, 0, 0, 0), o2 && (s2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(e22, t22, o2, s2, i2, n22, r22) {
          const a2 = [e22, t22, o2, s2], l22 = this.options, c22 = l22.debug;
          for (; a2.length; ) {
            s2 = a2.pop(), o2 = a2.pop(), t22 = a2.pop(), e22 = a2.pop();
            const h22 = 1 << t22, u22 = me2(t22, o2, s2);
            let d22 = this.tiles[u22];
            if (!d22 && (c22 > 1 && console.time("creation"), d22 = this.tiles[u22] = ue2(e22, t22, o2, s2, l22), this.tileCoords.push({ z: t22, x: o2, y: s2 }), c22)) {
              c22 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t22, o2, s2, d22.numFeatures, d22.numPoints, d22.numSimplified), console.timeEnd("creation"));
              const e3 = "z".concat(t22);
              this.stats[e3] = (this.stats[e3] || 0) + 1, this.total++;
            }
            if (d22.source = e22, null == i2) {
              if (t22 === l22.indexMaxZoom || d22.numPoints <= l22.indexMaxPoints)
                continue;
            } else {
              if (t22 === l22.maxZoom || t22 === i2)
                continue;
              if (null != i2) {
                const e3 = i2 - t22;
                if (o2 !== n22 >> e3 || s2 !== r22 >> e3)
                  continue;
              }
            }
            if (d22.source = null, 0 === e22.length)
              continue;
            c22 > 1 && console.time("clipping");
            const f22 = 0.5 * l22.buffer / l22.extent, p22 = 0.5 - f22, g22 = 0.5 + f22, m22 = 1 + f22;
            let y22 = null, x22 = null, w22 = null, b22 = null, S22 = H2(e22, h22, o2 - f22, o2 + g22, 0, d22.minX, d22.maxX, l22), v22 = H2(e22, h22, o2 + p22, o2 + m22, 0, d22.minX, d22.maxX, l22);
            e22 = null, S22 && (y22 = H2(S22, h22, s2 - f22, s2 + g22, 1, d22.minY, d22.maxY, l22), x22 = H2(S22, h22, s2 + p22, s2 + m22, 1, d22.minY, d22.maxY, l22), S22 = null), v22 && (w22 = H2(v22, h22, s2 - f22, s2 + g22, 1, d22.minY, d22.maxY, l22), b22 = H2(v22, h22, s2 + p22, s2 + m22, 1, d22.minY, d22.maxY, l22), v22 = null), c22 > 1 && console.timeEnd("clipping"), a2.push(y22 || [], t22 + 1, 2 * o2, 2 * s2), a2.push(x22 || [], t22 + 1, 2 * o2, 2 * s2 + 1), a2.push(w22 || [], t22 + 1, 2 * o2 + 1, 2 * s2), a2.push(b22 || [], t22 + 1, 2 * o2 + 1, 2 * s2 + 1);
          }
        }
        getTile(e22, t22, o2) {
          e22 = +e22, t22 = +t22, o2 = +o2;
          const s2 = this.options, { extent: i2, debug: n22 } = s2;
          if (e22 < 0 || e22 > 24)
            return null;
          const r22 = 1 << e22, a2 = me2(e22, t22 = t22 + r22 & r22 - 1, o2);
          if (this.tiles[a2])
            return ce2(this.tiles[a2], i2);
          n22 > 1 && console.log("drilling down to z%d-%d-%d", e22, t22, o2);
          let l22, c22 = e22, h22 = t22, u22 = o2;
          for (; !l22 && c22 > 0; )
            c22--, h22 >>= 1, u22 >>= 1, l22 = this.tiles[me2(c22, h22, u22)];
          return l22 && l22.source ? (n22 > 1 && (console.log("found parent tile z%d-%d-%d", c22, h22, u22), console.time("drilling down")), this.splitTile(l22.source, c22, h22, u22, e22, t22, o2), n22 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? ce2(this.tiles[a2], i2) : null) : null;
        }
      }
      function me2(e22, t22, o2) {
        return 32 * ((1 << e22) * o2 + t22) + e22;
      }
      function ye(e22, t22) {
        const o2 = e22.tileID.canonical;
        if (!this._geoJSONIndex)
          return void t22(null, null);
        const s2 = this._geoJSONIndex.getTile(o2.z, o2.x, o2.y);
        if (!s2)
          return void t22(null, null);
        const i2 = new p2(s2.features);
        let n22 = L2(i2);
        0 === n22.byteOffset && n22.byteLength === n22.buffer.byteLength || (n22 = new Uint8Array(n22)), t22(null, { vectorTile: i2, rawData: n22.buffer });
      }
      class xe extends c2 {
        constructor(e22, t22, o2, s2, i2, n22) {
          super(e22, t22, o2, s2, ye, n22), i2 && (this.loadGeoJSON = i2), this._dynamicIndex = new y2();
        }
        loadData(o2, s2) {
          const i2 = o2 && o2.request, n22 = i2 && i2.collectResourceTiming;
          this.loadGeoJSON(o2, (r22, a2) => {
            if (r22 || !a2)
              return s2(r22);
            if ("object" != typeof a2)
              return s2(new Error("Input data given to '".concat(o2.source, "' is not a valid GeoJSON object.")));
            {
              try {
                if (o2.filter) {
                  const t22 = e2.M(o2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                  if ("error" === t22.result)
                    throw new Error(t22.value.map((e22) => "".concat(e22.key, ": ").concat(e22.message)).join(", "));
                  a2.features = a2.features.filter((e22) => t22.value.evaluate({ zoom: 0 }, e22));
                }
                o2.dynamic ? ("Feature" === a2.type && (a2 = { type: "FeatureCollection", features: [a2] }), o2.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(a2.features, this.loaded), o2.cluster && (a2.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = o2.cluster ? new E2(function({ superclusterOptions: t22, clusterProperties: o3 }) {
                  if (!o3 || !t22)
                    return t22;
                  const s3 = {}, i3 = {}, n3 = { accumulated: null, zoom: 0 }, r4 = { properties: null }, a3 = Object.keys(o3);
                  for (const t3 of a3) {
                    const [n4, r5] = o3[t3], a4 = e2.M(r5), l22 = e2.M("string" == typeof n4 ? [n4, ["accumulated"], ["get", t3]] : n4);
                    s3[t3] = a4.value, i3[t3] = l22.value;
                  }
                  return t22.map = (e22) => {
                    r4.properties = e22;
                    const t3 = {};
                    for (const e3 of a3)
                      t3[e3] = s3[e3].evaluate(n3, r4);
                    return t3;
                  }, t22.reduce = (e22, t3) => {
                    r4.properties = t3;
                    for (const t4 of a3)
                      n3.accumulated = e22[t4], e22[t4] = i3[t4].evaluate(n3, r4);
                  }, t22;
                }(o2)).load(a2.features) : o2.dynamic ? this._dynamicIndex : function(e22, t22) {
                  return new ge2(e22, t22);
                }(a2, o2.geojsonVtOptions);
              } catch (e22) {
                return s2(e22);
              }
              const r3 = {};
              if (n22) {
                const e22 = t2(i2);
                e22 && (r3.resourceTiming = {}, r3.resourceTiming[o2.source] = JSON.parse(JSON.stringify(e22)));
              }
              s2(null, r3);
            }
          });
        }
        reloadTile(e22, t22) {
          const o2 = this.loaded;
          return o2 && o2[e22.uid] ? e22.partial ? t22(null, void 0) : super.reloadTile(e22, t22) : this.loadTile(e22, t22);
        }
        loadGeoJSON(t22, o2) {
          if (t22.request)
            e2.n(t22.request, o2);
          else {
            if ("string" != typeof t22.data)
              return o2(new Error("Input data given to '".concat(t22.source, "' is not a valid GeoJSON object.")));
            try {
              return o2(null, JSON.parse(t22.data));
            } catch (e22) {
              return o2(new Error("Input data given to '".concat(t22.source, "' is not a valid GeoJSON object.")));
            }
          }
        }
        getClusterExpansionZoom(e22, t22) {
          try {
            t22(null, this._geoJSONIndex.getClusterExpansionZoom(e22.clusterId));
          } catch (e3) {
            t22(e3);
          }
        }
        getClusterChildren(e22, t22) {
          try {
            t22(null, this._geoJSONIndex.getChildren(e22.clusterId));
          } catch (e3) {
            t22(e3);
          }
        }
        getClusterLeaves(e22, t22) {
          try {
            t22(null, this._geoJSONIndex.getLeaves(e22.clusterId, e22.limit, e22.offset));
          } catch (e3) {
            t22(e3);
          }
        }
      }
      class we2 {
        constructor(t22, o2) {
          this.tileID = new e2.aA(t22.tileID.overscaledZ, t22.tileID.wrap, t22.tileID.canonical.z, t22.tileID.canonical.x, t22.tileID.canonical.y), this.tileZoom = t22.tileZoom, this.uid = t22.uid, this.zoom = t22.zoom, this.canonical = t22.tileID.canonical, this.pixelRatio = t22.pixelRatio, this.tileSize = t22.tileSize, this.source = t22.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t22.projection, this.brightness = o2;
        }
        parse(t22, o2, s2, i2) {
          this.status = "parsing";
          const n22 = new e2.aA(s2.tileID.overscaledZ, s2.tileID.wrap, s2.tileID.canonical.z, s2.tileID.canonical.x, s2.tileID.canonical.y), r22 = {}, a2 = o2.familiesBySource[s2.source], l22 = new e2.dR(n22, s2.promoteId);
          return l22.bucketLayerIDs = [], l22.is3DTile = true, e2.e0(t22).then((t3) => {
            if (!t3)
              return i2(new Error("Could not parse tile"));
            const o3 = e2.e1(t3, 1 / e2.c8(s2.tileID.canonical)), c22 = t3.json.extensionsUsed && t3.json.extensionsUsed.includes("MAPBOX_mesh_features") || t3.json.asset.extras && t3.json.asset.extras.MAPBOX_mesh_features, h22 = t3.json.extensionsUsed && t3.json.extensionsUsed.includes("EXT_meshopt_compression"), u22 = new e2.a3(this.zoom, { brightness: this.brightness });
            for (const t4 in a2)
              for (const s3 of a2[t4]) {
                const t5 = s3[0];
                l22.bucketLayerIDs.push(s3.map((e22) => e22.id)), t5.recalculate(u22, []);
                const i3 = new e2.e2(o3, n22, c22, h22, this.brightness, l22);
                c22 || (i3.needsUpload = true), r22[t5.fqid] = i3, i3.evaluate(t5);
              }
            this.status = "done", i2(null, { buckets: r22, featureIndex: l22 });
          }).catch((e22) => i2(new Error(e22.message)));
        }
      }
      class be2 {
        constructor(e22, t22, o2, s2, i2, n22) {
          this.actor = e22, this.layerIndex = t22, this.brightness = n22, this.loading = {}, this.loaded = {};
        }
        loadTile(t22, o2) {
          const s2 = t22.uid, i2 = this.loading[s2] = new we2(t22, this.brightness);
          e2.bc(t22.request, (e22, n22) => {
            const r22 = !this.loading[s2];
            return delete this.loading[s2], r22 || e22 ? (i2.status = "done", r22 || (this.loaded[s2] = i2), o2(e22)) : n22 && 0 !== n22.byteLength ? void i2.parse(n22, this.layerIndex, t22, (e3, t3) => {
              i2.status = "done", this.loaded = this.loaded || {}, this.loaded[s2] = i2, e3 || !t3 ? o2(e3) : o2(null, t3);
            }) : (i2.status = "done", this.loaded[s2] = i2, o2());
          });
        }
        reloadTile(e22, t22) {
          const o2 = this.loaded, s2 = e22.uid;
          if (o2 && o2[s2]) {
            const i2 = o2[s2];
            i2.projection = e22.projection, i2.brightness = e22.brightness;
            const n22 = (o3, s3) => {
              i2.reloadCallback && (delete i2.reloadCallback, this.loadTile(e22, t22)), t22(o3, s3);
            };
            "parsing" === i2.status ? i2.reloadCallback = n22 : "done" === i2.status && this.loadTile(e22, t22);
          }
        }
        abortTile(e22, t22) {
          const o2 = e22.uid;
          this.loading[o2] && delete this.loading[o2], t22();
        }
        removeTile(e22, t22) {
          const o2 = this.loaded, s2 = e22.uid;
          o2 && o2[s2] && delete o2[s2], t22();
        }
      }
      class Se2 {
        constructor(t22) {
          this.self = t22, this.actor = new e2.e3(t22, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e2.bL({ name: "mercator" }), this.workerSourceTypes = { vector: c2, geojson: xe, "batched-model": be2 }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e22, t3) => {
            if (this.workerSourceTypes[e22])
              throw new Error('Worker source with name "'.concat(e22, '" already registered.'));
            this.workerSourceTypes[e22] = t3;
          }, this.self.registerRTLTextPlugin = (t3) => {
            if (e2.e4.isParsed())
              throw new Error("RTL text plugin already registered.");
            e2.e4.applyArabicShaping = t3.applyArabicShaping, e2.e4.processBidirectionalText = t3.processBidirectionalText, e2.e4.processStyledBidirectionalText = t3.processStyledBidirectionalText;
          };
        }
        clearCaches(e22, t22, o2) {
          delete this.layerIndexes[e22], delete this.availableImages[e22], delete this.workerSources[e22], delete this.demWorkerSources[e22], delete this.rasterArrayWorkerSource, o2();
        }
        checkIfReady(e22, t22, o2) {
          o2();
        }
        setReferrer(e22, t22) {
          this.referrer = t22;
        }
        spriteLoaded(t22, { scope: o2, isLoaded: s2 }) {
          if (this.isSpriteLoaded[t22] || (this.isSpriteLoaded[t22] = {}), this.isSpriteLoaded[t22][o2] = s2, this.workerSources[t22] && this.workerSources[t22][o2])
            for (const i2 in this.workerSources[t22][o2]) {
              const n22 = this.workerSources[t22][o2][i2];
              for (const t3 in n22) {
                const o3 = n22[t3];
                o3 instanceof c2 && (o3.isSpriteLoaded = s2, o3.fire(new e2.x("isSpriteLoaded")));
              }
            }
        }
        setImages(e22, { scope: t22, images: o2 }, s2) {
          if (this.availableImages[e22] || (this.availableImages[e22] = {}), this.availableImages[e22][t22] = o2, this.workerSources[e22] && this.workerSources[e22][t22]) {
            for (const s3 in this.workerSources[e22][t22]) {
              const i2 = this.workerSources[e22][t22][s3];
              for (const e3 in i2)
                i2[e3].availableImages = o2;
            }
            s2();
          } else
            s2();
        }
        setProjection(t22, o2) {
          this.projections[t22] = e2.bL(o2);
        }
        setBrightness(e22, t22, o2) {
          this.brightness = t22, o2();
        }
        setLayers(e22, t22, o2) {
          this.getLayerIndex(e22, t22.scope).replace(t22.layers, t22.options), o2();
        }
        updateLayers(e22, t22, o2) {
          this.getLayerIndex(e22, t22.scope).update(t22.layers, t22.removedIds, t22.options), o2();
        }
        loadTile(e22, t22, o2) {
          t22.projection = this.projections[e22] || this.defaultProjection, this.getWorkerSource(e22, t22.type, t22.source, t22.scope).loadTile(t22, o2);
        }
        loadDEMTile(e22, t22, o2) {
          this.getDEMWorkerSource(e22, t22.source, t22.scope).loadTile(t22, o2);
        }
        decodeRasterArray(e22, t22, o2) {
          this.getRasterArrayWorkerSource().decodeRasterArray(t22, o2);
        }
        reloadTile(e22, t22, o2) {
          t22.projection = this.projections[e22] || this.defaultProjection, this.getWorkerSource(e22, t22.type, t22.source, t22.scope).reloadTile(t22, o2);
        }
        abortTile(e22, t22, o2) {
          this.getWorkerSource(e22, t22.type, t22.source, t22.scope).abortTile(t22, o2);
        }
        removeTile(e22, t22, o2) {
          this.getWorkerSource(e22, t22.type, t22.source, t22.scope).removeTile(t22, o2);
        }
        removeSource(e22, t22, o2) {
          if (!(this.workerSources[e22] && this.workerSources[e22][t22.scope] && this.workerSources[e22][t22.scope][t22.type] && this.workerSources[e22][t22.scope][t22.type][t22.source]))
            return;
          const s2 = this.workerSources[e22][t22.scope][t22.type][t22.source];
          delete this.workerSources[e22][t22.scope][t22.type][t22.source], void 0 !== s2.removeSource ? s2.removeSource(t22, o2) : o2();
        }
        loadWorkerSource(e22, t22, o2) {
          try {
            this.self.importScripts(t22.url), o2();
          } catch (e3) {
            o2(e3.toString());
          }
        }
        syncRTLPluginState(t22, o2, s2) {
          try {
            e2.e4.setState(o2);
            const t3 = e2.e4.getPluginURL();
            if (e2.e4.isLoaded() && !e2.e4.isParsed() && null != t3) {
              this.self.importScripts(t3);
              const o3 = e2.e4.isParsed();
              s2(o3 ? void 0 : new Error("RTL Text Plugin failed to import scripts from ".concat(t3)), o3);
            }
          } catch (e22) {
            s2(e22.toString());
          }
        }
        setDracoUrl(e22, t22) {
          this.dracoUrl = t22;
        }
        getAvailableImages(e22, t22) {
          this.availableImages[e22] || (this.availableImages[e22] = {});
          let o2 = this.availableImages[e22][t22];
          return o2 || (o2 = []), o2;
        }
        getLayerIndex(e22, t22) {
          this.layerIndexes[e22] || (this.layerIndexes[e22] = {});
          let o2 = this.layerIndexes[e22][t22];
          return o2 || (o2 = this.layerIndexes[e22][t22] = new i(), o2.scope = t22), o2;
        }
        getWorkerSource(e22, t22, o2, s2) {
          return this.workerSources[e22] || (this.workerSources[e22] = {}), this.workerSources[e22][s2] || (this.workerSources[e22][s2] = {}), this.workerSources[e22][s2][t22] || (this.workerSources[e22][s2][t22] = {}), this.isSpriteLoaded[e22] || (this.isSpriteLoaded[e22] = {}), this.workerSources[e22][s2][t22][o2] || (this.workerSources[e22][s2][t22][o2] = new this.workerSourceTypes[t22]({ send: (t3, o3, s3, i2, n22, r22) => {
            this.actor.send(t3, o3, s3, e22, n22, r22);
          }, scheduler: this.actor.scheduler }, this.getLayerIndex(e22, s2), this.getAvailableImages(e22, s2), this.isSpriteLoaded[e22][s2], void 0, this.brightness)), this.workerSources[e22][s2][t22][o2];
        }
        getDEMWorkerSource(e22, t22, o2) {
          return this.demWorkerSources[e22] || (this.demWorkerSources[e22] = {}), this.demWorkerSources[e22][o2] || (this.demWorkerSources[e22][o2] = {}), this.demWorkerSources[e22][o2][t22] || (this.demWorkerSources[e22][o2][t22] = new h2()), this.demWorkerSources[e22][o2][t22];
        }
        getRasterArrayWorkerSource() {
          return this.rasterArrayWorkerSource || (this.rasterArrayWorkerSource = new u2()), this.rasterArrayWorkerSource;
        }
        enforceCacheSizeLimit(t22, o2) {
          e2.e5(o2);
        }
        getWorkerPerformanceMetrics(e22, t22, o2) {
          o2(void 0, void 0);
        }
      }
      return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Se2(self)), Se2;
    });
    define2(["./shared"], function(e2) {
      var t2 = "3.7.0";
      const i = { create: "create", load: "load", fullLoad: "fullLoad" }, o = { mark(e22) {
        performance.mark(e22);
      }, measure(e22, t22, i2) {
        performance.measure(e22, t22, i2);
      } };
      function r2(t22) {
        const i2 = t22.name.split("?")[0];
        return e2.a(i2) && i2.includes("mapbox-gl.js") ? "javascript" : e2.a(i2) && i2.includes("mapbox-gl.css") ? "css" : e2.b(i2) ? "fontRange" : e2.c(i2) ? "sprite" : e2.i(i2) ? "style" : e2.d(i2) ? "tilejson" : "other";
      }
      var s, a = {}, n2 = function() {
        if (s)
          return a;
        function e22(e3) {
          return !t22(e3);
        }
        function t22(t3) {
          return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window))
              return false;
            var e3, t4, i3 = new Blob([""], { type: "text/javascript" }), o3 = URL.createObjectURL(i3);
            try {
              t4 = new Worker(o3), e3 = true;
            } catch (t5) {
              e3 = false;
            }
            return t4 && t4.terminate(), URL.revokeObjectURL(o3), e3;
          }() ? function() {
            var e3 = document.createElement("canvas");
            e3.width = e3.height = 1;
            var t4 = e3.getContext("2d");
            if (!t4)
              return false;
            var i3 = t4.getImageData(0, 0, 1, 1);
            return i3 && i3.width === e3.width;
          }() ? (void 0 === i2[o2 = t3 && t3.failIfMajorPerformanceCaveat] && (i2[o2] = function(t4) {
            var i3, o3 = function(t5) {
              var i4 = document.createElement("canvas"), o4 = Object.create(e22.webGLContextAttributes);
              return o4.failIfMajorPerformanceCaveat = t5, i4.getContext("webgl2", o4);
            }(t4);
            if (!o3)
              return false;
            try {
              i3 = o3.createShader(o3.VERTEX_SHADER);
            } catch (e3) {
              return false;
            }
            return !(!i3 || o3.isContextLost()) && (o3.shaderSource(i3, "void main() {}"), o3.compileShader(i3), true === o3.getShaderParameter(i3, o3.COMPILE_STATUS));
          }(o2)), i2[o2] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
          var o2;
        }
        s = 1, a.supported = e22, a.notSupportedReason = t22;
        var i2 = {};
        return e22.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true }, a;
      }();
      function l2(e22, t22, i2) {
        const o2 = document.createElement(e22);
        return null != t22 && (o2.className = t22), i2 && i2.appendChild(o2), o2;
      }
      function c2(e22, t22, i2) {
        const o2 = document.createElementNS("http://www.w3.org/2000/svg", e22);
        for (const e3 of Object.keys(t22))
          o2.setAttributeNS(null, e3, String(t22[e3]));
        return i2 && i2.appendChild(o2), o2;
      }
      const h2 = "undefined" != typeof document ? document.documentElement && document.documentElement.style : null, u2 = h2 && void 0 !== h2.userSelect ? "userSelect" : "WebkitUserSelect";
      let d2;
      function _() {
        h2 && u2 && (d2 = h2[u2], h2[u2] = "none");
      }
      function p2() {
        h2 && u2 && (h2[u2] = d2);
      }
      function m2(e22) {
        e22.preventDefault(), e22.stopPropagation(), window.removeEventListener("click", m2, true);
      }
      function f2() {
        window.addEventListener("click", m2, true), window.setTimeout(() => {
          window.removeEventListener("click", m2, true);
        }, 0);
      }
      function g2(e22, t22) {
        const i2 = e22.getBoundingClientRect();
        return y2(e22, i2, t22);
      }
      function v2(e22, t22) {
        const i2 = e22.getBoundingClientRect(), o2 = [];
        for (let r22 = 0; r22 < t22.length; r22++)
          o2.push(y2(e22, i2, t22[r22]));
        return o2;
      }
      function x2(e22) {
        return void 0 !== window.InstallTrigger && 2 === e22.button && e22.ctrlKey && window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e22.button;
      }
      function y2(t22, i2, o2) {
        const r22 = t22.offsetWidth === i2.width ? 1 : t22.offsetWidth / i2.width;
        return new e2.P((o2.clientX - i2.left) * r22, (o2.clientY - i2.top) * r22);
      }
      const b2 = "01", w2 = "NO_ACCESS_TOKEN";
      class T2 {
        constructor(e22, t22, i2) {
          this._transformRequestFn = e22, this._customAccessToken = t22, this._silenceAuthErrors = !!i2, this._createSkuToken();
        }
        _createSkuToken() {
          const e22 = function() {
            let e3 = "";
            for (let t22 = 0; t22 < 10; t22++)
              e3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
            return { token: ["1", b2, e3].join(""), tokenExpiresAt: Date.now() + 432e5 };
          }();
          this._skuToken = e22.token, this._skuTokenExpiresAt = e22.tokenExpiresAt;
        }
        _isSkuTokenExpired() {
          return Date.now() > this._skuTokenExpiresAt;
        }
        transformRequest(e22, t22) {
          return this._transformRequestFn && this._transformRequestFn(e22, t22) || { url: e22 };
        }
        normalizeStyleURL(i2, o2) {
          if (!e2.f(i2))
            return i2;
          const r22 = C2(i2);
          return r22.params.push("sdk=js-".concat(t2)), r22.path = "/styles/v1".concat(r22.path), this._makeAPIURL(r22, this._customAccessToken || o2);
        }
        normalizeGlyphsURL(t22, i2) {
          if (!e2.f(t22))
            return t22;
          const o2 = C2(t22);
          return o2.path = "/fonts/v1".concat(o2.path), this._makeAPIURL(o2, this._customAccessToken || i2);
        }
        normalizeModelURL(t22, i2) {
          if (!e2.f(t22))
            return t22;
          const o2 = C2(t22);
          return o2.path = "/models/v1".concat(o2.path), this._makeAPIURL(o2, this._customAccessToken || i2);
        }
        normalizeSourceURL(t22, i2, o2, r22) {
          if (!e2.f(t22))
            return t22;
          const s2 = C2(t22);
          return s2.path = "/v4/".concat(s2.authority, ".json"), s2.params.push("secure"), o2 && s2.params.push("language=".concat(o2)), r22 && s2.params.push("worldview=".concat(r22)), this._makeAPIURL(s2, this._customAccessToken || i2);
        }
        normalizeSpriteURL(t22, i2, o2, r22) {
          const s2 = C2(t22);
          return e2.f(t22) ? (s2.path = "/styles/v1".concat(s2.path, "/sprite").concat(i2).concat(o2), this._makeAPIURL(s2, this._customAccessToken || r22)) : (s2.path += "".concat(i2).concat(o2), S2(s2));
        }
        normalizeTileURL(t22, i2, o2) {
          if (this._isSkuTokenExpired() && this._createSkuToken(), t22 && !e2.f(t22))
            return t22;
          const r22 = C2(t22);
          r22.path = r22.path.replace(/(\.(png|jpg)\d*)(?=$)/, "".concat(i2 || o2 && "raster" !== r22.authority && 512 === o2 ? "@2x" : "").concat(e2.m.supported ? ".webp" : "$1")), "raster" === r22.authority ? r22.path = "/".concat(e2.e.RASTER_URL_PREFIX).concat(r22.path) : "rasterarrays" === r22.authority ? r22.path = "/".concat(e2.e.RASTERARRAYS_URL_PREFIX).concat(r22.path) : "3dtiles" === r22.authority ? r22.path = "/".concat(e2.e.TILES3D_URL_PREFIX).concat(r22.path) : (r22.path = r22.path.replace(/^.+\/v4\//, "/"), r22.path = "/".concat(e2.e.TILE_URL_VERSION).concat(r22.path));
          const s2 = this._customAccessToken || function(e22) {
            for (const t3 of e22) {
              const e3 = t3.match(/^access_token=(.*)$/);
              if (e3)
                return e3[1];
            }
            return null;
          }(r22.params) || e2.e.ACCESS_TOKEN;
          return e2.e.REQUIRE_ACCESS_TOKEN && s2 && this._skuToken && r22.params.push("sku=".concat(this._skuToken)), this._makeAPIURL(r22, s2);
        }
        canonicalizeTileURL(t22, i2) {
          const o2 = C2(t22);
          if (!o2.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !o2.path.match(/\.[\w]+$/))
            return t22;
          let r22 = "mapbox://";
          o2.path.match(/^\/raster\/v1\//) ? r22 += "raster/".concat(o2.path.replace("/".concat(e2.e.RASTER_URL_PREFIX, "/"), "")) : o2.path.match(/^\/rasterarrays\/v1\//) ? r22 += "rasterarrays/".concat(o2.path.replace("/".concat(e2.e.RASTERARRAYS_URL_PREFIX, "/"), "")) : r22 += "tiles/".concat(o2.path.replace("/".concat(e2.e.TILE_URL_VERSION, "/"), ""));
          let s2 = o2.params;
          return i2 && (s2 = s2.filter((e22) => !e22.match(/^access_token=/))), s2.length && (r22 += "?".concat(s2.join("&"))), r22;
        }
        canonicalizeTileset(t22, i2) {
          const o2 = !!i2 && e2.f(i2), r22 = [];
          for (const i3 of t22.tiles || [])
            e2.h(i3) ? r22.push(this.canonicalizeTileURL(i3, o2)) : r22.push(i3);
          return r22;
        }
        _makeAPIURL(t22, i2) {
          const o2 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", r22 = C2(e2.e.API_URL);
          if (t22.protocol = r22.protocol, t22.authority = r22.authority, "http" === t22.protocol) {
            const e22 = t22.params.indexOf("secure");
            e22 >= 0 && t22.params.splice(e22, 1);
          }
          if ("/" !== r22.path && (t22.path = "".concat(r22.path).concat(t22.path)), !e2.e.REQUIRE_ACCESS_TOKEN)
            return S2(t22);
          if (i2 = i2 || e2.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
            if (!i2)
              throw new Error("An API access token is required to use Mapbox GL. ".concat(o2));
            if ("s" === i2[0])
              throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ".concat(o2));
          }
          return t22.params = t22.params.filter((e22) => -1 === e22.indexOf("access_token")), t22.params.push("access_token=".concat(i2 || "")), S2(t22);
        }
      }
      const E2 = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function C2(e22) {
        const t22 = e22.match(E2);
        if (!t22)
          throw new Error("Unable to parse URL object");
        return { protocol: t22[1], authority: t22[2], path: t22[3] || "/", params: t22[4] ? t22[4].split("&") : [] };
      }
      function S2(e22) {
        const t22 = e22.params.length ? "?".concat(e22.params.join("&")) : "";
        return "".concat(e22.protocol, "://").concat(e22.authority).concat(e22.path).concat(t22);
      }
      const I2 = "mapbox.eventData";
      function D2(t22) {
        if (!t22)
          return null;
        const i2 = t22.split(".");
        if (!i2 || 3 !== i2.length)
          return null;
        try {
          return JSON.parse(e2.j(i2[1]));
        } catch (e22) {
          return null;
        }
      }
      class R2 {
        constructor(e22) {
          this.type = e22, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
        }
        getStorageKey(t22) {
          const i2 = D2(e2.e.ACCESS_TOKEN);
          let o2 = "";
          return o2 = i2 && i2.u ? e2.k(i2.u) : e2.e.ACCESS_TOKEN || "", t22 ? "".concat(I2, ".").concat(t22, ":").concat(o2) : "".concat(I2, ":").concat(o2);
        }
        fetchEventData() {
          const t22 = e2.s("localStorage"), i2 = this.getStorageKey(), o2 = this.getStorageKey("uuid");
          if (t22)
            try {
              const e22 = localStorage.getItem(i2);
              e22 && (this.eventData = JSON.parse(e22));
              const t3 = localStorage.getItem(o2);
              t3 && (this.anonId = t3);
            } catch (t3) {
              e2.w("Unable to read from LocalStorage");
            }
        }
        saveEventData() {
          const t22 = e2.s("localStorage"), i2 = this.getStorageKey(), o2 = this.getStorageKey("uuid"), r22 = this.anonId;
          if (t22 && r22)
            try {
              localStorage.setItem(o2, r22), Object.keys(this.eventData).length >= 1 && localStorage.setItem(i2, JSON.stringify(this.eventData));
            } catch (t3) {
              e2.w("Unable to write to LocalStorage");
            }
        }
        processRequests(e22) {
        }
        postEvent(t22, i2, o2, r22) {
          if (!e2.e.EVENTS_URL)
            return;
          const s2 = C2(e2.e.EVENTS_URL);
          s2.params.push("access_token=".concat(r22 || e2.e.ACCESS_TOKEN || ""));
          const a2 = { event: this.type, created: new Date(t22).toISOString() }, n22 = i2 ? e2.l(a2, i2) : a2, l22 = { url: S2(s2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([n22]) };
          this.pendingRequest = e2.p(l22, (e22) => {
            this.pendingRequest = null, o2(e22), this.saveEventData(), this.processRequests(r22);
          });
        }
        queueRequest(e22, t22) {
          this.queue.push(e22), this.processRequests(t22);
        }
      }
      const A2 = new class extends R2 {
        constructor(e22) {
          super("appUserTurnstile"), this._customAccessToken = e22;
        }
        postTurnstileEvent(t22, i2) {
          e2.e.EVENTS_URL && e2.e.ACCESS_TOKEN && Array.isArray(t22) && t22.some((t3) => e2.f(t3) || e2.h(t3)) && this.queueRequest(Date.now(), i2);
        }
        processRequests(i2) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
          const o2 = D2(e2.e.ACCESS_TOKEN), r22 = o2 ? o2.u : e2.e.ACCESS_TOKEN;
          let s2 = r22 !== this.eventData.tokenU;
          e2.v(this.anonId) || (this.anonId = e2.u(), s2 = true);
          const a2 = this.queue.shift();
          if (this.eventData.lastSuccess) {
            const e22 = new Date(this.eventData.lastSuccess), t22 = new Date(a2), i3 = (a2 - this.eventData.lastSuccess) / 864e5;
            s2 = s2 || i3 >= 1 || i3 < -1 || e22.getDate() !== t22.getDate();
          } else
            s2 = true;
          s2 ? this.postEvent(a2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: t2, skuId: b2, "enabled.telemetry": false, userId: this.anonId }, (e22) => {
            e22 || (this.eventData.lastSuccess = a2, this.eventData.tokenU = r22);
          }, i2) : this.processRequests();
        }
      }(), L2 = A2.postTurnstileEvent.bind(A2), P2 = new class extends R2 {
        constructor() {
          super("map.load"), this.success = {}, this.skuToken = "";
        }
        postMapLoadEvent(t22, i2, o2, r22) {
          this.skuToken = i2, this.errorCb = r22, e2.e.EVENTS_URL && (o2 || e2.e.ACCESS_TOKEN ? this.queueRequest({ id: t22, timestamp: Date.now() }, o2) : this.errorCb(new Error(w2)));
        }
        processRequests(i2) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { id: o2, timestamp: r22 } = this.queue.shift();
          o2 && this.success[o2] || (this.anonId || this.fetchEventData(), e2.v(this.anonId) || (this.anonId = e2.u()), this.postEvent(r22, { sdkIdentifier: "mapbox-gl-js", sdkVersion: t2, skuId: b2, skuToken: this.skuToken, userId: this.anonId }, (e22) => {
            e22 ? this.errorCb(e22) : o2 && (this.success[o2] = true);
          }, i2));
        }
        remove() {
          this.errorCb = null;
        }
      }(), M2 = P2.postMapLoadEvent.bind(P2), z2 = new class extends R2 {
        constructor() {
          super("style.load"), this.eventIdPerMapInstanceMap = /* @__PURE__ */ new Map(), this.mapInstanceIdMap = /* @__PURE__ */ new WeakMap();
        }
        getMapInstanceId(t22) {
          let i2 = this.mapInstanceIdMap.get(t22);
          return i2 || (i2 = e2.u(), this.mapInstanceIdMap.set(t22, i2)), i2;
        }
        getEventId(e22) {
          const t22 = this.eventIdPerMapInstanceMap.get(e22) || 0;
          return this.eventIdPerMapInstanceMap.set(e22, t22 + 1), t22;
        }
        postStyleLoadEvent(t22, i2) {
          const { map: o2, style: r22, importedStyles: s2 } = i2;
          if (!e2.e.EVENTS_URL || !t22 && !e2.e.ACCESS_TOKEN)
            return;
          const a2 = this.getMapInstanceId(o2), n22 = { mapInstanceId: a2, eventId: this.getEventId(a2), style: r22 };
          s2.length && (n22.importedStyles = s2), this.queueRequest({ timestamp: Date.now(), payload: n22 }, t22);
        }
        processRequests(e22) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { timestamp: t22, payload: i2 } = this.queue.shift();
          this.postEvent(t22, i2, () => {
          }, e22);
        }
      }(), O2 = z2.postStyleLoadEvent.bind(z2), F2 = new class extends R2 {
        constructor() {
          super("gljs.performance");
        }
        postPerformanceEvent(t22, i2) {
          e2.e.EVENTS_URL && (t22 || e2.e.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: i2 }, t22);
        }
        processRequests(o2) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { timestamp: s2, performanceData: a2 } = this.queue.shift(), n22 = function(o3) {
            const s3 = performance.getEntriesByType("resource"), a3 = performance.getEntriesByType("mark"), n3 = function(e22) {
              const t22 = {};
              if (e22) {
                for (const i2 in e22)
                  if ("other" !== i2)
                    for (const o4 of e22[i2]) {
                      const e3 = "".concat(i2, "ResolveRangeMin"), r22 = "".concat(i2, "ResolveRangeMax"), s4 = "".concat(i2, "RequestCount"), a4 = "".concat(i2, "RequestCachedCount");
                      t22[e3] = Math.min(t22[e3] || 1 / 0, o4.startTime), t22[r22] = Math.max(t22[r22] || -1 / 0, o4.responseEnd);
                      const n4 = (e4) => {
                        void 0 === t22[e4] && (t22[e4] = 0), ++t22[e4];
                      };
                      void 0 !== o4.transferSize && 0 === o4.transferSize && n4(a4), n4(s4);
                    }
              }
              return t22;
            }(function(e22, t22) {
              const i2 = {};
              if (e22)
                for (const o4 of e22) {
                  const e3 = t22(o4);
                  void 0 === i2[e3] && (i2[e3] = []), i2[e3].push(o4);
                }
              return i2;
            }(s3, r2)), l22 = window.devicePixelRatio, c22 = navigator.connection || navigator.mozConnection || navigator.webkitConnection, h22 = c22 ? c22.effectiveType : void 0, u22 = { counters: [], metadata: [], attributes: [] }, d22 = (e22, t22, i2) => {
              null != i2 && e22.push({ name: t22, value: i2.toString() });
            };
            for (const e22 in n3)
              d22(u22.counters, e22, n3[e22]);
            if (o3.interactionRange[0] !== 1 / 0 && o3.interactionRange[1] !== -1 / 0 && (d22(u22.counters, "interactionRangeMin", o3.interactionRange[0]), d22(u22.counters, "interactionRangeMax", o3.interactionRange[1])), a3)
              for (const e22 of Object.keys(i)) {
                const t22 = i[e22], o4 = a3.find((e3) => e3.name === t22);
                o4 && d22(u22.counters, t22, o4.startTime);
              }
            return d22(u22.counters, "visibilityHidden", o3.visibilityHidden), d22(u22.attributes, "style", function(t22) {
              if (t22)
                for (const i2 of t22) {
                  const t3 = i2.name.split("?")[0];
                  if (e2.i(t3)) {
                    const e22 = t3.split("/").slice(-2);
                    if (2 === e22.length)
                      return "mapbox://styles/".concat(e22[0], "/").concat(e22[1]);
                  }
                }
            }(s3)), d22(u22.attributes, "terrainEnabled", o3.terrainEnabled ? "true" : "false"), d22(u22.attributes, "fogEnabled", o3.fogEnabled ? "true" : "false"), d22(u22.attributes, "projection", o3.projection), d22(u22.attributes, "zoom", o3.zoom), d22(u22.metadata, "devicePixelRatio", l22), d22(u22.metadata, "connectionEffectiveType", h22), d22(u22.metadata, "navigatorUserAgent", navigator.userAgent), d22(u22.metadata, "screenWidth", window.screen.width), d22(u22.metadata, "screenHeight", window.screen.height), d22(u22.metadata, "windowWidth", window.innerWidth), d22(u22.metadata, "windowHeight", window.innerHeight), d22(u22.metadata, "mapWidth", o3.width / l22), d22(u22.metadata, "mapHeight", o3.height / l22), d22(u22.metadata, "webglRenderer", o3.renderer), d22(u22.metadata, "webglVendor", o3.vendor), d22(u22.metadata, "sdkVersion", t2), d22(u22.metadata, "sdkIdentifier", "mapbox-gl-js"), u22;
          }(a2);
          for (const e22 of n22.metadata)
            ;
          for (const e22 of n22.counters)
            ;
          for (const e22 of n22.attributes)
            ;
          this.postEvent(s2, n22, () => {
          }, o2);
        }
      }(), k2 = F2.postPerformanceEvent.bind(F2), B2 = new class extends R2 {
        constructor() {
          super("map.auth"), this.success = {}, this.skuToken = "";
        }
        getSession(t22, i2, o2, r22) {
          if (!e2.e.API_URL || !e2.e.SESSION_PATH)
            return;
          const s2 = C2(e2.e.API_URL + e2.e.SESSION_PATH);
          s2.params.push("sku=".concat(i2 || "")), s2.params.push("access_token=".concat(r22 || e2.e.ACCESS_TOKEN || ""));
          const a2 = { url: S2(s2), headers: { "Content-Type": "text/plain" } };
          this.pendingRequest = e2.g(a2, (e22) => {
            this.pendingRequest = null, o2(e22), this.saveEventData(), this.processRequests(r22);
          });
        }
        getSessionAPI(t22, i2, o2, r22) {
          this.skuToken = i2, this.errorCb = r22, e2.e.SESSION_PATH && e2.e.API_URL && (o2 || e2.e.ACCESS_TOKEN ? this.queueRequest({ id: t22, timestamp: Date.now() }, o2) : this.errorCb(new Error(w2)));
        }
        processRequests(e22) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { id: t22, timestamp: i2 } = this.queue.shift();
          t22 && this.success[t22] || this.getSession(i2, this.skuToken, (e3) => {
            e3 ? this.errorCb(e3) : t22 && (this.success[t22] = true);
          }, e22);
        }
        remove() {
          this.errorCb = null;
        }
      }(), N2 = B2.getSessionAPI.bind(B2), U2 = /* @__PURE__ */ new Set();
      function G2(e22, t22) {
        t22 ? U2.add(e22) : U2.delete(e22);
      }
      class j {
        constructor() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = /* @__PURE__ */ new Set(), this._updatedImages = /* @__PURE__ */ new Set();
        }
        isDirty() {
          return this._changed;
        }
        setDirty() {
          this._changed = true;
        }
        getUpdatedSourceCaches() {
          return this._updatedSourceCaches;
        }
        updateSourceCache(e22, t22) {
          this._updatedSourceCaches[e22] = t22, this.setDirty();
        }
        discardSourceCacheUpdate(e22) {
          delete this._updatedSourceCaches[e22];
        }
        updateLayer(e22) {
          const t22 = e22.scope;
          this._updatedLayers[t22] = this._updatedLayers[t22] || /* @__PURE__ */ new Set(), this._updatedLayers[t22].add(e22.id), this.setDirty();
        }
        removeLayer(e22) {
          const t22 = e22.scope;
          this._removedLayers[t22] = this._removedLayers[t22] || {}, this._updatedLayers[t22] = this._updatedLayers[t22] || /* @__PURE__ */ new Set(), this._removedLayers[t22][e22.id] = e22, this._updatedLayers[t22].delete(e22.id), this._updatedPaintProps.delete(e22.fqid), this.setDirty();
        }
        getRemovedLayer(e22) {
          return this._removedLayers[e22.scope] ? this._removedLayers[e22.scope][e22.id] : null;
        }
        discardLayerRemoval(e22) {
          this._removedLayers[e22.scope] && delete this._removedLayers[e22.scope][e22.id];
        }
        getLayerUpdatesByScope() {
          const e22 = {};
          for (const t22 in this._updatedLayers)
            e22[t22] = e22[t22] || {}, e22[t22].updatedIds = Array.from(this._updatedLayers[t22].values());
          for (const t22 in this._removedLayers)
            e22[t22] = e22[t22] || {}, e22[t22].removedIds = Object.keys(this._removedLayers[t22]);
          return e22;
        }
        getUpdatedPaintProperties() {
          return this._updatedPaintProps;
        }
        updatePaintProperties(e22) {
          this._updatedPaintProps.add(e22.fqid), this.setDirty();
        }
        getUpdatedImages() {
          return Array.from(this._updatedImages.values());
        }
        updateImage(e22) {
          this._updatedImages.add(e22), this.setDirty();
        }
        resetUpdatedImages() {
          this._updatedImages.clear();
        }
        reset() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages.clear();
        }
      }
      function V2(e22) {
        const { userImage: t22 } = e22;
        return !!(t22 && t22.render && t22.render()) && (e22.data.replace(new Uint8Array(t22.data.buffer)), true);
      }
      class q2 extends e2.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = {}, this.requestors = [], this.patterns = {}, this.atlasImage = {}, this.atlasTexture = {}, this.dirty = true;
        }
        createScope(t22) {
          this.images[t22] = {}, this.loaded[t22] = false, this.updatedImages[t22] = {}, this.patterns[t22] = {}, this.callbackDispatchedThisFrame[t22] = {}, this.atlasImage[t22] = new e2.r({ width: 1, height: 1 });
        }
        isLoaded() {
          for (const e22 in this.loaded)
            if (!this.loaded[e22])
              return false;
          return true;
        }
        setLoaded(e22, t22) {
          if (this.loaded[t22] !== e22 && (this.loaded[t22] = e22, e22)) {
            for (const { ids: e3, callback: i2 } of this.requestors)
              this._notify(e3, t22, i2);
            this.requestors = [];
          }
        }
        hasImage(e22, t22) {
          return !!this.getImage(e22, t22);
        }
        getImage(e22, t22) {
          return this.images[t22][e22];
        }
        addImage(e22, t22, i2) {
          this._validate(e22, i2) && (this.images[t22][e22] = i2);
        }
        _validate(t22, i2) {
          let o2 = true;
          return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new e2.t(new Error('Image "'.concat(t22, '" has invalid "stretchX" value')))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new e2.t(new Error('Image "'.concat(t22, '" has invalid "stretchY" value')))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new e2.t(new Error('Image "'.concat(t22, '" has invalid "content" value')))), o2 = false), o2;
        }
        _validateStretch(e22, t22) {
          if (!e22)
            return true;
          let i2 = 0;
          for (const o2 of e22) {
            if (o2[0] < i2 || o2[1] < o2[0] || t22 < o2[1])
              return false;
            i2 = o2[1];
          }
          return true;
        }
        _validateContent(e22, t22) {
          return !(e22 && (4 !== e22.length || e22[0] < 0 || t22.data.width < e22[0] || e22[1] < 0 || t22.data.height < e22[1] || e22[2] < 0 || t22.data.width < e22[2] || e22[3] < 0 || t22.data.height < e22[3] || e22[2] < e22[0] || e22[3] < e22[1]));
        }
        updateImage(e22, t22, i2) {
          i2.version = this.images[t22][e22].version + 1, this.images[t22][e22] = i2, this.updatedImages[t22][e22] = true;
        }
        removeImage(e22, t22) {
          const i2 = this.images[t22][e22];
          delete this.images[t22][e22], delete this.patterns[t22][e22], i2.userImage && i2.userImage.onRemove && i2.userImage.onRemove();
        }
        listImages(e22) {
          return Object.keys(this.images[e22]);
        }
        getImages(e22, t22, i2) {
          let o2 = true;
          const r22 = !!this.loaded[t22];
          if (!r22)
            for (const i3 of e22)
              this.images[t22][i3] || (o2 = false);
          r22 || o2 ? this._notify(e22, t22, i2) : this.requestors.push({ ids: e22, scope: t22, callback: i2 });
        }
        getUpdatedImages(e22) {
          return this.updatedImages[e22];
        }
        _notify(t22, i2, o2) {
          const r22 = {};
          for (const o3 of t22) {
            this.images[i2][o3] || this.fire(new e2.x("styleimagemissing", { id: o3 }));
            const t3 = this.images[i2][o3];
            t3 ? r22[o3] = { data: t3.data.clone(), pixelRatio: t3.pixelRatio, sdf: t3.sdf, version: t3.version, stretchX: t3.stretchX, stretchY: t3.stretchY, content: t3.content, hasRenderCallback: Boolean(t3.userImage && t3.userImage.render) } : e2.w('Image "'.concat(o3, '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.'));
          }
          o2(null, r22);
        }
        getPixelSize(e22) {
          const { width: t22, height: i2 } = this.atlasImage[e22];
          return { width: t22, height: i2 };
        }
        getPattern(t22, i2, o2) {
          const r22 = this.patterns[i2][t22], s2 = this.getImage(t22, i2);
          if (!s2)
            return null;
          if (r22 && r22.position.version === s2.version)
            return r22.position;
          if (r22)
            r22.position.version = s2.version;
          else {
            const o3 = { w: s2.data.width + 2 * e2.y, h: s2.data.height + 2 * e2.y, x: 0, y: 0 }, r3 = new e2.I(o3, s2, e2.y);
            this.patterns[i2][t22] = { bin: o3, position: r3 };
          }
          return this._updatePatternAtlas(i2, o2), this.patterns[i2][t22].position;
        }
        bind(t22, i2) {
          const o2 = t22.gl;
          let r22 = this.atlasTexture[i2];
          r22 ? this.dirty && (r22.update(this.atlasImage[i2]), this.dirty = false) : (r22 = new e2.T(t22, this.atlasImage[i2], o2.RGBA8), this.atlasTexture[i2] = r22), r22.bind(o2.LINEAR, o2.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas(t22, i2) {
          const o2 = [];
          for (const e22 in this.patterns[t22])
            o2.push(this.patterns[t22][e22].bin);
          const { w: r22, h: s2 } = e2.z(o2), a2 = this.atlasImage[t22];
          a2.resize({ width: r22 || 1, height: s2 || 1 });
          for (const o3 in this.patterns[t22]) {
            const { bin: r3, position: s3 } = this.patterns[t22][o3];
            let n22 = s3.padding;
            const l22 = r3.x + n22, c22 = r3.y + n22, h22 = this.images[t22][o3].data, u22 = h22.width, d22 = h22.height;
            n22 = n22 > 1 ? n22 - 1 : n22, e2.r.copy(h22, a2, { x: 0, y: 0 }, { x: l22, y: c22 }, { width: u22, height: d22 }, i2), e2.r.copy(h22, a2, { x: 0, y: d22 - n22 }, { x: l22, y: c22 - n22 }, { width: u22, height: n22 }, i2), e2.r.copy(h22, a2, { x: 0, y: 0 }, { x: l22, y: c22 + d22 }, { width: u22, height: n22 }, i2), e2.r.copy(h22, a2, { x: u22 - n22, y: 0 }, { x: l22 - n22, y: c22 }, { width: n22, height: d22 }, i2), e2.r.copy(h22, a2, { x: 0, y: 0 }, { x: l22 + u22, y: c22 }, { width: n22, height: d22 }, i2), e2.r.copy(h22, a2, { x: u22 - n22, y: d22 - n22 }, { x: l22 - n22, y: c22 - n22 }, { width: n22, height: n22 }, i2), e2.r.copy(h22, a2, { x: 0, y: d22 - n22 }, { x: l22 + u22, y: c22 - n22 }, { width: n22, height: n22 }, i2), e2.r.copy(h22, a2, { x: 0, y: 0 }, { x: l22 + u22, y: c22 + d22 }, { width: n22, height: n22 }, i2), e2.r.copy(h22, a2, { x: u22 - n22, y: 0 }, { x: l22 - n22, y: c22 + d22 }, { width: n22, height: n22 }, i2);
          }
          this.dirty = true;
        }
        beginFrame() {
          for (const e22 in this.images)
            this.callbackDispatchedThisFrame[e22] = {};
        }
        dispatchRenderCallbacks(e22, t22) {
          for (const i2 of e22) {
            if (this.callbackDispatchedThisFrame[t22][i2])
              continue;
            this.callbackDispatchedThisFrame[t22][i2] = true;
            const e3 = this.images[t22][i2];
            V2(e3) && this.updateImage(i2, t22, e3);
          }
        }
      }
      function Z2(t22) {
        const i2 = t22.key, o2 = t22.value, r22 = t22.valueSpec || {}, s2 = t22.objectElementValidators || {}, a2 = t22.style, n22 = t22.styleSpec;
        let l22 = [];
        const c22 = e2.B(o2);
        if ("object" !== c22)
          return [new e2.V(i2, o2, "object expected, ".concat(c22, " found"))];
        for (const t3 in o2) {
          const c3 = t3.split(".")[0];
          let h22;
          s2[c3] ? h22 = s2[c3] : r22[c3] ? h22 = _e : s2["*"] ? h22 = s2["*"] : r22["*"] && (h22 = _e), h22 ? l22 = l22.concat(h22({ key: (i2 ? "".concat(i2, ".") : i2) + t3, value: o2[t3], valueSpec: r22[c3] || r22["*"], style: a2, styleSpec: n22, object: o2, objectKey: t3 }, o2)) : l22.push(new e2.A(i2, o2[t3], 'unknown property "'.concat(t3, '"')));
        }
        for (const t3 in r22)
          s2[t3] || r22[t3].required && void 0 === r22[t3].default && void 0 === o2[t3] && l22.push(new e2.V(i2, o2, 'missing required property "'.concat(t3, '"')));
        return l22;
      }
      function H2(t22) {
        const i2 = t22.value, o2 = t22.valueSpec, r22 = t22.style, s2 = t22.styleSpec, a2 = t22.key, n22 = t22.arrayElementValidator || _e;
        if ("array" !== e2.B(i2))
          return [new e2.V(a2, i2, "array expected, ".concat(e2.B(i2), " found"))];
        if (o2.length && i2.length !== o2.length)
          return [new e2.V(a2, i2, "array length ".concat(o2.length, " expected, length ").concat(i2.length, " found"))];
        if (o2["min-length"] && i2.length < o2["min-length"])
          return [new e2.V(a2, i2, "array length at least ".concat(o2["min-length"], " expected, length ").concat(i2.length, " found"))];
        let l22 = { type: o2.value, values: o2.values, minimum: o2.minimum, maximum: o2.maximum, function: void 0 };
        s2.$version < 7 && (l22.function = o2.function), "object" === e2.B(o2.value) && (l22 = o2.value);
        let c22 = [];
        for (let e22 = 0; e22 < i2.length; e22++)
          c22 = c22.concat(n22({ array: i2, arrayIndex: e22, value: i2[e22], valueSpec: l22, style: r22, styleSpec: s2, key: "".concat(a2, "[").concat(e22, "]") }, true));
        return c22;
      }
      function W2(t22) {
        const i2 = t22.key, o2 = t22.value, r22 = t22.valueSpec;
        let s2 = e2.B(o2);
        if ("number" === s2 && o2 != o2 && (s2 = "NaN"), "number" !== s2)
          return [new e2.V(i2, o2, "number expected, ".concat(s2, " found"))];
        if ("minimum" in r22) {
          let s3 = r22.minimum;
          if ("array" === e2.B(r22.minimum) && (s3 = r22.minimum[t22.arrayIndex]), o2 < s3)
            return [new e2.V(i2, o2, "".concat(o2, " is less than the minimum value ").concat(s3))];
        }
        if ("maximum" in r22) {
          let s3 = r22.maximum;
          if ("array" === e2.B(r22.maximum) && (s3 = r22.maximum[t22.arrayIndex]), o2 > s3)
            return [new e2.V(i2, o2, "".concat(o2, " is greater than the maximum value ").concat(s3))];
        }
        return [];
      }
      function $(t22) {
        const i2 = t22.valueSpec, o2 = e2.D(t22.value.type);
        let r22, s2, a2, n22 = {};
        const l22 = "categorical" !== o2 && void 0 === t22.value.property, c22 = !l22, h22 = "array" === e2.B(t22.value.stops) && "array" === e2.B(t22.value.stops[0]) && "object" === e2.B(t22.value.stops[0][0]), u22 = Z2({ key: t22.key, value: t22.value, valueSpec: t22.styleSpec.function, style: t22.style, styleSpec: t22.styleSpec, objectElementValidators: { stops: function(t3) {
          if ("identity" === o2)
            return [new e2.V(t3.key, t3.value, 'identity function may not have a "stops" property')];
          let i3 = [];
          const r3 = t3.value;
          return i3 = i3.concat(H2({ key: t3.key, value: r3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: d22 })), "array" === e2.B(r3) && 0 === r3.length && i3.push(new e2.V(t3.key, r3, "array must have at least one stop")), i3;
        }, default: function(e22) {
          return _e({ key: e22.key, value: e22.value, valueSpec: i2, style: e22.style, styleSpec: e22.styleSpec });
        } } });
        return "identity" === o2 && l22 && u22.push(new e2.V(t22.key, t22.value, 'missing required property "property"')), "identity" === o2 || t22.value.stops || u22.push(new e2.V(t22.key, t22.value, 'missing required property "stops"')), "exponential" === o2 && t22.valueSpec.expression && !e2.F(t22.valueSpec) && u22.push(new e2.V(t22.key, t22.value, "exponential functions not supported")), t22.styleSpec.$version >= 8 && (c22 && !e2.G(t22.valueSpec) ? u22.push(new e2.V(t22.key, t22.value, "property functions not supported")) : l22 && !e2.H(t22.valueSpec) && u22.push(new e2.V(t22.key, t22.value, "zoom functions not supported"))), "categorical" !== o2 && !h22 || void 0 !== t22.value.property || u22.push(new e2.V(t22.key, t22.value, '"property" property is required')), u22;
        function d22(t3) {
          let o3 = [];
          const r3 = t3.value, l3 = t3.key;
          if ("array" !== e2.B(r3))
            return [new e2.V(l3, r3, "array expected, ".concat(e2.B(r3), " found"))];
          if (2 !== r3.length)
            return [new e2.V(l3, r3, "array length 2 expected, length ".concat(r3.length, " found"))];
          if (h22) {
            if ("object" !== e2.B(r3[0]))
              return [new e2.V(l3, r3, "object expected, ".concat(e2.B(r3[0]), " found"))];
            if (void 0 === r3[0].zoom)
              return [new e2.V(l3, r3, "object stop key must have zoom")];
            if (void 0 === r3[0].value)
              return [new e2.V(l3, r3, "object stop key must have value")];
            const i3 = e2.D(r3[0].zoom);
            if ("number" != typeof i3)
              return [new e2.V(l3, r3[0].zoom, "stop zoom values must be numbers")];
            if (a2 && a2 > i3)
              return [new e2.V(l3, r3[0].zoom, "stop zoom values must appear in ascending order")];
            i3 !== a2 && (a2 = i3, s2 = void 0, n22 = {}), o3 = o3.concat(Z2({ key: "".concat(l3, "[0]"), value: r3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: W2, value: _2 } }));
          } else
            o3 = o3.concat(_2({ key: "".concat(l3, "[0]"), value: r3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, r3));
          return e2.J(e2.K(r3[1])) ? o3.concat([new e2.V("".concat(l3, "[1]"), r3[1], "expressions are not allowed in function stops.")]) : o3.concat(_e({ key: "".concat(l3, "[1]"), value: r3[1], valueSpec: i2, style: t3.style, styleSpec: t3.styleSpec }));
        }
        function _2(t3, a3) {
          const l3 = e2.B(t3.value), c3 = e2.D(t3.value), h3 = null !== t3.value ? t3.value : a3;
          if (r22) {
            if (l3 !== r22)
              return [new e2.V(t3.key, h3, "".concat(l3, " stop domain type must match previous stop domain type ").concat(r22))];
          } else
            r22 = l3;
          if ("number" !== l3 && "string" !== l3 && "boolean" !== l3 && "number" != typeof c3 && "string" != typeof c3 && "boolean" != typeof c3)
            return [new e2.V(t3.key, h3, "stop domain value must be a number, string, or boolean")];
          if ("number" !== l3 && "categorical" !== o2) {
            let r3 = "number expected, ".concat(l3, " found");
            return e2.G(i2) && void 0 === o2 && (r3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new e2.V(t3.key, h3, r3)];
          }
          return "categorical" !== o2 || "number" !== l3 || "number" == typeof c3 && isFinite(c3) && Math.floor(c3) === c3 ? "categorical" !== o2 && "number" === l3 && "number" == typeof c3 && "number" == typeof s2 && void 0 !== s2 && c3 < s2 ? [new e2.V(t3.key, h3, "stop domain values must appear in ascending order")] : (s2 = c3, "categorical" === o2 && c3 in n22 ? [new e2.V(t3.key, h3, "stop domain values must be unique")] : (n22[c3] = true, [])) : [new e2.V(t3.key, h3, "integer expected, found ".concat(String(c3)))];
        }
      }
      function X2(t22) {
        const i2 = ("property" === t22.expressionContext ? e2.L : e2.M)(e2.K(t22.value), t22.valueSpec);
        if ("error" === i2.result)
          return i2.value.map((i3) => new e2.V("".concat(t22.key).concat(i3.key), t22.value, i3.message));
        const o2 = i2.value.expression || i2.value._styleExpression.expression;
        if ("property" === t22.expressionContext && "text-font" === t22.propertyKey && !o2.outputDefined())
          return [new e2.V(t22.key, t22.value, 'Invalid data expression for "'.concat(t22.propertyKey, '". Output values must be contained as literals within the expression.'))];
        if ("property" === t22.expressionContext && "layout" === t22.propertyType && !e2.N(o2))
          return [new e2.V(t22.key, t22.value, '"feature-state" data expressions are not supported with layout properties.')];
        if ("filter" === t22.expressionContext)
          return Y2(o2, t22);
        if (t22.expressionContext && 0 === t22.expressionContext.indexOf("cluster")) {
          if (!e2.O(o2, ["zoom", "feature-state"]))
            return [new e2.V(t22.key, t22.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if ("cluster-initial" === t22.expressionContext && !e2.Q(o2))
            return [new e2.V(t22.key, t22.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function Y2(t22, i2) {
        const o2 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
        if (i2.valueSpec && i2.valueSpec.expression)
          for (const e22 of i2.valueSpec.expression.parameters)
            o2.delete(e22);
        if (0 === o2.size)
          return [];
        const r22 = [];
        return t22 instanceof e2.S && o2.has(t22.name) ? [new e2.V(i2.key, i2.value, '["'.concat(t22.name, '"] expression is not supported in a filter for a ').concat(i2.object.type, " layer with id: ").concat(i2.object.id))] : (t22.eachChild((e22) => {
          r22.push(...Y2(e22, i2));
        }), r22);
      }
      function K2(t22) {
        const i2 = t22.key, o2 = t22.value, r22 = t22.valueSpec, s2 = [];
        return Array.isArray(r22.values) ? -1 === r22.values.indexOf(e2.D(o2)) && s2.push(new e2.V(i2, o2, "expected one of [".concat(r22.values.join(", "), "], ").concat(JSON.stringify(o2), " found"))) : -1 === Object.keys(r22.values).indexOf(e2.D(o2)) && s2.push(new e2.V(i2, o2, "expected one of [".concat(Object.keys(r22.values).join(", "), "], ").concat(JSON.stringify(o2), " found"))), s2;
      }
      function J2(t22) {
        return e2.W(e2.K(t22.value)) ? X2(e2.C({}, t22, { expressionContext: "filter", valueSpec: t22.styleSpec["filter_".concat(t22.layerType || "fill")] })) : Q2(t22);
      }
      function Q2(t22) {
        const i2 = t22.value, o2 = t22.key;
        if ("array" !== e2.B(i2))
          return [new e2.V(o2, i2, "array expected, ".concat(e2.B(i2), " found"))];
        const r22 = t22.styleSpec;
        let s2, a2 = [];
        if (i2.length < 1)
          return [new e2.V(o2, i2, "filter array must have at least 1 element")];
        switch (a2 = a2.concat(K2({ key: "".concat(o2, "[0]"), value: i2[0], valueSpec: r22.filter_operator, style: t22.style, styleSpec: t22.styleSpec })), e2.D(i2[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            i2.length >= 2 && "$type" === e2.D(i2[1]) && a2.push(new e2.V(o2, i2, '"$type" cannot be use with operator "'.concat(i2[0], '"')));
          case "==":
          case "!=":
            3 !== i2.length && a2.push(new e2.V(o2, i2, 'filter array for operator "'.concat(i2[0], '" must have 3 elements')));
          case "in":
          case "!in":
            i2.length >= 2 && (s2 = e2.B(i2[1]), "string" !== s2 && a2.push(new e2.V("".concat(o2, "[1]"), i2[1], "string expected, ".concat(s2, " found"))));
            for (let n22 = 2; n22 < i2.length; n22++)
              s2 = e2.B(i2[n22]), "$type" === e2.D(i2[1]) ? a2 = a2.concat(K2({ key: "".concat(o2, "[").concat(n22, "]"), value: i2[n22], valueSpec: r22.geometry_type, style: t22.style, styleSpec: t22.styleSpec })) : "string" !== s2 && "number" !== s2 && "boolean" !== s2 && a2.push(new e2.V("".concat(o2, "[").concat(n22, "]"), i2[n22], "string, number, or boolean expected, ".concat(s2, " found")));
            break;
          case "any":
          case "all":
          case "none":
            for (let e22 = 1; e22 < i2.length; e22++)
              a2 = a2.concat(Q2({ key: "".concat(o2, "[").concat(e22, "]"), value: i2[e22], style: t22.style, styleSpec: t22.styleSpec }));
            break;
          case "has":
          case "!has":
            s2 = e2.B(i2[1]), 2 !== i2.length ? a2.push(new e2.V(o2, i2, 'filter array for "'.concat(i2[0], '" operator must have 2 elements'))) : "string" !== s2 && a2.push(new e2.V("".concat(o2, "[1]"), i2[1], "string expected, ".concat(s2, " found")));
        }
        return a2;
      }
      function ee2(t22, i2) {
        const o2 = t22.key, r22 = t22.style, s2 = t22.layer, a2 = t22.styleSpec, n22 = t22.value, l22 = t22.objectKey, c22 = a2["".concat(i2, "_").concat(t22.layerType)];
        if (!c22)
          return [];
        const h22 = l22.match(/^(.*)-transition$/);
        if ("paint" === i2 && h22 && c22[h22[1]] && c22[h22[1]].transition)
          return _e({ key: o2, value: n22, valueSpec: a2.transition, style: r22, styleSpec: a2 });
        const u22 = t22.valueSpec || c22[l22];
        if (!u22)
          return [new e2.A(o2, n22, 'unknown property "'.concat(l22, '"'))];
        let d22;
        if ("string" === e2.B(n22) && e2.G(u22) && !u22.tokens && (d22 = /^{([^}]+)}$/.exec(n22))) {
          const t3 = '`{ "type": "identity", "property": '.concat(d22 ? JSON.stringify(d22[1]) : '"_"', " }`");
          return [new e2.V(o2, n22, '"'.concat(l22, '" does not support interpolation syntax\nUse an identity property function instead: ').concat(t3, "."))];
        }
        const _2 = [];
        if ("symbol" === t22.layerType)
          "text-field" !== l22 || !r22 || r22.glyphs || r22.imports || _2.push(new e2.V(o2, n22, 'use of "text-field" requires a style "glyphs" property')), "text-font" === l22 && e2.X(e2.K(n22)) && "identity" === e2.D(n22.type) && _2.push(new e2.V(o2, n22, '"text-font" does not support identity functions'));
        else if ("model" === t22.layerType && "paint" === i2 && s2 && s2.layout && s2.layout.hasOwnProperty("model-id") && e2.G(u22) && (e2.Y(u22) || e2.H(u22))) {
          const t3 = e2.L(e2.K(n22), u22), i3 = t3.value.expression || t3.value._styleExpression.expression;
          i3 && !e2.O(i3, ["measure-light"]) && ("model-emissive-strength" === l22 && e2.Q(i3) && e2.N(i3) || _2.push(new e2.V(o2, n22, "".concat(l22, " does not support measure-light expressions when the model layer source is vector tile or GeoJSON."))));
        }
        return _2.concat(_e({ key: t22.key, value: n22, valueSpec: u22, style: r22, styleSpec: a2, expressionContext: "property", propertyType: i2, propertyKey: l22 }));
      }
      function te2(e22) {
        return ee2(e22, "paint");
      }
      function ie2(e22) {
        return ee2(e22, "layout");
      }
      function oe2(t22) {
        let i2 = [];
        const o2 = t22.value, r22 = t22.key, s2 = t22.style, a2 = t22.styleSpec;
        o2.type || o2.ref || i2.push(new e2.V(r22, o2, 'either "type" or "ref" is required'));
        let n22 = e2.D(o2.type);
        const l22 = e2.D(o2.ref);
        if (o2.id) {
          const a3 = e2.D(o2.id);
          for (let n3 = 0; n3 < t22.arrayIndex; n3++) {
            const t3 = s2.layers[n3];
            e2.D(t3.id) === a3 && i2.push(new e2.V(r22, o2.id, 'duplicate layer id "'.concat(o2.id, '", previously used at line ').concat(t3.id.__line__)));
          }
        }
        if ("ref" in o2) {
          let t3;
          ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
            t4 in o2 && i2.push(new e2.V(r22, o2[t4], '"'.concat(t4, '" is prohibited for ref layers')));
          }), s2.layers.forEach((i3) => {
            e2.D(i3.id) === l22 && (t3 = i3);
          }), t3 ? t3.ref ? i2.push(new e2.V(r22, o2.ref, "ref cannot reference another ref layer")) : n22 = e2.D(t3.type) : "string" == typeof l22 && i2.push(new e2.V(r22, o2.ref, 'ref layer "'.concat(l22, '" not found')));
        } else if ("background" !== n22 && "sky" !== n22 && "slot" !== n22)
          if (o2.source) {
            const t3 = s2.sources && s2.sources[o2.source], a3 = t3 && e2.D(t3.type);
            t3 ? "vector" === a3 && "raster" === n22 ? i2.push(new e2.V(r22, o2.source, 'layer "'.concat(o2.id, '" requires a raster source'))) : "raster" === a3 && "raster" !== n22 ? i2.push(new e2.V(r22, o2.source, 'layer "'.concat(o2.id, '" requires a vector source'))) : "vector" !== a3 || o2["source-layer"] ? "raster-dem" === a3 && "hillshade" !== n22 ? i2.push(new e2.V(r22, o2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "raster-array" !== a3 || ["raster", "raster-particle"].includes(n22) ? "line" !== n22 || !o2.paint || !o2.paint["line-gradient"] && !o2.paint["line-trim-offset"] || "geojson" === a3 && t3.lineMetrics ? "raster-particle" === n22 && "raster-array" !== a3 && i2.push(new e2.V(r22, o2.source, 'layer "'.concat(o2.id, "\" requires a 'raster-array' source."))) : i2.push(new e2.V(r22, o2, 'layer "'.concat(o2.id, '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.'))) : i2.push(new e2.V(r22, o2.source, "raster-array source can only be used with layer type 'raster'.")) : i2.push(new e2.V(r22, o2, 'layer "'.concat(o2.id, '" must specify a "source-layer"'))) : i2.push(new e2.V(r22, o2.source, 'source "'.concat(o2.source, '" not found')));
          } else
            i2.push(new e2.V(r22, o2, 'missing required property "source"'));
        return i2 = i2.concat(Z2({ key: r22, value: o2, valueSpec: a2.layer, style: t22.style, styleSpec: t22.styleSpec, objectElementValidators: { "*": () => [], type: () => _e({ key: "".concat(r22, ".type"), value: o2.type, valueSpec: a2.layer.type, style: t22.style, styleSpec: t22.styleSpec, object: o2, objectKey: "type" }), filter: (t3) => J2(e2.C({ layerType: n22 }, t3)), layout: (t3) => Z2({ layer: o2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => ie2(e2.C({ layerType: n22 }, t4)) } }), paint: (t3) => Z2({ layer: o2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => te2(e2.C({ layerType: n22, layer: o2 }, t4)) } }) } })), i2;
      }
      function re2(t22) {
        const i2 = t22.value, o2 = t22.key, r22 = e2.B(i2);
        return "string" !== r22 ? [new e2.V(o2, i2, "string expected, ".concat(r22, " found"))] : [];
      }
      const se2 = { promoteId: function({ key: t22, value: i2 }) {
        if ("string" === e2.B(i2))
          return re2({ key: t22, value: i2 });
        {
          const e22 = [];
          for (const o2 in i2)
            e22.push(...re2({ key: "".concat(t22, ".").concat(o2), value: i2[o2] }));
          return e22;
        }
      } };
      function ae2(t22) {
        const i2 = t22.value, o2 = t22.key, r22 = t22.styleSpec, s2 = t22.style;
        if (!i2.type)
          return [new e2.V(o2, i2, '"type" is required')];
        const a2 = e2.D(i2.type);
        let n22 = [];
        switch (["vector", "raster", "raster-dem", "raster-array"].includes(a2) && (i2.url || i2.tiles || n22.push(new e2.A(o2, i2, 'Either "url" or "tiles" is required.'))), a2) {
          case "vector":
          case "raster":
          case "raster-dem":
          case "raster-array":
            return n22 = n22.concat(Z2({ key: o2, value: i2, valueSpec: r22["source_".concat(a2.replace("-", "_"))], style: t22.style, styleSpec: r22, objectElementValidators: se2 })), n22;
          case "geojson":
            if (n22 = Z2({ key: o2, value: i2, valueSpec: r22.source_geojson, style: s2, styleSpec: r22, objectElementValidators: se2 }), i2.cluster)
              for (const e22 in i2.clusterProperties) {
                const [t3, r3] = i2.clusterProperties[e22], s3 = "string" == typeof t3 ? [t3, ["accumulated"], ["get", e22]] : t3;
                n22.push(...X2({ key: "".concat(o2, ".").concat(e22, ".map"), value: r3, expressionContext: "cluster-map" })), n22.push(...X2({ key: "".concat(o2, ".").concat(e22, ".reduce"), value: s3, expressionContext: "cluster-reduce" }));
              }
            return n22;
          case "video":
            return Z2({ key: o2, value: i2, valueSpec: r22.source_video, style: s2, styleSpec: r22 });
          case "image":
            return Z2({ key: o2, value: i2, valueSpec: r22.source_image, style: s2, styleSpec: r22 });
          case "canvas":
            return [new e2.V(o2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return K2({ key: "".concat(o2, ".type"), value: i2.type, valueSpec: { values: ne2(r22) }, style: s2, styleSpec: r22 });
        }
      }
      function ne2(e22) {
        return e22.source.reduce((t22, i2) => {
          const o2 = e22[i2];
          return "enum" === o2.type.type && (t22 = t22.concat(Object.keys(o2.type.values))), t22;
        }, []);
      }
      function le2(t22) {
        const i2 = t22.value, o2 = t22.styleSpec, r22 = o2.light, s2 = t22.style;
        let a2 = [];
        const n22 = e2.B(i2);
        if (void 0 === i2)
          return a2;
        if ("object" !== n22)
          return a2 = a2.concat([new e2.V("light", i2, "object expected, ".concat(n22, " found"))]), a2;
        for (const t3 in i2) {
          const n3 = t3.match(/^(.*)-transition$/);
          a2 = a2.concat(n3 && r22[n3[1]] && r22[n3[1]].transition ? _e({ key: t3, value: i2[t3], valueSpec: o2.transition, style: s2, styleSpec: o2 }) : r22[t3] ? _e({ key: t3, value: i2[t3], valueSpec: r22[t3], style: s2, styleSpec: o2 }) : [new e2.V(t3, i2[t3], 'unknown property "'.concat(t3, '"'))]);
        }
        return a2;
      }
      function ce2(t22) {
        const i2 = t22.value;
        let o2 = [];
        if (!i2)
          return o2;
        const r22 = e2.B(i2);
        if ("object" !== r22)
          return o2 = o2.concat([new e2.V("light-3d", i2, "object expected, ".concat(r22, " found"))]), o2;
        const s2 = t22.styleSpec, a2 = s2["light-3d"], n22 = t22.key, l22 = t22.style, c22 = t22.style.lights;
        for (const t3 of ["type", "id"])
          if (!(t3 in i2))
            return o2 = o2.concat([new e2.V("light-3d", i2, "missing property ".concat(t3, " on light"))]), o2;
        if (i2.type && c22)
          for (let r3 = 0; r3 < t22.arrayIndex; r3++) {
            const t3 = e2.D(i2.type), s3 = c22[r3];
            e2.D(s3.type) === t3 && o2.push(new e2.V(n22, i2.id, 'duplicate light type "'.concat(i2.type, '", previously defined at line ').concat(s3.id.__line__)));
          }
        const h22 = "properties_light_".concat(i2.type);
        if (!(h22 in s2))
          return o2 = o2.concat([new e2.V("light-3d", i2, "Invalid light type ".concat(i2.type))]), o2;
        const u22 = s2[h22];
        for (const r3 in i2)
          if ("properties" === r3) {
            const a3 = i2[r3], n3 = e2.B(a3);
            if ("object" !== n3)
              return o2 = o2.concat([new e2.V("properties", a3, "object expected, ".concat(n3, " found"))]), o2;
            for (const i3 in a3)
              o2 = o2.concat(u22[i3] ? _e({ key: i3, value: a3[i3], valueSpec: u22[i3], style: l22, styleSpec: s2 }) : [new e2.A(t22.key, a3[i3], 'unknown property "'.concat(i3, '"'))]);
          } else {
            const t3 = r3.match(/^(.*)-transition$/);
            o2 = o2.concat(t3 && a2[t3[1]] && a2[t3[1]].transition ? _e({ key: r3, value: i2[r3], valueSpec: s2.transition, style: l22, styleSpec: s2 }) : a2[r3] ? _e({ key: r3, value: i2[r3], valueSpec: a2[r3], style: l22, styleSpec: s2 }) : [new e2.A(r3, i2[r3], 'unknown property "'.concat(r3, '"'))]);
          }
        return o2;
      }
      function he2(t22) {
        const i2 = t22.value, o2 = t22.key, r22 = t22.style, s2 = t22.styleSpec, a2 = s2.terrain;
        let n22 = [];
        const l22 = e2.B(i2);
        if (void 0 === i2)
          return n22;
        if ("null" === l22)
          return n22;
        if ("object" !== l22)
          return n22 = n22.concat([new e2.V("terrain", i2, "object expected, ".concat(l22, " found"))]), n22;
        for (const t3 in i2) {
          const o3 = t3.match(/^(.*)-transition$/);
          n22 = n22.concat(o3 && a2[o3[1]] && a2[o3[1]].transition ? _e({ key: t3, value: i2[t3], valueSpec: s2.transition, style: r22, styleSpec: s2 }) : a2[t3] ? _e({ key: t3, value: i2[t3], valueSpec: a2[t3], style: r22, styleSpec: s2 }) : [new e2.A(t3, i2[t3], 'unknown property "'.concat(t3, '"'))]);
        }
        if (i2.source) {
          const t3 = r22.sources && r22.sources[i2.source], s3 = t3 && e2.D(t3.type);
          t3 ? "raster-dem" !== s3 && n22.push(new e2.V(o2, i2.source, "terrain cannot be used with a source of type ".concat(String(s3), ', it only be used with a "raster-dem" source type'))) : n22.push(new e2.V(o2, i2.source, 'source "'.concat(i2.source, '" not found')));
        } else
          n22.push(new e2.V(o2, i2, 'terrain is missing required property "source"'));
        return n22;
      }
      function ue2(t22) {
        const i2 = t22.value, o2 = t22.style, r22 = t22.styleSpec, s2 = r22.fog;
        let a2 = [];
        const n22 = e2.B(i2);
        if (void 0 === i2)
          return a2;
        if ("object" !== n22)
          return a2 = a2.concat([new e2.V("fog", i2, "object expected, ".concat(n22, " found"))]), a2;
        for (const t3 in i2) {
          const n3 = t3.match(/^(.*)-transition$/);
          a2 = a2.concat(n3 && s2[n3[1]] && s2[n3[1]].transition ? _e({ key: t3, value: i2[t3], valueSpec: r22.transition, style: o2, styleSpec: r22 }) : s2[t3] ? _e({ key: t3, value: i2[t3], valueSpec: s2[t3], style: o2, styleSpec: r22 }) : [new e2.A(t3, i2[t3], 'unknown property "'.concat(t3, '"'))]);
        }
        return a2;
      }
      const de2 = { "*": () => [], array: H2, boolean: function(t22) {
        const i2 = t22.value, o2 = t22.key, r22 = e2.B(i2);
        return "boolean" !== r22 ? [new e2.V(o2, i2, "boolean expected, ".concat(r22, " found"))] : [];
      }, number: W2, color: function(t22) {
        const i2 = t22.key, o2 = t22.value, r22 = e2.B(o2);
        return "string" !== r22 ? [new e2.V(i2, o2, "color expected, ".concat(r22, " found"))] : null === e2.U.parseCSSColor(o2) ? [new e2.V(i2, o2, 'color expected, "'.concat(o2, '" found'))] : [];
      }, enum: K2, filter: J2, function: $, layer: oe2, object: Z2, source: ae2, model: e2.Z, light: le2, "light-3d": ce2, terrain: he2, fog: ue2, string: re2, formatted: function(e22) {
        return 0 === re2(e22).length ? [] : X2(e22);
      }, resolvedImage: function(e22) {
        return 0 === re2(e22).length ? [] : X2(e22);
      }, projection: function(t22) {
        const i2 = t22.value, o2 = t22.styleSpec, r22 = o2.projection, s2 = t22.style;
        let a2 = [];
        const n22 = e2.B(i2);
        if ("object" === n22)
          for (const e22 in i2)
            a2 = a2.concat(_e({ key: e22, value: i2[e22], valueSpec: r22[e22], style: s2, styleSpec: o2 }));
        else
          "string" !== n22 && (a2 = a2.concat([new e2.V("projection", i2, "object or string expected, ".concat(n22, " found"))]));
        return a2;
      }, import: function(t22) {
        const { value: i2, styleSpec: o2 } = t22, { data: r22, ...s2 } = i2;
        Object.defineProperty(s2, "__line__", { value: i2.__line__, enumerable: false });
        let a2 = Z2(e2.C({}, t22, { value: s2, valueSpec: o2.import }));
        return "" === e2.D(s2.id) && a2.push(new e2.V("".concat(t22.key, ".id"), s2, "import id can't be an empty string")), r22 && (a2 = a2.concat(me2(r22, o2, { key: "".concat(t22.key, ".data") }))), a2;
      } };
      function _e(t22, i2 = false) {
        const o2 = t22.value, r22 = t22.valueSpec, s2 = t22.styleSpec;
        if (r22.expression && e2.X(e2.D(o2)))
          return $(t22);
        if (r22.expression && e2.J(e2.K(o2)))
          return X2(t22);
        if (r22.type && de2[r22.type]) {
          const o3 = de2[r22.type](t22);
          return true === i2 && o3.length > 0 && "array" === e2.B(t22.value) ? X2(t22) : o3;
        }
        return Z2(e2.C({}, t22, { valueSpec: r22.type ? s2[r22.type] : r22 }));
      }
      function pe2(t22) {
        const i2 = t22.value, o2 = t22.key, r22 = re2(t22);
        return r22.length || (-1 === i2.indexOf("{fontstack}") && r22.push(new e2.V(o2, i2, '"glyphs" url must include a "{fontstack}" token')), -1 === i2.indexOf("{range}") && r22.push(new e2.V(o2, i2, '"glyphs" url must include a "{range}" token'))), r22;
      }
      function me2(t22, i2 = e2._, o2 = {}) {
        return _e({ key: o2.key || "", value: t22, valueSpec: i2.$root, styleSpec: i2, style: t22, objectElementValidators: { glyphs: pe2, "*": () => [] } });
      }
      function fe2(t22, i2 = e2._) {
        return Ie2(me2(t22, i2));
      }
      const ge2 = (e22) => Ie2(ae2(e22)), ve2 = (e22) => Ie2(le2(e22)), xe = (e22) => Ie2(ce2(e22)), ye = (e22) => Ie2(he2(e22)), be2 = (e22) => Ie2(ue2(e22)), we2 = (e22) => Ie2(oe2(e22)), Te2 = (e22) => Ie2(J2(e22)), Ee2 = (e22) => Ie2(te2(e22)), Ce2 = (e22) => Ie2(ie2(e22)), Se2 = (t22) => Ie2(e2.Z(t22));
      function Ie2(e22) {
        return e22.slice().sort((e3, t22) => e3.line && t22.line ? e3.line - t22.line : 0);
      }
      function De2(t22, i2) {
        let o2 = false;
        if (i2 && i2.length)
          for (const r22 of i2)
            r22 instanceof e2.A ? e2.w(r22.message) : (t22.fire(new e2.t(new Error(r22.message))), o2 = true);
        return o2;
      }
      let Re2;
      class Ae2 extends e2.E {
        constructor(t22, i2 = "flat") {
          super(), this._transitionable = new e2.$(Re2 || (Re2 = new e2.a0({ anchor: new e2.a1(e2._.light.anchor), position: new e2.a2(e2._.light.position), color: new e2.a1(e2._.light.color), intensity: new e2.a1(e2._.light.intensity) }))), this.setLight(t22, i2), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(e22, t22, i2 = {}) {
          this._validate(ve2, e22, i2) || (this._transitionable.setTransitionOrValue(e22), this.id = t22);
        }
        updateTransitions(e22) {
          this._transitioning = this._transitionable.transitioned(e22, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e22) {
          this.properties = this._transitioning.possiblyEvaluate(e22);
        }
        _validate(t22, i2, o2) {
          return (!o2 || false !== o2.validate) && De2(this, t22.call(fe2, e2.l({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e2._ })));
        }
      }
      const Le2 = new e2.a0({ source: new e2.a1(e2._.terrain.source), exaggeration: new e2.a1(e2._.terrain.exaggeration) });
      let Pe2 = class extends e2.E {
        constructor(t22, i2, o2, r22) {
          super(), this.scope = o2, this._transitionable = new e2.$(Le2, o2, r22), this._transitionable.setTransitionOrValue(t22, r22), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i2;
        }
        get() {
          return this._transitionable.serialize();
        }
        set(e22, t22) {
          this._transitionable.setTransitionOrValue(e22, t22);
        }
        updateTransitions(e22) {
          this._transitioning = this._transitionable.transitioned(e22, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e22) {
          this.properties = this._transitioning.possiblyEvaluate(e22);
        }
        getExaggeration(t22) {
          return this._transitioning.possiblyEvaluate(new e2.a3(t22)).get("exaggeration");
        }
        isZoomDependent() {
          const t22 = this._transitionable._values.exaggeration;
          return null != t22 && null != t22.value && null != t22.value.expression && t22.value.expression instanceof e2.a4;
        }
      };
      const Me2 = 45, ze = 65, Oe2 = 0.05;
      function Fe2(t22, i2, o2, r22) {
        const s2 = e2.a7(Me2, ze, o2), [a2, n22] = ke2(t22, r22);
        let l22 = 1 - Math.min(1, Math.exp((i2 - a2) / (n22 - a2) * -6));
        return l22 *= l22 * l22, l22 = Math.min(1, 1.00747 * l22), l22 * s2 * t22.alpha;
      }
      function ke2(e22, t22) {
        const i2 = 0.5 / Math.tan(0.5 * t22);
        return [e22.range[0] + i2, e22.range[1] + i2];
      }
      function Be2(t22, i2, o2, r22, s2) {
        const a2 = e2.a6.vec3.transformMat4([], [i2, o2, r22], s2.mercatorFogMatrix);
        return Fe2(t22, e2.a6.vec3.length(a2), s2.pitch, s2._fov);
      }
      function Ne2(t22, i2, o2, r22, s2, a2, n22) {
        const l22 = [[o2, r22, 0], [s2, r22, 0], [s2, a2, 0], [o2, a2, 0]];
        let c22 = Number.MAX_VALUE, h22 = -Number.MAX_VALUE;
        for (const t3 of l22) {
          const o3 = e2.a6.vec3.transformMat4([], t3, i2), r3 = e2.a6.vec3.length(o3);
          c22 = Math.min(c22, r3), h22 = Math.max(h22, r3);
        }
        return [Fe2(t22, c22, n22.pitch, n22._fov), Fe2(t22, h22, n22.pitch, n22._fov)];
      }
      const Ue2 = new e2.a0({ range: new e2.a1(e2._.fog.range), color: new e2.a1(e2._.fog.color), "high-color": new e2.a1(e2._.fog["high-color"]), "space-color": new e2.a1(e2._.fog["space-color"]), "horizon-blend": new e2.a1(e2._.fog["horizon-blend"]), "star-intensity": new e2.a1(e2._.fog["star-intensity"]), "vertical-range": new e2.a1(e2._.fog["vertical-range"]) });
      class Ge2 extends e2.E {
        constructor(t22, i2, o2, r22) {
          super(), this._transitionable = new e2.$(Ue2, o2, new Map(r22)), this.set(t22, r22), this._transitioning = this._transitionable.untransitioned(), this._transform = i2, this.properties = new e2.a8(Ue2), this.scope = o2;
        }
        get state() {
          const t22 = this._transform, i2 = "globe" === t22.projection.name, o2 = e2.a9(t22.zoom), r22 = this.properties.get("range"), s2 = [0.5, 3];
          return { range: i2 ? [e2.aa(s2[0], r22[0], o2), e2.aa(s2[1], r22[1], o2)] : r22, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(t22, i2, o2 = {}) {
          if (this._validate(be2, t22, o2))
            return;
          const r22 = e2.l({}, t22);
          for (const t3 of Object.keys(e2._.fog))
            void 0 === r22[t3] && (r22[t3] = e2._.fog[t3].default);
          this._options = r22, this._transitionable.setTransitionOrValue(this._options, i2);
        }
        getOpacity(t22) {
          if (!this._transform.projection.supportsFog)
            return 0;
          const i2 = this.properties && this.properties.get("color") || 1;
          return ("globe" === this._transform.projection.name ? 1 : e2.a7(Me2, ze, t22)) * i2.a;
        }
        getOpacityAtLatLng(t22, i2) {
          return this._transform.projection.supportsFog ? function(t3, i3, o2) {
            const r22 = e2.a5.fromLngLat(i3), s2 = o2.elevation ? o2.elevation.getAtPointOrZero(r22) : 0;
            return Be2(t3, r22.x, r22.y, s2, o2);
          }(this.state, t22, i2) : 0;
        }
        getOpacityForTile(t22) {
          if (!this._transform.projection.supportsFog)
            return [1, 1];
          const i2 = this._transform.calculateFogTileMatrix(t22.toUnwrapped());
          return Ne2(this.state, i2, 0, 0, e2.ab, e2.ab, this._transform);
        }
        getOpacityForBounds(e22, t22, i2, o2, r22) {
          return this._transform.projection.supportsFog ? Ne2(this.state, e22, t22, i2, o2, r22, this._transform) : [1, 1];
        }
        getFovAdjustedRange(e22) {
          return this._transform.projection.supportsFog ? ke2(this.state, e22) : [0, 1];
        }
        isVisibleOnFrustum(t22) {
          if (!this._transform.projection.supportsFog)
            return false;
          const i2 = [4, 5, 6, 7];
          for (const o2 of i2) {
            const i3 = t22.points[o2];
            let r22;
            if (i3[2] >= 0)
              r22 = i3;
            else {
              const s2 = t22.points[o2 - 4];
              r22 = e2.ac(s2, i3, s2[2] / (s2[2] - i3[2]));
            }
            if (Be2(this.state, r22[0], r22[1], 0, this._transform) >= Oe2)
              return true;
          }
          return false;
        }
        updateConfig(e22) {
          this._transitionable.setTransitionOrValue(this._options, new Map(e22));
        }
        updateTransitions(e22) {
          this._transitioning = this._transitionable.transitioned(e22, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e22) {
          this.properties = this._transitioning.possiblyEvaluate(e22);
        }
        _validate(t22, i2, o2) {
          return (!o2 || false !== o2.validate) && De2(this, t22.call(fe2, e2.l({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e2._ })));
        }
      }
      class je2 extends e2.E {
        constructor(t22, i2, o2, r22) {
          super(), this.scope = o2, this._options = t22, this.properties = new e2.a8(i2), this._transitionable = new e2.$(i2, o2, new Map(r22)), this._transitionable.setTransitionOrValue(t22.properties), this._transitioning = this._transitionable.untransitioned();
        }
        updateConfig(e22) {
          this._transitionable.setTransitionOrValue(this._options.properties, new Map(e22));
        }
        updateTransitions(e22) {
          this._transitioning = this._transitionable.transitioned(e22, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e22) {
          this.properties = this._transitioning.possiblyEvaluate(e22);
        }
        get() {
          return this._options.properties = this._transitionable.serialize(), this._options;
        }
        set(e22, t22) {
          this._options = e22, this._transitionable.setTransitionOrValue(e22.properties, t22);
        }
        shadowsEnabled() {
          return !!this.properties && true === this.properties.get("cast-shadows");
        }
      }
      let Ve2, qe2;
      class Ze2 {
        constructor(e22, t22, i2, o2) {
          this.screenBounds = e22, this.cameraPoint = t22, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i2, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o2);
        }
        static createFromScreenPoints(t22, i2) {
          let o2, r22;
          if (t22 instanceof e2.P || "number" == typeof t22[0]) {
            const s2 = e2.P.convert(t22);
            o2 = [s2], r22 = i2.isPointAboveHorizon(s2);
          } else {
            const s2 = e2.P.convert(t22[0]), a2 = e2.P.convert(t22[1]);
            o2 = [s2, a2], r22 = e2.ae(s2, a2).every((e22) => i2.isPointAboveHorizon(e22));
          }
          return new Ze2(o2, i2.getCameraPoint(), r22, i2);
        }
        isPointQuery() {
          return 1 === this.screenBounds.length;
        }
        bufferedScreenGeometry(t22) {
          return e2.ae(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t22);
        }
        bufferedCameraGeometry(t22) {
          const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e2.P(1, 1)) : this.screenBounds[1], r22 = e2.ae(i2, o2, 0, false);
          return this.cameraPoint.y > o2.y && (this.cameraPoint.x > i2.x && this.cameraPoint.x < o2.x ? r22.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o2.x ? r22[2] = this.cameraPoint : this.cameraPoint.x <= i2.x && (r22[3] = this.cameraPoint)), e2.af(r22, t22);
        }
        bufferedCameraGeometryGlobe(t22) {
          const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e2.P(1, 1)) : this.screenBounds[1], r22 = e2.ae(i2, o2, t22), s2 = this.cameraPoint.clone();
          switch (3 * ((s2.y > i2.y) + (s2.y > o2.y)) + ((s2.x > i2.x) + (s2.x > o2.x))) {
            case 0:
              r22[0] = s2, r22[4] = s2.clone();
              break;
            case 1:
              r22.splice(1, 0, s2);
              break;
            case 2:
              r22[1] = s2;
              break;
            case 3:
              r22.splice(4, 0, s2);
              break;
            case 5:
              r22.splice(2, 0, s2);
              break;
            case 6:
              r22[3] = s2;
              break;
            case 7:
              r22.splice(3, 0, s2);
              break;
            case 8:
              r22[2] = s2;
          }
          return r22;
        }
        containsTile(t22, i2, o2, r22 = 0) {
          const s2 = t22.queryPadding / i2._pixelsPerMercatorPixel + 1, a2 = o2 ? this._bufferedCameraMercator(s2, i2) : this._bufferedScreenMercator(s2, i2);
          let n22 = t22.tileID.wrap + (a2.unwrapped ? r22 : 0);
          const l22 = a2.polygon.map((i3) => e2.ag(t22.tileTransform, i3, n22));
          if (!e2.ah(l22, 0, 0, e2.ab, e2.ab))
            return;
          n22 = t22.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r22 : 0);
          const c22 = this.screenGeometryMercator.polygon.map((i3) => e2.ai(t22.tileTransform, i3, n22)), h22 = c22.map((t3) => new e2.P(t3[0], t3[1])), u22 = i2.getFreeCameraOptions().position || new e2.a5(0, 0, 0), d22 = e2.ai(t22.tileTransform, u22, n22), _2 = c22.map((t3) => {
            const i3 = e2.a6.vec3.sub(t3, t3, d22);
            return e2.a6.vec3.normalize(i3, i3), new e2.aj(d22, i3);
          }), p22 = e2.ak(t22, 1, i2.zoom) * i2._pixelsPerMercatorPixel;
          return { queryGeometry: this, tilespaceGeometry: h22, tilespaceRays: _2, bufferedTilespaceGeometry: l22, bufferedTilespaceBounds: (m22 = e2.al(l22), m22.min.x = e2.ap(m22.min.x, 0, e2.ab), m22.min.y = e2.ap(m22.min.y, 0, e2.ab), m22.max.x = e2.ap(m22.max.x, 0, e2.ab), m22.max.y = e2.ap(m22.max.y, 0, e2.ab), m22), tile: t22, tileID: t22.tileID, pixelToTileUnitsFactor: p22 };
          var m22;
        }
        _bufferedScreenMercator(e22, t22) {
          const i2 = $e2(e22);
          if (this._screenRaycastCache[i2])
            return this._screenRaycastCache[i2];
          {
            let o2;
            return o2 = "globe" === t22.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e22), t22) : { polygon: this.bufferedScreenGeometry(e22).map((e3) => t22.pointCoordinate3D(e3)), unwrapped: true }, this._screenRaycastCache[i2] = o2, o2;
          }
        }
        _bufferedCameraMercator(e22, t22) {
          const i2 = $e2(e22);
          if (this._cameraRaycastCache[i2])
            return this._cameraRaycastCache[i2];
          {
            let o2;
            return o2 = "globe" === t22.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e22), t22) : { polygon: this.bufferedCameraGeometry(e22).map((e3) => t22.pointCoordinate3D(e3)), unwrapped: true }, this._cameraRaycastCache[i2] = o2, o2;
          }
        }
        _projectAndResample(t22, i2) {
          const o2 = function(t3, i3) {
            const o3 = e2.a6.mat4.multiply([], i3.pixelMatrix, i3.globeMatrix), r3 = [0, -e2.aq, 0, 1], s2 = [0, e2.aq, 0, 1], a2 = [0, 0, 0, 1];
            e2.a6.vec4.transformMat4(r3, r3, o3), e2.a6.vec4.transformMat4(s2, s2, o3), e2.a6.vec4.transformMat4(a2, a2, o3);
            const n22 = new e2.P(r3[0] / r3[3], r3[1] / r3[3]), l22 = new e2.P(s2[0] / s2[3], s2[1] / s2[3]), c22 = e2.an(t3, n22) && r3[3] < a2[3], h22 = e2.an(t3, l22) && s2[3] < a2[3];
            if (!c22 && !h22)
              return null;
            const u22 = function(e22, t4, i4) {
              for (let o4 = 1; o4 < e22.length; o4++) {
                const r4 = We2(t4.pointCoordinate3D(e22[o4 - 1]).x), s3 = We2(t4.pointCoordinate3D(e22[o4]).x);
                if (i4 < 0) {
                  if (r4 < s3)
                    return { idx: o4, t: -r4 / (s3 - 1 - r4) };
                } else if (s3 < r4)
                  return { idx: o4, t: (1 - r4) / (s3 + 1 - r4) };
              }
              return null;
            }(t3, i3, c22 ? -1 : 1);
            if (!u22)
              return null;
            const { idx: d22, t: _2 } = u22;
            let p22 = d22 > 1 ? He2(t3.slice(0, d22), i3) : [], m22 = d22 < t3.length ? He2(t3.slice(d22), i3) : [];
            p22 = p22.map((t4) => new e2.P(We2(t4.x), t4.y)), m22 = m22.map((t4) => new e2.P(We2(t4.x), t4.y));
            const f22 = [...p22];
            0 === f22.length && f22.push(m22[m22.length - 1]);
            const g22 = e2.aa(f22[f22.length - 1].y, (0 === m22.length ? p22[0] : m22[0]).y, _2);
            let v22;
            return v22 = c22 ? [new e2.P(0, g22), new e2.P(0, 0), new e2.P(1, 0), new e2.P(1, g22)] : [new e2.P(1, g22), new e2.P(1, 1), new e2.P(0, 1), new e2.P(0, g22)], f22.push(...v22), 0 === m22.length ? f22.push(p22[0]) : f22.push(...m22), { polygon: f22.map((t4) => new e2.a5(t4.x, t4.y)), unwrapped: false };
          }(t22, i2);
          if (o2)
            return o2;
          const r22 = function(t3, i3) {
            let o3 = false, r3 = -1 / 0, s2 = 0;
            for (let e22 = 0; e22 < t3.length - 1; e22++)
              t3[e22].x > r3 && (r3 = t3[e22].x, s2 = e22);
            for (let e22 = 0; e22 < t3.length - 1; e22++) {
              const i4 = (s2 + e22) % (t3.length - 1), r4 = t3[i4], a3 = t3[i4 + 1];
              Math.abs(r4.x - a3.x) > 0.5 && (r4.x < a3.x ? (r4.x += 1, 0 === i4 && (t3[t3.length - 1].x += 1)) : (a3.x += 1, i4 + 1 === t3.length - 1 && (t3[0].x += 1)), o3 = true);
            }
            const a2 = e2.am(i3.center.lng);
            return o3 && a2 < Math.abs(a2 - 1) && t3.forEach((e22) => {
              e22.x -= 1;
            }), { polygon: t3, unwrapped: o3 };
          }(He2(t22, i2).map((t3) => new e2.P(We2(t3.x), t3.y)), i2);
          return { polygon: r22.polygon.map((t3) => new e2.a5(t3.x, t3.y)), unwrapped: r22.unwrapped };
        }
      }
      function He2(t22, i2) {
        return e2.ao(t22, (e22) => {
          const t3 = i2.pointCoordinate3D(e22);
          e22.x = t3.x, e22.y = t3.y;
        }, 1 / 256);
      }
      function We2(e22) {
        return e22 < 0 ? 1 + e22 % 1 : e22 % 1;
      }
      function $e2(e22) {
        return 100 * e22 | 0;
      }
      function Xe2(t22, i2, o2, r22, s2) {
        const a2 = function(o3, r3) {
          if (o3)
            return s2(o3);
          if (r3) {
            if (t22.url && r3.tiles && t22.tiles && delete t22.tiles, r3.variants) {
              if (!Array.isArray(r3.variants))
                return s2(new Error("variants must be an array"));
              for (const t3 of r3.variants) {
                if (null == t3 || "object" != typeof t3 || t3.constructor !== Object)
                  return s2(new Error("variant must be an object"));
                if (!Array.isArray(t3.capabilities))
                  return s2(new Error("capabilities must be an array"));
                if (1 === t3.capabilities.length && "meshopt" === t3.capabilities[0]) {
                  r3 = e2.l(r3, t3);
                  break;
                }
              }
            }
            const o4 = e2.ar(e2.l(r3, t22), ["tilejson", "tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
            r3.vector_layers && (o4.vectorLayers = r3.vector_layers, o4.vectorLayerIds = o4.vectorLayers.map((e22) => e22.id)), r3.raster_layers && (o4.rasterLayers = r3.raster_layers, o4.rasterLayerIds = o4.rasterLayers.map((e22) => e22.id)), o4.tiles = i2.canonicalizeTileset(o4, t22.url), s2(null, o4);
          }
        }, n22 = function(e22, t3, i3) {
          if (!e22)
            return null;
          if (!t3 && !i3)
            return e22;
          i3 = i3 || e22.worldview_default;
          const o3 = Object.values(e22.language || {});
          if (0 === o3.length)
            return null;
          const r3 = Object.values(e22.worldview || {});
          if (0 === r3.length)
            return null;
          const s3 = o3.every((e3) => e3 === t3), a3 = r3.every((e3) => e3 === i3);
          return s3 && a3 ? e22 : t3 in (e22.language_options || {}) || i3 in (e22.worldview_options || {}) ? null : e22.language_options && e22.worldview_options ? e22 : null;
        }(t22.data, o2, r22);
        return n22 ? e2.q.frame(() => a2(null, n22)) : t22.url ? e2.n(i2.transformRequest(i2.normalizeSourceURL(t22.url, null, o2, r22), e2.R.Source), a2) : e2.q.frame(() => {
          const { data: e22, ...i3 } = t22;
          a2(null, i3);
        });
      }
      class Ye2 {
        constructor(t22, i2, o2) {
          this.bounds = e2.as.convert(this.validateBounds(t22)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
        }
        validateBounds(e22) {
          return Array.isArray(e22) && 4 === e22.length ? [Math.max(-180, e22[0]), Math.max(-90, e22[1]), Math.min(180, e22[2]), Math.min(90, e22[3])] : [-180, -90, 180, 90];
        }
        contains(t22) {
          const i2 = Math.pow(2, t22.z), o2 = Math.floor(e2.am(this.bounds.getWest()) * i2), r22 = Math.floor(e2.at(this.bounds.getNorth()) * i2), s2 = Math.ceil(e2.am(this.bounds.getEast()) * i2), a2 = Math.ceil(e2.at(this.bounds.getSouth()) * i2);
          return t22.x >= o2 && t22.x < s2 && t22.y >= r22 && t22.y < a2;
        }
      }
      class Ke2 extends e2.E {
        constructor(t22, i2, o2, r22) {
          if (super(), this.id = t22, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e2.l(this, e2.ar(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = e2.l({ type: "vector" }, i2), this._collectResourceTiming = !!i2.collectResourceTiming, 512 !== this.tileSize)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(r22), this._tileWorkers = {}, this._deduped = new e2.au();
        }
        load(t22) {
          this._loaded = false, this.fire(new e2.x("dataloading", { dataType: "source" }));
          const i2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map._worldview;
          this._tileJSONRequest = Xe2(this._options, this.map._requestManager, i2, o2, (r22, s2) => {
            this._tileJSONRequest = null, this._loaded = true, r22 ? (i2 && console.warn("Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ".concat(i2)), o2 && 2 !== o2.length && console.warn("Requested worldview strings must be a valid ISO alpha-2 code. Found: ".concat(o2)), this.fire(new e2.t(r22))) : s2 && (e2.l(this, s2), s2.bounds && (this.tileBounds = new Ye2(s2.bounds, this.minzoom, this.maxzoom)), L2(s2.tiles, this.map._requestManager._customAccessToken), this.fire(new e2.x("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e2.x("data", { dataType: "source", sourceDataType: "content" }))), t22 && t22(r22);
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(e22) {
          return !this.tileBounds || this.tileBounds.contains(e22.canonical);
        }
        onAdd(e22) {
          this.map = e22, this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const t22 = e2.av(this.id, this.scope);
          this.load(() => this.map.style.clearSource(t22));
        }
        setTiles(e22) {
          return this._options.tiles = e22, this.reload(), this;
        }
        setUrl(e22) {
          return this.url = e22, this._options.url = e22, this.reload(), this;
        }
        onRemove(e22) {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return e2.l({}, this._options);
        }
        loadTile(t22, i2) {
          const o2 = this.map._requestManager.normalizeTileURL(t22.tileID.canonical.url(this.tiles, this.scheme)), r22 = this.map._requestManager.transformRequest(o2, e2.R.Tile), s2 = this.map.style ? this.map.style.getLut(this.scope) : null, a2 = { request: r22, data: void 0, uid: t22.uid, tileID: t22.tileID, tileZoom: t22.tileZoom, zoom: t22.tileID.overscaledZ, lut: s2 ? { image: s2.image.clone() } : null, tileSize: this.tileSize * t22.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: e2.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t22.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t22.isExtraShadowCaster, tessellationStep: this.map._tessellationStep };
          if (a2.request.collectResourceTiming = this._collectResourceTiming, t22.actor && "expired" !== t22.state)
            "loading" === t22.state ? t22.reloadCallback = i2 : t22.request = t22.actor.send("reloadTile", a2, n22.bind(this));
          else if (t22.actor = this._tileWorkers[o2] = this._tileWorkers[o2] || this.dispatcher.getActor(), this.dispatcher.ready)
            t22.request = t22.actor.send("loadTile", a2, n22.bind(this), void 0, true);
          else {
            const i3 = e2.aw.call({ deduped: this._deduped }, a2, (e22, i4) => {
              e22 || !i4 ? n22.call(this, e22) : (a2.data = { cacheControl: i4.cacheControl, expires: i4.expires, rawData: i4.rawData.slice(0) }, t22.actor && t22.actor.send("loadTile", a2, n22.bind(this), void 0, true));
            }, true);
            t22.request = { cancel: i3 };
          }
          function n22(o3, r3) {
            return delete t22.request, t22.aborted ? i2(null) : o3 && 404 !== o3.status ? i2(o3) : (r3 && r3.resourceTiming && (t22.resourceTiming = r3.resourceTiming), this.map._refreshExpiredTiles && r3 && t22.setExpiryData(r3), t22.loadVectorData(r3, this.map.painter), e2.ax(this.dispatcher), i2(null), void (t22.reloadCallback && (this.loadTile(t22, t22.reloadCallback), t22.reloadCallback = null)));
          }
        }
        abortTile(e22) {
          e22.request && (e22.request.cancel(), delete e22.request), e22.actor && e22.actor.send("abortTile", { uid: e22.uid, type: this.type, source: this.id, scope: this.scope });
        }
        unloadTile(e22, t22) {
          e22.actor && e22.actor.send("removeTile", { uid: e22.uid, type: this.type, source: this.id, scope: this.scope }), e22.destroy();
        }
        hasTransition() {
          return false;
        }
        afterUpdate() {
          this._tileWorkers = {};
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      class Je2 extends e2.E {
        constructor(t22, i2, o2, r22) {
          super(), this.id = t22, this.dispatcher = o2, this.setEventedParent(r22), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e2.l({ type: "raster" }, i2), e2.l(this, e2.ar(i2, ["url", "scheme", "tileSize"]));
        }
        load(t22) {
          this._loaded = false, this.fire(new e2.x("dataloading", { dataType: "source" })), this._tileJSONRequest = Xe2(this._options, this.map._requestManager, null, null, (i2, o2) => {
            this._tileJSONRequest = null, this._loaded = true, i2 ? this.fire(new e2.t(i2)) : o2 && (e2.l(this, o2), o2.bounds && (this.tileBounds = new Ye2(o2.bounds, this.minzoom, this.maxzoom)), L2(o2.tiles), this.fire(new e2.x("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e2.x("data", { dataType: "source", sourceDataType: "content" }))), t22 && t22(i2);
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e22) {
          this.map = e22, this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const t22 = e2.av(this.id, this.scope);
          this.load(() => this.map.style.clearSource(t22));
        }
        setTiles(e22) {
          return this._options.tiles = e22, this.reload(), this;
        }
        setUrl(e22) {
          return this.url = e22, this._options.url = e22, this.reload(), this;
        }
        onRemove(e22) {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return e2.l({}, this._options);
        }
        hasTile(e22) {
          return !this.tileBounds || this.tileBounds.contains(e22.canonical);
        }
        loadTile(t22, i2) {
          const o2 = e2.q.devicePixelRatio >= 2, r22 = this.map._requestManager.normalizeTileURL(t22.tileID.canonical.url(this.tiles, this.scheme), o2, this.tileSize);
          t22.request = e2.o(this.map._requestManager.transformRequest(r22, e2.R.Tile), (o3, r3, s2, a2) => (delete t22.request, t22.aborted ? (t22.state = "unloaded", i2(null)) : o3 ? (t22.state = "errored", i2(o3)) : r3 ? (this.map._refreshExpiredTiles && t22.setExpiryData({ cacheControl: s2, expires: a2 }), t22.setTexture(r3, this.map.painter), t22.state = "loaded", e2.ax(this.dispatcher), void i2(null)) : i2(null)));
        }
        abortTile(e22, t22) {
          e22.request && (e22.request.cancel(), delete e22.request), t22 && t22();
        }
        unloadTile(t22, i2) {
          t22.texture && t22.texture instanceof e2.T ? (t22.destroy(true), t22.texture && t22.texture instanceof e2.T && this.map.painter.saveTileTexture(t22.texture)) : t22.destroy(), i2 && i2();
        }
        hasTransition() {
          return false;
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      class Qe2 extends Je2 {
        constructor(t22, i2, o2, r22) {
          super(t22, i2, o2, r22), this.type = "raster-array", this.maxzoom = 22, this._options = e2.l({ type: "raster-array" }, i2);
        }
        triggerRepaint(e22) {
          const t22 = this.map.painter._terrain, i2 = this.map.style.getSourceCache(this.id);
          t22 && t22.enabled && i2 && t22._clearRenderCacheForTile(i2.id, e22.tileID), this.map.triggerRepaint();
        }
        loadTile(t22, i2) {
          const o2 = this.map._requestManager.normalizeTileURL(t22.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize), r22 = this.map._requestManager.transformRequest(o2, e2.R.Tile);
          t22.requestParams = r22, t22.actor || (t22.actor = this.dispatcher.getActor()), t22.request = t22.fetchHeader(void 0, (e22, o3, r3, s2) => {
            if (delete t22.request, t22.aborted)
              return t22.state = "unloaded", i2(null);
            if (e22) {
              if (20 === e22.code)
                return;
              return t22.state = "errored", i2(e22);
            }
            this.map._refreshExpiredTiles && t22.setExpiryData({ cacheControl: r3, expires: s2 }), t22.state = "empty", i2(null);
          });
        }
        unloadTile(t22, i2) {
          const o2 = t22.texture;
          o2 && o2 instanceof e2.T ? (t22.destroy(true), this.map.painter.saveTileTexture(o2)) : (t22.destroy(), t22.flushQueues(), t22._isHeaderLoaded = false, delete t22._mrt, delete t22.textureDescriptor), t22.fbo && (t22.fbo.destroy(), delete t22.fbo), delete t22.request, delete t22.requestParams, delete t22.neighboringTiles, t22.state = "unloaded";
        }
        prepareTile(t22, i2, o2) {
          t22._isHeaderLoaded && ("empty" !== t22.state && (t22.state = "reloading"), t22.fetchBand(i2, o2, (i3, o3) => {
            if (i3)
              return t22.state = "errored", this.fire(new e2.t(i3)), void this.triggerRepaint(t22);
            o3 && (t22.setTexture(o3, this.map.painter), t22.state = "loaded", this.triggerRepaint(t22));
          }));
        }
        getInitialBand(e22) {
          if (!this.rasterLayers)
            return 0;
          const t22 = this.rasterLayers.find(({ id: t3 }) => t3 === e22), i2 = t22 && t22.fields, o2 = i2 && i2.bands && i2.bands;
          return o2 ? o2[0] : 0;
        }
        getTextureDescriptor(t22, i2, o2) {
          if (!t22)
            return;
          const r22 = i2.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
          if (!r22)
            return;
          let s2 = null;
          i2 instanceof e2.aB ? s2 = i2.paint.get("raster-array-band") : i2 instanceof e2.aC && (s2 = i2.paint.get("raster-particle-array-band"));
          const a2 = s2 || this.getInitialBand(r22);
          if (null != a2)
            if (t22.textureDescriptor) {
              if (!t22.updateNeeded(r22, a2) || o2)
                return Object.assign({}, t22.textureDescriptor, { texture: t22.texture });
            } else
              this.prepareTile(t22, r22, a2);
        }
      }
      const et = { vector: Ke2, raster: Je2, "raster-dem": class extends Je2 {
        constructor(t22, i2, o2, r22) {
          super(t22, i2, o2, r22), this.type = "raster-dem", this.maxzoom = 22, this._options = e2.l({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
        }
        loadTile(t22, i2) {
          const o2 = this.map._requestManager.normalizeTileURL(t22.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
          function r22(e22, o3) {
            e22 && (t22.state = "errored", i2(e22)), o3 && (t22.dem = o3, t22.dem.onDeserialize(), t22.needsHillshadePrepare = true, t22.needsDEMTextureUpload = true, t22.state = "loaded", i2(null));
          }
          t22.request = e2.o(this.map._requestManager.transformRequest(o2, e2.R.Tile), (function(o3, s2, a2, n22) {
            if (delete t22.request, t22.aborted)
              t22.state = "unloaded", i2(null);
            else if (o3)
              t22.state = "errored", i2(o3);
            else if (s2) {
              this.map._refreshExpiredTiles && t22.setExpiryData({ cacheControl: a2, expires: n22 });
              const i3 = ImageBitmap && s2 instanceof ImageBitmap && e2.ay(), o4 = 1 - (s2.width - e2.az(s2.width)) / 2;
              o4 < 1 || t22.neighboringTiles || (t22.neighboringTiles = this._getNeighboringTiles(t22.tileID));
              const l22 = i3 ? s2 : e2.q.getImageData(s2, o4), c22 = { uid: t22.uid, coord: t22.tileID, source: this.id, scope: this.scope, rawImageData: l22, encoding: this.encoding, padding: o4 };
              t22.actor && "expired" !== t22.state || (t22.actor = this.dispatcher.getActor(), t22.actor.send("loadDEMTile", c22, r22.bind(this), void 0, true));
            }
          }).bind(this));
        }
        _getNeighboringTiles(t22) {
          const i2 = t22.canonical, o2 = Math.pow(2, i2.z), r22 = (i2.x - 1 + o2) % o2, s2 = 0 === i2.x ? t22.wrap - 1 : t22.wrap, a2 = (i2.x + 1 + o2) % o2, n22 = i2.x + 1 === o2 ? t22.wrap + 1 : t22.wrap, l22 = {};
          return l22[new e2.aA(t22.overscaledZ, s2, i2.z, r22, i2.y).key] = { backfilled: false }, l22[new e2.aA(t22.overscaledZ, n22, i2.z, a2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l22[new e2.aA(t22.overscaledZ, s2, i2.z, r22, i2.y - 1).key] = { backfilled: false }, l22[new e2.aA(t22.overscaledZ, t22.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l22[new e2.aA(t22.overscaledZ, n22, i2.z, a2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l22[new e2.aA(t22.overscaledZ, s2, i2.z, r22, i2.y + 1).key] = { backfilled: false }, l22[new e2.aA(t22.overscaledZ, t22.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l22[new e2.aA(t22.overscaledZ, n22, i2.z, a2, i2.y + 1).key] = { backfilled: false }), l22;
        }
      }, "raster-array": Qe2, geojson: class extends e2.E {
        constructor(t22, i2, o2, r22) {
          super(), this.id = t22, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o2.getActor(), this.setEventedParent(r22), this._data = i2.data, this._options = e2.l({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), void 0 !== i2.minzoom && (this.minzoom = i2.minzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
          const s2 = e2.ab / this.tileSize;
          this.workerOptions = e2.l({ source: this.id, scope: this.scope, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i2.buffer ? i2.buffer : 128) * s2, tolerance: (void 0 !== i2.tolerance ? i2.tolerance : 0.375) * s2, extent: e2.ab, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i2.clusterMaxZoom ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: e2.ab, radius: (void 0 !== i2.clusterRadius ? i2.clusterRadius : 50) * s2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter, dynamic: i2.dynamic }, i2.workerOptions);
        }
        onAdd(e22) {
          this.map = e22, this.setData(this._data);
        }
        setData(e22) {
          return this._data = e22, this._updateWorkerData(), this;
        }
        updateData(t22) {
          if (!this._options.dynamic)
            return this.fire(new e2.t(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
          if ("string" != typeof t22 && ("Feature" === t22.type && (t22 = { type: "FeatureCollection", features: [t22] }), "FeatureCollection" !== t22.type))
            return this.fire(new e2.t(new Error("Data to update should be a feature or a feature collection.")));
          if (this._coalesce && "string" != typeof t22 && "string" != typeof this._data && "FeatureCollection" === this._data.type) {
            const e22 = /* @__PURE__ */ new Map();
            for (const t3 of this._data.features)
              e22.set(t3.id, t3);
            for (const i2 of t22.features)
              e22.set(i2.id, i2);
            this._data.features = [...e22.values()];
          } else
            this._data = t22;
          return this._updateWorkerData(true), this;
        }
        getClusterExpansionZoom(e22, t22) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e22, source: this.id, scope: this.scope }, t22), this;
        }
        getClusterChildren(e22, t22) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: e22, source: this.id, scope: this.scope }, t22), this;
        }
        getClusterLeaves(e22, t22, i2, o2) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, scope: this.scope, clusterId: e22, limit: t22, offset: i2 }, o2), this;
        }
        _updateWorkerData(t22 = false) {
          if (this._pendingLoad)
            return void (this._coalesce = true);
          this.fire(new e2.x("dataloading", { dataType: "source" })), this._loaded = false;
          const i2 = e2.l({ append: t22 }, this.workerOptions);
          i2.scope = this.scope;
          const o2 = this._data;
          "string" == typeof o2 ? (i2.request = this.map._requestManager.transformRequest(e2.q.resolveURL(o2), e2.R.Source), i2.request.collectResourceTiming = this._collectResourceTiming) : i2.data = JSON.stringify(o2), this._pendingLoad = this.actor.send("".concat(this.type, ".loadData"), i2, (i3, o3) => {
            if (this._loaded = true, this._pendingLoad = null, i3)
              this.fire(new e2.t(i3));
            else {
              const i4 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
              this._collectResourceTiming && o3 && o3.resourceTiming && o3.resourceTiming[this.id] && (i4.resourceTiming = o3.resourceTiming[this.id]), t22 && (this._partialReload = true), this.fire(new e2.x("data", i4)), this._partialReload = false, this._metadataFired = true;
            }
            this._coalesce && (this._updateWorkerData(t22), this._coalesce = false);
          });
        }
        loaded() {
          return this._loaded;
        }
        loadTile(t22, i2) {
          const o2 = t22.actor ? "reloadTile" : "loadTile";
          t22.actor = this.actor;
          const r22 = this.map.style ? this.map.style.getLut(this.scope) : null, s2 = this._partialReload, a2 = { type: this.type, uid: t22.uid, tileID: t22.tileID, tileZoom: t22.tileZoom, zoom: t22.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, lut: r22 ? { image: r22.image.clone() } : null, scope: this.scope, pixelRatio: e2.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: this.map.style && this.map.style.getBrightness() || 0, partial: s2 };
          t22.request = this.actor.send(o2, a2, (e22, r3) => s2 && !r3 ? (t22.state = "loaded", i2(null)) : (delete t22.request, t22.destroy(), t22.aborted ? i2(null) : e22 ? i2(e22) : (t22.loadVectorData(r3, this.map.painter, "reloadTile" === o2), i2(null))), void 0, "loadTile" === o2);
        }
        abortTile(e22) {
          e22.request && (e22.request.cancel(), delete e22.request), e22.aborted = true;
        }
        unloadTile(e22, t22) {
          this.actor.send("removeTile", { uid: e22.uid, type: this.type, source: this.id, scope: this.scope }), e22.destroy();
        }
        onRemove(e22) {
          this._pendingLoad && this._pendingLoad.cancel();
        }
        serialize() {
          return e2.l({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return false;
        }
      }, video: class extends e2.aD {
        constructor(e22, t22, i2, o2) {
          super(e22, t22, i2, o2), this.roundZoom = true, this.type = "video", this.options = t22;
        }
        load() {
          this._loaded = false;
          const t22 = this.options;
          this.urls = [];
          for (const i2 of t22.urls)
            this.urls.push(this.map._requestManager.transformRequest(i2, e2.R.Source).url);
          e2.aE(this.urls, (t3, i2) => {
            this._loaded = true, t3 ? this.fire(new e2.t(t3)) : i2 && (this.video = i2, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
              this.map.triggerRepaint();
            }), this.map && this.video.play(), this._finishLoading());
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(t22) {
          if (this.video) {
            const i2 = this.video.seekable;
            t22 < i2.start(0) || t22 > i2.end(0) ? this.fire(new e2.t(new e2.V("sources.".concat(this.id), null, "Playback for this video can be set only between the ".concat(i2.start(0), " and ").concat(i2.end(0), "-second mark.")))) : this.video.currentTime = t22;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(e22) {
          this.map || (this.map = e22, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
            return;
          const t22 = this.map.painter.context, i2 = t22.gl;
          this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new e2.T(t22, this.video, i2.RGBA8), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t22);
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }, image: e2.aD, model: class extends e2.E {
        constructor(e22, t22, i2, o2) {
          super(), this.id = e22, this.type = "model", this.models = [], this._loaded = false, this._options = t22;
        }
        load() {
          const t22 = [];
          for (const i2 in this._options.models) {
            const o2 = this._options.models[i2], r22 = e2.aG(this.map._requestManager.transformRequest(o2.uri, e2.R.Model).url).then((t3) => {
              if (!t3)
                return;
              const r3 = e2.aH(t3), s2 = new e2.aI(i2, o2.position, o2.orientation, r3);
              s2.computeBoundsAndApplyParent(), this.models.push(s2);
            }).catch((t3) => {
              this.fire(new e2.t(new Error("Could not load model ".concat(i2, " from ").concat(o2.uri, ": ").concat(t3.message))));
            });
            t22.push(r22);
          }
          return Promise.allSettled(t22).then(() => {
            this._loaded = true, this.fire(new e2.x("data", { dataType: "source", sourceDataType: "metadata" }));
          }).catch((t3) => {
            this.fire(new e2.t(new Error("Could not load models: ".concat(t3.message))));
          });
        }
        onAdd(e22) {
          this.map = e22, this.load();
        }
        hasTransition() {
          return false;
        }
        loaded() {
          return this._loaded;
        }
        getModels() {
          return this.models;
        }
        loadTile(e22, t22) {
        }
        serialize() {
          return { type: "model" };
        }
      }, "batched-model": class extends e2.E {
        constructor(e22, t22, i2, o2) {
          super(), this.type = "batched-model", this.id = e22, this.tileSize = 512, this._options = t22, this.tiles = this._options.tiles, this.maxzoom = t22.maxzoom || 19, this.minzoom = t22.minzoom || 0, this.roundZoom = true, this.usedInConflation = true, this.dispatcher = i2, this.reparseOverscaled = false, this.scheme = "xyz", this._loaded = false, this.setEventedParent(o2);
        }
        onAdd(e22) {
          this.map = e22, this.load();
        }
        load(t22) {
          this._loaded = false, this.fire(new e2.x("dataloading", { dataType: "source" }));
          const i2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map._worldview;
          this._tileJSONRequest = Xe2(this._options, this.map._requestManager, i2, o2, (r22, s2) => {
            this._tileJSONRequest = null, this._loaded = true, r22 ? (i2 && console.warn("Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ".concat(i2)), o2 && 2 !== o2.length && console.warn("Requested worldview strings must be a valid ISO alpha-2 code. Found: ".concat(o2)), this.fire(new e2.t(r22))) : s2 && (e2.l(this, s2), s2.bounds && (this.tileBounds = new Ye2(s2.bounds, this.minzoom, this.maxzoom)), L2(s2.tiles, this.map._requestManager._customAccessToken), this.fire(new e2.x("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e2.x("data", { dataType: "source", sourceDataType: "content" }))), t22 && t22(r22);
          });
        }
        hasTransition() {
          return false;
        }
        hasTile(e22) {
          return !this.tileBounds || this.tileBounds.contains(e22.canonical);
        }
        loaded() {
          return this._loaded;
        }
        loadTile(t22, i2) {
          const o2 = this.map._requestManager.normalizeTileURL(t22.tileID.canonical.url(this.tiles, this.scheme)), r22 = { request: this.map._requestManager.transformRequest(o2, e2.R.Tile), data: void 0, uid: t22.uid, tileID: t22.tileID, tileZoom: t22.tileZoom, zoom: t22.tileID.overscaledZ, tileSize: this.tileSize * t22.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: t22.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0 };
          if (t22.actor && "expired" !== t22.state)
            if ("loading" === t22.state)
              t22.reloadCallback = i2;
            else {
              if (t22.buckets) {
                const e22 = Object.values(t22.buckets);
                for (const t3 of e22)
                  t3.dirty = true;
                return void (t22.state = "loaded");
              }
              t22.request = t22.actor.send("reloadTile", r22, s2.bind(this));
            }
          else
            t22.actor = this.dispatcher.getActor(), t22.request = t22.actor.send("loadTile", r22, s2.bind(this), void 0, true);
          function s2(e22, o3) {
            return t22.aborted ? i2(null) : e22 && 404 !== e22.status ? i2(e22) : (o3 && (o3.resourceTiming && (t22.resourceTiming = o3.resourceTiming), this.map._refreshExpiredTiles && t22.setExpiryData(o3), t22.buckets = { ...t22.buckets, ...o3.buckets }, o3.featureIndex && (t22.latestFeatureIndex = o3.featureIndex)), t22.state = "loaded", void i2(null));
          }
        }
        serialize() {
          return e2.l({}, this._options);
        }
      }, canvas: class extends e2.aD {
        constructor(t22, i2, o2, r22) {
          super(t22, i2, o2, r22), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((e22) => !Array.isArray(e22) || 2 !== e22.length || e22.some((e3) => "number" != typeof e3)) || this.fire(new e2.t(new e2.V("sources.".concat(t22), null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e2.t(new e2.V("sources.".concat(t22), null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new e2.t(new e2.V("sources.".concat(t22), null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof HTMLCanvasElement || this.fire(new e2.t(new e2.V("sources.".concat(t22), null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e2.t(new e2.V("sources.".concat(t22), null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
        }
        load() {
          this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e2.t(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = true, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = false);
          }, this._finishLoading());
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(e22) {
          this.map = e22, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove(e22) {
          this.pause();
        }
        prepare() {
          let t22 = false;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, t22 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t22 = true), this._hasInvalidDimensions())
            return;
          if (0 === Object.keys(this.tiles).length)
            return;
          const i2 = this.map.painter.context;
          this.texture ? !t22 && !this._playing || this.texture instanceof e2.aF || this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e2.T(i2, this.canvas, i2.gl.RGBA8, { premultiply: true }), this._prepareData(i2);
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const e22 of [this.canvas.width, this.canvas.height])
            if (isNaN(e22) || e22 <= 0)
              return true;
          return false;
        }
      }, custom: class extends e2.E {
        constructor(t22, i2, o2, r22) {
          super(), this.id = t22, this.type = "custom", this._dataType = "raster", this._dispatcher = o2, this._implementation = i2, this.setEventedParent(r22), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new e2.t(new Error("Missing implementation for ".concat(this.id, " custom source")))), this._implementation.loadTile || this.fire(new e2.t(new Error("Missing loadTile implementation for ".concat(this.id, " custom source")))), this._implementation.bounds && (this.tileBounds = new Ye2(this._implementation.bounds, this.minzoom, this.maxzoom)), i2.update = this._update.bind(this), i2.clearTiles = this._clearTiles.bind(this), i2.coveringTiles = this._coveringTiles.bind(this), e2.l(this, e2.ar(i2, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
        }
        serialize() {
          return e2.ar(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
        }
        load() {
          this._loaded = true, this.fire(new e2.x("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e2.x("data", { dataType: "source", sourceDataType: "content" }));
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t22) {
          this.map = t22, this._loaded = false, this.fire(new e2.x("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t22), this.load();
        }
        onRemove(e22) {
          this._implementation.onRemove && this._implementation.onRemove(e22);
        }
        hasTile(e22) {
          if (this._implementation.hasTile) {
            const { x: t22, y: i2, z: o2 } = e22.canonical;
            return this._implementation.hasTile({ x: t22, y: i2, z: o2 });
          }
          return !this.tileBounds || this.tileBounds.contains(e22.canonical);
        }
        loadTile(e22, t22) {
          const { x: i2, y: o2, z: r22 } = e22.tileID.canonical, s2 = new AbortController();
          e22.request = Promise.resolve(this._implementation.loadTile({ x: i2, y: o2, z: r22 }, { signal: s2.signal })).then((function(i3) {
            return delete e22.request, e22.aborted ? (e22.state = "unloaded", t22(null)) : void 0 === i3 ? (e22.state = "errored", t22(null)) : null === i3 ? (this.loadTileData(e22, { width: this.tileSize, height: this.tileSize, data: null }), e22.state = "loaded", t22(null)) : function(e3) {
              return e3 instanceof ImageData || e3 instanceof HTMLCanvasElement || e3 instanceof ImageBitmap || e3 instanceof HTMLImageElement;
            }(i3) ? (this.loadTileData(e22, i3), e22.state = "loaded", void t22(null)) : (e22.state = "errored", t22(new Error("Can't infer data type for ".concat(this.id, ", only raster data supported at the moment"))));
          }).bind(this)).catch((i3) => {
            20 !== i3.code && (e22.state = "errored", t22(i3));
          }), e22.request.cancel = () => s2.abort();
        }
        loadTileData(e22, t22) {
          e22.setTexture(t22, this.map.painter);
        }
        unloadTile(t22, i2) {
          if (t22.texture && t22.texture instanceof e2.T ? (t22.destroy(true), t22.texture && t22.texture instanceof e2.T && this.map.painter.saveTileTexture(t22.texture)) : t22.destroy(), this._implementation.unloadTile) {
            const { x: e22, y: i3, z: o2 } = t22.tileID.canonical;
            this._implementation.unloadTile({ x: e22, y: i3, z: o2 });
          }
          i2 && i2();
        }
        abortTile(e22, t22) {
          e22.request && e22.request.cancel && (e22.request.cancel(), delete e22.request), t22 && t22();
        }
        hasTransition() {
          return false;
        }
        _coveringTiles() {
          return this.map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e22) => ({ x: e22.canonical.x, y: e22.canonical.y, z: e22.canonical.z }));
        }
        _clearTiles() {
          const t22 = e2.av(this.id, this.scope);
          this.map.style.clearSource(t22);
        }
        _update() {
          this.fire(new e2.x("data", { dataType: "source", sourceDataType: "content" }));
        }
      } }, tt = function(t22, i2, o2, r22) {
        const s2 = new et[i2.type](t22, i2, o2, r22);
        if (s2.id !== t22)
          throw new Error("Expected Source id to be ".concat(t22, " instead of ").concat(s2.id));
        return e2.aJ(["load", "abort", "unload", "serialize", "prepare"], s2), s2;
      };
      function it(t22, i2) {
        const o2 = e2.a6.mat4.identity([]);
        return e2.a6.mat4.scale(o2, o2, [0.5 * t22.width, 0.5 * -t22.height, 1]), e2.a6.mat4.translate(o2, o2, [1, -1, 0]), e2.a6.mat4.multiply(o2, o2, t22.calculateProjMatrix(i2.toUnwrapped())), Float32Array.from(o2);
      }
      function ot(e22, t22, i2, o2, r22, s2, a2, n22 = false) {
        const l22 = e22.tilesIn(o2, a2, n22);
        l22.sort(st);
        const c22 = [];
        for (const o3 of l22)
          c22.push({ wrappedTileID: o3.tile.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(t22, i2, e22._state, o3, r22, s2, it(e22.transform, o3.tile.tileID), n22) });
        const h22 = function(e3) {
          const t3 = {}, i3 = {};
          for (const o3 of e3) {
            const e4 = o3.queryResults, r3 = o3.wrappedTileID, s3 = i3[r3] = i3[r3] || {};
            for (const i4 in e4) {
              const o4 = e4[i4], r4 = s3[i4] = s3[i4] || {}, a3 = t3[i4] = t3[i4] || [];
              for (const e5 of o4)
                r4[e5.featureIndex] || (r4[e5.featureIndex] = true, a3.push(e5));
            }
          }
          return t3;
        }(c22);
        for (const t3 in h22)
          h22[t3].forEach((t4) => {
            const i3 = t4.feature, o3 = i3.layer;
            o3 && "background" !== o3.type && "sky" !== o3.type && "slot" !== o3.type && (i3.source = o3.source, o3["source-layer"] && (i3.sourceLayer = o3["source-layer"]), i3.state = void 0 !== i3.id ? e22.getFeatureState(o3["source-layer"], i3.id) : {});
          });
        return h22;
      }
      function rt(e22, t22) {
        const i2 = e22.getRenderableIds().map((t3) => e22.getTileByID(t3)), o2 = [], r22 = {};
        for (let e3 = 0; e3 < i2.length; e3++) {
          const s2 = i2[e3], a2 = s2.tileID.canonical.key;
          r22[a2] || (r22[a2] = true, s2.querySourceFeatures(o2, t22));
        }
        return o2;
      }
      function st(e22, t22) {
        const i2 = e22.tileID, o2 = t22.tileID;
        return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
      }
      const at = 32, nt = 33, lt = new Uint16Array(8184);
      for (let e22 = 0; e22 < 2046; e22++) {
        let t22 = e22 + 2, i2 = 0, o2 = 0, r22 = 0, s2 = 0, a2 = 0, n22 = 0;
        for (1 & t22 ? r22 = s2 = a2 = at : i2 = o2 = n22 = at; (t22 >>= 1) > 1; ) {
          const e3 = i2 + r22 >> 1, l3 = o2 + s2 >> 1;
          1 & t22 ? (r22 = i2, s2 = o2, i2 = a2, o2 = n22) : (i2 = r22, o2 = s2, r22 = a2, s2 = n22), a2 = e3, n22 = l3;
        }
        const l22 = 4 * e22;
        lt[l22 + 0] = i2, lt[l22 + 1] = o2, lt[l22 + 2] = r22, lt[l22 + 3] = s2;
      }
      const ct = new Uint16Array(2178), ht = new Uint8Array(1089), ut = new Uint16Array(1089);
      function dt(e22) {
        return 0 === e22 ? -0.03125 : 32 === e22 ? 0.03125 : 0;
      }
      const _t = (() => ({ type: 2, extent: e2.ab, loadGeometry: () => [[new e2.P(0, 0), new e2.P(e2.ab + 1, 0), new e2.P(e2.ab + 1, e2.ab + 1), new e2.P(0, e2.ab + 1), new e2.P(0, 0)]] }))();
      class pt {
        constructor(t22, i2, o2, r22, s2) {
          this.tileID = t22, this.uid = e2.aP(), this.uses = 0, this.tileSize = i2, this.tileZoom = o2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = s2, r22 && r22.style && (this._lastUpdatedBrightness = r22.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", r22 && r22.transform && (this.projection = r22.transform.projection);
        }
        registerFadeDuration(t22) {
          const i2 = t22 + this.timeAdded;
          i2 < e2.q.now() || this.fadeEndTime && i2 < this.fadeEndTime || (this.fadeEndTime = i2);
        }
        wasRequested() {
          return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
        }
        get tileTransform() {
          return this._tileTransform || (this._tileTransform = e2.aK(this.tileID.canonical, this.projection)), this._tileTransform;
        }
        loadVectorData(t22, i2, o2) {
          if (this.unloadVectorData(), this.state = "loaded", t22) {
            t22.featureIndex && (this.latestFeatureIndex = t22.featureIndex, t22.rawTileData ? (this.latestRawTileData = t22.rawTileData, this.latestFeatureIndex.rawTileData = t22.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t22.collisionBoxArray, this.buckets = function(e22, t3) {
              const i3 = {};
              if (!t3)
                return i3;
              for (const o3 of e22) {
                const e3 = o3.layerIds.map((e4) => t3.getLayer(e4)).filter(Boolean);
                if (0 !== e3.length) {
                  o3.layers = e3, o3.stateDependentLayerIds && (o3.stateDependentLayers = o3.stateDependentLayerIds.map((t4) => e3.filter((e4) => e4.id === t4)[0]));
                  for (const t4 of e3)
                    i3[t4.fqid] = o3;
                }
              }
              return i3;
            }(t22.buckets, i2.style), this.hasSymbolBuckets = false;
            for (const t3 in this.buckets) {
              const i3 = this.buckets[t3];
              if (i3 instanceof e2.aR) {
                if (this.hasSymbolBuckets = true, !o2)
                  break;
                i3.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets)
              for (const t3 in this.buckets) {
                const i3 = this.buckets[t3];
                if (i3 instanceof e2.aR && i3.hasRTLText) {
                  this.hasRTLText = true, e2.aS();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const e22 in this.buckets) {
              const t3 = this.buckets[e22], o3 = i2.style.getOwnLayer(e22);
              if (!o3)
                continue;
              const r22 = o3.queryRadius(t3);
              this.queryPadding = Math.max(this.queryPadding, r22);
            }
            t22.imageAtlas && (this.imageAtlas = t22.imageAtlas), t22.glyphAtlasImage && (this.glyphAtlasImage = t22.glyphAtlasImage), t22.lineAtlas && (this.lineAtlas = t22.lineAtlas), this._lastUpdatedBrightness = t22.brightness;
          } else
            this.collisionBoxArray = new e2.aQ();
        }
        unloadVectorData() {
          if (this.hasData()) {
            for (const e22 in this.buckets)
              this.buckets[e22].destroy();
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        getBucket(e22) {
          return this.buckets[e22.fqid];
        }
        upload(t22) {
          for (const e22 in this.buckets) {
            const i3 = this.buckets[e22];
            i3.uploadPending() && i3.upload(t22);
          }
          const i2 = t22.gl, o2 = this.imageAtlas;
          if (o2 && !o2.uploaded) {
            const r22 = !!Object.keys(o2.patternPositions).length;
            this.imageAtlasTexture = new e2.T(t22, o2.image, i2.RGBA8, { useMipmap: r22 }), this.imageAtlas.uploaded = true;
          }
          this.glyphAtlasImage && (this.glyphAtlasTexture = new e2.T(t22, this.glyphAtlasImage, i2.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new e2.T(t22, this.lineAtlas.image, i2.R8), this.lineAtlas.uploaded = true);
        }
        prepare(e22, t22, i2) {
          if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(e22, this.imageAtlasTexture, i2), !t22 || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData)
            return;
          const o2 = t22.style.getBrightness();
          (this._lastUpdatedBrightness || o2) && (this._lastUpdatedBrightness && o2 && Math.abs(this._lastUpdatedBrightness - o2) < 1e-3 || (this._lastUpdatedBrightness = o2, this.updateBuckets(t22)));
        }
        queryRenderedFeatures(e22, t22, i2, o2, r22, s2, a2, n22) {
          return this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) ? this.latestFeatureIndex.query({ tileResult: o2, pixelPosMatrix: a2, transform: s2, params: r22, tileTransform: this.tileTransform }, e22, t22, i2) : {};
        }
        querySourceFeatures(t22, i2) {
          const o2 = this.latestFeatureIndex;
          if (!o2 || !o2.rawTileData)
            return;
          const r22 = o2.loadVTLayers(), s2 = i2 ? i2.sourceLayer : "", a2 = r22._geojsonTileLayer || r22[s2];
          if (!a2)
            return;
          const n22 = e2.aT(i2 && i2.filter), { z: l22, x: c22, y: h22 } = this.tileID.canonical, u22 = { z: l22, x: c22, y: h22 };
          for (let i3 = 0; i3 < a2.length; i3++) {
            const r3 = a2.feature(i3);
            if (n22.needGeometry) {
              const t3 = e2.aU(r3, true);
              if (!n22.filter(new e2.a3(this.tileID.overscaledZ), t3, this.tileID.canonical))
                continue;
            } else if (!n22.filter(new e2.a3(this.tileID.overscaledZ), r3))
              continue;
            const d22 = o2.getId(r3, s2), _2 = new e2.aV(r3, l22, c22, h22, d22);
            _2.tile = u22, t22.push(_2);
          }
        }
        hasData() {
          return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
        }
        patternsLoaded() {
          return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(t22) {
          const i2 = this.expirationTime;
          if (t22.cacheControl) {
            const i3 = e2.aW(t22.cacheControl);
            i3["max-age"] && (this.expirationTime = Date.now() + 1e3 * i3["max-age"]);
          } else
            t22.expires && (this.expirationTime = new Date(t22.expires).getTime());
          if (this.expirationTime) {
            const e22 = Date.now();
            let t3 = false;
            if (this.expirationTime > e22)
              t3 = false;
            else if (i2)
              if (this.expirationTime < i2)
                t3 = true;
              else {
                const o2 = this.expirationTime - i2;
                o2 ? this.expirationTime = e22 + Math.max(o2, 3e4) : t3 = true;
              }
            else
              t3 = true;
            t3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(e22, t22) {
          this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(e22).length && t22 && this.updateBuckets(t22);
        }
        updateBuckets(t22) {
          if (!this.latestFeatureIndex)
            return;
          const i2 = this.latestFeatureIndex.loadVTLayers(), o2 = t22.style.listImages(), r22 = t22.style.getBrightness();
          for (const s2 in this.buckets) {
            if (!t22.style.hasLayer(s2))
              continue;
            const a2 = this.buckets[s2], n22 = a2.layers[0].sourceLayer || "_geojsonTileLayer", l22 = i2[n22], c22 = t22.style.getOwnSourceCache(a2.layers[0].source);
            let h22 = {};
            c22 && (h22 = c22._state.getState(n22, void 0)), a2.update(h22, l22, o2, this.imageAtlas && this.imageAtlas.patternPositions || {}, r22), (a2 instanceof e2.aX || a2 instanceof e2.aY) && t22._terrain && t22._terrain.enabled && c22 && a2.programConfigurations.needsUpload && t22._terrain._clearRenderCacheForTile(c22.id, this.tileID);
            const u22 = t22 && t22.style && t22.style.getOwnLayer(s2);
            u22 && (this.queryPadding = Math.max(this.queryPadding, u22.queryRadius(a2)));
          }
        }
        holdingForFade() {
          return void 0 !== this.symbolFadeHoldUntil;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < e2.q.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(t22) {
          this.symbolFadeHoldUntil = e2.q.now() + t22;
        }
        setTexture(t22, i2) {
          const o2 = i2.context, r22 = o2.gl;
          this.texture = this.texture || i2.getTileTexture(t22.width), this.texture && this.texture instanceof e2.T ? this.texture.update(t22) : (this.texture = new e2.T(o2, t22, r22.RGBA8, { useMipmap: true }), this.texture.bind(r22.LINEAR, r22.CLAMP_TO_EDGE));
        }
        setDependencies(e22, t22) {
          const i2 = {};
          for (const e3 of t22)
            i2[e3] = true;
          this.dependencies[e22] = i2;
        }
        hasDependency(e22, t22) {
          for (const i2 of e22) {
            const e3 = this.dependencies[i2];
            if (e3) {
              for (const i3 of t22)
                if (e3[i3])
                  return true;
            }
          }
          return false;
        }
        clearQueryDebugViz() {
        }
        _makeDebugTileBoundsBuffers(t22, i2) {
          if (!i2 || "mercator" === i2.name || this._tileDebugBuffer)
            return;
          const o2 = e2.aZ(_t, this.tileID.canonical, this.tileTransform)[0], r22 = new e2.a_(), s2 = new e2.a$();
          for (let e22 = 0; e22 < o2.length; e22++) {
            const { x: t3, y: i3 } = o2[e22];
            r22.emplaceBack(t3, i3), s2.emplaceBack(e22);
          }
          s2.emplaceBack(0), this._tileDebugIndexBuffer = t22.createIndexBuffer(s2), this._tileDebugBuffer = t22.createVertexBuffer(r22, e2.b0.members), this._tileDebugSegments = e2.b1.simpleSegment(0, 0, r22.length, s2.length);
        }
        _makeTileBoundsBuffers(t22, i2) {
          if (this._tileBoundsBuffer || !i2 || "mercator" === i2.name)
            return;
          const o2 = e2.aZ(_t, this.tileID.canonical, this.tileTransform)[0];
          let r22, s2;
          if (this.isRaster) {
            const t3 = function(t4, i3) {
              const o3 = e2.aK(t4, i3), r3 = Math.pow(2, t4.z);
              for (let s4 = 0; s4 < nt; s4++)
                for (let a3 = 0; a3 < nt; a3++) {
                  const n3 = e2.aL((t4.x + (a3 + dt(a3)) / at) / r3), l3 = e2.aM((t4.y + (s4 + dt(s4)) / at) / r3), c3 = i3.project(n3, l3), h22 = s4 * nt + a3;
                  ct[2 * h22 + 0] = Math.round((c3.x * o3.scale - o3.x) * e2.ab), ct[2 * h22 + 1] = Math.round((c3.y * o3.scale - o3.y) * e2.ab);
                }
              ht.fill(0), ut.fill(0);
              for (let e22 = 2045; e22 >= 0; e22--) {
                const t5 = 4 * e22, i4 = lt[t5 + 0], o4 = lt[t5 + 1], r4 = lt[t5 + 2], s4 = lt[t5 + 3], a3 = i4 + r4 >> 1, n3 = o4 + s4 >> 1, l3 = a3 + n3 - o4, c3 = n3 + i4 - a3, h22 = o4 * nt + i4, u22 = s4 * nt + r4, d22 = n3 * nt + a3, _2 = Math.hypot((ct[2 * h22 + 0] + ct[2 * u22 + 0]) / 2 - ct[2 * d22 + 0], (ct[2 * h22 + 1] + ct[2 * u22 + 1]) / 2 - ct[2 * d22 + 1]) >= 16;
                ht[d22] = ht[d22] || (_2 ? 1 : 0), e22 < 1022 && (ht[d22] = ht[d22] || ht[(o4 + c3 >> 1) * nt + (i4 + l3 >> 1)] || ht[(s4 + c3 >> 1) * nt + (r4 + l3 >> 1)]);
              }
              const s3 = new e2.aN(), a2 = new e2.aO();
              let n22 = 0;
              function l22(t5, i4) {
                const o4 = i4 * nt + t5;
                return 0 === ut[o4] && (s3.emplaceBack(ct[2 * o4 + 0], ct[2 * o4 + 1], t5 * e2.ab / at, i4 * e2.ab / at), ut[o4] = ++n22), ut[o4] - 1;
              }
              function c22(e22, t5, i4, o4, r4, s4) {
                const n3 = e22 + i4 >> 1, h22 = t5 + o4 >> 1;
                if (Math.abs(e22 - r4) + Math.abs(t5 - s4) > 1 && ht[h22 * nt + n3])
                  c22(r4, s4, e22, t5, n3, h22), c22(i4, o4, r4, s4, n3, h22);
                else {
                  const n4 = l22(e22, t5), c3 = l22(i4, o4), h3 = l22(r4, s4);
                  a2.emplaceBack(n4, c3, h3);
                }
              }
              return c22(0, 0, at, at, at, 0), c22(at, at, 0, 0, 0, at), { vertices: s3, indices: a2 };
            }(this.tileID.canonical, i2);
            r22 = t3.vertices, s2 = t3.indices;
          } else {
            r22 = new e2.aN(), s2 = new e2.aO();
            for (const { x: e22, y: t4 } of o2)
              r22.emplaceBack(e22, t4, 0, 0);
            const t3 = e2.b2(r22.int16, void 0, 4);
            for (let e22 = 0; e22 < t3.length; e22 += 3)
              s2.emplaceBack(t3[e22], t3[e22 + 1], t3[e22 + 2]);
          }
          this._tileBoundsBuffer = t22.createVertexBuffer(r22, e2.b3.members), this._tileBoundsIndexBuffer = t22.createIndexBuffer(s2), this._tileBoundsSegments = e2.b1.simpleSegment(0, 0, r22.length, s2.length);
        }
        _makeGlobeTileDebugBuffers(t22, i2) {
          const o2 = i2.projection;
          if (!o2 || "globe" !== o2.name || i2.freezeTileCoverage)
            return;
          const r22 = this.tileID.canonical, s2 = e2.b4(r22, i2), a2 = e2.b5(s2), n22 = e2.a9(i2.zoom);
          let l22;
          n22 > 0 && (l22 = e2.a6.mat4.invert(new Float64Array(16), i2.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t22, r22, i2, a2, l22, n22), this._makeGlobeTileDebugTextBuffer(t22, r22, i2, a2, l22, n22);
        }
        _globePoint(t22, i2, o2, r22, s2, a2, n22) {
          let l22 = e2.b6(t22, i2, o2);
          if (a2) {
            const s3 = 1 << o2.z, c22 = e2.am(r22.center.lng), h22 = e2.at(r22.center.lat), u22 = (o2.x + 0.5) / s3 - c22;
            let d22 = 0;
            u22 > 0.5 ? d22 = -1 : u22 < -0.5 && (d22 = 1);
            let _2 = (t22 / e2.ab + o2.x) / s3 + d22, p22 = (i2 / e2.ab + o2.y) / s3;
            _2 = (_2 - c22) * r22._pixelsPerMercatorPixel + c22, p22 = (p22 - h22) * r22._pixelsPerMercatorPixel + h22;
            const m22 = [_2 * r22.worldSize, p22 * r22.worldSize, 0];
            e2.a6.vec3.transformMat4(m22, m22, a2), l22 = e2.b7(l22, m22, n22);
          }
          return e2.a6.vec3.transformMat4(l22, l22, s2);
        }
        _makeGlobeTileDebugBorderBuffer(t22, i2, o2, r22, s2, a2) {
          const n22 = new e2.a_(), l22 = new e2.a$(), c22 = new e2.b8(), h22 = (e22, t3, h3, u3, d22) => {
            const _2 = (h3 - e22) / (d22 - 1), p22 = (u3 - t3) / (d22 - 1), m22 = n22.length;
            for (let h4 = 0; h4 < d22; h4++) {
              const u4 = e22 + h4 * _2, d3 = t3 + h4 * p22;
              n22.emplaceBack(u4, d3);
              const f22 = this._globePoint(u4, d3, i2, o2, r22, s2, a2);
              c22.emplaceBack(f22[0], f22[1], f22[2]), l22.emplaceBack(m22 + h4);
            }
          }, u22 = e2.ab;
          h22(0, 0, u22, 0, 16), h22(u22, 0, u22, u22, 16), h22(u22, u22, 0, u22, 16), h22(0, u22, 0, 0, 16), this._tileDebugIndexBuffer = t22.createIndexBuffer(l22), this._tileDebugBuffer = t22.createVertexBuffer(n22, e2.b0.members), this._globeTileDebugBorderBuffer = t22.createVertexBuffer(c22, e2.b9.members), this._tileDebugSegments = e2.b1.simpleSegment(0, 0, n22.length, l22.length);
        }
        _makeGlobeTileDebugTextBuffer(t22, i2, o2, r22, s2, a2) {
          const n22 = e2.ab / 4, l22 = new e2.a_(), c22 = new e2.aO(), h22 = new e2.b8(), u22 = 25;
          c22.reserve(32), l22.reserve(u22), h22.reserve(u22);
          const d22 = (e22, t3) => u22 * e22 + t3;
          for (let e22 = 0; e22 < u22; e22++) {
            const t3 = e22 * n22;
            for (let e3 = 0; e3 < u22; e3++) {
              const c3 = e3 * n22;
              l22.emplaceBack(c3, t3);
              const u3 = this._globePoint(c3, t3, i2, o2, r22, s2, a2);
              h22.emplaceBack(u3[0], u3[1], u3[2]);
            }
          }
          for (let e22 = 0; e22 < 4; e22++)
            for (let t3 = 0; t3 < 4; t3++) {
              const i3 = d22(e22, t3), o3 = d22(e22, t3 + 1), r3 = d22(e22 + 1, t3), s3 = d22(e22 + 1, t3 + 1);
              c22.emplaceBack(i3, o3, r3), c22.emplaceBack(r3, o3, s3);
            }
          this._tileDebugTextIndexBuffer = t22.createIndexBuffer(c22), this._tileDebugTextBuffer = t22.createVertexBuffer(l22, e2.b0.members), this._globeTileDebugTextBuffer = t22.createVertexBuffer(h22, e2.b9.members), this._tileDebugTextSegments = e2.b1.simpleSegment(0, 0, u22, 32);
        }
        destroy(t22 = false) {
          for (const e22 in this.buckets)
            this.buckets[e22].destroy();
          this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t22 && this.texture && this.texture instanceof e2.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
        }
      }
      e2.ba.setPbf(e2.bb);
      class mt extends pt {
        constructor(e22, t22, i2, o2, r22) {
          super(e22, t22, i2, o2, r22), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = false;
        }
        setTexture(t22, i2) {
          const o2 = i2.context, r22 = o2.gl;
          this.texture = this.texture || i2.getTileTexture(t22.width), this.texture && this.texture instanceof e2.T ? this.texture.update(t22, { premultiply: false }) : this.texture = new e2.T(o2, t22, r22.RGBA8, { premultiply: false });
        }
        flushQueues() {
          for (; this._workQueue.length; )
            this._workQueue.pop()();
          for (; this._fetchQueue.length; )
            this._fetchQueue.pop()();
        }
        fetchHeader(t22 = 16384, i2) {
          const o2 = this._mrt = new e2.ba(30), r22 = Object.assign({}, this.requestParams, { headers: { Range: "bytes=0-" + (t22 - 1) } });
          return this.entireBuffer = null, this.request = e2.bc(r22, (e22, r3, s2, a2) => {
            if (e22)
              i2(e22);
            else
              try {
                const e3 = o2.getHeaderLength(r3);
                if (e3 > t22)
                  return void (this.request = this.fetchHeader(e3, i2));
                o2.parseHeader(r3), this._isHeaderLoaded = true;
                let n22 = 0;
                for (const e4 of Object.values(o2.layers))
                  n22 = Math.max(n22, e4.dataIndex[e4.dataIndex.length - 1].last_byte);
                r3.byteLength >= n22 && (this.entireBuffer = r3), i2(null, this.entireBuffer || r3, s2, a2);
              } catch (e3) {
                i2(e3);
              }
          }), this.request;
        }
        fetchBand(t22, i2, o2) {
          const r22 = this._mrt;
          if (!this._isHeaderLoaded || !r22)
            return void o2(new Error("Tile header is not ready"));
          const s2 = this.actor;
          if (!s2)
            return void o2(new Error("Can't fetch tile band without an actor"));
          let a2;
          const n22 = (e22, r3) => {
            a2.complete(e22, r3), e22 ? o2(e22) : (this.updateTextureDescriptor(t22, i2), o2(null, this.textureDescriptor && this.textureDescriptor.img));
          }, l22 = (e22, t3) => {
            if (e22)
              return o2(e22);
            const i3 = s2.send("decodeRasterArray", { buffer: t3, task: a2 }, n22, void 0, true);
            this._workQueue.push(() => {
              i3 && i3.cancel(), a2.cancel();
            });
          }, c22 = r22.getLayer(t22);
          if (!c22)
            return void o2(new Error('Unknown sourceLayer "'.concat(t22, '"')));
          if (c22.hasDataForBand(i2))
            return this.updateTextureDescriptor(t22, i2), void o2(null, this.textureDescriptor ? this.textureDescriptor.img : null);
          const h22 = c22.getDataRange([i2]);
          if (a2 = r22.createDecodingTask(h22), !a2 || a2.tasks.length)
            if (this.flushQueues(), this.entireBuffer)
              l22(null, this.entireBuffer.slice(h22.firstByte, h22.lastByte + 1));
            else {
              const t3 = Object.assign({}, this.requestParams, { headers: { Range: "bytes=".concat(h22.firstByte, "-").concat(h22.lastByte) } }), i3 = e2.bc(t3, l22);
              this._fetchQueue.push(() => {
                i3.cancel(), a2.cancel();
              });
            }
          else
            o2(null);
        }
        updateNeeded(e22, t22) {
          return (!this.textureDescriptor || this.textureDescriptor.band !== t22 || this.textureDescriptor.layer !== e22) && "errored" !== this.state;
        }
        updateTextureDescriptor(t22, i2) {
          if (!this._mrt)
            return;
          const o2 = this._mrt.getLayer(t22);
          if (!o2 || !o2.hasBand(i2) || !o2.hasDataForBand(i2))
            return;
          const { bytes: r22, tileSize: s2, buffer: a2, offset: n22, scale: l22 } = o2.getBandView(i2), c22 = s2 + 2 * a2, h22 = { data: r22, width: c22, height: c22 }, u22 = this.texture;
          u22 && u22 instanceof e2.T && u22.update(h22, { premultiply: false }), this.textureDescriptor = { layer: t22, band: i2, img: h22, buffer: a2, offset: n22, tileSize: s2, format: o2.pixelFormat, mix: [l22, 256 * l22, 65536 * l22, 16777216 * l22] };
        }
      }
      class ft {
        constructor(e22, t22) {
          this.max = e22, this.onRemove = t22, this.reset();
        }
        reset() {
          for (const e22 in this.data)
            for (const t22 of this.data[e22])
              t22.timeout && clearTimeout(t22.timeout), this.onRemove(t22.value);
          return this.data = {}, this.order = [], this;
        }
        add(e22, t22, i2) {
          const o2 = e22.wrapped().key;
          void 0 === this.data[o2] && (this.data[o2] = []);
          const r22 = { value: t22, timeout: void 0 };
          if (void 0 !== i2 && (r22.timeout = setTimeout(() => {
            this.remove(e22, r22);
          }, i2)), this.data[o2].push(r22), this.order.push(o2), this.order.length > this.max) {
            const e3 = this._getAndRemoveByKey(this.order[0]);
            e3 && this.onRemove(e3);
          }
          return this;
        }
        has(e22) {
          return e22.wrapped().key in this.data;
        }
        getAndRemove(e22) {
          return this.has(e22) ? this._getAndRemoveByKey(e22.wrapped().key) : null;
        }
        _getAndRemoveByKey(e22) {
          const t22 = this.data[e22].shift();
          return t22.timeout && clearTimeout(t22.timeout), 0 === this.data[e22].length && delete this.data[e22], this.order.splice(this.order.indexOf(e22), 1), t22.value;
        }
        getByKey(e22) {
          const t22 = this.data[e22];
          return t22 ? t22[0].value : null;
        }
        get(e22) {
          return this.has(e22) ? this.data[e22.wrapped().key][0].value : null;
        }
        remove(e22, t22) {
          if (!this.has(e22))
            return this;
          const i2 = e22.wrapped().key, o2 = void 0 === t22 ? 0 : this.data[i2].indexOf(t22), r22 = this.data[i2][o2];
          return this.data[i2].splice(o2, 1), r22.timeout && clearTimeout(r22.timeout), 0 === this.data[i2].length && delete this.data[i2], this.onRemove(r22.value), this.order.splice(this.order.indexOf(i2), 1), this;
        }
        setMaxSize(e22) {
          for (this.max = e22; this.order.length > this.max; ) {
            const e3 = this._getAndRemoveByKey(this.order[0]);
            e3 && this.onRemove(e3);
          }
          return this;
        }
        filter(e22) {
          const t22 = [];
          for (const i2 in this.data)
            for (const o2 of this.data[i2])
              e22(o2.value) || t22.push(o2);
          for (const e3 of t22)
            this.remove(e3.value.tileID, e3);
        }
      }
      class gt {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(t22, i2, o2) {
          const r22 = String(i2);
          if (this.stateChanges[t22] = this.stateChanges[t22] || {}, this.stateChanges[t22][r22] = this.stateChanges[t22][r22] || {}, e2.l(this.stateChanges[t22][r22], o2), null === this.deletedStates[t22]) {
            this.deletedStates[t22] = {};
            for (const e22 in this.state[t22])
              e22 !== r22 && (this.deletedStates[t22][e22] = null);
          } else if (this.deletedStates[t22] && null === this.deletedStates[t22][r22]) {
            this.deletedStates[t22][r22] = {};
            for (const e22 in this.state[t22][r22])
              o2[e22] || (this.deletedStates[t22][r22][e22] = null);
          } else
            for (const e22 in o2)
              this.deletedStates[t22] && this.deletedStates[t22][r22] && null === this.deletedStates[t22][r22][e22] && delete this.deletedStates[t22][r22][e22];
        }
        removeFeatureState(e22, t22, i2) {
          if (null === this.deletedStates[e22])
            return;
          const o2 = String(t22);
          if (this.deletedStates[e22] = this.deletedStates[e22] || {}, i2 && void 0 !== t22)
            null !== this.deletedStates[e22][o2] && (this.deletedStates[e22][o2] = this.deletedStates[e22][o2] || {}, this.deletedStates[e22][o2][i2] = null);
          else if (void 0 !== t22)
            if (this.stateChanges[e22] && this.stateChanges[e22][o2])
              for (i2 in this.deletedStates[e22][o2] = {}, this.stateChanges[e22][o2])
                this.deletedStates[e22][o2][i2] = null;
            else
              this.deletedStates[e22][o2] = null;
          else
            this.deletedStates[e22] = null;
        }
        getState(t22, i2) {
          const o2 = this.state[t22] || {}, r22 = this.stateChanges[t22] || {}, s2 = this.deletedStates[t22];
          if (null === s2)
            return {};
          if (void 0 !== i2) {
            const t3 = String(i2), a3 = e2.l({}, o2[t3], r22[t3]);
            if (s2) {
              const e22 = s2[i2];
              if (null === e22)
                return {};
              for (const t4 in e22)
                delete a3[t4];
            }
            return a3;
          }
          const a2 = e2.l({}, o2, r22);
          if (s2)
            for (const e22 in s2)
              delete a2[e22];
          return a2;
        }
        initializeTileState(e22, t22) {
          e22.setFeatureState(this.state, t22);
        }
        coalesceChanges(t22, i2) {
          const o2 = {};
          for (const t3 in this.stateChanges) {
            this.state[t3] = this.state[t3] || {};
            const i3 = {};
            for (const o3 in this.stateChanges[t3])
              this.state[t3][o3] || (this.state[t3][o3] = {}), e2.l(this.state[t3][o3], this.stateChanges[t3][o3]), i3[o3] = this.state[t3][o3];
            o2[t3] = i3;
          }
          for (const t3 in this.deletedStates) {
            this.state[t3] = this.state[t3] || {};
            const i3 = {};
            if (null === this.deletedStates[t3])
              for (const e22 in this.state[t3])
                i3[e22] = {}, this.state[t3][e22] = {};
            else
              for (const e22 in this.deletedStates[t3]) {
                if (null === this.deletedStates[t3][e22])
                  this.state[t3][e22] = {};
                else if (this.state[t3][e22])
                  for (const i4 of Object.keys(this.deletedStates[t3][e22]))
                    delete this.state[t3][e22][i4];
                i3[e22] = this.state[t3][e22];
              }
            o2[t3] = o2[t3] || {}, e2.l(o2[t3], i3);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o2).length)
            for (const e22 in t22)
              t22[e22].setFeatureState(o2, i2);
        }
      }
      class vt extends e2.E {
        constructor(e22, t22, i2) {
          super(), this.id = e22, this._onlySymbols = i2, t22.on("data", (e3) => {
            "source" === e3.dataType && "metadata" === e3.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === e3.dataType && "content" === e3.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
          }), t22.on("error", () => {
            this._sourceErrored = true;
          }), this._source = t22, this._tiles = {}, this._cache = new ft(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t22.minTileCacheSize, this._maxTileCacheSize = t22.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = false, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new gt(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "raster-array" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
        }
        onAdd(e22) {
          this.map = e22, this._minTileCacheSize = void 0 === this._minTileCacheSize && e22 ? e22._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e22 ? e22._maxTileCacheSize : this._maxTileCacheSize;
        }
        loaded() {
          if (this._sourceErrored)
            return true;
          if (!this._sourceLoaded)
            return false;
          if (!this._source.loaded())
            return false;
          for (const e22 in this._tiles) {
            const t22 = this._tiles[e22];
            if ("loaded" !== t22.state && "errored" !== t22.state)
              return false;
          }
          return true;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = true;
        }
        resume() {
          if (!this._paused)
            return;
          const e22 = this._shouldReloadOnResume;
          this._paused = false, this._shouldReloadOnResume = false, e22 && this.reload(), this.transform && this.update(this.transform);
        }
        _loadTile(e22, t22) {
          return e22.isSymbolTile = this._onlySymbols, e22.isExtraShadowCaster = this._shadowCasterTiles[e22.tileID.key], this._source.loadTile(e22, t22);
        }
        _unloadTile(e22) {
          if (this._source.unloadTile)
            return this._source.unloadTile(e22);
        }
        _abortTile(e22) {
          if (this._source.abortTile)
            return this._source.abortTile(e22);
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(e22) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const t22 in this._tiles) {
            const i2 = this._tiles[t22];
            i2.upload(e22), i2.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
          }
        }
        getIds() {
          return e2.bd(this._tiles).map((e22) => e22.tileID).sort(xt).map((e22) => e22.key);
        }
        getRenderableIds(t22, i2) {
          const o2 = [];
          for (const e22 in this._tiles)
            this._isIdRenderable(+e22, t22, i2) && o2.push(this._tiles[e22]);
          return t22 ? o2.sort((t3, i3) => {
            const o3 = t3.tileID, r22 = i3.tileID, s2 = new e2.P(o3.canonical.x, o3.canonical.y)._rotate(this.transform.angle), a2 = new e2.P(r22.canonical.x, r22.canonical.y)._rotate(this.transform.angle);
            return o3.overscaledZ - r22.overscaledZ || a2.y - s2.y || a2.x - s2.x;
          }).map((e22) => e22.tileID.key) : o2.map((e22) => e22.tileID).sort(xt).map((e22) => e22.key);
        }
        hasRenderableParent(e22) {
          const t22 = this.findLoadedParent(e22, 0);
          return !!t22 && this._isIdRenderable(t22.tileID.key);
        }
        _isIdRenderable(e22, t22, i2) {
          return this._tiles[e22] && this._tiles[e22].hasData() && !this._coveredTiles[e22] && (t22 || !this._tiles[e22].holdingForFade()) && (i2 || !this._shadowCasterTiles[e22]);
        }
        reload() {
          if (this._paused)
            this._shouldReloadOnResume = true;
          else {
            this._cache.reset();
            for (const e22 in this._tiles)
              "errored" !== this._tiles[e22].state && this._reloadTile(+e22, "reloading");
          }
        }
        _reloadTile(e22, t22) {
          const i2 = this._tiles[e22];
          i2 && ("loading" !== i2.state && (i2.state = t22), this._loadTile(i2, this._tileLoaded.bind(this, i2, e22, t22)));
        }
        _tileLoaded(t22, i2, o2, r22) {
          if (r22)
            if (t22.state = "errored", 404 !== r22.status)
              this._source.fire(new e2.t(r22, { tile: t22 }));
            else {
              if (this._source.fire(new e2.x("data", { dataType: "source", sourceDataType: "error", sourceId: this._source.id, tile: t22 })), !(t22.tileID.key in this._loadedParentTiles))
                return;
              if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                const e22 = this.map.painter.terrain;
                this.update(this.transform, e22.getScaledDemTileSize(), true), e22.resetTileLookupCache(this.id);
              } else
                this.update(this.transform);
            }
          else
            t22.timeAdded = e2.q.now(), "expired" === o2 && (t22.refreshedUponExpiration = true), this._setTileReloadTimer(i2, t22), "raster-dem" === this._source.type && t22.dem && this._backfillDEM(t22), this._state.initializeTileState(t22, this.map ? this.map.painter : null), this._source.fire(new e2.x("data", { dataType: "source", tile: t22, coord: t22.tileID, sourceCacheId: this.id }));
        }
        _backfillDEM(e22) {
          const t22 = this.getRenderableIds();
          for (let o2 = 0; o2 < t22.length; o2++) {
            const r22 = t22[o2];
            if (e22.neighboringTiles && e22.neighboringTiles[r22]) {
              const t3 = this.getTileByID(r22);
              i2(e22, t3), i2(t3, e22);
            }
          }
          function i2(e3, t3) {
            if (!e3.dem || e3.dem.borderReady)
              return;
            e3.needsHillshadePrepare = true, e3.needsDEMTextureUpload = true;
            let i3 = t3.tileID.canonical.x - e3.tileID.canonical.x;
            const o2 = t3.tileID.canonical.y - e3.tileID.canonical.y, r22 = Math.pow(2, e3.tileID.canonical.z), s2 = t3.tileID.key;
            0 === i3 && 0 === o2 || Math.abs(o2) > 1 || (Math.abs(i3) > 1 && (1 === Math.abs(i3 + r22) ? i3 += r22 : 1 === Math.abs(i3 - r22) && (i3 -= r22)), t3.dem && e3.dem && (e3.dem.backfillBorder(t3.dem, i3, o2), e3.neighboringTiles && e3.neighboringTiles[s2] && (e3.neighboringTiles[s2].backfilled = true)));
          }
        }
        getTile(e22) {
          return this.getTileByID(e22.key);
        }
        getTileByID(e22) {
          return this._tiles[e22];
        }
        _retainLoadedChildren(e22, t22, i2, o2) {
          for (const r22 in this._tiles) {
            let s2 = this._tiles[r22];
            if (o2[r22] || !s2.hasData() || s2.tileID.overscaledZ <= t22 || s2.tileID.overscaledZ > i2)
              continue;
            let a2 = s2.tileID;
            for (; s2 && s2.tileID.overscaledZ > t22 + 1; ) {
              const e3 = s2.tileID.scaledTo(s2.tileID.overscaledZ - 1);
              s2 = this._tiles[e3.key], s2 && s2.hasData() && (a2 = e3);
            }
            let n22 = a2;
            for (; n22.overscaledZ > t22; )
              if (n22 = n22.scaledTo(n22.overscaledZ - 1), e22[n22.key]) {
                o2[a2.key] = a2;
                break;
              }
          }
        }
        findLoadedParent(e22, t22) {
          if (e22.key in this._loadedParentTiles) {
            const i2 = this._loadedParentTiles[e22.key];
            return i2 && i2.tileID.overscaledZ >= t22 ? i2 : null;
          }
          for (let i2 = e22.overscaledZ - 1; i2 >= t22; i2--) {
            const t3 = e22.scaledTo(i2), o2 = this._getLoadedTile(t3);
            if (o2)
              return o2;
          }
        }
        _getLoadedTile(e22) {
          const t22 = this._tiles[e22.key];
          return t22 && t22.hasData() ? t22 : this._cache.getByKey(this._source.reparseOverscaled ? e22.wrapped().key : e22.canonical.key);
        }
        updateCacheSize(e22, t22) {
          t22 = t22 || this._source.tileSize;
          const i2 = Math.ceil(e22.width / t22) + 1, o2 = Math.ceil(e22.height / t22) + 1, r22 = Math.floor(i2 * o2 * 5), s2 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, r22) : r22, a2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s2) : s2;
          this._cache.setMaxSize(a2);
        }
        handleWrapJump(e22) {
          const t22 = Math.round((e22 - (void 0 === this._prevLng ? e22 : this._prevLng)) / 360);
          if (this._prevLng = e22, t22) {
            const e3 = {};
            for (const i2 in this._tiles) {
              const o2 = this._tiles[i2];
              o2.tileID = o2.tileID.unwrapTo(o2.tileID.wrap + t22), e3[o2.tileID.key] = o2;
            }
            this._tiles = e3;
            for (const e4 in this._timers)
              clearTimeout(this._timers[e4]), delete this._timers[e4];
            for (const e4 in this._tiles)
              this._setTileReloadTimer(+e4, this._tiles[e4]);
          }
        }
        update(t22, i2, o2, r22) {
          if (this.transform = t22, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
            return;
          if (this.usedForTerrain && !o2)
            return;
          this.updateCacheSize(t22, i2), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};
          const s2 = "batched-model" === this._source.type;
          let a2;
          if (this.used || this.usedForTerrain) {
            if (this._source.tileID)
              a2 = t22.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new e2.aA(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y));
            else if (0 !== this.tileCoverLift) {
              const r3 = t22.clone();
              r3.tileCoverLift = this.tileCoverLift, a2 = r3.coveringTiles({ tileSize: i2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !o2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: s2 }), this._source.minzoom <= 1 && "globe" === t22.projection.name && (a2.push(new e2.aA(1, 0, 1, 0, 0)), a2.push(new e2.aA(1, 0, 1, 1, 0)), a2.push(new e2.aA(1, 0, 1, 0, 1)), a2.push(new e2.aA(1, 0, 1, 1, 1)));
            } else if (a2 = t22.coveringTiles({ tileSize: i2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !o2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: s2 }), this._source.hasTile) {
              const e22 = this._source.hasTile.bind(this._source);
              a2 = a2.filter((t3) => e22(t3));
            }
          } else
            a2 = [];
          if (a2.length > 0 && this.castsShadows && r22 && "globe" !== this.transform.projection.name && !this.usedForTerrain && !yt(this._source.type)) {
            const e22 = t22.coveringZoomLevel({ tileSize: i2 || this._source.tileSize, roundZoom: this._source.roundZoom && !o2 }), n3 = Math.min(e22, this._source.maxzoom);
            if (s2) {
              const e3 = t22.extendTileCover(a2, n3);
              for (const t3 of e3)
                a2.push(t3);
            } else {
              const e3 = t22.extendTileCover(a2, n3, r22);
              for (const t3 of e3)
                this._shadowCasterTiles[t3.key] = true, a2.push(t3);
            }
          }
          const n22 = this._updateRetainedTiles(a2);
          if (yt(this._source.type) && 0 !== a2.length) {
            const t3 = {}, i3 = {}, o3 = Object.keys(n22);
            for (const r4 of o3) {
              const o4 = n22[r4], s3 = this._tiles[r4];
              if (!s3 || s3.fadeEndTime && s3.fadeEndTime <= e2.q.now())
                continue;
              const a3 = this.findLoadedParent(o4, Math.max(o4.overscaledZ - vt.maxOverzooming, this._source.minzoom));
              a3 && (this._addTile(a3.tileID), t3[a3.tileID.key] = a3.tileID), i3[r4] = o4;
            }
            const r3 = a2[a2.length - 1].overscaledZ;
            for (const e22 in this._tiles) {
              const t4 = this._tiles[e22];
              if (n22[e22] || !t4.hasData())
                continue;
              let o4 = t4.tileID;
              for (; o4.overscaledZ > r3; ) {
                o4 = o4.scaledTo(o4.overscaledZ - 1);
                const r4 = this._tiles[o4.key];
                if (r4 && r4.hasData() && i3[o4.key]) {
                  n22[e22] = t4.tileID;
                  break;
                }
              }
            }
            for (const e22 in t3)
              n22[e22] || (this._coveredTiles[e22] = true, n22[e22] = t3[e22]);
          }
          for (const e22 in n22)
            this._tiles[e22].clearFadeHold();
          const l22 = e2.be(this._tiles, n22);
          for (const e22 of l22) {
            const t3 = this._tiles[e22];
            t3.hasSymbolBuckets && !t3.holdingForFade() ? t3.setHoldDuration(this.map._fadeDuration) : t3.hasSymbolBuckets && !t3.symbolFadeFinished() || this._removeTile(+e22);
          }
          this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
        }
        releaseSymbolFadeTiles() {
          for (const e22 in this._tiles)
            this._tiles[e22].holdingForFade() && this._removeTile(+e22);
        }
        _updateRetainedTiles(e22) {
          const t22 = {};
          if (0 === e22.length)
            return t22;
          const i2 = {}, o2 = e22.reduce((e3, t3) => Math.min(e3, t3.overscaledZ), 1 / 0), r22 = e22[0].overscaledZ, s2 = Math.max(r22 - vt.maxOverzooming, this._source.minzoom), a2 = Math.max(r22 + vt.maxUnderzooming, this._source.minzoom), n22 = {};
          for (const i3 of e22) {
            const e3 = this._addTile(i3);
            t22[i3.key] = i3, e3.hasData() || o2 < this._source.maxzoom && (n22[i3.key] = i3);
          }
          this._retainLoadedChildren(n22, o2, a2, t22);
          for (const o3 of e22) {
            let e3 = this._tiles[o3.key];
            if (e3.hasData())
              continue;
            if (o3.canonical.z >= this._source.maxzoom) {
              const e4 = o3.children(this._source.maxzoom)[0], i3 = this.getTile(e4);
              if (i3 && i3.hasData()) {
                t22[e4.key] = e4;
                continue;
              }
            } else {
              const e4 = o3.children(this._source.maxzoom);
              if (t22[e4[0].key] && t22[e4[1].key] && t22[e4[2].key] && t22[e4[3].key])
                continue;
            }
            let r3 = e3.wasRequested();
            for (let a3 = o3.overscaledZ - 1; a3 >= s2; --a3) {
              const s3 = o3.scaledTo(a3);
              if (i2[s3.key])
                break;
              if (i2[s3.key] = true, e3 = this.getTile(s3), !e3 && r3 && (e3 = this._addTile(s3)), e3 && (t22[s3.key] = s3, r3 = e3.wasRequested(), e3.hasData()))
                break;
            }
          }
          return t22;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const e22 in this._tiles) {
            const t22 = [];
            let i2, o2 = this._tiles[e22].tileID;
            for (; o2.overscaledZ > 0; ) {
              if (o2.key in this._loadedParentTiles) {
                i2 = this._loadedParentTiles[o2.key];
                break;
              }
              t22.push(o2.key);
              const e3 = o2.scaledTo(o2.overscaledZ - 1);
              if (i2 = this._getLoadedTile(e3), i2)
                break;
              o2 = e3;
            }
            for (const e3 of t22)
              this._loadedParentTiles[e3] = i2;
          }
        }
        _addTile(t22) {
          let i2 = this._tiles[t22.key];
          if (i2)
            return true !== i2.isExtraShadowCaster || !!this._shadowCasterTiles[t22.key] || this._reloadTile(t22.key, "reloading"), i2;
          i2 = this._cache.getAndRemove(t22), i2 && (this._setTileReloadTimer(t22.key, i2), i2.tileID = t22, this._state.initializeTileState(i2, this.map ? this.map.painter : null), this._cacheTimers[t22.key] && (clearTimeout(this._cacheTimers[t22.key]), delete this._cacheTimers[t22.key], this._setTileReloadTimer(t22.key, i2)));
          const o2 = Boolean(i2);
          if (!o2) {
            const e22 = this.map ? this.map.painter : null, o3 = this._source.tileSize * t22.overscaleFactor();
            i2 = "raster-array" === this._source.type ? new mt(t22, o3, this.transform.tileZoom, e22, this._isRaster) : new pt(t22, o3, this.transform.tileZoom, e22, this._isRaster), this._loadTile(i2, this._tileLoaded.bind(this, i2, t22.key, i2.state));
          }
          return i2 ? (i2.uses++, this._tiles[t22.key] = i2, o2 || this._source.fire(new e2.x("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2) : null;
        }
        _setTileReloadTimer(e22, t22) {
          e22 in this._timers && (clearTimeout(this._timers[e22]), delete this._timers[e22]);
          const i2 = t22.getExpiryTimeout();
          i2 && (this._timers[e22] = setTimeout(() => {
            this._reloadTile(e22, "expired"), delete this._timers[e22];
          }, i2));
        }
        _removeTile(e22) {
          const t22 = this._tiles[e22];
          t22 && (t22.uses--, delete this._tiles[e22], this._timers[e22] && (clearTimeout(this._timers[e22]), delete this._timers[e22]), t22.uses > 0 || (t22.hasData() && "reloading" !== t22.state || "empty" === t22.state ? this._cache.add(t22.tileID, t22, t22.getExpiryTimeout()) : (t22.aborted = true, this._abortTile(t22), this._unloadTile(t22))));
        }
        clearTiles() {
          this._shouldReloadOnResume = false, this._paused = false;
          for (const e22 in this._tiles)
            this._removeTile(+e22);
          this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
        }
        tilesIn(t22, i2, o2) {
          const r22 = [], s2 = this.transform;
          if (!s2)
            return r22;
          const a2 = "globe" === s2.projection.name, n22 = e2.am(s2.center.lng);
          for (const l22 in this._tiles) {
            const c22 = this._tiles[l22];
            if (o2 && c22.clearQueryDebugViz(), c22.holdingForFade())
              continue;
            let h22;
            if (a2) {
              const t3 = c22.tileID.canonical;
              if (0 === t3.z) {
                const i3 = [Math.abs(e2.ap(n22, ...bt(t3, -1)) - n22), Math.abs(e2.ap(n22, ...bt(t3, 1)) - n22)];
                h22 = [0, 2 * i3.indexOf(Math.min(...i3)) - 1];
              } else {
                const i3 = [Math.abs(e2.ap(n22, ...bt(t3, -1)) - n22), Math.abs(e2.ap(n22, ...bt(t3, 0)) - n22), Math.abs(e2.ap(n22, ...bt(t3, 1)) - n22)];
                h22 = [i3.indexOf(Math.min(...i3)) - 1];
              }
            } else
              h22 = [0];
            for (const e22 of h22) {
              const o3 = t22.containsTile(c22, s2, i2, e22);
              o3 && r22.push(o3);
            }
          }
          return r22;
        }
        getShadowCasterCoordinates() {
          return this._getRenderableCoordinates(false, true);
        }
        getVisibleCoordinates(e22) {
          return this._getRenderableCoordinates(e22);
        }
        _getRenderableCoordinates(e22, t22) {
          const i2 = this.getRenderableIds(e22, t22).map((e3) => this._tiles[e3].tileID), o2 = "globe" === this.transform.projection.name;
          for (const e3 of i2)
            e3.projMatrix = this.transform.calculateProjMatrix(e3.toUnwrapped()), e3.expandedProjMatrix = o2 ? this.transform.calculateProjMatrix(e3.toUnwrapped(), false, true) : e3.projMatrix;
          return i2;
        }
        sortCoordinatesByDistance(e22) {
          const t22 = e22.slice(), i2 = this.transform._camera.position, o2 = this.transform._camera.forward(), r22 = {};
          for (const e3 of t22) {
            const t3 = 1 / (1 << e3.canonical.z);
            r22[e3.key] = ((e3.canonical.x + 0.5) * t3 + e3.wrap - i2[0]) * o2[0] + ((e3.canonical.y + 0.5) * t3 - i2[1]) * o2[1] - i2[2] * o2[2];
          }
          return t22.sort((e3, t3) => r22[e3.key] - r22[t3.key]), t22;
        }
        hasTransition() {
          if (this._source.hasTransition())
            return true;
          if (yt(this._source.type))
            for (const t22 in this._tiles) {
              const i2 = this._tiles[t22];
              if (void 0 !== i2.fadeEndTime && i2.fadeEndTime >= e2.q.now())
                return true;
            }
          return false;
        }
        setFeatureState(e22, t22, i2) {
          this._state.updateState(e22 = e22 || "_geojsonTileLayer", t22, i2);
        }
        removeFeatureState(e22, t22, i2) {
          this._state.removeFeatureState(e22 = e22 || "_geojsonTileLayer", t22, i2);
        }
        getFeatureState(e22, t22) {
          return this._state.getState(e22 = e22 || "_geojsonTileLayer", t22);
        }
        setDependencies(e22, t22, i2) {
          const o2 = this._tiles[e22];
          o2 && o2.setDependencies(t22, i2);
        }
        reloadTilesForDependencies(e22, t22) {
          for (const i2 in this._tiles)
            this._tiles[i2].hasDependency(e22, t22) && this._reloadTile(+i2, "reloading");
          this._cache.filter((i2) => !i2.hasDependency(e22, t22));
        }
        _preloadTiles(t22, i2) {
          if (!this._sourceLoaded) {
            const e22 = () => {
              this._sourceLoaded && (this._source.off("data", e22), this._preloadTiles(t22, i2));
            };
            return void this._source.on("data", e22);
          }
          const o2 = /* @__PURE__ */ new Map(), r22 = Array.isArray(t22) ? t22 : [t22], s2 = this.map.painter.terrain, a2 = this.usedForTerrain && s2 ? s2.getScaledDemTileSize() : this._source.tileSize;
          for (const e22 of r22) {
            const t3 = e22.coveringTiles({ tileSize: a2, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
            for (const e3 of t3)
              o2.set(e3.key, e3);
            this.usedForTerrain && e22.updateElevation(false);
          }
          const n22 = Array.from(o2.values());
          e2.bf(n22, (e22, t3) => {
            const i3 = new pt(e22, this._source.tileSize * e22.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
            this._loadTile(i3, (e3) => {
              "raster-dem" === this._source.type && i3.dem && this._backfillDEM(i3), t3(e3, i3);
            });
          }, i2);
        }
      }
      function xt(e22, t22) {
        const i2 = Math.abs(2 * e22.wrap) - +(e22.wrap < 0), o2 = Math.abs(2 * t22.wrap) - +(t22.wrap < 0);
        return e22.overscaledZ - t22.overscaledZ || o2 - i2 || t22.canonical.y - e22.canonical.y || t22.canonical.x - e22.canonical.x;
      }
      function yt(e22) {
        return "raster" === e22 || "image" === e22 || "video" === e22 || "custom" === e22;
      }
      function bt(e22, t22) {
        const i2 = 1 << e22.z;
        return [e22.x / i2 + t22, (e22.x + 1) / i2 + t22];
      }
      vt.maxOverzooming = 10, vt.maxUnderzooming = 3;
      class wt {
        constructor(e22) {
          this.style = e22, this.layersGotHidden = false, this.layers = [];
        }
        processLayersChanged() {
          this.layers = [];
          const e22 = false, t22 = false;
          for (const i2 in this.style._mergedLayers) {
            const o2 = this.style._mergedLayers[i2];
            if ("fill-extrusion" === o2.type)
              this.layers.push({ layer: o2, visible: e22, visibilityChanged: t22 });
            else if ("model" === o2.type) {
              const i3 = this.style.getLayerSource(o2);
              i3 && "batched-model" === i3.type && this.layers.push({ layer: o2, visible: e22, visibilityChanged: t22 });
            }
          }
        }
        onNewFrame(e22) {
          this.layersGotHidden = false;
          for (const t22 of this.layers) {
            const i2 = t22.layer;
            let o2 = false;
            "fill-extrusion" === i2.type ? o2 = !i2.isHidden(e22) && i2.paint.get("fill-extrusion-opacity") > 0 : "model" === i2.type && (o2 = !i2.isHidden(e22) && i2.paint.get("model-opacity") > 0), this.layersGotHidden = this.layersGotHidden || !o2 && t22.visible, t22.visible = o2;
          }
        }
        updateZOffset(e22, t22) {
          this.currentBuildingBuckets = [];
          for (const e3 of this.layers) {
            const i3 = e3.layer, o2 = this.style.getLayerSourceCache(i3);
            let r22 = 1;
            "fill-extrusion" === i3.type && (r22 = e3.visible ? i3.paint.get("fill-extrusion-vertical-scale") : 0);
            let s2 = o2 ? o2.getTile(t22) : null;
            if (!s2 && o2 && t22.canonical.z > o2.getSource().minzoom) {
              let e4 = t22.scaledTo(Math.min(o2.getSource().maxzoom, t22.overscaledZ - 1));
              for (; e4.overscaledZ >= o2.getSource().minzoom && (s2 = o2.getTile(e4), !s2 && 0 !== e4.overscaledZ); )
                e4 = e4.scaledTo(e4.overscaledZ - 1);
            }
            this.currentBuildingBuckets.push({ bucket: s2 ? s2.getBucket(i3) : null, tileID: s2 ? s2.tileID : t22, verticalScale: r22 });
          }
          e22.hasAnyZOffset = false;
          let i2 = false;
          for (let o2 = 0; o2 < e22.symbolInstances.length; o2++) {
            const r22 = e22.symbolInstances.get(o2), s2 = r22.zOffset, a2 = this._getHeightAtTileOffset(t22, r22.tileAnchorX, r22.tileAnchorY);
            r22.zOffset = a2 !== Number.NEGATIVE_INFINITY ? a2 : s2, i2 || s2 === r22.zOffset || (i2 = true), e22.hasAnyZOffset || 0 === r22.zOffset || (e22.hasAnyZOffset = true);
          }
          i2 && (e22.zOffsetBuffersNeedUpload = true, e22.zOffsetSortDirty = true);
        }
        _mapCoordToOverlappingTile(t22, i2, o2, r22) {
          let s2 = i2, a2 = o2;
          if (t22.canonical.z !== r22.canonical.z) {
            const n22 = r22.canonical, l22 = 1 / (1 << t22.canonical.z - n22.z);
            s2 = (i2 + t22.canonical.x * e2.ab) * l22 - n22.x * e2.ab | 0, a2 = (o2 + t22.canonical.y * e2.ab) * l22 - n22.y * e2.ab | 0;
          }
          return { tileX: s2, tileY: a2 };
        }
        _getHeightAtTileOffset(e22, t22, i2) {
          let o2, r22;
          for (let s2 = 0; s2 < this.layers.length; ++s2) {
            if ("fill-extrusion" !== this.layers[s2].layer.type)
              continue;
            const { bucket: a2, tileID: n22, verticalScale: l22 } = this.currentBuildingBuckets[s2];
            if (!a2)
              continue;
            const { tileX: c22, tileY: h22 } = this._mapCoordToOverlappingTile(e22, t22, i2, n22), u22 = a2.getHeightAtTileCoord(c22, h22);
            u22 && void 0 !== u22.height && (u22.hidden ? o2 = u22.height : r22 = Math.max(u22.height * l22, r22 || 0));
          }
          if (void 0 !== r22)
            return r22;
          for (let r3 = 0; r3 < this.layers.length; ++r3) {
            const s2 = this.layers[r3];
            if ("model" !== s2.layer.type || !s2.visible)
              continue;
            const { bucket: a2, tileID: n22 } = this.currentBuildingBuckets[r3];
            if (!a2)
              continue;
            const { tileX: l22, tileY: c22 } = this._mapCoordToOverlappingTile(e22, t22, i2, n22), h22 = a2.getHeightAtTileCoord(l22, c22);
            if (h22 && !h22.hidden)
              return void 0 === h22.height && void 0 !== o2 ? Math.min(h22.maxHeight, o2) * h22.verticalScale : h22.height ? h22.height * h22.verticalScale : Number.NEGATIVE_INFINITY;
          }
          return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
        }
      }
      function Tt(t22, i2) {
        const o2 = {};
        for (const e22 in t22)
          "ref" !== e22 && (o2[e22] = t22[e22]);
        return e2.bg.forEach((e22) => {
          e22 in i2 && (o2[e22] = i2[e22]);
        }), o2;
      }
      function Et(e22) {
        e22 = e22.slice();
        const t22 = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0; i2 < e22.length; i2++)
          t22[e22[i2].id] = e22[i2];
        for (let i2 = 0; i2 < e22.length; i2++)
          "ref" in e22[i2] && (e22[i2] = Tt(e22[i2], t22[e22[i2].ref]));
        return e22;
      }
      const Ct = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setSlot: "setSlot", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setCamera: "setCamera", setLights: "setLights", setProjection: "setProjection", addImport: "addImport", removeImport: "removeImport", updateImport: "updateImport" };
      function St(e22, t22, i2) {
        i2.push({ command: Ct.addSource, args: [e22, t22[e22]] });
      }
      function It(e22, t22, i2) {
        t22.push({ command: Ct.removeSource, args: [e22] }), i2[e22] = true;
      }
      function Dt(e22, t22, i2, o2) {
        It(e22, i2, o2), St(e22, t22, i2);
      }
      function Rt(t22, i2, o2) {
        let r22;
        for (r22 in t22[o2])
          if (t22[o2].hasOwnProperty(r22) && "data" !== r22 && !e2.bh(t22[o2][r22], i2[o2][r22]))
            return false;
        for (r22 in i2[o2])
          if (i2[o2].hasOwnProperty(r22) && "data" !== r22 && !e2.bh(t22[o2][r22], i2[o2][r22]))
            return false;
        return true;
      }
      function At(t22, i2, o2, r22, s2, a2) {
        let n22;
        for (n22 in i2 = i2 || {}, t22 = t22 || {})
          t22.hasOwnProperty(n22) && (e2.bh(t22[n22], i2[n22]) || o2.push({ command: a2, args: [r22, n22, i2[n22], s2] }));
        for (n22 in i2)
          i2.hasOwnProperty(n22) && !t22.hasOwnProperty(n22) && (e2.bh(t22[n22], i2[n22]) || o2.push({ command: a2, args: [r22, n22, i2[n22], s2] }));
      }
      function Lt(e22) {
        return e22.id;
      }
      function Pt(e22, t22) {
        return e22[t22.id] = t22, e22;
      }
      class Mt {
        constructor(e22, t22) {
          this.reset(e22, t22);
        }
        reset(e22, t22) {
          this.points = e22 || [], this._distances = [0];
          for (let e3 = 1; e3 < this.points.length; e3++)
            this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t22 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(t22) {
          if (1 === this.points.length)
            return this.points[0];
          t22 = e2.ap(t22, 0, 1);
          let i2 = 1, o2 = this._distances[i2];
          const r22 = t22 * this.paddedLength + this.padding;
          for (; o2 < r22 && i2 < this._distances.length; )
            o2 = this._distances[++i2];
          const s2 = i2 - 1, a2 = this._distances[s2], n22 = o2 - a2, l22 = n22 > 0 ? (r22 - a2) / n22 : 0;
          return this.points[s2].mult(1 - l22).add(this.points[i2].mult(l22));
        }
      }
      class zt {
        constructor(e22, t22, i2) {
          const o2 = this.boxCells = [], r22 = this.circleCells = [];
          this.xCellCount = Math.ceil(e22 / i2), this.yCellCount = Math.ceil(t22 / i2);
          for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++)
            o2.push([]), r22.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e22, this.height = t22, this.xScale = this.xCellCount / e22, this.yScale = this.yCellCount / t22, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(e22, t22, i2, o2, r22) {
          this._forEachCell(t22, i2, o2, r22, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e22), this.bboxes.push(t22), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(r22);
        }
        insertCircle(e22, t22, i2, o2) {
          this._forEachCell(t22 - o2, i2 - o2, t22 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e22), this.circles.push(t22), this.circles.push(i2), this.circles.push(o2);
        }
        _insertBoxCell(e22, t22, i2, o2, r22, s2) {
          this.boxCells[r22].push(s2);
        }
        _insertCircleCell(e22, t22, i2, o2, r22, s2) {
          this.circleCells[r22].push(s2);
        }
        _query(e22, t22, i2, o2, r22, s2) {
          if (i2 < 0 || e22 > this.width || o2 < 0 || t22 > this.height)
            return !r22 && [];
          const a2 = [];
          if (e22 <= 0 && t22 <= 0 && this.width <= i2 && this.height <= o2) {
            if (r22)
              return true;
            for (let e3 = 0; e3 < this.boxKeys.length; e3++)
              a2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
            for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
              const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], o3 = this.circles[3 * e3 + 2];
              a2.push({ key: this.circleKeys[e3], x1: t3 - o3, y1: i3 - o3, x2: t3 + o3, y2: i3 + o3 });
            }
            return s2 ? a2.filter(s2) : a2;
          }
          return this._forEachCell(e22, t22, i2, o2, this._queryCell, a2, { hitTest: r22, seenUids: { box: {}, circle: {} } }, s2), r22 ? a2.length > 0 : a2;
        }
        _queryCircle(e22, t22, i2, o2, r22) {
          const s2 = e22 - i2, a2 = e22 + i2, n22 = t22 - i2, l22 = t22 + i2;
          if (a2 < 0 || s2 > this.width || l22 < 0 || n22 > this.height)
            return !o2 && [];
          const c22 = [];
          return this._forEachCell(s2, n22, a2, l22, this._queryCellCircle, c22, { hitTest: o2, circle: { x: e22, y: t22, radius: i2 }, seenUids: { box: {}, circle: {} } }, r22), o2 ? c22.length > 0 : c22;
        }
        query(e22, t22, i2, o2, r22) {
          return this._query(e22, t22, i2, o2, false, r22);
        }
        hitTest(e22, t22, i2, o2, r22) {
          return this._query(e22, t22, i2, o2, true, r22);
        }
        hitTestCircle(e22, t22, i2, o2) {
          return this._queryCircle(e22, t22, i2, true, o2);
        }
        _queryCell(e22, t22, i2, o2, r22, s2, a2, n22) {
          const l22 = a2.seenUids, c22 = this.boxCells[r22];
          if (null !== c22) {
            const r3 = this.bboxes;
            for (const h3 of c22)
              if (!l22.box[h3]) {
                l22.box[h3] = true;
                const c3 = 4 * h3;
                if (e22 <= r3[c3 + 2] && t22 <= r3[c3 + 3] && i2 >= r3[c3 + 0] && o2 >= r3[c3 + 1] && (!n22 || n22(this.boxKeys[h3]))) {
                  if (a2.hitTest)
                    return s2.push(true), true;
                  s2.push({ key: this.boxKeys[h3], x1: r3[c3], y1: r3[c3 + 1], x2: r3[c3 + 2], y2: r3[c3 + 3] });
                }
              }
          }
          const h22 = this.circleCells[r22];
          if (null !== h22) {
            const r3 = this.circles;
            for (const c3 of h22)
              if (!l22.circle[c3]) {
                l22.circle[c3] = true;
                const h3 = 3 * c3;
                if (this._circleAndRectCollide(r3[h3], r3[h3 + 1], r3[h3 + 2], e22, t22, i2, o2) && (!n22 || n22(this.circleKeys[c3]))) {
                  if (a2.hitTest)
                    return s2.push(true), true;
                  {
                    const e3 = r3[h3], t3 = r3[h3 + 1], i3 = r3[h3 + 2];
                    s2.push({ key: this.circleKeys[c3], x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 });
                  }
                }
              }
          }
        }
        _queryCellCircle(e22, t22, i2, o2, r22, s2, a2, n22) {
          const l22 = a2.circle, c22 = a2.seenUids, h22 = this.boxCells[r22];
          if (null !== h22) {
            const e3 = this.bboxes;
            for (const t3 of h22)
              if (!c22.box[t3]) {
                c22.box[t3] = true;
                const i3 = 4 * t3;
                if (this._circleAndRectCollide(l22.x, l22.y, l22.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!n22 || n22(this.boxKeys[t3])))
                  return s2.push(true), true;
              }
          }
          const u22 = this.circleCells[r22];
          if (null !== u22) {
            const e3 = this.circles;
            for (const t3 of u22)
              if (!c22.circle[t3]) {
                c22.circle[t3] = true;
                const i3 = 3 * t3;
                if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l22.x, l22.y, l22.radius) && (!n22 || n22(this.circleKeys[t3])))
                  return s2.push(true), true;
              }
          }
        }
        _forEachCell(e22, t22, i2, o2, r22, s2, a2, n22) {
          const l22 = this._convertToXCellCoord(e22), c22 = this._convertToYCellCoord(t22), h22 = this._convertToXCellCoord(i2), u22 = this._convertToYCellCoord(o2);
          for (let d22 = l22; d22 <= h22; d22++)
            for (let l3 = c22; l3 <= u22; l3++)
              if (r22.call(this, e22, t22, i2, o2, this.xCellCount * l3 + d22, s2, a2, n22))
                return;
        }
        _convertToXCellCoord(e22) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e22 * this.xScale)));
        }
        _convertToYCellCoord(e22) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e22 * this.yScale)));
        }
        _circlesCollide(e22, t22, i2, o2, r22, s2) {
          const a2 = o2 - e22, n22 = r22 - t22, l22 = i2 + s2;
          return l22 * l22 > a2 * a2 + n22 * n22;
        }
        _circleAndRectCollide(e22, t22, i2, o2, r22, s2, a2) {
          const n22 = (s2 - o2) / 2, l22 = Math.abs(e22 - (o2 + n22));
          if (l22 > n22 + i2)
            return false;
          const c22 = (a2 - r22) / 2, h22 = Math.abs(t22 - (r22 + c22));
          if (h22 > c22 + i2)
            return false;
          if (l22 <= n22 || h22 <= c22)
            return true;
          const u22 = l22 - n22, d22 = h22 - c22;
          return u22 * u22 + d22 * d22 <= i2 * i2;
        }
      }
      const Ot = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, Ft = Math.tan(85 * Math.PI / 180);
      function kt(t22, i2, o2, r22, s2, a2, n22) {
        const l22 = e2.a6.mat4.create();
        if (o2)
          if ("globe" === a2.name) {
            const t3 = e2.bi(s2, i2);
            e2.a6.mat4.multiply(l22, l22, t3);
          } else {
            const t3 = e2.a6.mat2.invert([], n22);
            l22[0] = t3[0], l22[1] = t3[1], l22[4] = t3[2], l22[5] = t3[3], r22 || e2.a6.mat4.rotateZ(l22, l22, s2.angle);
          }
        else
          e2.a6.mat4.multiply(l22, s2.labelPlaneMatrix, t22);
        return l22;
      }
      function Bt(e22, t22, i2, o2, r22, s2, a2) {
        const n22 = kt(e22, t22, i2, o2, r22, s2, a2);
        return "globe" === s2.name && i2 || (n22[2] = n22[6] = n22[10] = n22[14] = 0), n22;
      }
      function Nt(t22, i2, o2, r22, s2, a2, n22) {
        if (o2) {
          if ("globe" === a2.name) {
            const l22 = kt(t22, i2, o2, r22, s2, a2, n22);
            return e2.a6.mat4.invert(l22, l22), e2.a6.mat4.multiply(l22, t22, l22), l22;
          }
          {
            const i3 = e2.a6.mat4.clone(t22), o3 = e2.a6.mat4.identity([]);
            return o3[0] = n22[0], o3[1] = n22[1], o3[4] = n22[2], o3[5] = n22[3], e2.a6.mat4.multiply(i3, i3, o3), r22 || e2.a6.mat4.rotateZ(i3, i3, -s2.angle), i3;
          }
        }
        return s2.glCoordMatrix;
      }
      function Ut(t22, i2, o2, r22) {
        const s2 = [t22, i2, o2, 1];
        o2 ? e2.a6.vec4.transformMat4(s2, s2, r22) : Kt(s2, s2, r22);
        const a2 = s2[3];
        return s2[0] /= a2, s2[1] /= a2, s2[2] /= a2, s2;
      }
      function Gt(e22, t22) {
        return Math.min(0.5 + e22 / t22 * 0.5, 1.5);
      }
      function jt(e22, t22) {
        const i2 = e22[0] / e22[3], o2 = e22[1] / e22[3];
        return i2 >= -t22[0] && i2 <= t22[0] && o2 >= -t22[1] && o2 <= t22[1];
      }
      function Vt(t22, i2, o2, r22, s2, a2, n22, l22, c22, h22) {
        const u22 = o2.transform, d22 = r22 ? t22.textSizeData : t22.iconSizeData, _2 = e2.bj(d22, o2.transform.zoom), p22 = "globe" === u22.projection.name, m22 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], f22 = r22 ? t22.text.dynamicLayoutVertexArray : t22.icon.dynamicLayoutVertexArray;
        f22.clear();
        let g22 = null;
        p22 && (g22 = r22 ? t22.text.globeExtVertexArray : t22.icon.globeExtVertexArray);
        const v22 = t22.lineVertexArray, x22 = r22 ? t22.text.placedSymbolArray : t22.icon.placedSymbolArray, y22 = o2.transform.width / o2.transform.height;
        let b22, w22 = false;
        for (let r3 = 0; r3 < x22.length; r3++) {
          const p3 = x22.get(r3), { numGlyphs: T22, writingMode: E22 } = p3;
          if (E22 !== e2.bk.vertical || w22 || b22 === e2.bk.horizontal || (w22 = true), b22 = E22, (p3.hidden || E22 === e2.bk.vertical) && !w22) {
            Yt(T22, f22);
            continue;
          }
          w22 = false;
          const C22 = new e2.P(p3.tileAnchorX, p3.tileAnchorY);
          let { x: S22, y: I22, z: D22 } = u22.projection.projectTilePoint(C22.x, C22.y, h22.canonical);
          if (c22) {
            const [e22, t3, i3] = c22(C22);
            S22 += e22, I22 += t3, D22 += i3;
          }
          const R22 = [S22, I22, D22, 1];
          if (e2.a6.vec4.transformMat4(R22, R22, i2), !jt(R22, m22)) {
            Yt(T22, f22);
            continue;
          }
          const A22 = R22[3], L22 = Gt(o2.transform.getCameraToCenterDistance(u22.projection), A22), P22 = e2.bl(d22, _2, p3), M22 = n22 ? P22 / L22 : P22 * L22, z22 = Ut(S22, I22, D22, s2);
          if (z22[3] <= 0) {
            Yt(T22, f22);
            continue;
          }
          let O22 = {};
          const F22 = n22 ? null : c22, k22 = Ht(p3, M22, false, l22, i2, s2, a2, t22.glyphOffsetArray, v22, f22, g22, z22, C22, O22, y22, F22, u22.projection, h22, n22);
          w22 = k22.useVertical, F22 && k22.needsFlipping && (O22 = {}), (k22.notEnoughRoom || w22 || k22.needsFlipping && Ht(p3, M22, true, l22, i2, s2, a2, t22.glyphOffsetArray, v22, f22, g22, z22, C22, O22, y22, F22, u22.projection, h22, n22).notEnoughRoom) && Yt(T22, f22);
        }
        r22 ? (t22.text.dynamicLayoutVertexBuffer.updateData(f22), g22 && t22.text.globeExtVertexBuffer && t22.text.globeExtVertexBuffer.updateData(g22)) : (t22.icon.dynamicLayoutVertexBuffer.updateData(f22), g22 && t22.icon.globeExtVertexBuffer && t22.icon.globeExtVertexBuffer.updateData(g22));
      }
      function qt(e22, t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22, d22, _2, p22, m22) {
        const { lineStartIndex: f22, glyphStartIndex: g22, segment: v22 } = n22, x22 = g22 + n22.numGlyphs, y22 = f22 + n22.lineLength, b22 = t22.getoffsetX(g22), w22 = t22.getoffsetX(x22 - 1), T22 = Xt(e22 * b22, i2, o2, r22, s2, a2, v22, f22, y22, l22, c22, h22, u22, d22, true, _2, p22, m22);
        if (!T22)
          return null;
        const E22 = Xt(e22 * w22, i2, o2, r22, s2, a2, v22, f22, y22, l22, c22, h22, u22, d22, true, _2, p22, m22);
        return E22 ? { first: T22, last: E22 } : null;
      }
      function Zt(t22, i2, o2, r22) {
        return t22 === e2.bk.horizontal && Math.abs(r22) > Math.abs(o2) ? { useVertical: true } : t22 === e2.bk.vertical ? r22 > 0 ? { needsFlipping: true } : null : i2 !== Ot.unknown && function(e22, t3) {
          return 0 === e22 || Math.abs(t3 / e22) > Ft;
        }(o2, r22) ? i2 === Ot.flipRequired ? { needsFlipping: true } : null : o2 < 0 ? { needsFlipping: true } : null;
      }
      function Ht(t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22, d22, _2, p22, m22, f22, g22, v22, x22) {
        const y22 = i2 / 24, b22 = t22.lineOffsetX * y22, w22 = t22.lineOffsetY * y22, { lineStartIndex: T22, glyphStartIndex: E22, numGlyphs: C22, segment: S22, writingMode: I22, flipState: D22 } = t22, R22 = T22 + t22.lineLength, A22 = (t3) => {
          if (u22) {
            const [i4, o4, r4] = t3.up, s3 = h22.length;
            e2.bm(u22, s3 + 0, i4, o4, r4), e2.bm(u22, s3 + 1, i4, o4, r4), e2.bm(u22, s3 + 2, i4, o4, r4), e2.bm(u22, s3 + 3, i4, o4, r4);
          }
          const [i3, o3, r3] = t3.point;
          e2.bn(h22, i3, o3, r3, t3.angle);
        };
        if (C22 > 1) {
          const e22 = qt(y22, l22, b22, w22, o2, d22, _2, t22, c22, a2, p22, f22, false, g22, v22, x22);
          if (!e22)
            return { notEnoughRoom: true };
          if (r22 && !o2) {
            let [i3, o3, r3] = e22.first.point, [s3, a3, l3] = e22.last.point;
            [i3, o3] = Ut(i3, o3, r3, n22), [s3, a3] = Ut(s3, a3, l3, n22);
            const c3 = Zt(I22, D22, (s3 - i3) * m22, a3 - o3);
            if (t22.flipState = c3 && c3.needsFlipping ? Ot.flipRequired : Ot.flipNotRequired, c3)
              return c3;
          }
          A22(e22.first);
          for (let e3 = E22 + 1; e3 < E22 + C22 - 1; e3++) {
            const t3 = Xt(y22 * l22.getoffsetX(e3), b22, w22, o2, d22, _2, S22, T22, R22, c22, a2, p22, f22, false, false, g22, v22, x22);
            if (!t3)
              return h22.length -= 4 * (e3 - E22), { notEnoughRoom: true };
            A22(t3);
          }
          A22(e22.last);
        } else {
          if (r22 && !o2) {
            const i4 = Ut(_2.x, _2.y, 0, s2), o3 = T22 + S22 + 1, r3 = new e2.P(c22.getx(o3), c22.gety(o3)), a3 = Ut(r3.x, r3.y, 0, s2), n3 = a3[3] > 0 ? a3 : $t(_2, r3, i4, 1, s2, void 0, g22, v22.canonical), l3 = Zt(I22, D22, (n3[0] - i4[0]) * m22, n3[1] - i4[1]);
            if (t22.flipState = l3 && l3.needsFlipping ? Ot.flipRequired : Ot.flipNotRequired, l3)
              return l3;
          }
          const i3 = Xt(y22 * l22.getoffsetX(E22), b22, w22, o2, d22, _2, S22, T22, R22, c22, a2, p22, f22, false, false, g22, v22, x22);
          if (!i3)
            return { notEnoughRoom: true };
          A22(i3);
        }
        return {};
      }
      function Wt(e22, t22, i2, o2, r22) {
        const { x: s2, y: a2, z: n22 } = o2.projectTilePoint(e22.x, e22.y, t22);
        if (!r22)
          return Ut(s2, a2, n22, i2);
        const [l22, c22, h22] = r22(e22);
        return Ut(s2 + l22, a2 + c22, n22 + h22, i2);
      }
      function $t(t22, i2, o2, r22, s2, a2, n22, l22) {
        const c22 = Wt(t22.sub(i2)._unit()._add(t22), l22, s2, n22, a2);
        return e2.a6.vec3.sub(c22, o2, c22), e2.a6.vec3.normalize(c22, c22), e2.a6.vec3.scaleAndAdd(c22, o2, c22, r22);
      }
      function Xt(t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22, d22, _2, p22, m22, f22, g22, v22) {
        const x22 = r22 ? t22 - i2 : t22 + i2;
        let y22 = x22 > 0 ? 1 : -1, b22 = 0;
        r22 && (y22 *= -1, b22 = Math.PI), y22 < 0 && (b22 += Math.PI);
        let w22 = l22 + n22 + (y22 > 0 ? 0 : 1) | 0, T22 = s2, E22 = s2, C22 = 0, S22 = 0;
        const I22 = Math.abs(x22), D22 = [], R22 = [];
        let A22 = a2, L22 = A22;
        const P22 = () => $t(L22, A22, E22, I22 - C22 + 1, u22, _2, f22, g22.canonical);
        for (; C22 + S22 <= I22; ) {
          if (w22 += y22, w22 < l22 || w22 >= c22)
            return null;
          if (E22 = T22, L22 = A22, D22.push(E22), p22 && R22.push(L22), A22 = new e2.P(h22.getx(w22), h22.gety(w22)), T22 = d22[w22], !T22) {
            const e22 = Wt(A22, g22.canonical, u22, f22, _2);
            T22 = e22[3] > 0 ? d22[w22] = e22 : P22();
          }
          C22 += S22, S22 = e2.a6.vec3.distance(E22, T22);
        }
        m22 && _2 && (d22[w22] && (T22 = P22(), S22 = e2.a6.vec3.distance(E22, T22)), d22[w22] = T22);
        const M22 = (I22 - C22) / S22, z22 = A22.sub(L22)._mult(M22)._add(L22), O22 = e2.a6.vec3.sub([], T22, E22), F22 = e2.a6.vec3.scaleAndAdd([], E22, O22, M22);
        let k22 = [0, 0, 1], B22 = O22[0], N22 = O22[1];
        if (v22 && (k22 = f22.upVector(g22.canonical, z22.x, z22.y), 0 !== k22[0] || 0 !== k22[1] || 1 !== k22[2])) {
          const t3 = [k22[2], 0, -k22[0]], i3 = e2.a6.vec3.cross([], k22, t3);
          e2.a6.vec3.normalize(t3, t3), e2.a6.vec3.normalize(i3, i3), B22 = e2.a6.vec3.dot(O22, t3), N22 = e2.a6.vec3.dot(O22, i3);
        }
        if (o2) {
          const t3 = e2.a6.vec3.cross([], k22, O22);
          e2.a6.vec3.normalize(t3, t3), e2.a6.vec3.scaleAndAdd(F22, F22, t3, o2 * y22);
        }
        const U22 = b22 + Math.atan2(N22, B22);
        return D22.push(F22), p22 && R22.push(z22), { point: F22, angle: U22, path: D22, tilePath: R22, up: k22 };
      }
      function Yt(e22, t22) {
        const i2 = t22.length, o2 = i2 + 4 * e22;
        t22.resize(o2), t22.float32.fill(-1 / 0, 4 * i2, 4 * o2);
      }
      function Kt(e22, t22, i2) {
        const o2 = t22[0], r22 = t22[1];
        return e22[0] = i2[0] * o2 + i2[4] * r22 + i2[12], e22[1] = i2[1] * o2 + i2[5] * r22 + i2[13], e22[3] = i2[3] * o2 + i2[7] * r22 + i2[15], e22;
      }
      const Jt = 100;
      class Qt {
        constructor(e22, t22, i2 = new zt(e22.width + 200, e22.height + 200, 25), o2 = new zt(e22.width + 200, e22.height + 200, 25)) {
          this.transform = e22, this.grid = i2, this.ignoredGrid = o2, this.pitchfactor = Math.cos(e22._pitch) * e22.cameraToCenterDistance, this.screenRightBoundary = e22.width + Jt, this.screenBottomBoundary = e22.height + Jt, this.gridRightBoundary = e22.width + 200, this.gridBottomBoundary = e22.height + 200, this.fogState = t22;
        }
        placeCollisionBox(e22, t22, i2, o2, r22, s2, a2, n22) {
          let l22 = i2.projectedAnchorX, c22 = i2.projectedAnchorY, h22 = i2.projectedAnchorZ;
          const u22 = i2.elevation, d22 = i2.tileID, _2 = e22.getProjection();
          if (u22 && d22) {
            const [e3, t3, o3] = _2.upVector(d22.canonical, i2.tileAnchorX, i2.tileAnchorY), r3 = _2.upVectorScale(d22.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
            l22 += e3 * u22 * r3, c22 += t3 * u22 * r3, h22 += o3 * u22 * r3;
          }
          const p22 = this.projectAndGetPerspectiveRatio(a2, l22, c22, h22, i2.tileID, "globe" === _2.name || !!u22 || this.transform.pitch > 0, _2), m22 = s2 * p22.perspectiveRatio, f22 = (i2.x1 * t22 + o2.x - i2.padding) * m22 + p22.point.x, g22 = (i2.y1 * t22 + o2.y - i2.padding) * m22 + p22.point.y, v22 = (i2.x2 * t22 + o2.x + i2.padding) * m22 + p22.point.x, x22 = (i2.y2 * t22 + o2.y + i2.padding) * m22 + p22.point.y, y22 = p22.perspectiveRatio <= 0.55 || p22.occluded;
          return !this.isInsideGrid(f22, g22, v22, x22) || !r22 && this.grid.hitTest(f22, g22, v22, x22, n22) || y22 ? { box: [], offscreen: false, occluded: p22.occluded } : { box: [f22, g22, v22, x22], offscreen: this.isOffscreen(f22, g22, v22, x22), occluded: false };
        }
        placeCollisionCircles(t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22, d22, _2, p22, m22) {
          const f22 = [], g22 = this.transform.elevation, v22 = t22.getProjection(), x22 = g22 ? g22.getAtTileOffsetFunc(m22, this.transform.center.lat, this.transform.worldSize, v22) : null, y22 = new e2.P(o2.tileAnchorX, o2.tileAnchorY);
          let { x: b22, y: w22, z: T22 } = v22.projectTilePoint(y22.x, y22.y, m22.canonical);
          if (x22) {
            const [e22, t3, i3] = x22(y22);
            b22 += e22, w22 += t3, T22 += i3;
          }
          const E22 = "globe" === v22.name, C22 = this.projectAndGetPerspectiveRatio(n22, b22, w22, T22, m22, E22 || !!g22 || this.transform.pitch > 0, v22), { perspectiveRatio: S22 } = C22, I22 = (u22 ? a2 / S22 : a2 * S22) / e2.bq, D22 = Ut(b22, w22, T22, l22), R22 = C22.signedDistanceFromCamera > 0 ? qt(I22, s2, o2.lineOffsetX * I22, o2.lineOffsetY * I22, false, D22, y22, o2, r22, l22, {}, g22 && !u22 ? x22 : null, u22 && !!g22, v22, m22, u22) : null;
          let A22 = false, L22 = false, P22 = true;
          if (R22 && !C22.occluded) {
            const t3 = 0.5 * _2 * S22 + p22, o3 = new e2.P(-100, -100), r3 = new e2.P(this.screenRightBoundary, this.screenBottomBoundary), s3 = new Mt(), { first: a3, last: n3 } = R22, l3 = a3.path.length;
            let u3 = [];
            for (let e22 = l3 - 1; e22 >= 1; e22--)
              u3.push(a3.path[e22]);
            for (let e22 = 1; e22 < n3.path.length; e22++)
              u3.push(n3.path[e22]);
            const m3 = 2.5 * t3;
            c22 && (u3 = u3.map(([e22, t4, i3], o4) => (x22 && !E22 && (i3 = x22(o4 < l3 - 1 ? a3.tilePath[l3 - 1 - o4] : n3.tilePath[o4 - l3 + 2])[2]), Ut(e22, t4, i3, c22))), u3.some((e22) => e22[3] <= 0) && (u3 = []));
            let g3 = [];
            if (u3.length > 0) {
              let t4 = 1 / 0, i3 = -1 / 0, s4 = 1 / 0, a4 = -1 / 0;
              for (const e22 of u3)
                t4 = Math.min(t4, e22[0]), s4 = Math.min(s4, e22[1]), i3 = Math.max(i3, e22[0]), a4 = Math.max(a4, e22[1]);
              i3 >= o3.x && t4 <= r3.x && a4 >= o3.y && s4 <= r3.y && (g3 = [u3.map((t5) => new e2.P(t5[0], t5[1]))], (t4 < o3.x || i3 > r3.x || s4 < o3.y || a4 > r3.y) && (g3 = e2.bo(g3, o3.x, o3.y, r3.x, r3.y)));
            }
            for (const e22 of g3) {
              s3.reset(e22, 0.25 * t3);
              let o4 = 0;
              o4 = s3.length <= 0.5 * t3 ? 1 : Math.ceil(s3.paddedLength / m3) + 1;
              for (let e3 = 0; e3 < o4; e3++) {
                const r4 = e3 / Math.max(o4 - 1, 1), a4 = s3.lerp(r4), n4 = a4.x + Jt, l4 = a4.y + Jt;
                f22.push(n4, l4, t3, 0);
                const c3 = n4 - t3, u4 = l4 - t3, _3 = n4 + t3, p3 = l4 + t3;
                if (P22 = P22 && this.isOffscreen(c3, u4, _3, p3), L22 = L22 || this.isInsideGrid(c3, u4, _3, p3), !i2 && this.grid.hitTestCircle(n4, l4, t3, d22) && (A22 = true, !h22))
                  return { circles: [], offscreen: false, collisionDetected: A22, occluded: false };
              }
            }
          }
          return { circles: !h22 && A22 || !L22 ? [] : f22, offscreen: P22, collisionDetected: A22, occluded: C22.occluded };
        }
        queryRenderedSymbols(t22) {
          if (0 === t22.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
            return {};
          const i2 = [];
          let o2 = 1 / 0, r22 = 1 / 0, s2 = -1 / 0, a2 = -1 / 0;
          for (const n3 of t22) {
            const t3 = new e2.P(n3.x + Jt, n3.y + Jt);
            o2 = Math.min(o2, t3.x), r22 = Math.min(r22, t3.y), s2 = Math.max(s2, t3.x), a2 = Math.max(a2, t3.y), i2.push(t3);
          }
          const n22 = this.grid.query(o2, r22, s2, a2).concat(this.ignoredGrid.query(o2, r22, s2, a2)), l22 = {}, c22 = {};
          for (const t3 of n22) {
            const o3 = t3.key;
            if (void 0 === l22[o3.bucketInstanceId] && (l22[o3.bucketInstanceId] = {}), l22[o3.bucketInstanceId][o3.featureIndex])
              continue;
            const r3 = [new e2.P(t3.x1, t3.y1), new e2.P(t3.x2, t3.y1), new e2.P(t3.x2, t3.y2), new e2.P(t3.x1, t3.y2)];
            e2.bp(i2, r3) && (l22[o3.bucketInstanceId][o3.featureIndex] = true, void 0 === c22[o3.bucketInstanceId] && (c22[o3.bucketInstanceId] = []), c22[o3.bucketInstanceId].push(o3.featureIndex));
          }
          return c22;
        }
        insertCollisionBox(e22, t22, i2, o2, r22) {
          (t22 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r22 }, e22[0], e22[1], e22[2], e22[3]);
        }
        insertCollisionCircles(e22, t22, i2, o2, r22) {
          const s2 = t22 ? this.ignoredGrid : this.grid, a2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r22 };
          for (let t3 = 0; t3 < e22.length; t3 += 4)
            s2.insertCircle(a2, e22[t3], e22[t3 + 1], e22[t3 + 2]);
        }
        projectAndGetPerspectiveRatio(t22, i2, o2, r22, s2, a2, n22) {
          const l22 = [i2, o2, r22, 1];
          let c22 = false;
          if (r22 || this.transform.pitch > 0) {
            if (e2.a6.vec4.transformMat4(l22, l22, t22), this.fogState && s2 && "globe" !== n22.name) {
              const t3 = function(t4, i3, o3, r3, s3, a3) {
                const n3 = a3.calculateFogTileMatrix(s3), l3 = [i3, o3, r3];
                return e2.a6.vec3.transformMat4(l3, l3, n3), Fe2(t4, e2.a6.vec3.length(l3), a3.pitch, a3._fov);
              }(this.fogState, i2, o2, r22, s2.toUnwrapped(), this.transform);
              c22 = t3 > 0.9;
            }
          } else
            Kt(l22, l22, t22);
          const h22 = l22[3];
          return { point: new e2.P((l22[0] / h22 + 1) / 2 * this.transform.width + Jt, (-l22[1] / h22 + 1) / 2 * this.transform.height + Jt), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(n22) / h22 * 0.5, 1.5), signedDistanceFromCamera: h22, occluded: a2 && l22[2] > h22 || c22 };
        }
        isOffscreen(e22, t22, i2, o2) {
          return i2 < Jt || e22 >= this.screenRightBoundary || o2 < Jt || t22 > this.screenBottomBoundary;
        }
        isInsideGrid(e22, t22, i2, o2) {
          return i2 >= 0 && e22 < this.gridRightBoundary && o2 >= 0 && t22 < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const t22 = e2.a6.mat4.identity([]);
          return e2.a6.mat4.translate(t22, t22, [-100, -100, 0]), t22;
        }
      }
      function ei2(t22, i2, o2) {
        const r22 = i2.createTileMatrix(t22, t22.worldSize, o2.toUnwrapped());
        return e2.a6.mat4.multiply(new Float32Array(16), t22.projMatrix, r22);
      }
      function ti2(e22, t22, i2) {
        if (t22.projection.name === i2.projection.name)
          return e22.projMatrix;
        const o2 = i2.clone();
        return o2.setProjection(t22.projection), ei2(o2, t22.getProjection(), e22);
      }
      function ii2(e22, t22, i2) {
        return t22.name === i2.projection.name ? e22.projMatrix : ei2(i2, t22, e22);
      }
      class oi2 {
        constructor(e22, t22, i2, o2) {
          this.opacity = e22 ? Math.max(0, Math.min(1, e22.opacity + (e22.placed ? t22 : -t22))) : o2 && i2 ? 1 : 0, this.placed = i2;
        }
        isHidden() {
          return 0 === this.opacity && !this.placed;
        }
      }
      class ri2 {
        constructor(e22, t22, i2, o2, r22, s2 = false) {
          this.text = new oi2(e22 ? e22.text : null, t22, i2, r22), this.icon = new oi2(e22 ? e22.icon : null, t22, o2, r22), this.clipped = s2;
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class si2 {
        constructor(e22, t22, i2, o2 = false) {
          this.text = e22, this.icon = t22, this.skipFade = i2, this.clipped = o2;
        }
      }
      class ai2 {
        constructor() {
          this.invProjMatrix = e2.a6.mat4.create(), this.viewportMatrix = e2.a6.mat4.create(), this.circles = [];
        }
      }
      class ni2 {
        constructor(e22, t22, i2, o2, r22) {
          this.bucketInstanceId = e22, this.featureIndex = t22, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = r22;
        }
      }
      class li2 {
        constructor(e22) {
          this.crossSourceCollisions = e22, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(e22) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[e22]) {
            const t22 = ++this.maxGroupID;
            this.collisionGroups[e22] = { ID: t22, predicate: (e3) => e3.collisionGroupID === t22 };
          }
          return this.collisionGroups[e22];
        }
      }
      function ci2(t22, i2, o2, r22, s2) {
        const { horizontalAlign: a2, verticalAlign: n22 } = e2.bx(t22), l22 = -(a2 - 0.5) * i2, c22 = -(n22 - 0.5) * o2, h22 = e2.bw(t22, r22);
        return new e2.P(l22 + h22[0] * s2, c22 + h22[1] * s2);
      }
      function hi2(t22, i2, o2, r22, s2) {
        const a2 = new e2.P(t22, i2);
        return o2 && a2._rotate(r22 ? s2 : -s2), a2;
      }
      class ui2 {
        constructor(e22, t22, i2, o2, r22, s2) {
          this.transform = e22.clone(), this.projection = e22.projection.name, this.collisionIndex = new Qt(this.transform, r22), this.buildingIndex = s2, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t22, this.retainedQueryData = {}, this.collisionGroups = new li2(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
        }
        getBucketParts(t22, i2, o2, r22) {
          const s2 = o2.getBucket(i2), a2 = o2.latestFeatureIndex;
          if (!s2 || !a2 || i2.fqid !== s2.layerIds[0])
            return;
          const n22 = s2.layers[0].layout, l22 = s2.layers[0].paint, c22 = o2.collisionBoxArray, h22 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), u22 = o2.tileSize / e2.ab, d22 = o2.tileID.toUnwrapped();
          this.transform.setProjection(s2.projection);
          const _2 = (p22 = o2.tileID, m22 = s2.getProjection(), f22 = this.transform, m22.name === this.projection ? f22.calculateProjMatrix(p22.toUnwrapped()) : ei2(f22, m22, p22));
          var p22, m22, f22;
          const g22 = "map" === n22.get("text-pitch-alignment"), v22 = "map" === n22.get("text-rotation-alignment");
          i2.compileFilter();
          const x22 = i2.dynamicFilter(), y22 = i2.dynamicFilterNeedsFeature(), b22 = this.transform.calculatePixelsToTileUnitsMatrix(o2), w22 = Bt(_2, o2.tileID.canonical, g22, v22, this.transform, s2.getProjection(), b22);
          let T22 = null;
          if (g22) {
            const t3 = Nt(_2, o2.tileID.canonical, g22, v22, this.transform, s2.getProjection(), b22);
            T22 = e2.a6.mat4.multiply([], this.transform.labelPlaneMatrix, t3);
          }
          let E22 = null;
          x22 && o2.latestFeatureIndex && (E22 = { unwrappedTileID: d22, dynamicFilter: x22, dynamicFilterNeedsFeature: y22 }), this.retainedQueryData[s2.bucketInstanceId] = new ni2(s2.bucketInstanceId, a2, s2.sourceLayerIndex, s2.index, o2.tileID);
          const C22 = { bucket: s2, layout: n22, paint: l22, posMatrix: _2, textLabelPlaneMatrix: w22, labelToScreenMatrix: T22, clippingData: E22, scale: h22, textPixelRatio: u22, holdingForFade: o2.holdingForFade(), collisionBoxArray: c22, partiallyEvaluatedTextSize: e2.bj(s2.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e2.bj(s2.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(s2.sourceID), latestFeatureIndex: o2.latestFeatureIndex };
          if (r22)
            for (const e22 of s2.sortKeyRanges) {
              const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r3 } = e22;
              t22.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r3, parameters: C22 });
            }
          else
            t22.push({ symbolInstanceStart: 0, symbolInstanceEnd: s2.symbolInstances.length, parameters: C22 });
        }
        attemptAnchorPlacement(e22, t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22, d22, _2, p22, m22, f22, g22) {
          const { textOffset0: v22, textOffset1: x22, crossTileID: y22 } = u22, b22 = [v22, x22], w22 = ci2(e22, i2, o2, b22, r22), T22 = this.collisionIndex.placeCollisionBox(_2, r22, t22, hi2(w22.x, w22.y, s2, a2, this.transform.angle), h22, n22, l22, c22.predicate);
          if (m22) {
            const e3 = _2.getSymbolInstanceIconSize(g22, this.transform.zoom, u22.placedIconSymbolIndex);
            if (0 === this.collisionIndex.placeCollisionBox(_2, e3, m22, hi2(w22.x, w22.y, s2, a2, this.transform.angle), h22, n22, l22, c22.predicate).box.length)
              return;
          }
          if (T22.box.length > 0) {
            let t3;
            return this.prevPlacement && this.prevPlacement.variableOffsets[y22] && this.prevPlacement.placements[y22] && this.prevPlacement.placements[y22].text && (t3 = this.prevPlacement.variableOffsets[y22].anchor), this.variableOffsets[y22] = { textOffset: b22, width: i2, height: o2, anchor: e22, textScale: r22, prevAnchor: t3 }, this.markUsedJustification(_2, e22, u22, p22), _2.allowVerticalPlacement && (this.markUsedOrientation(_2, p22, u22), this.placedOrientations[y22] = p22), { shift: w22, placedGlyphBoxes: T22 };
          }
        }
        placeLayerBucketPart(t22, i2, o2, r22) {
          const { bucket: s2, layout: a2, paint: n22, posMatrix: l22, textLabelPlaneMatrix: c22, labelToScreenMatrix: h22, clippingData: u22, textPixelRatio: d22, holdingForFade: _2, collisionBoxArray: p22, partiallyEvaluatedTextSize: m22, partiallyEvaluatedIconSize: f22, collisionGroup: g22, latestFeatureIndex: v22 } = t22.parameters, x22 = a2.get("text-optional"), y22 = a2.get("icon-optional"), b22 = a2.get("text-allow-overlap"), w22 = a2.get("icon-allow-overlap"), T22 = "map" === a2.get("text-rotation-alignment"), E22 = "map" === a2.get("text-pitch-alignment"), C22 = a2.get("symbol-z-elevate"), S22 = n22.get("symbol-z-offset"), I22 = "sea" === n22.get("symbol-elevation-reference");
          this.transform.setProjection(s2.projection);
          let D22 = b22 && (w22 || !s2.hasIconData() || y22), R22 = w22 && (b22 || !s2.hasTextData() || x22);
          const A22 = !S22.isConstant();
          !s2.collisionArrays && p22 && s2.deserializeCollisionBoxes(p22), o2 && r22 && s2.updateCollisionDebugBuffers(this.transform.zoom, p22);
          const L22 = (t3, r3, n3) => {
            const { crossTileID: p3, numVerticalGlyphVertices: C3 } = t3;
            let L3 = null;
            if (u22 && u22.dynamicFilterNeedsFeature || A22) {
              const e22 = this.retainedQueryData[s2.bucketInstanceId];
              L3 = v22.loadFeature({ featureIndex: t3.featureIndex, bucketIndex: e22.bucketIndex, sourceLayerIndex: e22.sourceLayerIndex, layoutVertexArrayOffset: 0 });
            }
            if (u22 && !(0, u22.dynamicFilter)({ zoom: this.transform.zoom, pitch: this.transform.pitch }, L3, this.retainedQueryData[s2.bucketInstanceId].tileID.canonical, new e2.P(t3.tileAnchorX, t3.tileAnchorY), this.transform.calculateDistanceTileData(u22.unwrappedTileID)))
              return this.placements[p3] = new si2(false, false, false, true), void i2.add(p3);
            const P22 = S22.evaluate(L3, {});
            if (i2.has(p3))
              return;
            if (_2)
              return void (this.placements[p3] = new si2(false, false, false));
            let M22 = false, z22 = false, O22 = true, F22 = false, k22 = false, B22 = null, N22 = { box: null, offscreen: null, occluded: null }, U22 = { box: null, offscreen: null, occluded: null }, G22 = null, j2 = null, V22 = null, q22 = 0, Z22 = 0, H22 = 0;
            n3.textFeatureIndex ? q22 = n3.textFeatureIndex : t3.useRuntimeCollisionCircles && (q22 = t3.featureIndex), n3.verticalTextFeatureIndex && (Z22 = n3.verticalTextFeatureIndex);
            const W22 = (e22) => {
              e22.tileID = this.retainedQueryData[s2.bucketInstanceId].tileID;
              const i3 = this.transform.elevation;
              e22.elevation = I22 ? P22 : P22 + (i3 ? i3.getAtTileOffset(e22.tileID, e22.tileAnchorX, e22.tileAnchorY) : 0), e22.elevation += t3.zOffset;
            }, $2 = n3.textBox;
            if ($2) {
              W22($2);
              const i3 = (i4) => {
                let o4 = e2.bk.horizontal;
                if (s2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                  const e22 = this.prevPlacement.placedOrientations[p3];
                  e22 && (this.placedOrientations[p3] = e22, o4 = e22, this.markUsedOrientation(s2, o4, t3));
                }
                return o4;
              }, o3 = (t4, i4) => {
                if (s2.allowVerticalPlacement && C3 > 0 && n3.verticalTextBox) {
                  for (const o4 of s2.writingModes)
                    if (o4 === e2.bk.vertical ? (N22 = i4(), U22 = N22) : N22 = t4(), N22 && N22.box && N22.box.length)
                      break;
                } else
                  N22 = t4();
              };
              if (a2.get("text-variable-anchor")) {
                let c3 = a2.get("text-variable-anchor");
                if (this.prevPlacement && this.prevPlacement.variableOffsets[p3]) {
                  const e22 = this.prevPlacement.variableOffsets[p3];
                  c3.indexOf(e22.anchor) > 0 && (c3 = c3.filter((t4) => t4 !== e22.anchor), c3.unshift(e22.anchor));
                }
                const h3 = (e22, i4, o4) => {
                  const a3 = s2.getSymbolInstanceTextSize(m22, t3, this.transform.zoom, r3), n4 = (e22.x2 - e22.x1) * a3 + 2 * e22.padding, h4 = (e22.y2 - e22.y1) * a3 + 2 * e22.padding, u4 = t3.hasIconTextFit && !w22 ? i4 : null;
                  u4 && W22(u4);
                  let _3 = { box: [], offscreen: false, occluded: false };
                  const p4 = b22 ? 2 * c3.length : c3.length;
                  for (let i5 = 0; i5 < p4; ++i5) {
                    const p5 = this.attemptAnchorPlacement(c3[i5 % c3.length], e22, n4, h4, a3, T22, E22, d22, l22, g22, i5 >= c3.length, t3, r3, s2, o4, u4, m22, f22);
                    if (p5 && (_3 = p5.placedGlyphBoxes, _3 && _3.box && _3.box.length)) {
                      M22 = true, B22 = p5.shift;
                      break;
                    }
                  }
                  return _3;
                };
                o3(() => h3($2, n3.iconBox, e2.bk.horizontal), () => {
                  const t4 = n3.verticalTextBox;
                  return t4 && W22(t4), s2.allowVerticalPlacement && !(N22 && N22.box && N22.box.length) && C3 > 0 && t4 ? h3(t4, n3.verticalIconBox, e2.bk.vertical) : { box: null, offscreen: null, occluded: null };
                }), N22 && (M22 = N22.box, O22 = N22.offscreen, F22 = N22.occluded);
                const u3 = i3(!(!N22 || !N22.box));
                if (!M22 && this.prevPlacement) {
                  const e22 = this.prevPlacement.variableOffsets[p3];
                  e22 && (this.variableOffsets[p3] = e22, this.markUsedJustification(s2, e22.anchor, t3, u3));
                }
              } else {
                const a3 = (i4, o4) => {
                  const a4 = s2.getSymbolInstanceTextSize(m22, t3, this.transform.zoom, r3), n4 = this.collisionIndex.placeCollisionBox(s2, a4, i4, new e2.P(0, 0), b22, d22, l22, g22.predicate);
                  return n4 && n4.box && n4.box.length && (this.markUsedOrientation(s2, o4, t3), this.placedOrientations[p3] = o4), n4;
                };
                o3(() => a3($2, e2.bk.horizontal), () => {
                  const t4 = n3.verticalTextBox;
                  return s2.allowVerticalPlacement && C3 > 0 && t4 ? (W22(t4), a3(t4, e2.bk.vertical)) : { box: null, offscreen: null, occluded: null };
                }), i3(!!(N22 && N22.box && N22.box.length));
              }
            }
            if (G22 = N22, M22 = G22 && G22.box && G22.box.length > 0, O22 = G22 && G22.offscreen, F22 = G22 && G22.occluded, t3.useRuntimeCollisionCircles) {
              const i3 = s2.text.placedSymbolArray.get(t3.centerJustifiedTextSymbolIndex >= 0 ? t3.centerJustifiedTextSymbolIndex : t3.verticalPlacedTextSymbolIndex), r4 = e2.bl(s2.textSizeData, m22, i3), n4 = a2.get("text-padding");
              j2 = this.collisionIndex.placeCollisionCircles(s2, b22, i3, s2.lineVertexArray, s2.glyphOffsetArray, r4, l22, c22, h22, o2, E22, g22.predicate, t3.collisionCircleDiameter * r4 / e2.bq, n4, this.retainedQueryData[s2.bucketInstanceId].tileID), M22 = b22 || j2.circles.length > 0 && !j2.collisionDetected, O22 = O22 && j2.offscreen, F22 = j2.occluded;
            }
            if (n3.iconFeatureIndex && (H22 = n3.iconFeatureIndex), n3.iconBox) {
              const i3 = (i4) => {
                W22(i4);
                const o3 = t3.hasIconTextFit && B22 ? hi2(B22.x, B22.y, T22, E22, this.transform.angle) : new e2.P(0, 0), r4 = s2.getSymbolInstanceIconSize(f22, this.transform.zoom, t3.placedIconSymbolIndex);
                return this.collisionIndex.placeCollisionBox(s2, r4, i4, o3, w22, d22, l22, g22.predicate);
              };
              U22 && U22.box && U22.box.length && n3.verticalIconBox ? (V22 = i3(n3.verticalIconBox), z22 = V22.box.length > 0) : (V22 = i3(n3.iconBox), z22 = V22.box.length > 0), O22 = O22 && V22.offscreen, k22 = V22.occluded;
            }
            const X22 = x22 || 0 === t3.numHorizontalGlyphVertices && 0 === C3, Y22 = y22 || 0 === t3.numIconVertices;
            if (X22 || Y22 ? Y22 ? X22 || (z22 = z22 && M22) : M22 = z22 && M22 : z22 = M22 = z22 && M22, M22 && G22 && G22.box && this.collisionIndex.insertCollisionBox(G22.box, a2.get("text-ignore-placement"), s2.bucketInstanceId, U22 && U22.box && Z22 ? Z22 : q22, g22.ID), z22 && V22 && this.collisionIndex.insertCollisionBox(V22.box, a2.get("icon-ignore-placement"), s2.bucketInstanceId, H22, g22.ID), j2 && (M22 && this.collisionIndex.insertCollisionCircles(j2.circles, a2.get("text-ignore-placement"), s2.bucketInstanceId, q22, g22.ID), o2)) {
              const e22 = s2.bucketInstanceId;
              let t4 = this.collisionCircleArrays[e22];
              void 0 === t4 && (t4 = this.collisionCircleArrays[e22] = new ai2());
              for (let e3 = 0; e3 < j2.circles.length; e3 += 4)
                t4.circles.push(j2.circles[e3 + 0]), t4.circles.push(j2.circles[e3 + 1]), t4.circles.push(j2.circles[e3 + 2]), t4.circles.push(j2.collisionDetected ? 1 : 0);
            }
            const K22 = "globe" !== s2.projection.name;
            D22 = D22 && (K22 || !F22), R22 = R22 && (K22 || !k22), this.placements[p3] = new si2(M22 || D22, z22 || R22, O22 || s2.justReloaded), i2.add(p3);
          };
          if (C22 && this.buildingIndex && (this.buildingIndex.updateZOffset(s2, this.retainedQueryData[s2.bucketInstanceId].tileID), s2.updateZOffset()), s2.sortFeaturesByY) {
            const t3 = s2.getSortedSymbolIndexes(this.transform.angle);
            for (let e22 = t3.length - 1; e22 >= 0; --e22) {
              const i3 = t3[e22];
              L22(s2.symbolInstances.get(i3), i3, s2.collisionArrays[i3]);
            }
            s2.hasAnyZOffset && e2.w("".concat(s2.layerIds[0], " layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y"));
          } else if (s2.hasAnyZOffset) {
            const e22 = s2.getSortedIndexesByZOffset();
            for (let t3 = 0; t3 < e22.length; ++t3) {
              const i3 = e22[t3];
              L22(s2.symbolInstances.get(i3), i3, s2.collisionArrays[i3]);
            }
          } else
            for (let e22 = t22.symbolInstanceStart; e22 < t22.symbolInstanceEnd; e22++)
              L22(s2.symbolInstances.get(e22), e22, s2.collisionArrays[e22]);
          if (o2 && s2.bucketInstanceId in this.collisionCircleArrays) {
            const t3 = this.collisionCircleArrays[s2.bucketInstanceId];
            e2.a6.mat4.invert(t3.invProjMatrix, l22), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          s2.justReloaded = false;
        }
        markUsedJustification(t22, i2, o2, r22) {
          const { leftJustifiedTextSymbolIndex: s2, centerJustifiedTextSymbolIndex: a2, rightJustifiedTextSymbolIndex: n22, verticalPlacedTextSymbolIndex: l22, crossTileID: c22 } = o2, h22 = e2.bv(i2), u22 = r22 === e2.bk.vertical ? l22 : "left" === h22 ? s2 : "center" === h22 ? a2 : "right" === h22 ? n22 : -1;
          s2 >= 0 && (t22.text.placedSymbolArray.get(s2).crossTileID = u22 >= 0 && s2 !== u22 ? 0 : c22), a2 >= 0 && (t22.text.placedSymbolArray.get(a2).crossTileID = u22 >= 0 && a2 !== u22 ? 0 : c22), n22 >= 0 && (t22.text.placedSymbolArray.get(n22).crossTileID = u22 >= 0 && n22 !== u22 ? 0 : c22), l22 >= 0 && (t22.text.placedSymbolArray.get(l22).crossTileID = u22 >= 0 && l22 !== u22 ? 0 : c22);
        }
        markUsedOrientation(t22, i2, o2) {
          const r22 = i2 === e2.bk.horizontal || i2 === e2.bk.horizontalOnly ? i2 : 0, s2 = i2 === e2.bk.vertical ? i2 : 0, { leftJustifiedTextSymbolIndex: a2, centerJustifiedTextSymbolIndex: n22, rightJustifiedTextSymbolIndex: l22, verticalPlacedTextSymbolIndex: c22 } = o2, h22 = t22.text.placedSymbolArray;
          a2 >= 0 && (h22.get(a2).placedOrientation = r22), n22 >= 0 && (h22.get(n22).placedOrientation = r22), l22 >= 0 && (h22.get(l22).placedOrientation = r22), c22 >= 0 && (h22.get(c22).placedOrientation = s2);
        }
        commit(e22) {
          this.commitTime = e22, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const t22 = this.prevPlacement;
          let i2 = false;
          this.prevZoomAdjustment = t22 ? t22.zoomAdjustment(this.transform.zoom) : 0;
          const o2 = t22 ? t22.symbolFadeChange(e22) : 1, r22 = t22 ? t22.opacities : {}, s2 = t22 ? t22.variableOffsets : {}, a2 = t22 ? t22.placedOrientations : {};
          for (const e3 in this.placements) {
            const t3 = this.placements[e3], s3 = r22[e3];
            s3 ? (this.opacities[e3] = new ri2(s3, o2, t3.text, t3.icon, null, t3.clipped), i2 = i2 || t3.text !== s3.text.placed || t3.icon !== s3.icon.placed) : (this.opacities[e3] = new ri2(null, o2, t3.text, t3.icon, t3.skipFade, t3.clipped), i2 = i2 || t3.text || t3.icon);
          }
          for (const e3 in r22) {
            const t3 = r22[e3];
            if (!this.opacities[e3]) {
              const r3 = new ri2(t3, o2, false, false);
              r3.isHidden() || (this.opacities[e3] = r3, i2 = i2 || t3.text.placed || t3.icon.placed);
            }
          }
          for (const e3 in s2)
            this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = s2[e3]);
          for (const e3 in a2)
            this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = a2[e3]);
          i2 ? this.lastPlacementChangeTime = e22 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t22 ? t22.lastPlacementChangeTime : e22);
        }
        updateLayerOpacities(e22, t22, i2, o2) {
          const r22 = /* @__PURE__ */ new Set();
          for (const s2 of t22) {
            const t3 = s2.getBucket(e22);
            t3 && s2.latestFeatureIndex && e22.fqid === t3.layerIds[0] && (this.updateBucketOpacities(t3, r22, s2, s2.collisionBoxArray, i2, o2, s2.tileID, e22.scope), t3.layers[0].layout.get("symbol-z-elevate") && this.buildingIndex && (this.buildingIndex.updateZOffset(t3, s2.tileID), t3.updateZOffset()));
          }
        }
        updateBucketOpacities(t22, i2, o2, r22, s2, a2, n22, l22) {
          t22.hasTextData() && t22.text.opacityVertexArray.clear(), t22.hasIconData() && t22.icon.opacityVertexArray.clear(), t22.hasIconCollisionBoxData() && t22.iconCollisionBox.collisionVertexArray.clear(), t22.hasTextCollisionBoxData() && t22.textCollisionBox.collisionVertexArray.clear();
          const c22 = t22.layers[0].layout, h22 = t22.layers[0].paint, u22 = !!t22.layers[0].dynamicFilter(), d22 = new ri2(null, 0, false, false, true), _2 = c22.get("text-allow-overlap"), p22 = c22.get("icon-allow-overlap"), m22 = c22.get("text-variable-anchor"), f22 = "map" === c22.get("text-rotation-alignment"), g22 = "map" === c22.get("text-pitch-alignment"), v22 = h22.get("symbol-z-offset"), x22 = "sea" === h22.get("symbol-elevation-reference"), y22 = !v22.isConstant(), b22 = new ri2(null, 0, _2 && (p22 || !t22.hasIconData() || c22.get("icon-optional")), p22 && (_2 || !t22.hasTextData() || c22.get("text-optional")), true);
          !t22.collisionArrays && r22 && (t22.hasIconCollisionBoxData() || t22.hasTextCollisionBoxData()) && t22.deserializeCollisionBoxes(r22);
          const w22 = (e22, t3, i3) => {
            for (let o3 = 0; o3 < t3 / 4; o3++)
              e22.opacityVertexArray.emplaceBack(i3);
          };
          let T22 = 0;
          a2 && t22.updateReplacement(n22, a2);
          for (let r3 = 0; r3 < t22.symbolInstances.length; r3++) {
            const c3 = t22.symbolInstances.get(r3), { numHorizontalGlyphVertices: h3, numVerticalGlyphVertices: _3, crossTileID: p3, numIconVertices: E22, tileAnchorX: C22, tileAnchorY: S22 } = c3;
            let I22 = null;
            if (c3 && y22) {
              const e22 = this.retainedQueryData[t22.bucketInstanceId];
              I22 = o2.latestFeatureIndex.loadFeature({ featureIndex: c3.featureIndex, bucketIndex: e22.bucketIndex, sourceLayerIndex: e22.sourceLayerIndex, layoutVertexArrayOffset: 0 });
            }
            const D22 = v22.evaluate(I22, {}), R22 = i2.has(p3);
            let A22 = this.opacities[p3];
            R22 ? A22 = d22 : A22 || (A22 = b22, this.opacities[p3] = A22), i2.add(p3);
            const L22 = h3 > 0 || _3 > 0, P22 = E22 > 0, M22 = this.placedOrientations[p3], z22 = M22 === e2.bk.vertical, O22 = M22 === e2.bk.horizontal || M22 === e2.bk.horizontalOnly;
            !L22 && !P22 || A22.isHidden() || T22++;
            let F22 = false;
            if ((L22 || P22) && a2)
              for (const i3 of t22.activeReplacements) {
                if (e2.br(i3, s2, e2.bs.Symbol, l22))
                  continue;
                if (i3.min.x > C22 || C22 > i3.max.x || i3.min.y > S22 || S22 > i3.max.y)
                  continue;
                const t3 = e2.bt(C22, S22, n22.canonical, i3.footprintTileId.canonical);
                if (F22 = e2.bu(t3, i3.footprint), F22)
                  break;
              }
            if (L22) {
              const e22 = F22 ? bi2 : yi2(A22.text);
              w22(t22.text, h3, z22 ? bi2 : e22), w22(t22.text, _3, O22 ? bi2 : e22);
              const i3 = A22.text.isHidden(), { leftJustifiedTextSymbolIndex: o3, centerJustifiedTextSymbolIndex: r4, rightJustifiedTextSymbolIndex: s3, verticalPlacedTextSymbolIndex: a3 } = c3, n3 = t22.text.placedSymbolArray, l3 = i3 || z22 ? 1 : 0;
              o3 >= 0 && (n3.get(o3).hidden = l3), r4 >= 0 && (n3.get(r4).hidden = l3), s3 >= 0 && (n3.get(s3).hidden = l3), a3 >= 0 && (n3.get(a3).hidden = i3 || O22 ? 1 : 0);
              const u3 = this.variableOffsets[p3];
              u3 && this.markUsedJustification(t22, u3.anchor, c3, M22);
              const d3 = this.placedOrientations[p3];
              d3 && (this.markUsedJustification(t22, "left", c3, d3), this.markUsedOrientation(t22, d3, c3));
            }
            if (P22) {
              const e22 = F22 ? bi2 : yi2(A22.icon), { placedIconSymbolIndex: i3, verticalPlacedIconSymbolIndex: o3 } = c3, r4 = t22.icon.placedSymbolArray, s3 = A22.icon.isHidden() ? 1 : 0;
              i3 >= 0 && (w22(t22.icon, E22, z22 ? bi2 : e22), r4.get(i3).hidden = s3), o3 >= 0 && (w22(t22.icon, c3.numVerticalIconVertices, O22 ? bi2 : e22), r4.get(o3).hidden = s3);
            }
            if (t22.hasIconCollisionBoxData() || t22.hasTextCollisionBoxData()) {
              const i3 = t22.collisionArrays[r3];
              if (i3) {
                let o3 = new e2.P(0, 0), r4 = true;
                if (i3.textBox || i3.verticalTextBox) {
                  if (m22) {
                    const e22 = this.variableOffsets[p3];
                    e22 ? (o3 = ci2(e22.anchor, e22.width, e22.height, e22.textOffset, e22.textScale), f22 && o3._rotate(g22 ? this.transform.angle : -this.transform.angle)) : r4 = false;
                  }
                  u22 && (r4 = !A22.clipped), i3.textBox && di2(t22.textCollisionBox.collisionVertexArray, A22.text.placed, !r4 || z22, D22, x22, o3.x, o3.y), i3.verticalTextBox && di2(t22.textCollisionBox.collisionVertexArray, A22.text.placed, !r4 || O22, D22, x22, o3.x, o3.y);
                }
                const s3 = r4 && Boolean(!O22 && i3.verticalIconBox);
                i3.iconBox && di2(t22.iconCollisionBox.collisionVertexArray, A22.icon.placed, s3, D22, x22, c3.hasIconTextFit ? o3.x : 0, c3.hasIconTextFit ? o3.y : 0), i3.verticalIconBox && di2(t22.iconCollisionBox.collisionVertexArray, A22.icon.placed, !s3, D22, x22, c3.hasIconTextFit ? o3.x : 0, c3.hasIconTextFit ? o3.y : 0);
              }
            }
          }
          if (t22.fullyClipped = 0 === T22, t22.sortFeatures(this.transform.angle), this.retainedQueryData[t22.bucketInstanceId] && (this.retainedQueryData[t22.bucketInstanceId].featureSortOrder = t22.featureSortOrder), t22.hasTextData() && t22.text.opacityVertexBuffer && t22.text.opacityVertexBuffer.updateData(t22.text.opacityVertexArray), t22.hasIconData() && t22.icon.opacityVertexBuffer && t22.icon.opacityVertexBuffer.updateData(t22.icon.opacityVertexArray), t22.hasIconCollisionBoxData() && t22.iconCollisionBox.collisionVertexBuffer && t22.iconCollisionBox.collisionVertexBuffer.updateData(t22.iconCollisionBox.collisionVertexArray), t22.hasTextCollisionBoxData() && t22.textCollisionBox.collisionVertexBuffer && t22.textCollisionBox.collisionVertexBuffer.updateData(t22.textCollisionBox.collisionVertexArray), t22.bucketInstanceId in this.collisionCircleArrays) {
            const e22 = this.collisionCircleArrays[t22.bucketInstanceId];
            t22.placementInvProjMatrix = e22.invProjMatrix, t22.placementViewportMatrix = e22.viewportMatrix, t22.collisionCircleArray = e22.circles, delete this.collisionCircleArrays[t22.bucketInstanceId];
          }
        }
        symbolFadeChange(e22) {
          return 0 === this.fadeDuration ? 1 : (e22 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(e22) {
          return Math.max(0, (this.transform.zoom - e22) / 1.5);
        }
        hasTransitions(e22) {
          return this.stale || e22 - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(e22, t22) {
          const i2 = this.zoomAtLastRecencyCheck === t22 ? 1 - this.zoomAdjustment(t22) : 1;
          return this.zoomAtLastRecencyCheck = t22, this.commitTime + this.fadeDuration * i2 > e22;
        }
        setStale() {
          this.stale = true;
        }
      }
      function di2(e22, t22, i2, o2, r22, s2, a2) {
        e22.emplaceBack(t22 ? 1 : 0, i2 ? 1 : 0, s2 || 0, a2 || 0, o2, r22 ? 1 : 0), e22.emplaceBack(t22 ? 1 : 0, i2 ? 1 : 0, s2 || 0, a2 || 0, o2, r22 ? 1 : 0), e22.emplaceBack(t22 ? 1 : 0, i2 ? 1 : 0, s2 || 0, a2 || 0, o2, r22 ? 1 : 0), e22.emplaceBack(t22 ? 1 : 0, i2 ? 1 : 0, s2 || 0, a2 || 0, o2, r22 ? 1 : 0);
      }
      const _i = Math.pow(2, 25), pi2 = Math.pow(2, 24), mi2 = Math.pow(2, 17), fi2 = Math.pow(2, 16), gi2 = Math.pow(2, 9), vi2 = Math.pow(2, 8), xi2 = Math.pow(2, 1);
      function yi2(e22) {
        if (0 === e22.opacity && !e22.placed)
          return 0;
        if (1 === e22.opacity && e22.placed)
          return 4294967295;
        const t22 = e22.placed ? 1 : 0, i2 = Math.floor(127 * e22.opacity);
        return i2 * _i + t22 * pi2 + i2 * mi2 + t22 * fi2 + i2 * gi2 + t22 * vi2 + i2 * xi2 + t22;
      }
      const bi2 = 0;
      class wi2 {
        constructor(e22) {
          this._sortAcrossTiles = "viewport-y" !== e22.layout.get("symbol-z-order") && void 0 !== e22.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
        }
        continuePlacement(e22, t22, i2, o2, r22) {
          const s2 = this._bucketParts;
          for (; this._currentTileIndex < e22.length; )
            if (t22.getBucketParts(s2, o2, e22[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r22())
              return true;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = false, s2.sort((e3, t3) => e3.sortKey - t3.sortKey)); this._currentPartIndex < s2.length; ) {
            const e3 = s2[this._currentPartIndex];
            if (t22.placeLayerBucketPart(e3, this._seenCrossTileIDs, i2, 0 === e3.symbolInstanceStart), this._currentPartIndex++, r22())
              return true;
          }
          return false;
        }
      }
      class Ti2 {
        constructor(e22, t22, i2, o2, r22, s2, a2, n22, l22) {
          this.placement = new ui2(e22, r22, s2, a2, n22, l22), this._currentPlacementIndex = t22.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t22, i2, o2, r22) {
          const s2 = e2.q.now(), a2 = () => {
            const t3 = e2.q.now() - s2;
            return !this._forceFullPlacement && t3 > 2;
          };
          for (; this._currentPlacementIndex >= 0; ) {
            const s3 = i2[t22[this._currentPlacementIndex]], n22 = this.placement.collisionIndex.transform.zoom;
            if ("symbol" === s3.type && (!s3.minzoom || s3.minzoom <= n22) && (!s3.maxzoom || s3.maxzoom > n22)) {
              const t3 = s3, i3 = t3.layout.get("symbol-z-elevate"), n3 = void 0 !== t3.layout.get("symbol-sort-key").constantOr(1), l22 = t3.layout.get("symbol-z-order"), c22 = "viewport-y" === l22 || "auto" === l22 && !("viewport-y" !== l22 && n3), h22 = t3.layout.get("text-allow-overlap") || t3.layout.get("icon-allow-overlap") || t3.layout.get("text-ignore-placement") || t3.layout.get("icon-ignore-placement"), u22 = c22 && h22, d22 = this._inProgressLayer = this._inProgressLayer || new wi2(t3), _2 = e2.av(s3.source, s3.scope);
              if (d22.continuePlacement(i3 || u22 ? r22[_2] : o2[_2], this.placement, this._showCollisionBoxes, s3, a2))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }
        commit(e22) {
          return this.placement.commit(e22), this.placement;
        }
      }
      const Ei2 = 512 / e2.ab / 2;
      class Ci2 {
        constructor(t22, i2, o2) {
          this.tileID = t22, this.bucketInstanceId = o2, this.index = new e2.by(i2.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
          const r22 = t22.canonical.x * e2.ab, s2 = t22.canonical.y * e2.ab;
          for (let e22 = 0; e22 < i2.length; e22++) {
            const { key: t3, crossTileID: o3, tileAnchorX: a2, tileAnchorY: n22 } = i2.get(e22), l22 = Math.floor((r22 + a2) * Ei2), c22 = Math.floor((s2 + n22) * Ei2);
            this.index.add(l22, c22), this.keys.push(t3), this.crossTileIDs.push(o3);
          }
          this.index.finish();
        }
        findMatches(t22, i2, o2) {
          const r22 = this.tileID.canonical.z < i2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i2.canonical.z), s2 = Ei2 / Math.pow(2, i2.canonical.z - this.tileID.canonical.z), a2 = i2.canonical.x * e2.ab, n22 = i2.canonical.y * e2.ab;
          for (let e22 = 0; e22 < t22.length; e22++) {
            const i3 = t22.get(e22);
            if (i3.crossTileID)
              continue;
            const { key: l22, tileAnchorX: c22, tileAnchorY: h22 } = i3, u22 = Math.floor((a2 + c22) * s2), d22 = Math.floor((n22 + h22) * s2), _2 = this.index.range(u22 - r22, d22 - r22, u22 + r22, d22 + r22);
            for (const e3 of _2) {
              const t3 = this.crossTileIDs[e3];
              if (this.keys[e3] === l22 && !o2.has(t3)) {
                o2.add(t3), i3.crossTileID = t3;
                break;
              }
            }
          }
        }
      }
      class Si2 {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class Ii2 {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(e22) {
          const t22 = Math.round((e22 - this.lng) / 360);
          if (0 !== t22)
            for (const e3 in this.indexes) {
              const i2 = this.indexes[e3], o2 = {};
              for (const e4 in i2) {
                const r22 = i2[e4];
                r22.tileID = r22.tileID.unwrapTo(r22.tileID.wrap + t22), o2[r22.tileID.key] = r22;
              }
              this.indexes[e3] = o2;
            }
          this.lng = e22;
        }
        addBucket(e22, t22, i2) {
          if (this.indexes[e22.overscaledZ] && this.indexes[e22.overscaledZ][e22.key]) {
            if (this.indexes[e22.overscaledZ][e22.key].bucketInstanceId === t22.bucketInstanceId)
              return false;
            this.removeBucketCrossTileIDs(e22.overscaledZ, this.indexes[e22.overscaledZ][e22.key]);
          }
          for (let e3 = 0; e3 < t22.symbolInstances.length; e3++)
            t22.symbolInstances.get(e3).crossTileID = 0;
          this.usedCrossTileIDs[e22.overscaledZ] || (this.usedCrossTileIDs[e22.overscaledZ] = /* @__PURE__ */ new Set());
          const o2 = this.usedCrossTileIDs[e22.overscaledZ];
          for (const i3 in this.indexes) {
            const r22 = this.indexes[i3];
            if (Number(i3) > e22.overscaledZ)
              for (const i4 in r22) {
                const s2 = r22[i4];
                s2.tileID.isChildOf(e22) && s2.findMatches(t22.symbolInstances, e22, o2);
              }
            else {
              const s2 = r22[e22.scaledTo(Number(i3)).key];
              s2 && s2.findMatches(t22.symbolInstances, e22, o2);
            }
          }
          for (let e3 = 0; e3 < t22.symbolInstances.length; e3++) {
            const r22 = t22.symbolInstances.get(e3);
            r22.crossTileID || (r22.crossTileID = i2.generate(), o2.add(r22.crossTileID));
          }
          return void 0 === this.indexes[e22.overscaledZ] && (this.indexes[e22.overscaledZ] = {}), this.indexes[e22.overscaledZ][e22.key] = new Ci2(e22, t22.symbolInstances, t22.bucketInstanceId), true;
        }
        removeBucketCrossTileIDs(e22, t22) {
          for (const i2 of t22.crossTileIDs)
            this.usedCrossTileIDs[e22].delete(i2);
        }
        removeStaleBuckets(e22) {
          let t22 = false;
          for (const i2 in this.indexes) {
            const o2 = this.indexes[i2];
            for (const r22 in o2)
              e22[o2[r22].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[r22]), delete o2[r22], t22 = true);
          }
          return t22;
        }
      }
      class Di2 {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new Si2(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(e22, t22, i2, o2) {
          let r22 = this.layerIndexes[e22.fqid];
          void 0 === r22 && (r22 = this.layerIndexes[e22.fqid] = new Ii2());
          let s2 = false;
          const a2 = {};
          "globe" !== o2.name && r22.handleWrapJump(i2);
          for (const i3 of t22) {
            const t3 = i3.getBucket(e22);
            t3 && e22.fqid === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), r22.addBucket(i3.tileID, t3, this.crossTileIDs) && (s2 = true), a2[t3.bucketInstanceId] = true);
          }
          return r22.removeStaleBuckets(a2) && (s2 = true), s2;
        }
        pruneUnusedLayers(e22) {
          const t22 = {};
          e22.forEach((e3) => {
            t22[e3] = true;
          });
          for (const e3 in this.layerIndexes)
            t22[e3] || delete this.layerIndexes[e3];
        }
      }
      const Ri2 = 771;
      class Ai2 {
        constructor(e22, t22, i2, o2) {
          this.blendFunction = e22, this.blendColor = t22, this.mask = i2, this.blendEquation = o2;
        }
      }
      Ai2.Replace = [1, 0, 1, 0], Ai2.disabled = new Ai2(Ai2.Replace, e2.bz.transparent, [false, false, false, false]), Ai2.unblended = new Ai2(Ai2.Replace, e2.bz.transparent, [true, true, true, true]), Ai2.alphaBlended = new Ai2([1, Ri2, 1, Ri2], e2.bz.transparent, [true, true, true, true]), Ai2.alphaBlendedNonPremultiplied = new Ai2([770, Ri2, 770, Ri2], e2.bz.transparent, [true, true, true, true]), Ai2.multiply = new Ai2([774, 0, 774, 0], e2.bz.transparent, [true, true, true, true]);
      class Li2 {
        constructor(e22, t22, i2) {
          this.func = e22, this.mask = t22, this.range = i2;
        }
      }
      Li2.ReadOnly = false, Li2.ReadWrite = true, Li2.disabled = new Li2(519, Li2.ReadOnly, [0, 1]);
      const Pi2 = 7680;
      class Mi2 {
        constructor(e22, t22, i2, o2, r22, s2) {
          this.test = e22, this.ref = t22, this.mask = i2, this.fail = o2, this.depthFail = r22, this.pass = s2;
        }
      }
      Mi2.disabled = new Mi2({ func: 519, mask: 0 }, 0, 0, Pi2, Pi2, Pi2);
      const zi2 = 1029, Oi2 = 2305;
      class Fi2 {
        constructor(e22, t22, i2) {
          this.enable = e22, this.mode = t22, this.frontFace = i2;
        }
      }
      function ki2(t22, i2) {
        const o2 = e2.bC(t22, 3);
        e2.a6.mat4.fromQuat(t22, i2), e2.bE(t22, 3, o2);
      }
      function Bi2(t22, i2) {
        const o2 = e2.a6.quat.identity([]);
        return e2.a6.quat.rotateZ(o2, o2, -i2), e2.a6.quat.rotateX(o2, o2, -t22), o2;
      }
      function Ni2(t22, i2) {
        const o2 = [t22[0], t22[1], 0], r22 = [i2[0], i2[1], 0];
        if (e2.a6.vec3.length(o2) >= 1e-15) {
          const t3 = e2.a6.vec3.normalize([], o2);
          e2.a6.vec3.scale(r22, t3, e2.a6.vec3.dot(r22, t3)), i2[0] = r22[0], i2[1] = r22[1];
        }
        const s2 = e2.a6.vec3.cross([], i2, t22);
        if (e2.a6.vec3.len(s2) < 1e-15)
          return null;
        const a2 = Math.atan2(-s2[1], s2[0]);
        return Bi2(Math.atan2(Math.sqrt(t22[0] * t22[0] + t22[1] * t22[1]), -t22[2]), a2);
      }
      Fi2.disabled = new Fi2(false, zi2, Oi2), Fi2.backCCW = new Fi2(true, zi2, Oi2), Fi2.backCW = new Fi2(true, zi2, 2304), Fi2.frontCW = new Fi2(true, 1028, 2304), Fi2.frontCCW = new Fi2(true, 1028, Oi2);
      class Ui2 {
        constructor(e22, t22) {
          this.position = e22, this.orientation = t22;
        }
        get position() {
          return this._position;
        }
        set position(t22) {
          if (t22) {
            const i2 = t22 instanceof e2.a5 ? t22 : new e2.a5(t22[0], t22[1], t22[2]);
            this._renderWorldCopies && (i2.x = e2.bA(i2.x, 0, 1)), this._position = i2;
          } else
            this._position = null;
        }
        lookAtPoint(t22, i2) {
          if (this.orientation = null, !this.position)
            return;
          const o2 = this.position, r22 = this._elevation ? this._elevation.getAtPointOrZero(e2.a5.fromLngLat(t22)) : 0, s2 = e2.a5.fromLngLat(t22, r22), a2 = [s2.x - o2.x, s2.y - o2.y, s2.z - o2.z];
          i2 || (i2 = [0, 0, 1]), i2[2] = Math.abs(i2[2]), this.orientation = Ni2(a2, i2);
        }
        setPitchBearing(t22, i2) {
          this.orientation = Bi2(e2.bB(t22), e2.bB(-i2));
        }
      }
      class Gi2 {
        constructor(t22, i2) {
          this._transform = e2.a6.mat4.identity([]), this.orientation = i2, this.position = t22;
        }
        get mercatorPosition() {
          const t22 = this.position;
          return new e2.a5(t22[0], t22[1], t22[2]);
        }
        get position() {
          const t22 = e2.bC(this._transform, 3);
          return [t22[0], t22[1], t22[2]];
        }
        set position(t22) {
          var i2;
          t22 && e2.bE(this._transform, 3, [(i2 = t22)[0], i2[1], i2[2], 1]);
        }
        get orientation() {
          return this._orientation;
        }
        set orientation(t22) {
          this._orientation = t22 || e2.a6.quat.identity([]), t22 && ki2(this._transform, this._orientation);
        }
        getPitchBearing() {
          const e22 = this.forward(), t22 = this.right();
          return { bearing: Math.atan2(-t22[1], t22[0]), pitch: Math.atan2(Math.sqrt(e22[0] * e22[0] + e22[1] * e22[1]), -e22[2]) };
        }
        setPitchBearing(e22, t22) {
          this._orientation = Bi2(e22, t22), ki2(this._transform, this._orientation);
        }
        forward() {
          const t22 = e2.bC(this._transform, 2);
          return [-t22[0], -t22[1], -t22[2]];
        }
        up() {
          const t22 = e2.bC(this._transform, 1);
          return [-t22[0], -t22[1], -t22[2]];
        }
        right() {
          const t22 = e2.bC(this._transform, 0);
          return [t22[0], t22[1], t22[2]];
        }
        getCameraToWorld(t22, i2) {
          const o2 = new Float64Array(16);
          return e2.a6.mat4.invert(o2, this.getWorldToCamera(t22, i2)), o2;
        }
        getCameraToWorldMercator() {
          return this._transform;
        }
        getWorldToCameraPosition(t22, i2, o2) {
          const r22 = this.position;
          e2.a6.vec3.scale(r22, r22, -t22);
          const s2 = new Float64Array(16);
          return e2.a6.mat4.fromScaling(s2, [o2, o2, o2]), e2.a6.mat4.translate(s2, s2, r22), s2[10] *= i2, s2;
        }
        getWorldToCamera(t22, i2) {
          const o2 = new Float64Array(16), r22 = new Float64Array(4), s2 = this.position;
          return e2.a6.quat.conjugate(r22, this._orientation), e2.a6.vec3.scale(s2, s2, -t22), e2.a6.mat4.fromQuat(o2, r22), e2.a6.mat4.translate(o2, o2, s2), o2[1] *= -1, o2[5] *= -1, o2[9] *= -1, o2[13] *= -1, o2[8] *= i2, o2[9] *= i2, o2[10] *= i2, o2[11] *= i2, o2;
        }
        getCameraToClipPerspective(t22, i2, o2, r22) {
          const s2 = new Float64Array(16);
          return e2.a6.mat4.perspective(s2, t22, i2, o2, r22), s2;
        }
        getCameraToClipOrthographic(t22, i2, o2, r22, s2, a2) {
          const n22 = new Float64Array(16);
          return e2.a6.mat4.ortho(n22, t22, i2, o2, r22, s2, a2), n22;
        }
        getDistanceToElevation(t22, i2 = false) {
          const o2 = 0 === t22 ? 0 : e2.bD(t22, i2 ? e2.aM(this.position[1]) : this.position[1]), r22 = this.forward();
          return (o2 - this.position[2]) / r22[2];
        }
        clone() {
          return new Gi2([...this.position], [...this.orientation]);
        }
      }
      const ji2 = { BaseColor: 5, MetallicRoughness: 6, Normal: 7, Occlusion: 8, Emission: 9, LUT: 10, ShadowMap0: 11 };
      class Vi2 {
        constructor(e22 = 0, t22 = 0, i2 = 0, o2 = 0) {
          if (isNaN(e22) || e22 < 0 || isNaN(t22) || t22 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = e22, this.bottom = t22, this.left = i2, this.right = o2;
        }
        interpolate(t22, i2, o2) {
          return null != i2.top && null != t22.top && (this.top = e2.aa(t22.top, i2.top, o2)), null != i2.bottom && null != t22.bottom && (this.bottom = e2.aa(t22.bottom, i2.bottom, o2)), null != i2.left && null != t22.left && (this.left = e2.aa(t22.left, i2.left, o2)), null != i2.right && null != t22.right && (this.right = e2.aa(t22.right, i2.right, o2)), this;
        }
        getCenter(t22, i2) {
          const o2 = e2.ap((this.left + t22 - this.right) / 2, 0, t22), r22 = e2.ap((this.top + i2 - this.bottom) / 2, 0, i2);
          return new e2.P(o2, r22);
        }
        equals(e22) {
          return this.top === e22.top && this.bottom === e22.bottom && this.left === e22.left && this.right === e22.right;
        }
        clone() {
          return new Vi2(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      const qi2 = (e22, t22, i2) => (1 - i2) * e22 + i2 * t22, Zi2 = (e22) => e22 * e22 * e22 * e22 * e22;
      class Hi2 {
        constructor(t22, i2, o2, r22, s2, a2, n22) {
          this.tileSize = 512, this._renderWorldCopies = void 0 === s2 || s2, this._minZoom = t22 || 0, this._maxZoom = i2 || 22, this._minPitch = o2 != null ? o2 : 0, this._maxPitch = r22 != null ? r22 : 60, this.setProjection(a2), this.setMaxBounds(n22), this.width = 0, this.height = 0, this._center = new e2.bK(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new Vi2(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Gi2(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = false, this._horizonShift = 0.1, this._orthographicProjectionAtLowPitch = false;
        }
        clone() {
          const e22 = new Hi2(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
          return e22._elevation = this._elevation, e22._centerAltitude = this._centerAltitude, e22._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e22.tileSize = this.tileSize, e22.mercatorFromTransition = this.mercatorFromTransition, e22.width = this.width, e22.height = this.height, e22.cameraElevationReference = this.cameraElevationReference, e22._center = this._center, e22._setZoom(this.zoom), e22._seaLevelZoom = this._seaLevelZoom, e22.angle = this.angle, e22._fov = this._fov, e22._pitch = this._pitch, e22._nearZ = this._nearZ, e22._farZ = this._farZ, e22._averageElevation = this._averageElevation, e22._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e22._unmodified = this._unmodified, e22._edgeInsets = this._edgeInsets.clone(), e22._camera = this._camera.clone(), e22._calcMatrices(), e22.freezeTileCoverage = this.freezeTileCoverage, e22.frustumCorners = this.frustumCorners, e22;
        }
        get isOrthographic() {
          return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < 15;
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(e22) {
          this._elevation !== e22 && (this._elevation = e22, this._updateCameraOnTerrain(), this._calcMatrices());
        }
        get depthOcclusionForSymbolsAndCircles() {
          return "globe" !== this.projection.name && !this.isOrthographic;
        }
        updateElevation(e22, t22 = false) {
          const i2 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
          (null == this._seaLevelZoom || i2) && this._updateCameraOnTerrain(), (e22 || i2) && this._constrainCamera(t22), this._calcMatrices();
        }
        getProjection() {
          return e2.ar(this.projection, ["name", "center", "parallels"]);
        }
        setProjection(t22) {
          this.projectionOptions = t22 || { name: "mercator" };
          const i2 = this.projection ? this.getProjection() : void 0;
          this.projection = e2.bL(this.projectionOptions);
          const o2 = this.getProjection(), r22 = !e2.bh(i2, o2);
          return r22 && this._calcMatrices(), this.mercatorFromTransition = false, r22;
        }
        setOrthographicProjectionAtLowPitch(e22) {
          return this._orthographicProjectionAtLowPitch !== e22 && (this._orthographicProjectionAtLowPitch = e22, this._calcMatrices(), true);
        }
        setMercatorFromTransition() {
          const t22 = this.projection.name;
          this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = e2.bL({ name: "mercator" });
          const i2 = t22 !== this.projection.name;
          return i2 && this._calcMatrices(), i2;
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(e22) {
          this._minZoom !== e22 && (this._minZoom = e22, this.zoom = Math.max(this.zoom, e22));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(e22) {
          this._maxZoom !== e22 && (this._maxZoom = e22, this.zoom = Math.min(this.zoom, e22));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(e22) {
          this._minPitch !== e22 && (this._minPitch = e22, this.pitch = Math.max(this.pitch, e22));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(e22) {
          this._maxPitch !== e22 && (this._maxPitch = e22, this.pitch = Math.min(this.pitch, e22));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies && true === this.projection.supportsWorldCopies;
        }
        set renderWorldCopies(e22) {
          void 0 === e22 ? e22 = true : null === e22 && (e22 = false), this._renderWorldCopies = e22;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get cameraWorldSizeForFog() {
          const e22 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(e22));
        }
        get cameraWorldSize() {
          const e22 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(e22));
        }
        get pixelsPerMeter() {
          return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
        }
        get cameraPixelsPerMeter() {
          return e2.bD(1, this.center.lat) * this.cameraWorldSizeForFog;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new e2.P(this.width, this.height);
        }
        get bearing() {
          return e2.bA(this.rotation, -180, 180);
        }
        set bearing(e22) {
          this.rotation = e22;
        }
        get rotation() {
          return -this.angle / Math.PI * 180;
        }
        set rotation(t22) {
          const i2 = -t22 * Math.PI / 180;
          this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = e2.a6.mat2.create(), e2.a6.mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(t22) {
          const i2 = e2.ap(t22, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
        }
        get aspect() {
          return this.width / this.height;
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        get fovX() {
          return this._fov;
        }
        get fovY() {
          const e22 = 1 / Math.tan(0.5 * this.fovX);
          return 2 * Math.atan(1 / this.aspect / e22);
        }
        set fov(t22) {
          t22 = Math.max(0.01, Math.min(60, t22)), this._fov !== t22 && (this._unmodified = false, this._fov = e2.bB(t22), this._calcMatrices());
        }
        get averageElevation() {
          return this._averageElevation;
        }
        set averageElevation(e22) {
          this._averageElevation = e22, this._calcFogMatrices(), this._distanceTileDataCache = {};
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(e22) {
          const t22 = Math.min(Math.max(e22, this.minZoom), this.maxZoom);
          this._zoom !== t22 && (this._unmodified = false, this._setZoom(t22), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
        }
        _setZoom(e22) {
          this._zoom = e22, this.scale = this.zoomScale(e22), this.tileZoom = Math.floor(e22), this.zoomFraction = e22 - this.tileZoom;
        }
        get tileCoverLift() {
          return this._tileCoverLift;
        }
        set tileCoverLift(e22) {
          this._tileCoverLift !== e22 && (this._tileCoverLift = e22);
        }
        _updateCameraOnTerrain() {
          const e22 = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, t22 = this.elevation && e22 === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
          if (!this._elevation || e22 === Number.NEGATIVE_INFINITY && (!t22 || !this._centerAltitude))
            return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
          const i2 = this._elevation;
          t22 || this._centerAltitude && this._centerAltitudeValidForExaggeration && i2.exaggeration() && this._centerAltitudeValidForExaggeration !== i2.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i2.exaggeration(), this._centerAltitudeValidForExaggeration = i2.exaggeration()) : (this._centerAltitude = e22 || 0, this._centerAltitudeValidForExaggeration = i2.exaggeration()), this._updateSeaLevelZoom();
        }
        _updateSeaLevelZoom() {
          void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
        }
        sampleAverageElevation() {
          if (!this._elevation)
            return 0;
          const t22 = this._elevation, i2 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o2 = this.horizonLineFromTop();
          let r22 = 0, s2 = 0;
          for (let a2 = 0; a2 < i2.length; a2++) {
            const n22 = new e2.P(i2[a2][0] * this.width, o2 + i2[a2][1] * (this.height - o2)), l22 = t22.pointCoordinate(n22);
            if (!l22)
              continue;
            const c22 = 1 / Math.hypot(l22[0] - this._camera.position[0], l22[1] - this._camera.position[1]);
            r22 += l22[3] * c22, s2 += c22;
          }
          return 0 === s2 ? NaN : r22 / s2;
        }
        get center() {
          return this._center;
        }
        set center(e22) {
          e22.lat === this._center.lat && e22.lng === this._center.lng || (this._unmodified = false, this._center = e22, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
        }
        _updateZoomFromElevation() {
          if (null == this._seaLevelZoom || !this._elevation)
            return;
          const e22 = this._seaLevelZoom, t22 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i2 = this.pixelsPerMeter / this.worldSize * t22, o2 = this._mercatorZfromZoom(e22), r22 = this._mercatorZfromZoom(this._maxZoom), s2 = Math.max(o2 - i2, r22);
          this._setZoom(this._zoomFromMercatorZ(s2));
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(e22) {
          this._edgeInsets.equals(e22) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e22, 1), this._calcMatrices());
        }
        computeZoomRelativeTo(t22) {
          const i2 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t22.toAltitude()));
          let o2;
          o2 = t22.z < this._camera.position[2] ? [i2.x, i2.y, i2.z] : [t22.x, t22.y, t22.z];
          const r22 = e2.a6.vec3.length(e2.a6.vec3.sub([], this._camera.position, o2));
          return e2.ap(this._zoomFromMercatorZ(r22), this._minZoom, this._maxZoom);
        }
        setFreeCameraOptions(t22) {
          if (!this.height)
            return;
          if (!t22.position && !t22.orientation)
            return;
          this._updateCameraState();
          let i2 = false;
          if (t22.orientation && !e2.a6.quat.exactEquals(t22.orientation, this._camera.orientation) && (i2 = this._setCameraOrientation(t22.orientation)), t22.position) {
            const o2 = [t22.position.x, t22.position.y, t22.position.z];
            e2.a6.vec3.exactEquals(o2, this._camera.position) || (this._setCameraPosition(o2), i2 = true);
          }
          i2 && (this._updateStateFromCamera(), this.recenterOnTerrain());
        }
        getFreeCameraOptions() {
          this._updateCameraState();
          const t22 = this._camera.position, i2 = new Ui2();
          return i2.position = new e2.a5(t22[0], t22[1], t22[2]), i2.orientation = this._camera.orientation, i2._elevation = this.elevation, i2._renderWorldCopies = this.renderWorldCopies, i2;
        }
        _setCameraOrientation(t22) {
          if (!e2.a6.quat.length(t22))
            return false;
          e2.a6.quat.normalize(t22, t22);
          const i2 = e2.a6.vec3.transformQuat([], [0, 0, -1], t22), o2 = e2.a6.vec3.transformQuat([], [0, -1, 0], t22);
          if (o2[2] < 0)
            return false;
          const r22 = Ni2(i2, o2);
          return !!r22 && (this._camera.orientation = r22, true);
        }
        _setCameraPosition(t22) {
          const i2 = this.zoomScale(this.minZoom) * this.tileSize, o2 = this.zoomScale(this.maxZoom) * this.tileSize, r22 = this.cameraToCenterDistance;
          t22[2] = e2.ap(t22[2], r22 / o2, r22 / i2), this._camera.position = t22;
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        get fovAboveCenter() {
          return this._fov * (0.5 + this.centerOffset.y / this.height);
        }
        isPaddingEqual(e22) {
          return this._edgeInsets.equals(e22);
        }
        interpolatePadding(e22, t22, i2) {
          this._unmodified = false, this._edgeInsets.interpolate(e22, t22, i2), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(e22) {
          const t22 = (e22.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e22.tileSize));
          return Math.max(0, t22);
        }
        getVisibleUnwrappedCoordinates(t22) {
          const i2 = [new e2.bM(0, t22)];
          if (this.renderWorldCopies) {
            const o2 = this.pointCoordinate(new e2.P(0, 0)), r22 = this.pointCoordinate(new e2.P(this.width, 0)), s2 = this.pointCoordinate(new e2.P(this.width, this.height)), a2 = this.pointCoordinate(new e2.P(0, this.height)), n22 = Math.floor(Math.min(o2.x, r22.x, s2.x, a2.x)), l22 = Math.floor(Math.max(o2.x, r22.x, s2.x, a2.x)), c22 = 1;
            for (let o3 = n22 - c22; o3 <= l22 + c22; o3++)
              0 !== o3 && i2.push(new e2.bM(o3, t22));
          }
          return i2;
        }
        isLODDisabled(e22) {
          return (!e22 || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
        }
        extendTileCover(t22, i2, o2) {
          let r22 = [];
          const s2 = void 0 !== o2, a2 = !s2;
          if (a2 && this.zoom < i2)
            return r22;
          if (s2 && 0 === o2[0] && 0 === o2[1])
            return r22;
          const n22 = /* @__PURE__ */ new Set(), l22 = (t3, i3, o3, s3, a3) => {
            const l3 = e2.c1(i3, t3, o3, s3, a3);
            n22.has(l3) || (r22.push(new e2.aA(t3, i3, o3, s3, a3)), n22.add(l3));
          };
          for (let e22 = 0; e22 < t22.length; e22++) {
            const r3 = t22[e22];
            if (a2 && r3.canonical.z !== i2)
              continue;
            const n3 = r3.canonical, c3 = r3.overscaledZ, h22 = r3.wrap, u22 = 1 << n3.z, d22 = n3.x + 1 < u22, _2 = n3.x > 0, p22 = n3.y + 1 < u22, m22 = n3.y > 0, f22 = r3.wrap - (_2 ? 0 : 1), g22 = r3.wrap + (d22 ? 0 : 1), v22 = _2 ? n3.x - 1 : u22 - 1, x22 = d22 ? n3.x + 1 : 0;
            if (s2)
              o2[0] < 0 ? (l22(c3, g22, n3.z, x22, n3.y), o2[1] < 0 && p22 && (l22(c3, h22, n3.z, n3.x, n3.y + 1), l22(c3, g22, n3.z, x22, n3.y + 1)), o2[1] > 0 && m22 && (l22(c3, h22, n3.z, n3.x, n3.y - 1), l22(c3, g22, n3.z, x22, n3.y - 1))) : o2[0] > 0 ? (l22(c3, f22, n3.z, v22, n3.y), o2[1] < 0 && p22 && (l22(c3, h22, n3.z, n3.x, n3.y + 1), l22(c3, f22, n3.z, v22, n3.y + 1)), o2[1] > 0 && m22 && (l22(c3, h22, n3.z, n3.x, n3.y - 1), l22(c3, f22, n3.z, v22, n3.y - 1))) : o2[1] < 0 && p22 ? l22(c3, h22, n3.z, n3.x, n3.y + 1) : m22 && l22(c3, h22, n3.z, n3.x, n3.y - 1);
            else {
              const e3 = r3.visibleQuadrants;
              1 & e3 && (l22(c3, f22, n3.z, v22, n3.y), m22 && (l22(c3, h22, n3.z, n3.x, n3.y - 1), l22(c3, f22, n3.z, v22, n3.y - 1))), 2 & e3 && (l22(c3, g22, n3.z, x22, n3.y), m22 && (l22(c3, h22, n3.z, n3.x, n3.y - 1), l22(c3, g22, n3.z, x22, n3.y - 1))), 4 & e3 && (l22(c3, f22, n3.z, v22, n3.y), p22 && (l22(c3, h22, n3.z, n3.x, n3.y + 1), l22(c3, f22, n3.z, v22, n3.y + 1))), 8 & e3 && (l22(c3, g22, n3.z, x22, n3.y), p22 && (l22(c3, h22, n3.z, n3.x, n3.y + 1), l22(c3, g22, n3.z, x22, n3.y + 1)));
            }
          }
          const c22 = [];
          for (const e22 of r22)
            r22.some((t3) => e22.isChildOf(t3)) || c22.push(e22);
          if (r22 = c22.filter((e22) => !t22.some((t3) => !!(e22.overscaledZ < i2 && t3.isChildOf(e22)) || e22.equals(t3) || e22.isChildOf(t3))), a2) {
            const e22 = 1 << i2, t3 = "globe" === this.projection.name ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), o3 = [e22 * t3.x, e22 * t3.y], s3 = 4, a3 = s3 * s3;
            r22 = r22.filter((e3) => {
              const t4 = e3.canonical.x + 0.5 - o3[0], i3 = e3.canonical.y + 0.5 - o3[1];
              return t4 * t4 + i3 * i3 < a3;
            });
          }
          return r22;
        }
        coveringTiles(t22) {
          let i2 = this.coveringZoomLevel(t22);
          const o2 = i2, r22 = this.elevation && this.elevation.exaggeration(), s2 = r22 && !t22.isTerrainDEM, a2 = "mercator" === this.projection.name;
          if (void 0 !== t22.minzoom && i2 < t22.minzoom)
            return [];
          void 0 !== t22.maxzoom && i2 > t22.maxzoom && (i2 = t22.maxzoom);
          const n22 = this.locationCoordinate(this.center), l22 = this.center.lat, c22 = 1 << i2, h22 = [c22 * n22.x, c22 * n22.y, 0], u22 = "globe" === this.projection.name, d22 = !u22, _2 = e2.bN.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2, d22), p22 = u22 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), m22 = c22 * e2.bD(1, this.center.lat), f22 = this._camera.position[2] / e2.bD(1, this.center.lat), g22 = [c22 * p22.x, c22 * p22.y, f22 * (d22 ? 1 : m22)], v22 = u22 || r22, x22 = this.cameraToCenterDistance / t22.tileSize * (t22.roundZoom ? 1 : 0.502), y22 = this.isLODDisabled(true) ? i2 : 0;
          let b22;
          if (this._elevation && t22.isTerrainDEM)
            b22 = 1e4 * this._elevation.exaggeration();
          else if (this._elevation) {
            const e22 = this._elevation.getMinMaxForVisibleTiles();
            b22 = e22 ? e22.max : this._centerAltitude;
          } else
            b22 = this._centerAltitude;
          const w22 = t22.isTerrainDEM ? -b22 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, T22 = this.projection.isReprojectedInTileSpace ? e2.bO(this) : 1, E22 = (t3) => {
            const i3 = 1 / 4e4, o3 = new e2.a5(t3.x + i3, t3.y, t3.z), r3 = new e2.a5(t3.x, t3.y + i3, t3.z), s3 = t3.toLngLat(), a3 = o3.toLngLat(), n3 = r3.toLngLat(), l3 = this.locationCoordinate(s3), c3 = this.locationCoordinate(a3), h3 = this.locationCoordinate(n3), u3 = Math.hypot(c3.x - l3.x, c3.y - l3.y), d3 = Math.hypot(h3.x - l3.x, h3.y - l3.y);
            return Math.sqrt(u3 * d3) * T22 / i3;
          }, C22 = (t3) => {
            const i3 = b22, o3 = w22;
            return { aabb: e2.bR(this, c22, 0, 0, 0, t3, o3, i3, this.projection), zoom: 0, x: 0, y: 0, minZ: o3, maxZ: i3, wrap: t3, fullyVisible: false };
          }, S22 = [];
          let I22 = [];
          const D22 = i2, R22 = t22.reparseOverscaled ? o2 : i2, A22 = (f22 - this._centerAltitude) * m22, L22 = (e22) => {
            if (!this._elevation || !e22.tileID || !a2)
              return;
            const t3 = this._elevation.getMinMaxForTile(e22.tileID), i3 = e22.aabb;
            t3 ? (i3.min[2] = t3.min, i3.max[2] = t3.max, i3.center[2] = (i3.min[2] + i3.max[2]) / 2) : (e22.shouldSplit = M22(e22), e22.shouldSplit || (i3.min[2] = i3.max[2] = i3.center[2] = this._centerAltitude));
          }, P22 = (e22, t3) => {
            if (0.707 * t3 < e22)
              return 1;
            const i3 = t3 / e22;
            return i3 / (1.4144271570014144 + (Math.pow(1.1, i3 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
          }, M22 = (t3) => {
            if (t3.zoom < y22)
              return true;
            if (t3.zoom === D22)
              return false;
            if (null != t3.shouldSplit)
              return t3.shouldSplit;
            const i3 = t3.aabb.distanceX(g22), r3 = t3.aabb.distanceY(g22);
            let n3 = A22, c3 = 1;
            if (u22) {
              n3 = t3.aabb.distanceZ(g22);
              const i4 = Math.pow(2, t3.zoom), o3 = e2.aM((t3.y + 1) / i4), r4 = e2.aM(t3.y / i4), s3 = Math.min(Math.max(l22, o3), r4), a3 = e2.c5(s3) / e2.c5(l22);
              if (c3 = s3 === l22 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, a3 / this._mercatorScaleRatio), this.zoom <= e2.c2 && t3.zoom === D22 - 1 && a3 >= 0.9)
                return true;
            } else if (s2 && (n3 = t3.aabb.distanceZ(g22) * m22), this.projection.isReprojectedInTileSpace && o2 <= 5) {
              const i4 = Math.pow(2, t3.zoom), o3 = E22(new e2.a5((t3.x + 0.5) / i4, (t3.y + 0.5) / i4));
              c3 = o3 > 0.85 ? 1 : o3;
            }
            if (!a2) {
              const e22 = Math.sqrt(i3 * i3 + r3 * r3 + n3 * n3);
              let o3 = (1 << D22 - t3.zoom) * x22 * c3;
              return o3 *= P22(Math.max(n3, A22), e22), e22 < o3;
            }
            let d3 = Number.MAX_VALUE, _3 = 0;
            const p3 = t3.aabb.getCorners(), f3 = [];
            for (const t4 of p3) {
              e2.a6.vec3.sub(f3, t4, g22), u22 || (s2 ? f3[2] *= m22 : f3[2] = A22);
              const i4 = e2.a6.vec3.dot(f3, this._camera.forward());
              i4 < d3 && (d3 = i4, _3 = Math.abs(f3[2]));
            }
            let v3 = (1 << D22 - t3.zoom) * x22 * c3;
            if (v3 *= P22(Math.max(_3, A22), d3), d3 < v3)
              return true;
            const b3 = t3.aabb.closestPoint(h22);
            return b3[0] === h22[0] && b3[1] === h22[1];
          };
          if (this.renderWorldCopies)
            for (let e22 = 1; e22 <= 3; e22++)
              S22.push(C22(-e22)), S22.push(C22(e22));
          for (S22.push(C22(0)); S22.length > 0; ) {
            const o3 = S22.pop(), r3 = o3.x, n3 = o3.y;
            let l3 = o3.fullyVisible;
            const d3 = () => "globe" === this.projection.name && (0 === o3.y || o3.y === (1 << o3.zoom) - 1);
            if (!l3) {
              let t3 = v22 ? o3.aabb.intersects(_2) : o3.aabb.intersectsFlat(_2);
              if (0 === t3 && d3()) {
                const i3 = new e2.bP(o3.zoom, r3, n3);
                t3 = e2.bQ(this, c22, i3, true).intersects(_2);
              }
              if (0 === t3)
                continue;
              l3 = 2 === t3;
            }
            if (o3.zoom !== D22 && M22(o3))
              for (let t3 = 0; t3 < 4; t3++) {
                const i3 = (r3 << 1) + t3 % 2, h3 = (n3 << 1) + (t3 >> 1), d4 = { aabb: a2 ? o3.aabb.quadrant(t3) : e2.bR(this, c22, o3.zoom + 1, i3, h3, o3.wrap, o3.minZ, o3.maxZ, this.projection), zoom: o3.zoom + 1, x: i3, y: h3, wrap: o3.wrap, fullyVisible: l3, tileID: void 0, shouldSplit: void 0, minZ: o3.minZ, maxZ: o3.maxZ };
                s2 && !u22 && (d4.tileID = new e2.aA(o3.zoom + 1 === D22 ? R22 : o3.zoom + 1, o3.wrap, o3.zoom + 1, i3, h3), L22(d4)), S22.push(d4);
              }
            else {
              const s3 = o3.zoom === D22 ? R22 : o3.zoom;
              if (t22.minzoom && t22.minzoom > s3)
                continue;
              let a3 = 0;
              if (!l3) {
                let i3 = v22 ? o3.aabb.intersectsPrecise(_2) : o3.aabb.intersectsPreciseFlat(_2);
                if (0 === i3 && d3()) {
                  const t3 = new e2.bP(o3.zoom, r3, n3);
                  i3 = e2.bQ(this, c22, t3, true).intersectsPrecise(_2);
                }
                if (0 === i3)
                  continue;
                if (t22.calculateQuadrantVisibility)
                  if (_2.containsPoint(o3.aabb.center))
                    a3 = 15;
                  else
                    for (let e22 = 0; e22 < 4; e22++)
                      0 !== o3.aabb.quadrant(e22).intersects(_2) && (a3 |= 1 << e22);
              }
              const u3 = h22[0] - (0.5 + r3 + (o3.wrap << o3.zoom)) * (1 << i2 - o3.zoom), p3 = h22[1] - 0.5 - n3, m3 = o3.tileID ? o3.tileID : new e2.aA(s3, o3.wrap, o3.zoom, r3, n3);
              t22.calculateQuadrantVisibility && (m3.visibleQuadrants = a3), I22.push({ tileID: m3, distanceSq: u3 * u3 + p3 * p3 });
            }
          }
          if (this.fogCullDistSq) {
            const i3 = this.fogCullDistSq, o3 = this.horizonLineFromTop();
            I22 = I22.filter((r3) => {
              const s3 = [0, 0, 0, 1], a3 = [e2.ab, e2.ab, 0, 1], n3 = this.calculateFogTileMatrix(r3.tileID.toUnwrapped());
              e2.a6.vec4.transformMat4(s3, s3, n3), e2.a6.vec4.transformMat4(a3, a3, n3);
              const l3 = e2.a6.vec4.min([], s3, a3), c3 = e2.a6.vec4.max([], s3, a3), h3 = e2.bS(l3, c3);
              if (0 === h3)
                return true;
              let u3 = false;
              const d3 = this._elevation;
              if (d3 && h3 > i3 && 0 !== o3) {
                const i4 = this.calculateProjMatrix(r3.tileID.toUnwrapped());
                let s4;
                t22.isTerrainDEM || (s4 = d3.getMinMaxForTile(r3.tileID)), s4 || (s4 = { min: w22, max: b22 });
                const a4 = e2.c3(this.rotation), n4 = [a4[0] * e2.ab, a4[1] * e2.ab, s4.max];
                e2.a6.vec3.transformMat4(n4, n4, i4), u3 = (1 - n4[1]) * this.height * 0.5 < o3;
              }
              return h3 < i3 || u3;
            });
          }
          return I22.sort((e22, t3) => e22.distanceSq - t3.distanceSq).map((e22) => e22.tileID);
        }
        resize(e22, t22) {
          this.width = e22, this.height = t22, this.pixelsToGLUnits = [2 / e22, -2 / t22], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(e22) {
          return Math.pow(2, e22);
        }
        scaleZoom(e22) {
          return Math.log(e22) / Math.LN2;
        }
        project(t22) {
          const i2 = e2.ap(t22.lat, -e2.bT, e2.bT), o2 = this.projection.project(t22.lng, i2);
          return new e2.P(o2.x * this.worldSize, o2.y * this.worldSize);
        }
        unproject(e22) {
          return this.projection.unproject(e22.x / this.worldSize, e22.y / this.worldSize);
        }
        get point() {
          return this.project(this.center);
        }
        get pointMerc() {
          return this.point._div(this.worldSize);
        }
        get pixelsPerMeterRatio() {
          return this.pixelsPerMeter / e2.bD(1, this.center.lat) / this.worldSize;
        }
        setLocationAtPoint(t22, i2) {
          let o2, r22;
          const s2 = this.centerPoint;
          if ("globe" === this.projection.name) {
            const e22 = this.worldSize;
            o2 = (i2.x - s2.x) / e22, r22 = (i2.y - s2.y) / e22;
          } else {
            const e22 = this.pointCoordinate(i2), t3 = this.pointCoordinate(s2);
            o2 = e22.x - t3.x, r22 = e22.y - t3.y;
          }
          const a2 = this.locationCoordinate(t22);
          this.setLocation(new e2.a5(a2.x - o2, a2.y - r22));
        }
        setLocation(e22) {
          this.center = this.coordinateLocation(e22), this.projection.wrap && (this.center = this.center.wrap());
        }
        locationPoint(e22) {
          return this.projection.locationPoint(this, e22);
        }
        locationPoint3D(e22) {
          return this.projection.locationPoint(this, e22, true);
        }
        pointLocation(e22) {
          return this.coordinateLocation(this.pointCoordinate(e22));
        }
        pointLocation3D(e22) {
          return this.coordinateLocation(this.pointCoordinate3D(e22));
        }
        locationCoordinate(t22, i2) {
          const o2 = i2 ? e2.bD(i2, t22.lat) : void 0, r22 = this.projection.project(t22.lng, t22.lat);
          return new e2.a5(r22.x, r22.y, o2);
        }
        coordinateLocation(e22) {
          return this.projection.unproject(e22.x, e22.y);
        }
        pointRayIntersection(t22, i2) {
          const o2 = null != i2 ? i2 : this._centerAltitude, r22 = [t22.x, t22.y, 0, 1], s2 = [t22.x, t22.y, 1, 1];
          e2.a6.vec4.transformMat4(r22, r22, this.pixelMatrixInverse), e2.a6.vec4.transformMat4(s2, s2, this.pixelMatrixInverse);
          const a2 = s2[3];
          e2.a6.vec4.scale(r22, r22, 1 / r22[3]), e2.a6.vec4.scale(s2, s2, 1 / a2);
          const n22 = r22[2], l22 = s2[2];
          return { p0: r22, p1: s2, t: n22 === l22 ? 0 : (o2 - n22) / (l22 - n22) };
        }
        screenPointToMercatorRay(t22) {
          const i2 = [t22.x, t22.y, 0, 1], o2 = [t22.x, t22.y, 1, 1];
          return e2.a6.vec4.transformMat4(i2, i2, this.pixelMatrixInverse), e2.a6.vec4.transformMat4(o2, o2, this.pixelMatrixInverse), e2.a6.vec4.scale(i2, i2, 1 / i2[3]), e2.a6.vec4.scale(o2, o2, 1 / o2[3]), i2[2] = e2.bD(i2[2], this._center.lat) * this.worldSize, o2[2] = e2.bD(o2[2], this._center.lat) * this.worldSize, e2.a6.vec4.scale(i2, i2, 1 / this.worldSize), e2.a6.vec4.scale(o2, o2, 1 / this.worldSize), new e2.aj([i2[0], i2[1], i2[2]], e2.a6.vec3.normalize([], e2.a6.vec3.sub([], o2, i2)));
        }
        rayIntersectionCoordinate(t22) {
          const { p0: i2, p1: o2, t: r22 } = t22, s2 = e2.bD(i2[2], this._center.lat), a2 = e2.bD(o2[2], this._center.lat);
          return new e2.a5(e2.aa(i2[0], o2[0], r22) / this.worldSize, e2.aa(i2[1], o2[1], r22) / this.worldSize, e2.aa(s2, a2, r22));
        }
        pointCoordinate(e22, t22 = this._centerAltitude) {
          return this.projection.pointCoordinate(this, e22.x, e22.y, t22);
        }
        pointCoordinate3D(t22) {
          if (!this.elevation)
            return this.pointCoordinate(t22);
          let i2 = this.projection.pointCoordinate3D(this, t22.x, t22.y);
          if (i2)
            return new e2.a5(i2[0], i2[1], i2[2]);
          let o2 = 0, r22 = this.horizonLineFromTop();
          if (t22.y > r22)
            return this.pointCoordinate(t22);
          const s2 = 0.02 * r22, a2 = t22.clone();
          for (let t3 = 0; t3 < 10 && r22 - o2 > s2; t3++) {
            a2.y = e2.aa(o2, r22, 0.66);
            const t4 = this.projection.pointCoordinate3D(this, a2.x, a2.y);
            t4 ? (r22 = a2.y, i2 = t4) : o2 = a2.y;
          }
          return i2 ? new e2.a5(i2[0], i2[1], i2[2]) : this.pointCoordinate(t22);
        }
        isPointAboveHorizon(e22) {
          return this.projection.isPointAboveHorizon(this, e22);
        }
        isPointOnSurface(t22) {
          if (t22.y < 0 || t22.y > this.height || t22.x < 0 || t22.x > this.width)
            return false;
          if (this.elevation || this.zoom >= e2.bU)
            return !this.isPointAboveHorizon(t22);
          const i2 = this.pointCoordinate(t22);
          return i2.y >= 0 && i2.y <= 1;
        }
        _coordinatePoint(t22, i2) {
          const o2 = i2 && this.elevation ? this.elevation.getAtPointOrZero(t22, this._centerAltitude) : this._centerAltitude, r22 = [t22.x * this.worldSize, t22.y * this.worldSize, o2 + t22.toAltitude(), 1];
          return e2.a6.vec4.transformMat4(r22, r22, this.pixelMatrix), r22[3] > 0 ? new e2.P(r22[0] / r22[3], r22[1] / r22[3]) : new e2.P(Number.MAX_VALUE, Number.MAX_VALUE);
        }
        _getBoundsNonRectangular() {
          const { top: t22, left: i2 } = this._edgeInsets, o2 = this.height - this._edgeInsets.bottom, r22 = this.width - this._edgeInsets.right, s2 = this.pointLocation3D(new e2.P(i2, t22)), a2 = this.pointLocation3D(new e2.P(r22, t22)), n22 = this.pointLocation3D(new e2.P(r22, o2)), l22 = this.pointLocation3D(new e2.P(i2, o2));
          let c22 = Math.min(s2.lng, a2.lng, n22.lng, l22.lng), h22 = Math.max(s2.lng, a2.lng, n22.lng, l22.lng), u22 = Math.min(s2.lat, a2.lat, n22.lat, l22.lat), d22 = Math.max(s2.lat, a2.lat, n22.lat, l22.lat);
          const _2 = Math.pow(2, -this.zoom) / 16 * 270, p22 = "globe" === this.projection.name ? 1 : 4, m22 = (t3, i3, o3, r3, s3) => {
            const a3 = (t3 + o3) / 2, n3 = (i3 + r3) / 2, l3 = new e2.P(a3, n3), { lng: f22, lat: g22 } = this.pointLocation3D(l3), v22 = Math.max(0, c22 - f22, u22 - g22, f22 - h22, g22 - d22);
            c22 = Math.min(c22, f22), h22 = Math.max(h22, f22), u22 = Math.min(u22, g22), d22 = Math.max(d22, g22), (s3 < p22 || v22 > _2) && (m22(t3, i3, a3, n3, s3 + 1), m22(a3, n3, o3, r3, s3 + 1));
          };
          if (m22(i2, t22, r22, t22, 1), m22(r22, t22, r22, o2, 1), m22(r22, o2, i2, o2, 1), m22(i2, o2, i2, t22, 1), "globe" === this.projection.name) {
            const [t3, i3] = e2.bV(this);
            t3 ? (d22 = 90, h22 = 180, c22 = -180) : i3 && (u22 = -90, h22 = 180, c22 = -180);
          }
          return new e2.as(new e2.bK(c22, u22), new e2.bK(h22, d22));
        }
        _getBoundsRectangular(t22, i2) {
          const { top: o2, left: r22 } = this._edgeInsets, s2 = this.height - this._edgeInsets.bottom, a2 = this.width - this._edgeInsets.right, n22 = new e2.P(r22, o2), l22 = new e2.P(a2, o2), c22 = new e2.P(a2, s2), h22 = new e2.P(r22, s2);
          let u22 = this.pointCoordinate(n22, t22), d22 = this.pointCoordinate(l22, t22);
          const _2 = this.pointCoordinate(c22, i2), p22 = this.pointCoordinate(h22, i2), m22 = (e22, t3) => (t3.y - e22.y) / (t3.x - e22.x);
          return u22.y > 1 && d22.y >= 0 ? u22 = new e2.a5((1 - p22.y) / m22(p22, u22) + p22.x, 1) : u22.y < 0 && d22.y <= 1 && (u22 = new e2.a5(-p22.y / m22(p22, u22) + p22.x, 0)), d22.y > 1 && u22.y >= 0 ? d22 = new e2.a5((1 - _2.y) / m22(_2, d22) + _2.x, 1) : d22.y < 0 && u22.y <= 1 && (d22 = new e2.a5(-_2.y / m22(_2, d22) + _2.x, 0)), new e2.as().extend(this.coordinateLocation(u22)).extend(this.coordinateLocation(d22)).extend(this.coordinateLocation(p22)).extend(this.coordinateLocation(_2));
        }
        _getBoundsRectangularTerrain() {
          const e22 = this.elevation;
          if (!e22.visibleDemTiles.length || e22.isUsingMockSource())
            return this._getBoundsRectangular(0, 0);
          const t22 = e22.visibleDemTiles.reduce((e3, t3) => {
            if (t3.dem) {
              const i2 = t3.dem.tree;
              e3.min = Math.min(e3.min, i2.minimums[0]), e3.max = Math.max(e3.max, i2.maximums[0]);
            }
            return e3;
          }, { min: Number.MAX_VALUE, max: 0 });
          return this._getBoundsRectangular(t22.min * e22.exaggeration(), t22.max * e22.exaggeration());
        }
        getBounds() {
          return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
        }
        horizonLineFromTop(e22 = true) {
          const t22 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) - this.centerOffset.y, i2 = this.height / 2 - t22 * (1 - this._horizonShift);
          return e22 ? Math.max(0, i2) : i2;
        }
        getMaxBounds() {
          return this.maxBounds;
        }
        setMaxBounds(t22) {
          this.maxBounds = t22, this.minLat = -e2.bT, this.maxLat = e2.bT, this.minLng = -180, this.maxLng = 180, t22 && (this.minLat = t22.getSouth(), this.maxLat = t22.getNorth(), this.minLng = t22.getWest(), this.maxLng = t22.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e2.am(this.minLng) * this.tileSize, this.worldMaxX = e2.am(this.maxLng) * this.tileSize, this.worldMinY = e2.at(this.maxLat) * this.tileSize, this.worldMaxY = e2.at(this.minLat) * this.tileSize, this._constrain();
        }
        calculatePosMatrix(e22, t22) {
          return this.projection.createTileMatrix(this, t22, e22);
        }
        calculateDistanceTileData(t22) {
          const i2 = t22.key, o2 = this._distanceTileDataCache;
          if (o2[i2])
            return o2[i2];
          const r22 = t22.canonical, s2 = 1 / this.height, a2 = this.cameraWorldSize, n22 = a2 / this.zoomScale(r22.z), l22 = (r22.x + Math.pow(2, r22.z) * t22.wrap) * n22, c22 = r22.y * n22, h22 = this.point;
          h22.x *= a2 / this.worldSize, h22.y *= a2 / this.worldSize;
          const u22 = this.angle, d22 = Math.sin(-u22), _2 = -Math.cos(-u22);
          return o2[i2] = { bearing: [d22, _2], center: [(h22.x - l22) * s2, (h22.y - c22) * s2], scale: n22 / e2.ab * s2 }, o2[i2];
        }
        calculateFogTileMatrix(t22) {
          const i2 = t22.key, o2 = this._fogTileMatrixCache;
          if (o2[i2])
            return o2[i2];
          const r22 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t22);
          return e2.a6.mat4.multiply(r22, this.worldToFogMatrix, r22), o2[i2] = new Float32Array(r22), o2[i2];
        }
        calculateProjMatrix(t22, i2 = false, o2 = false) {
          const r22 = t22.key;
          let s2;
          if (s2 = o2 ? this._expandedProjMatrixCache : i2 ? this._alignedProjMatrixCache : this._projMatrixCache, s2[r22])
            return s2[r22];
          const a2 = this.calculatePosMatrix(t22, this.worldSize);
          let n22;
          return n22 = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o2 ? this.expandedFarZProjMatrix : i2 ? this.alignedProjMatrix : this.projMatrix, e2.a6.mat4.multiply(a2, n22, a2), s2[r22] = new Float32Array(a2), s2[r22];
        }
        calculatePixelsToTileUnitsMatrix(t22) {
          const i2 = t22.tileID.key, o2 = this._pixelsToTileUnitsCache;
          if (o2[i2])
            return o2[i2];
          const r22 = e2.bW(t22, this);
          return o2[i2] = r22, o2[i2];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        globeToMercatorMatrix() {
          if ("globe" === this.projection.name) {
            const t22 = 1 / this.worldSize, i2 = e2.a6.mat4.fromScaling([], [t22, t22, t22]);
            return e2.a6.mat4.multiply(i2, i2, this.globeMatrix), i2;
          }
        }
        recenterOnTerrain() {
          if (!this._elevation || "globe" === this.projection.name)
            return;
          const t22 = this._elevation;
          this._updateCameraState();
          const i2 = e2.bD(1, this._center.lat) * this.worldSize, o2 = this._computeCameraPosition(i2), r22 = this._camera.forward(), s2 = e2.bD(1, this._center.lat);
          o2[2] /= s2, r22[2] /= s2, e2.a6.vec3.normalize(r22, r22);
          const a2 = t22.raycast(o2, r22, t22.exaggeration());
          if (a2) {
            const t3 = e2.a6.vec3.scaleAndAdd([], o2, r22, a2), i3 = new e2.a5(t3[0], t3[1], e2.bD(t3[2], e2.aM(t3[1]))), n22 = (i3.z + e2.a6.vec3.length([i3.x - o2[0], i3.y - o2[1], i3.z - o2[2] * s2])) * this._pixelsPerMercatorPixel;
            this._seaLevelZoom = this._zoomFromMercatorZ(n22), this._centerAltitude = i3.toAltitude(), this._center = this.coordinateLocation(i3), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
          }
        }
        _constrainCamera(t22 = false) {
          if (!this._elevation)
            return;
          const i2 = this._elevation, o2 = e2.bD(1, this._center.lat) * this.worldSize, r22 = this._computeCameraPosition(o2), s2 = i2.getAtPointOrZero(new e2.a5(...r22)), a2 = this.pixelsPerMeter / this.worldSize * s2, n22 = this._minimumHeightOverTerrain(), l22 = r22[2] - a2;
          if (l22 <= n22)
            if (l22 < 0 || t22) {
              const t3 = this.locationCoordinate(this._center, this._centerAltitude), i3 = [r22[0], r22[1], t3.z - r22[2]], o3 = e2.a6.vec3.length(i3);
              i3[2] -= (n22 - l22) / this._pixelsPerMercatorPixel;
              const s3 = e2.a6.vec3.length(i3);
              if (0 === s3)
                return;
              e2.a6.vec3.scale(i3, i3, o3 / s3 * this._pixelsPerMercatorPixel), this._camera.position = [r22[0], r22[1], t3.z * this._pixelsPerMercatorPixel - i3[2]], this._updateStateFromCamera();
            } else
              this._isCameraConstrained = true;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining)
            return;
          this._constraining = true;
          const t22 = "globe" === this.projection.name || this.mercatorFromTransition;
          if (this.projection.isReprojectedInTileSpace || t22) {
            const i3 = this.center;
            return i3.lat = e2.ap(i3.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t22) && (i3.lng = e2.ap(i3.lng, this.minLng, this.maxLng)), this.center = i3, void (this._constraining = false);
          }
          const i2 = this._unmodified, { x: o2, y: r22 } = this.point;
          let s2 = 0, a2 = o2, n22 = r22;
          const l22 = this.width / 2, c22 = this.height / 2, h22 = this.worldMinY * this.scale, u22 = this.worldMaxY * this.scale;
          if (r22 - c22 < h22 && (n22 = h22 + c22), r22 + c22 > u22 && (n22 = u22 - c22), u22 - h22 < this.height && (s2 = Math.max(s2, this.height / (u22 - h22)), n22 = (u22 + h22) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
            const e22 = this.worldMinX * this.scale, t3 = this.worldMaxX * this.scale, i3 = this.worldSize / 2 - (e22 + t3) / 2;
            a2 = (o2 + i3 + this.worldSize) % this.worldSize - i3, a2 - l22 < e22 && (a2 = e22 + l22), a2 + l22 > t3 && (a2 = t3 - l22), t3 - e22 < this.width && (s2 = Math.max(s2, this.width / (t3 - e22)), a2 = (t3 + e22) / 2);
          }
          a2 === o2 && n22 === r22 || (this.center = this.unproject(new e2.P(a2, n22))), s2 && (this.zoom += this.scaleZoom(s2)), this._constrainCamera(), this._unmodified = i2, this._constraining = false;
        }
        _minZoomForBounds() {
          let e22 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
          return this.maxBounds && (e22 = Math.max(e22, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e22;
        }
        _maxCameraBoundsDistance() {
          return this._mercatorZfromZoom(this._minZoomForBounds());
        }
        _calcMatrices() {
          if (!this.height)
            return;
          const t22 = this.centerOffset, i2 = "globe" === this.projection.name, o2 = this.pixelsPerMeter;
          "globe" === this.projection.name && (this._mercatorScaleRatio = e2.bD(1, this.center.lat) / e2.bD(1, e2.c4));
          const r22 = e2.bX(this.projection, this.zoom, this.width, this.height, 1024);
          this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, r22), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
          const s2 = "meters" === this.projection.zAxisUnit ? o2 : 1, a2 = this._camera.getWorldToCamera(this.worldSize, s2);
          let n22;
          const l22 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
          if (l22[8] = 2 * -t22.x / this.width, l22[9] = 2 * t22.y / this.height, this.isOrthographic) {
            let e22 = 0.5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(0.5 * this._fov), i3 = e22 * this.aspect, o3 = -i3, r3 = -e22;
            i3 -= t22.x, o3 -= t22.x, e22 += t22.y, r3 += t22.y, n22 = this._camera.getCameraToClipOrthographic(o3, i3, r3, e22, this._nearZ, this._farZ), ((e3, t3, i4, o4) => {
              for (let r4 = 0; r4 < 16; r4++)
                e3[r4] = qi2(t3[r4], i4[r4], o4);
            })(n22, n22, l22, Zi2(this.pitch >= 15 ? 1 : this.pitch / 15));
          } else
            n22 = l22;
          const c22 = e2.a6.mat4.mul([], l22, a2);
          let h22 = e2.a6.mat4.mul([], n22, a2);
          if (this.projection.isReprojectedInTileSpace) {
            const t3 = this.locationCoordinate(this.center), i3 = e2.a6.mat4.identity([]);
            e2.a6.mat4.translate(i3, i3, [t3.x * this.worldSize, t3.y * this.worldSize, 0]), e2.a6.mat4.multiply(i3, i3, e2.bY(this)), e2.a6.mat4.translate(i3, i3, [-t3.x * this.worldSize, -t3.y * this.worldSize, 0]), e2.a6.mat4.multiply(h22, h22, i3), e2.a6.mat4.multiply(c22, c22, i3), this.inverseAdjustmentMatrix = e2.bZ(this);
          } else
            this.inverseAdjustmentMatrix = [1, 0, 0, 1];
          if (this.mercatorMatrix = e2.a6.mat4.scale([], h22, [this.worldSize, this.worldSize, this.worldSize / s2, 1]), this.projMatrix = h22, this.invProjMatrix = e2.a6.mat4.invert(new Float64Array(16), this.projMatrix), i2) {
            const i3 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
            i3[8] = 2 * -t22.x / this.width, i3[9] = 2 * t22.y / this.height, this.expandedFarZProjMatrix = e2.a6.mat4.mul([], i3, a2);
          } else
            this.expandedFarZProjMatrix = this.projMatrix;
          const u22 = e2.a6.mat4.invert([], n22);
          this.frustumCorners = e2.b_.fromInvProjectionMatrix(u22, this.horizonLineFromTop(), this.height), this.cameraFrustum = e2.bN.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i2);
          const d22 = new Float32Array(16);
          e2.a6.mat4.identity(d22), e2.a6.mat4.scale(d22, d22, [1, -1, 1]), e2.a6.mat4.rotateX(d22, d22, this._pitch), e2.a6.mat4.rotateZ(d22, d22, this.angle);
          const _2 = e2.a6.mat4.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
          this.starsProjMatrix = e2.a6.mat4.clone(_2);
          const p22 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
          _2[8] = 2 * -t22.x / this.width, _2[9] = 2 * (t22.y + p22) / this.height, this.skyboxMatrix = e2.a6.mat4.multiply(d22, _2, d22);
          const m22 = this.point, f22 = m22.x, g22 = m22.y, v22 = this.width % 2 / 2, x22 = this.height % 2 / 2, y22 = Math.cos(this.angle), b22 = Math.sin(this.angle), w22 = f22 - Math.round(f22) + y22 * v22 + b22 * x22, T22 = g22 - Math.round(g22) + y22 * x22 + b22 * v22, E22 = new Float64Array(h22);
          if (e2.a6.mat4.translate(E22, E22, [w22 > 0.5 ? w22 - 1 : w22, T22 > 0.5 ? T22 - 1 : T22, 0]), this.alignedProjMatrix = E22, h22 = e2.a6.mat4.create(), e2.a6.mat4.scale(h22, h22, [this.width / 2, -this.height / 2, 1]), e2.a6.mat4.translate(h22, h22, [1, -1, 0]), this.labelPlaneMatrix = h22, h22 = e2.a6.mat4.create(), e2.a6.mat4.scale(h22, h22, [1, -1, 1]), e2.a6.mat4.translate(h22, h22, [-1, -1, 0]), e2.a6.mat4.scale(h22, h22, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h22, this.pixelMatrix = e2.a6.mat4.multiply(new Float64Array(16), this.labelPlaneMatrix, c22), this._calcFogMatrices(), this._distanceTileDataCache = {}, h22 = e2.a6.mat4.invert(new Float64Array(16), this.pixelMatrix), !h22)
            throw new Error("failed to invert matrix");
          if (this.pixelMatrixInverse = h22, "globe" === this.projection.name || this.mercatorFromTransition) {
            this.globeMatrix = e2.b$(this);
            const t3 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
            this.globeCenterInViewSpace = e2.a6.vec3.transformMat4(t3, t3, a2), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
          } else
            this.globeMatrix = h22;
          this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
        }
        _calcFogMatrices() {
          this._fogTileMatrixCache = {};
          const t22 = this.cameraWorldSizeForFog, i2 = this.cameraPixelsPerMeter, o2 = this._camera.position, r22 = 1 / this.height / this._pixelsPerMercatorPixel, s2 = [t22, t22, i2];
          e2.a6.vec3.scale(s2, s2, r22), e2.a6.vec3.scale(o2, o2, -1), e2.a6.vec3.multiply(o2, o2, s2);
          const a2 = e2.a6.mat4.create();
          e2.a6.mat4.translate(a2, a2, o2), e2.a6.mat4.scale(a2, a2, s2), this.mercatorFogMatrix = a2, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t22, i2, r22);
        }
        _computeCameraPosition(e22) {
          const t22 = (e22 = e22 || this.pixelsPerMeter) / this.pixelsPerMeter, i2 = this._camera.forward(), o2 = this.point, r22 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t22 - e22 / this.worldSize * this._centerAltitude;
          return [o2.x / this.worldSize - i2[0] * r22, o2.y / this.worldSize - i2[1] * r22, e22 / this.worldSize * this._centerAltitude - i2[2] * r22];
        }
        _updateCameraState() {
          this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
        }
        _translateCameraConstrained(t22) {
          const i2 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o2 = this._camera.position[2], r22 = t22[2];
          let s2 = 1;
          this.projection.wrap && (this.center = this.center.wrap()), r22 > 0 && (s2 = Math.min((i2 - o2) / r22, 1)), this._camera.position = e2.a6.vec3.scaleAndAdd([], this._camera.position, t22, s2), this._updateStateFromCamera();
        }
        _updateStateFromCamera() {
          const t22 = this._camera.position, i2 = this._camera.forward(), { pitch: o2, bearing: r22 } = this._camera.getPitchBearing(), s2 = e2.bD(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, a2 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e2.bB(this._maxPitch)), n22 = Math.max((t22[2] - s2) / Math.cos(o2), a2), l22 = this._zoomFromMercatorZ(n22);
          e2.a6.vec3.scaleAndAdd(t22, t22, i2, n22), this._pitch = e2.ap(o2, e2.bB(this.minPitch), e2.bB(this.maxPitch)), this.angle = e2.bA(r22, -Math.PI, Math.PI), this._setZoom(e2.ap(l22, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e2.a5(t22[0], t22[1], t22[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
        }
        _worldSizeFromZoom(e22) {
          return Math.pow(2, e22) * this.tileSize;
        }
        _mercatorZfromZoom(e22) {
          return this.cameraToCenterDistance / this._worldSizeFromZoom(e22);
        }
        _minimumHeightOverTerrain() {
          const e22 = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
          return this._mercatorZfromZoom(e22);
        }
        _zoomFromMercatorZ(e22) {
          return this.scaleZoom(this.cameraToCenterDistance / (e22 * this.tileSize));
        }
        zoomFromMercatorZAdjusted(t22) {
          let i2 = 0, o2 = e2.bU, r22 = 0, s2 = 1 / 0;
          for (; o2 - i2 > 1e-6 && o2 > i2; ) {
            const e22 = i2 + 0.5 * (o2 - i2), a2 = this.tileSize * Math.pow(2, e22), n22 = this.getCameraToCenterDistance(this.projection, e22, a2), l22 = this.scaleZoom(n22 / (t22 * this.tileSize)), c22 = Math.abs(e22 - l22);
            c22 < s2 && (s2 = c22, r22 = e22), e22 < l22 ? i2 = e22 : o2 = e22;
          }
          return r22;
        }
        _terrainEnabled() {
          return !(!this._elevation || !this.projection.supportsTerrain && (e2.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
        }
        anyCornerOffEdge(t22, i2) {
          const o2 = Math.min(t22.x, i2.x), r22 = Math.max(t22.x, i2.x), s2 = Math.min(t22.y, i2.y), a2 = Math.max(t22.y, i2.y);
          if (s2 < this.horizonLineFromTop(false))
            return true;
          if ("mercator" !== this.projection.name)
            return false;
          const n22 = [new e2.P(o2, s2), new e2.P(r22, a2), new e2.P(o2, a2), new e2.P(r22, s2)], l22 = this.renderWorldCopies ? -3 : 0, c22 = this.renderWorldCopies ? 4 : 1;
          for (const e22 of n22) {
            const t3 = this.pointRayIntersection(e22);
            if (t3.t < 0)
              return true;
            const i3 = this.rayIntersectionCoordinate(t3);
            if (i3.x < l22 || i3.y < 0 || i3.x > c22 || i3.y > 1)
              return true;
          }
          return false;
        }
        isHorizonVisible() {
          return this.pitch + e2.c0(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e2.P(0, 0), new e2.P(this.width, this.height));
        }
        zoomDeltaToMovement(t22, i2) {
          const o2 = e2.a6.vec3.length(e2.a6.vec3.sub([], this._camera.position, t22)), r22 = this._zoomFromMercatorZ(o2) + i2;
          return o2 - this._mercatorZfromZoom(r22);
        }
        getCameraPoint() {
          if ("globe" === this.projection.name) {
            const t22 = function([t3, i2, o2], r22) {
              const s2 = [t3, i2, o2, 1];
              e2.a6.vec4.transformMat4(s2, s2, r22);
              const a2 = s2[3] = Math.max(s2[3], 1e-6);
              return s2[0] /= a2, s2[1] /= a2, s2[2] /= a2, s2;
            }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
            return new e2.P(t22[0], t22[1]);
          }
          {
            const t22 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new e2.P(0, t22));
          }
        }
        getCameraToCenterDistance(t22, i2 = this.zoom, o2 = this.worldSize) {
          const r22 = e2.bX(t22, i2, this.width, this.height, 1024), s2 = t22.pixelSpaceConversion(this.center.lat, o2, r22);
          let a2 = 0.5 / Math.tan(0.5 * this._fov) * this.height * s2;
          return this.isOrthographic && (a2 = qi2(1, a2, Zi2(this.pitch >= 15 ? 1 : this.pitch / 15))), a2;
        }
        getWorldToCameraMatrix() {
          const t22 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
          return "globe" === this.projection.name && e2.a6.mat4.multiply(t22, t22, this.globeMatrix), t22;
        }
        getFrustum(t22) {
          return e2.bN.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t22, "meters" === this.projection.zAxisUnit);
        }
      }
      const Wi2 = (t22, i2) => {
        if (i2 > 0 && t22.terrain && e2.w("Cutoff is currently disabled on terrain"), i2 <= 0 || t22.terrain)
          return { shouldRenderCutoff: false, uniformValues: { u_cutoff_params: [0, 0, 0, 1] } };
        const o2 = t22.transform, r22 = Math.max(Math.abs(o2._zoom - (t22.minCutoffZoom - 1)), 1), s2 = o2.isLODDisabled(false) ? e2.a7(60, 45, o2.pitch) : e2.a7(30, 15, o2.pitch), a2 = o2._farZ - o2._nearZ, n22 = i2 * o2.height, l22 = ((1 - (c22 = s2)) * o2.cameraToCenterDistance + c22 * (o2._farZ + n22)) * r22;
        var c22;
        return { shouldRenderCutoff: s2 < 1, uniformValues: { u_cutoff_params: [o2._nearZ, o2._farZ, (l22 - o2._nearZ) / a2, (l22 - n22 - o2._nearZ) / a2] } };
      }, $i2 = { cascadeCount: 2, normalOffset: 3, shadowMapResolution: 2048 };
      class Xi2 {
        constructor(e22, t22) {
          this.aabb = e22, this.lastCascade = t22;
        }
      }
      class Yi2 {
        add(e22, t22) {
          const i2 = this.receivers[e22.key];
          void 0 !== i2 ? (i2.aabb.min[0] = Math.min(i2.aabb.min[0], t22.min[0]), i2.aabb.min[1] = Math.min(i2.aabb.min[1], t22.min[1]), i2.aabb.min[2] = Math.min(i2.aabb.min[2], t22.min[2]), i2.aabb.max[0] = Math.max(i2.aabb.max[0], t22.max[0]), i2.aabb.max[1] = Math.max(i2.aabb.max[1], t22.max[1]), i2.aabb.max[2] = Math.max(i2.aabb.max[2], t22.max[2])) : this.receivers[e22.key] = new Xi2(t22, null);
        }
        clear() {
          this.receivers = {};
        }
        get(e22) {
          return this.receivers[e22.key];
        }
        computeRequiredCascades(t22, i2, o2) {
          const r22 = e2.c9.fromPoints(t22.points);
          let s2 = 0;
          for (const t3 in this.receivers) {
            const a2 = this.receivers[t3];
            if (!a2)
              continue;
            if (!r22.intersectsAabb(a2.aabb))
              continue;
            a2.aabb.min = r22.closestPoint(a2.aabb.min), a2.aabb.max = r22.closestPoint(a2.aabb.max);
            const n22 = a2.aabb.getCorners();
            for (let t4 = 0; t4 < o2.length; t4++) {
              let r3 = true;
              for (const s3 of n22) {
                const a3 = [s3[0] * i2, s3[1] * i2, s3[2]];
                if (e2.a6.vec3.transformMat4(a3, a3, o2[t4].matrix), a3[0] < -1 || a3[0] > 1 || a3[1] < -1 || a3[1] > 1) {
                  r3 = false;
                  break;
                }
              }
              if (a2.lastCascade = t4, s2 = Math.max(s2, t4), r3)
                break;
            }
          }
          return s2 + 1;
        }
      }
      class Ki2 {
        constructor(e22) {
          this.painter = e22, this._enabled = false, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new Yi2(), this._depthMode = new Li2(e22.context.gl.LEQUAL, Li2.ReadWrite, [0, 1]), this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, 12e-4, 0.012], u_shadowmap_0: 0, u_shadowmap_1: 0 }, this._forceDisable = false, this.useNormalOffset = false, e22.tp.registerParameter(this, ["Shadows"], "_forceDisable", { label: "forceDisable" }, () => {
            this.painter.style.map.triggerRepaint();
          }), e22.tp.registerParameter($i2, ["Shadows"], "cascadeCount", { min: 1, max: 2, step: 1 }), e22.tp.registerParameter($i2, ["Shadows"], "normalOffset", { min: 0, max: 10, step: 0.05 }), e22.tp.registerParameter($i2, ["Shadows"], "shadowMapResolution", { min: 32, max: 2048, step: 32 }), e22.tp.registerBinding(this, ["Shadows"], "_numCascadesToRender", { readonly: true, label: "numCascadesToRender" });
        }
        destroy() {
          for (const e22 of this._cascades)
            e22.texture.destroy(), e22.framebuffer.destroy();
          this._cascades = [];
        }
        updateShadowParameters(t22, i2) {
          const o2 = this.painter;
          if (this._enabled = false, this._shadowLayerCount = 0, this._receivers.clear(), !i2 || !i2.properties)
            return;
          const r22 = i2.properties.get("shadow-intensity");
          if (!i2.shadowsEnabled() || r22 <= 0)
            return;
          if (this._shadowLayerCount = o2.style.order.reduce((e22, i3) => {
            const r3 = o2.style._mergedLayers[i3];
            return e22 + (r3.hasShadowPass() && !r3.isHidden(t22.zoom) ? 1 : 0);
          }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled)
            return;
          const s2 = o2.context, a2 = $i2.shadowMapResolution, n22 = $i2.shadowMapResolution;
          if (0 === this._cascades.length || $i2.shadowMapResolution !== this._cascades[0].texture.size[0]) {
            this._cascades = [];
            for (let t3 = 0; t3 < $i2.cascadeCount; ++t3) {
              const t4 = o2._shadowMapDebug, i3 = s2.gl, r3 = s2.createFramebuffer(a2, n22, t4, "texture"), l3 = new e2.T(s2, { width: a2, height: n22, data: null }, i3.DEPTH_COMPONENT16);
              if (r3.depthAttachment.set(l3.texture), t4) {
                const t5 = new e2.T(s2, { width: a2, height: n22, data: null }, i3.RGBA8);
                r3.colorAttachment.set(t5.texture);
              }
              this._cascades.push({ framebuffer: r3, texture: l3, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new e2.bN(), scale: 0 });
            }
          }
          this.shadowDirection = Qi2(i2);
          let l22 = 0;
          if (t22.elevation) {
            const e22 = t22.elevation, i3 = [1e4, -1e4];
            e22.visibleDemTiles.filter((e3) => e3.dem).forEach((e3) => {
              const t3 = e3.dem.tree;
              i3[0] = Math.min(i3[0], t3.minimums[0]), i3[1] = Math.max(i3[1], t3.maximums[0]);
            }), 1e4 !== i3[0] && (l22 = (i3[1] - i3[0]) * e22.exaggeration());
          }
          const c22 = 1.5 * t22.cameraToCenterDistance, h22 = 3 * c22, u22 = new Float64Array(16);
          for (let i3 = 0; i3 < this._cascades.length; ++i3) {
            const o3 = this._cascades[i3];
            let r3 = t22.height / 50, s3 = 1;
            1 === $i2.cascadeCount ? s3 = h22 : 0 === i3 ? s3 = c22 : (r3 = c22, s3 = h22);
            const [a3, n3] = to(t22, this.shadowDirection, r3, s3, $i2.shadowMapResolution, l22);
            o3.scale = t22.scale, o3.matrix = a3, o3.boundingSphereRadius = n3, e2.a6.mat4.invert(u22, o3.matrix), o3.frustum = e2.bN.fromInvProjectionMatrix(u22, 1, 0, true), o3.far = s3;
          }
          const d22 = this._cascades.length - 1;
          this._uniformValues.u_fade_range = [0.75 * this._cascades[d22].far, this._cascades[d22].far], this._uniformValues.u_shadow_intensity = r22, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / $i2.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = $i2.shadowMapResolution, this._uniformValues.u_shadowmap_0 = ji2.ShadowMap0, this._uniformValues.u_shadowmap_1 = ji2.ShadowMap0 + 1, this._groundShadowTiles = o2.transform.coveringTiles({ tileSize: 512, renderWorldCopies: true });
          const _2 = o2.transform.elevation;
          for (const e22 of this._groundShadowTiles) {
            let t3 = { min: 0, max: 0 };
            if (_2) {
              const i3 = _2.getMinMaxForTile(e22);
              i3 && (t3 = i3);
            }
            this.addShadowReceiver(e22.toUnwrapped(), t3.min, t3.max);
          }
        }
        get enabled() {
          return this._enabled && !this._forceDisable;
        }
        set enabled(e22) {
          this._enabled = e22;
        }
        drawShadowPass(t22, i2) {
          if (!this.enabled)
            return;
          const o2 = this.painter, r22 = o2.context;
          this._numCascadesToRender = this._receivers.computeRequiredCascades(o2.transform.getFrustum(0), o2.transform.worldSize, this._cascades), r22.viewport.set([0, 0, $i2.shadowMapResolution, $i2.shadowMapResolution]);
          for (let s2 = 0; s2 < this._numCascadesToRender; ++s2) {
            o2.currentShadowCascade = s2, r22.bindFramebuffer.set(this._cascades[s2].framebuffer.framebuffer), r22.clear({ color: e2.bz.white, depth: 1 });
            for (const e22 of t22.order) {
              const r3 = t22._mergedLayers[e22];
              if (!r3.hasShadowPass() || r3.isHidden(o2.transform.zoom))
                continue;
              const s3 = t22.getLayerSourceCache(r3), a2 = s3 ? i2[s3.id] : void 0;
              ("model" === r3.type || a2 && a2.length) && o2.renderLayer(o2, s3, r3, a2);
            }
          }
          o2.currentShadowCascade = 0;
        }
        drawGroundShadows() {
          if (!this.enabled)
            return;
          const e22 = this.painter, t22 = e22.style, i2 = e22.context, o2 = t22.directionalLight, r22 = t22.ambientLight;
          if (!o2 || !r22)
            return;
          const s2 = [], a2 = Wi2(e22, e22.longestCutoffRange);
          a2.shouldRenderCutoff && s2.push("RENDER_CUTOFF");
          const n22 = eo(t22, o2, r22), l22 = new Li2(i2.gl.LEQUAL, Li2.ReadOnly, e22.depthRangeFor3D);
          for (const t3 of this._groundShadowTiles) {
            const o3 = t3.toUnwrapped(), r3 = e22.isTileAffectedByFog(t3), c22 = e22.getOrCreateProgram("groundShadow", { defines: s2, overrideFog: r3 });
            this.setupShadows(o3, c22), e22.uploadCommonUniforms(i2, c22, o3, null, a2);
            const h22 = { u_matrix: e22.transform.calculateProjMatrix(o3), u_ground_shadow_factor: n22 };
            c22.draw(e22, i2.gl.TRIANGLES, l22, Mi2.disabled, Ai2.multiply, Fi2.disabled, h22, "ground_shadow", e22.tileExtentBuffer, e22.quadTriangleIndexBuffer, e22.tileExtentSegments, {}, e22.transform.zoom, null, null);
          }
        }
        getShadowPassColorMode() {
          return this.painter._shadowMapDebug ? Ai2.unblended : Ai2.disabled;
        }
        getShadowPassDepthMode() {
          return this._depthMode;
        }
        getShadowCastingLayerCount() {
          return this._shadowLayerCount;
        }
        calculateShadowPassMatrixFromTile(t22) {
          const i2 = this.painter.transform, o2 = i2.calculatePosMatrix(t22, i2.worldSize);
          return e2.a6.mat4.multiply(o2, this._cascades[this.painter.currentShadowCascade].matrix, o2), Float32Array.from(o2);
        }
        calculateShadowPassMatrixFromMatrix(t22) {
          return e2.a6.mat4.multiply(t22, this._cascades[this.painter.currentShadowCascade].matrix, t22), Float32Array.from(t22);
        }
        setupShadows(t22, i2, o2, r22 = 0) {
          if (!this.enabled)
            return;
          const s2 = this.painter.transform, a2 = this.painter.context, n22 = a2.gl, l22 = this._uniformValues, c22 = new Float64Array(16), h22 = s2.calculatePosMatrix(t22, s2.worldSize);
          for (let t3 = 0; t3 < this._cascades.length; t3++)
            e2.a6.mat4.multiply(c22, this._cascades[t3].matrix, h22), l22[0 === t3 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(c22), a2.activeTexture.set(n22.TEXTURE0 + ji2.ShadowMap0 + t3), this._cascades[t3].texture.bind(n22.NEAREST, n22.CLAMP_TO_EDGE);
          if (this.useNormalOffset = !!o2, this.useNormalOffset) {
            const i3 = e2.c8(t22.canonical), a3 = 2 / s2.tileSize * e2.ab / $i2.shadowMapResolution, n3 = a3 * this._cascades[0].boundingSphereRadius, c3 = a3 * this._cascades[this._cascades.length - 1].boundingSphereRadius, h3 = ("vector-tile" === o2 ? 1 : 3) / Math.pow(2, r22 - t22.canonical.z - (1 - s2.zoom + Math.floor(s2.zoom)));
            l22.u_shadow_normal_offset = [i3, n3 * h3, c3 * h3], l22.u_shadow_bias = [6e-5, 12e-4, 0.012];
          } else
            l22.u_shadow_bias = [36e-5, 12e-4, 0.012];
          i2.setShadowUniformValues(a2, l22);
        }
        setupShadowsFromMatrix(t22, i2, o2 = false) {
          if (!this.enabled)
            return;
          const r22 = this.painter.context, s2 = r22.gl, a2 = this._uniformValues, n22 = new Float64Array(16);
          for (let i3 = 0; i3 < $i2.cascadeCount; i3++)
            e2.a6.mat4.multiply(n22, this._cascades[i3].matrix, t22), a2[0 === i3 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(n22), r22.activeTexture.set(s2.TEXTURE0 + ji2.ShadowMap0 + i3), this._cascades[i3].texture.bind(s2.NEAREST, s2.CLAMP_TO_EDGE);
          if (this.useNormalOffset = o2, o2) {
            const e22 = $i2.normalOffset;
            a2.u_shadow_normal_offset = [1, e22, e22], a2.u_shadow_bias = [6e-5, 12e-4, 0.012];
          } else
            a2.u_shadow_bias = [36e-5, 12e-4, 0.012];
          i2.setShadowUniformValues(r22, a2);
        }
        getShadowUniformValues() {
          return this._uniformValues;
        }
        getCurrentCascadeFrustum() {
          return this._cascades[this.painter.currentShadowCascade].frustum;
        }
        computeSimplifiedTileShadowVolume(t22, i2, o2, r22) {
          if (r22[2] >= 0)
            return {};
          const s2 = function(t3, i3, o3) {
            const r3 = o3 / (1 << t3.canonical.z);
            return new e2.c9([t3.canonical.x * r3 + t3.wrap * o3, t3.canonical.y * r3 + t3.wrap * o3, 0], [(t3.canonical.x + 1) * r3 + t3.wrap * o3, (t3.canonical.y + 1) * r3 + t3.wrap * o3, i3]);
          }(t22, i2, o2).getCorners(), a2 = i2 / -r22[2];
          r22[0] < 0 ? (e2.a6.vec3.add(s2[0], s2[0], [r22[0] * a2, 0, 0]), e2.a6.vec3.add(s2[3], s2[3], [r22[0] * a2, 0, 0])) : r22[0] > 0 && (e2.a6.vec3.add(s2[1], s2[1], [r22[0] * a2, 0, 0]), e2.a6.vec3.add(s2[2], s2[2], [r22[0] * a2, 0, 0])), r22[1] < 0 ? (e2.a6.vec3.add(s2[0], s2[0], [0, r22[1] * a2, 0]), e2.a6.vec3.add(s2[1], s2[1], [0, r22[1] * a2, 0])) : r22[1] > 0 && (e2.a6.vec3.add(s2[2], s2[2], [0, r22[1] * a2, 0]), e2.a6.vec3.add(s2[3], s2[3], [0, r22[1] * a2, 0]));
          const n22 = {};
          return n22.vertices = s2, n22.planes = [Ji2(s2[1], s2[0], s2[4]), Ji2(s2[2], s2[1], s2[5]), Ji2(s2[3], s2[2], s2[6]), Ji2(s2[0], s2[3], s2[7])], n22;
        }
        addShadowReceiver(t22, i2, o2) {
          this._receivers.add(t22, e2.c9.fromTileIdAndHeight(t22, i2, o2));
        }
        getMaxCascadeForTile(e22) {
          const t22 = this._receivers.get(e22);
          return t22 && t22.lastCascade ? t22.lastCascade : 0;
        }
      }
      function Ji2(t22, i2, o2) {
        const r22 = e2.a6.vec3.sub([], o2, i2), s2 = e2.a6.vec3.sub([], t22, i2), a2 = e2.a6.vec3.cross([], r22, s2), n22 = e2.a6.vec3.length(a2);
        return 0 === n22 ? [0, 0, 1, 0] : (e2.a6.vec3.scale(a2, a2, 1 / n22), [a2[0], a2[1], a2[2], -e2.a6.vec3.dot(a2, i2)]);
      }
      function Qi2(t22) {
        const i2 = t22.properties.get("direction"), o2 = e2.c7(i2.x, i2.y, i2.z);
        o2[2] = e2.ap(o2[2], 0, 75);
        const r22 = e2.ca([o2[0], o2[1], o2[2]]);
        return e2.a6.vec3.fromValues(r22.x, r22.y, r22.z);
      }
      function eo(t22, i2, o2) {
        const r22 = i2.properties.get("color"), s2 = i2.properties.get("intensity"), a2 = i2.properties.get("direction"), n22 = [a2.x, a2.y, a2.z], l22 = o2.properties.get("color"), c22 = o2.properties.get("intensity"), h22 = Math.max(e2.a6.vec3.dot([0, 0, 1], n22), 0), u22 = [0, 0, 0];
        e2.a6.vec3.scale(u22, l22.toRenderColor(t22.getLut(i2.scope)).toArray01Linear().slice(0, 3), c22);
        const d22 = [0, 0, 0];
        return e2.a6.vec3.scale(d22, r22.toRenderColor(t22.getLut(o2.scope)).toArray01Linear().slice(0, 3), h22 * s2), e2.cb([u22[0] > 0 ? u22[0] / (u22[0] + d22[0]) : 0, u22[1] > 0 ? u22[1] / (u22[1] + d22[1]) : 0, u22[2] > 0 ? u22[2] / (u22[2] + d22[2]) : 0]);
      }
      function to(t22, i2, o2, r22, s2, a2) {
        const n22 = t22.zoom, l22 = t22.scale, c22 = t22.worldSize, h22 = 1 / c22, u22 = t22.aspect, d22 = Math.sqrt(1 + u22 * u22) * Math.tan(0.5 * t22.fovX), _2 = d22 * d22, p22 = r22 - o2, m22 = r22 + o2;
        let f22, g22;
        _2 > p22 / m22 ? (f22 = r22, g22 = r22 * d22) : (f22 = 0.5 * m22 * (1 + _2), g22 = 0.5 * Math.sqrt(p22 * p22 + 2 * (r22 * r22 + o2 * o2) * _2 + m22 * m22 * _2 * _2));
        const v22 = t22.projection.pixelsPerMeter(t22.center.lat, c22), x22 = t22._camera.getCameraToWorldMercator(), y22 = [0, 0, -f22 * h22];
        e2.a6.vec3.transformMat4(y22, y22, x22);
        let b22 = g22 * h22;
        const w22 = t22._edgeInsets;
        if (!(0 === w22.left && 0 === w22.top && 0 === w22.right && 0 === w22.bottom || w22.left === w22.right && w22.top === w22.bottom)) {
          const i3 = t22._camera.getWorldToCamera(t22.worldSize, "meters" === t22.projection.zAxisUnit ? v22 : 1), s3 = t22._camera.getCameraToClipPerspective(t22._fov, t22.width / t22.height, o2, r22);
          s3[8] = 2 * -t22.centerOffset.x / t22.width, s3[9] = 2 * t22.centerOffset.y / t22.height;
          const a3 = new Float64Array(16);
          e2.a6.mat4.mul(a3, s3, i3);
          const h3 = new Float64Array(16);
          e2.a6.mat4.invert(h3, a3);
          const u3 = e2.bN.fromInvProjectionMatrix(h3, c22, n22, true);
          for (const i4 of u3.points) {
            const o3 = ((T22 = i4)[0] /= l22, T22[1] /= l22, T22[2] = e2.bD(T22[2], t22._center.lat), T22);
            b22 = Math.max(b22, e2.a6.vec3.len(e2.a6.vec3.subtract([], y22, o3)));
          }
        }
        var T22;
        b22 *= s2 / (s2 - 1);
        const E22 = Math.acos(i2[2]), C22 = Math.atan2(-i2[0], -i2[1]), S22 = new Gi2();
        S22.position = y22, S22.setPitchBearing(E22, C22);
        const I22 = S22.getWorldToCamera(c22, v22), D22 = b22 * c22, R22 = Math.min(t22._mercatorZfromZoom(17) * c22 * -2, -2 * D22), A22 = S22.getCameraToClipOrthographic(-D22, D22, -D22, D22, R22, (D22 + a2 * v22) / i2[2]), L22 = new Float64Array(16);
        e2.a6.mat4.multiply(L22, A22, I22);
        const P22 = e2.a6.vec3.fromValues(Math.floor(1e6 * y22[0]) / 1e6 * c22, Math.floor(1e6 * y22[1]) / 1e6 * c22, 0), M22 = 0.5 * s2, z22 = [0, 0, 0];
        e2.a6.vec3.transformMat4(z22, P22, L22), e2.a6.vec3.scale(z22, z22, M22);
        const O22 = [Math.floor(z22[0]), Math.floor(z22[1]), Math.floor(z22[2])], F22 = [0, 0, 0];
        e2.a6.vec3.sub(F22, z22, O22), e2.a6.vec3.scale(F22, F22, -1 / M22);
        const k22 = new Float64Array(16);
        return e2.a6.mat4.identity(k22), e2.a6.mat4.translate(k22, k22, F22), e2.a6.mat4.multiply(L22, k22, L22), [L22, D22];
      }
      class io extends e2.E {
        constructor(e22) {
          super(), this.requestManager = e22, this.models = { "": {} }, this.numModelsLoading = {};
        }
        loadModel(t22, i2) {
          return e2.aG(this.requestManager.transformRequest(i2, e2.R.Model).url).then((i3) => {
            if (!i3)
              return;
            const o2 = e2.aH(i3), r22 = new e2.aI(t22, void 0, void 0, o2);
            return r22.computeBoundsAndApplyParent(), r22;
          }).catch((o2) => {
            if (o2 && 404 === o2.status)
              return null;
            this.fire(new e2.t(new Error("Could not load model ".concat(t22, " from ").concat(i2, ": ").concat(o2.message))));
          });
        }
        load(t22, i2) {
          this.models[i2] || (this.models[i2] = {});
          const o2 = Object.keys(t22);
          this.numModelsLoading[i2] = (this.numModelsLoading[i2] || 0) + o2.length;
          const r22 = [];
          for (const e22 of o2)
            r22.push(this.loadModel(e22, t22[e22]));
          Promise.allSettled(r22).then((t3) => {
            for (let e22 = 0; e22 < t3.length; e22++) {
              const { status: r3, value: s2 } = t3[e22];
              "fulfilled" === r3 && s2 && (this.models[i2][o2[e22]] = { model: s2, numReferences: 1 });
            }
            this.numModelsLoading[i2] -= o2.length, this.fire(new e2.x("data", { dataType: "style" }));
          }).catch((t3) => {
            this.fire(new e2.t(new Error("Could not load models: ".concat(t3.message))));
          });
        }
        isLoaded() {
          for (const e22 in this.numModelsLoading)
            if (this.numModelsLoading[e22] > 0)
              return false;
          return true;
        }
        hasModel(e22, t22) {
          return !!this.getModel(e22, t22);
        }
        getModel(e22, t22) {
          return this.models[t22] || (this.models[t22] = {}), this.models[t22][e22] ? this.models[t22][e22].model : void 0;
        }
        addModel(e22, t22, i2) {
          this.models[i2] || (this.models[i2] = {}), this.hasModel(e22, i2) && this.models[i2][e22].numReferences++, this.load({ [e22]: this.requestManager.normalizeModelURL(t22) }, i2);
        }
        addModels(e22, t22) {
          this.models[t22] || (this.models[t22] = {});
          const i2 = {};
          for (const o2 in e22)
            this.models[t22][o2] = {}, i2[o2] = this.requestManager.normalizeModelURL(e22[o2]);
          this.load(i2, t22);
        }
        addModelsFromBucket(e22, t22) {
          this.models[t22] || (this.models[t22] = {});
          const i2 = {};
          for (const o2 of e22)
            this.hasModel(o2, t22) ? this.models[t22][o2].numReferences++ : i2[o2] = this.requestManager.normalizeModelURL(o2);
          this.load(i2, t22);
        }
        removeModel(e22, t22) {
          if (this.models[t22] && this.models[t22][e22] && (this.models[t22][e22].numReferences--, 0 === this.models[t22][e22].numReferences)) {
            const i2 = this.models[t22][e22].model;
            delete this.models[t22][e22], i2.destroy();
          }
        }
        listModels(e22) {
          return this.models[e22] || (this.models[e22] = {}), Object.keys(this.models[e22]);
        }
        upload(e22, t22) {
          this.models[t22] || (this.models[t22] = {});
          for (const i2 in this.models[t22])
            this.models[t22][i2].model && this.models[t22][i2].model.upload(e22.context);
        }
      }
      const oo = new e2.a0({ data: new e2.a1(e2._.colorTheme.data) }), ro = (e22, t22) => De2(e22, t22 && t22.filter((e3) => "source.canvas" !== e3.identifier)), so = e2.ar(Ct, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection", "setCamera", "addImport", "removeImport", "updateImport"]), ao = e2.ar(Ct, ["setCenter", "setZoom", "setBearing", "setPitch"]), no = { version: 8, layers: [], sources: {} }, lo = { duration: 300, delay: 0 };
      class co extends e2.E {
        constructor(t22, i2 = {}) {
          super(), this.map = t22, this.scope = i2.scope || "", this.globalId = null, this.fragments = [], this.importDepth = i2.importDepth || 0, this.importsCache = i2.importsCache || /* @__PURE__ */ new Map(), this.resolvedImports = i2.resolvedImports || /* @__PURE__ */ new Set(), this.transition = e2.l({}, lo), this._buildingIndex = new wt(this), this.crossTileSymbolIndex = new Di2(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = false, this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this._changes = i2.styleChanges || new j(), this.dispatcher = i2.dispatcher ? i2.dispatcher : new e2.cd(e2.ce(), this), i2.imageManager ? this.imageManager = i2.imageManager : (this.imageManager = new q2(), this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), this.glyphManager = i2.glyphManager ? i2.glyphManager : new e2.cf(t22._requestManager, i2.localFontFamily ? e2.cg.all : i2.localIdeographFontFamily ? e2.cg.ideographs : e2.cg.none, i2.localFontFamily || i2.localIdeographFontFamily), i2.modelManager ? this.modelManager = i2.modelManager : (this.modelManager = new io(t22._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._precompileDone = false, this._shouldPrecompile = false, this._availableImages = [], this._order = [], this._markersNeedUpdate = false, this._styleColorTheme = { lut: null, lutLoading: false, lutLoadingCorrelationID: 0, colorTheme: null }, this._styleColorThemeForScope = {}, this.options = i2.configOptions ? i2.configOptions : /* @__PURE__ */ new Map(), this._configDependentLayers = i2.configDependentLayers ? i2.configDependentLayers : /* @__PURE__ */ new Set(), this._config = i2.config, this._initialConfig = i2.initialConfig, this.dispatcher.broadcast("setReferrer", e2.ch());
          const o2 = this;
          this._rtlTextPluginCallback = co.registerForPluginStateChange((t3) => {
            o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t3.pluginStatus, pluginURL: t3.pluginURL }, (t4, i3) => {
              if (e2.ci(t4), i3 && i3.every((e22) => e22))
                for (const e22 in o2._sourceCaches) {
                  const t5 = o2._sourceCaches[e22], i4 = t5.getSource().type;
                  "vector" !== i4 && "geojson" !== i4 || t5.reload();
                }
            });
          }), this.on("data", (e22) => {
            if ("source" !== e22.dataType || "metadata" !== e22.sourceDataType)
              return;
            const t3 = this.getOwnSource(e22.sourceId);
            if (t3 && t3.vectorLayerIds)
              for (const e3 in this._layers) {
                const i3 = this._layers[e3];
                i3.source === t3.id && this._validateLayer(i3);
              }
          });
        }
        load(e22) {
          return e22 ? ("string" == typeof e22 ? this.loadURL(e22) : this.loadJSON(e22), this) : this;
        }
        _getGlobalId(t22) {
          if (!t22)
            return null;
          if ("string" == typeof t22) {
            if (e2.f(t22))
              return t22;
            const i2 = e2.cj(t22);
            if (!i2.startsWith("http"))
              try {
                return new URL(i2, location.href).toString();
              } catch (e22) {
                return i2;
              }
            return i2;
          }
          return "json://".concat(e2.ck(JSON.stringify(t22)));
        }
        _diffStyle(t22, i2, o2) {
          this.globalId = this._getGlobalId(t22);
          const r22 = (e22, t3) => {
            try {
              t3(null, this.setState(e22, o2));
            } catch (e3) {
              t3(e3, false);
            }
          };
          if ("string" == typeof t22) {
            const o3 = this.map._requestManager.normalizeStyleURL(t22), s2 = this.map._requestManager.transformRequest(o3, e2.R.Style);
            e2.n(s2, (t3, o4) => {
              t3 ? this.fire(new e2.t(t3)) : o4 && r22(o4, i2);
            });
          } else
            "object" == typeof t22 && r22(t22, i2);
        }
        loadURL(t22, i2 = {}) {
          this.fire(new e2.x("dataloading", { dataType: "style" }));
          const o2 = "boolean" == typeof i2.validate ? i2.validate : !e2.f(t22);
          this.globalId = this._getGlobalId(t22), t22 = this.map._requestManager.normalizeStyleURL(t22, i2.accessToken), this.resolvedImports.add(t22);
          const r22 = this.importsCache.get(t22);
          if (r22)
            return this._load(r22, o2);
          const s2 = this.map._requestManager.transformRequest(t22, e2.R.Style);
          this._request = e2.n(s2, (i3, r3) => {
            if (this._request = null, i3)
              this.fire(new e2.t(i3));
            else if (r3)
              return this.importsCache.set(t22, r3), this._load(r3, o2);
          });
        }
        loadJSON(t22, i2 = {}) {
          this.fire(new e2.x("dataloading", { dataType: "style" })), this.globalId = this._getGlobalId(t22), this._request = e2.q.frame(() => {
            this._request = null, this._load(t22, false !== i2.validate);
          });
        }
        loadEmpty() {
          this.fire(new e2.x("dataloading", { dataType: "style" })), this._load(no, false);
        }
        _loadImports(t22, i2, o2) {
          if (this.importDepth >= 4)
            return e2.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
          const r22 = [];
          for (const e22 of t22) {
            const t3 = this._createFragmentStyle(e22), s2 = new Promise((e3) => {
              t3.once("style.import.load", e3), t3.once("error", e3);
            }).then(() => this.mergeAll());
            if (r22.push(s2), this.resolvedImports.has(e22.url)) {
              t3.loadEmpty();
              continue;
            }
            const a2 = e22.data || this.importsCache.get(e22.url);
            a2 ? (t3.loadJSON(a2, { validate: i2 }), this._isInternalStyle(a2) && (t3.globalId = null)) : e22.url ? t3.loadURL(e22.url, { validate: i2 }) : t3.loadEmpty();
            const n22 = { style: t3, id: e22.id, config: e22.config };
            if (o2) {
              const e3 = this.fragments.findIndex(({ id: e4 }) => e4 === o2);
              this.fragments = this.fragments.slice(0, e3).concat(n22).concat(this.fragments.slice(e3));
            } else
              this.fragments.push(n22);
          }
          return Promise.allSettled(r22);
        }
        getImportGlobalIds(e22 = this, t22 = /* @__PURE__ */ new Set()) {
          for (const i2 of e22.fragments)
            i2.style.globalId && t22.add(i2.style.globalId), this.getImportGlobalIds(i2.style, t22);
          return [...t22.values()];
        }
        _createFragmentStyle(t22) {
          const i2 = this.scope ? e2.av(t22.id, this.scope) : t22.id;
          let o2;
          const r22 = this._initialConfig && this._initialConfig[i2];
          (t22.config || r22) && (o2 = e2.l({}, t22.config, r22));
          const s2 = new co(this.map, { scope: i2, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: o2, configOptions: this.options, configDependentLayers: this._configDependentLayers });
          return s2.setEventedParent(this.map, { style: s2 }), s2;
        }
        _reloadImports() {
          this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();
        }
        _isInternalStyle(e22) {
          return this.isRootStyle() && (e22.fragment || !!e22.schema && false !== e22.fragment);
        }
        _load(t22, i2) {
          const o2 = t22.schema;
          if (this._isInternalStyle(t22)) {
            const o3 = e2.l({}, no, { imports: [{ id: "basemap", data: t22, url: "" }] });
            return void this._load(o3, i2);
          }
          if (this.updateConfig(this._config, o2), i2 && ro(this, fe2(t22)))
            return;
          this._loaded = true, this.stylesheet = e2.cl(t22);
          const r22 = () => {
            for (const e22 in t22.sources)
              this.addSource(e22, t22.sources[e22], { validate: false, isInitialLoad: true });
            t22.sprite ? this._loadSprite(t22.sprite) : (this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true })), this.glyphManager.setURL(t22.glyphs, this.scope);
            const o3 = Et(this.stylesheet.layers);
            if (this._order = o3.map((e22) => e22.id), this.stylesheet.light && e2.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights)
              if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
                const e22 = this.stylesheet.lights[0];
                this.light = new Ae2(e22.properties, e22.id);
              } else
                this.setLights(this.stylesheet.lights);
            this.light || (this.light = new Ae2(this.stylesheet.light)), this._layers = {}, this._serializedLayers = {};
            for (const t3 of o3) {
              const i3 = e2.cq(t3, this.scope, this._styleColorTheme.lut, this.options);
              0 !== i3.configDependencies.size && this._configDependentLayers.add(i3.fqid), i3.setEventedParent(this, { layer: { id: i3.id } }), this._layers[i3.id] = i3, this._serializedLayers[i3.id] = i3.serialize();
              const o4 = this.getOwnLayerSourceCache(i3), r4 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
              o4 && i3.canCastShadows() && r4 && (o4.castsShadows = true);
            }
            this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);
            const r3 = this.stylesheet.terrain;
            r3 && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(r3, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e2.x("data", { dataType: "style" }));
            const s3 = this.isRootStyle();
            t22.imports ? this._loadImports(t22.imports, i2).then(() => {
              this._reloadImports(), this.fire(new e2.x(s3 ? "style.load" : "style.import.load"));
            }) : (this._reloadImports(), this.fire(new e2.x(s3 ? "style.load" : "style.import.load")));
          }, s2 = this.stylesheet["color-theme"];
          if (this._styleColorTheme.colorTheme = s2, s2) {
            const t3 = this._evaluateColorThemeData(s2);
            this._loadColorTheme(t3).then(() => {
              r22();
            }).catch((t4) => {
              e2.w("Couldn't load color theme from the stylesheet: ".concat(t4)), r22();
            });
          } else
            this._styleColorTheme.lut = null, r22();
        }
        isRootStyle() {
          return 0 === this.importDepth;
        }
        mergeAll() {
          let t22, i2, o2, r22, s2, a2, n22, l22;
          const c22 = {};
          this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((e22) => {
            if (e22.stylesheet) {
              if (null != e22.light && (t22 = e22.light), e22.stylesheet.lights)
                for (const t3 of e22.stylesheet.lights)
                  "ambient" === t3.type && null != e22.ambientLight && (i2 = e22.ambientLight), "directional" === t3.type && null != e22.directionalLight && (o2 = e22.directionalLight);
              r22 = this._prioritizeTerrain(r22, e22.terrain, e22.stylesheet.terrain), e22.stylesheet.fog && null != e22.fog && (s2 = e22.fog), null != e22.stylesheet.camera && (l22 = e22.stylesheet.camera), null != e22.stylesheet.projection && (a2 = e22.stylesheet.projection), null != e22.stylesheet.transition && (n22 = e22.stylesheet.transition), c22[e22.scope] = e22._styleColorTheme;
            }
          }), this.light = t22, this.ambientLight = i2, this.directionalLight = o2, this.fog = s2, this._styleColorThemeForScope = c22, null === r22 ? delete this.terrain : this.terrain = r22, this.camera = l22 || { "camera-projection": "perspective" }, this.projection = a2 || { name: "mercator" }, this.transition = e2.l({}, lo, n22), this.mergeSources(), this.mergeLayers();
        }
        forEachFragmentStyle(e22) {
          const t22 = (i2) => {
            for (const e3 of i2.fragments)
              t22(e3.style);
            e22(i2);
          };
          t22(this);
        }
        _prioritizeTerrain(e22, t22, i2) {
          const o2 = e22 && 0 === e22.drapeRenderMode;
          return null === i2 ? t22 && 0 === t22.drapeRenderMode ? t22 : o2 ? e22 : null : null != t22 && (!e22 || o2 || t22 && 1 === t22.drapeRenderMode) ? t22 : e22;
        }
        mergeTerrain() {
          let e22;
          this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((t22) => {
            e22 = this._prioritizeTerrain(e22, t22.terrain, t22.stylesheet.terrain);
          }), null === e22 ? delete this.terrain : this.terrain = e22;
        }
        mergeProjection() {
          let e22;
          this.forEachFragmentStyle((t22) => {
            null != t22.stylesheet.projection && (e22 = t22.stylesheet.projection);
          }), this.projection = e22 || { name: "mercator" };
        }
        mergeSources() {
          const t22 = {}, i2 = {}, o2 = {};
          this.forEachFragmentStyle((r22) => {
            for (const i3 in r22._sourceCaches) {
              const o3 = e2.av(i3, r22.scope);
              t22[o3] = r22._sourceCaches[i3];
            }
            for (const t3 in r22._otherSourceCaches) {
              const o3 = e2.av(t3, r22.scope);
              i2[o3] = r22._otherSourceCaches[t3];
            }
            for (const t3 in r22._symbolSourceCaches) {
              const i3 = e2.av(t3, r22.scope);
              o2[i3] = r22._symbolSourceCaches[t3];
            }
          }), this._mergedSourceCaches = t22, this._mergedOtherSourceCaches = i2, this._mergedSymbolSourceCaches = o2;
        }
        mergeLayers() {
          const t22 = {}, i2 = [], o2 = {};
          this._mergedSlots = [], this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this.forEachFragmentStyle((o3) => {
            for (const r3 of o3._order) {
              const s2 = o3._layers[r3];
              if ("slot" === s2.type) {
                const i3 = e2.cm(r3);
                if (t22[i3])
                  continue;
                t22[i3] = [];
              }
              s2.slot && t22[s2.slot] ? t22[s2.slot].push(s2) : i2.push(s2);
            }
          }), this._mergedOrder = [];
          const r22 = (i3 = []) => {
            for (const s2 of i3)
              if ("slot" === s2.type) {
                const i4 = e2.cm(s2.id);
                t22[i4] && r22(t22[i4]), this._mergedSlots.push(i4);
              } else {
                const t3 = e2.av(s2.id, s2.scope);
                this._mergedOrder.push(t3), o2[t3] = s2, s2.is3D() && (this._has3DLayers = true), "circle" === s2.type && (this._hasCircleLayers = true), "symbol" === s2.type && (this._hasSymbolLayers = true), "clip" === s2.type && (this._clipLayerPresent = true);
              }
          };
          r22(i2), this._mergedOrder.sort((e22, t3) => {
            const i3 = o2[e22], r3 = o2[t3];
            return i3.hasInitialOcclusionOpacityProperties ? r3.is3D() ? 1 : 0 : i3.is3D() && r3.hasInitialOcclusionOpacityProperties ? -1 : 0;
          }), this._mergedLayers = o2, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
        }
        terrainSetForDrapingOnly() {
          return !!this.terrain && 0 === this.terrain.drapeRenderMode;
        }
        getCamera() {
          return this.stylesheet.camera;
        }
        setCamera(t22) {
          return this.stylesheet.camera = e2.l({}, this.stylesheet.camera, t22), this.camera = this.stylesheet.camera, this;
        }
        _evaluateColorThemeData(t22) {
          return t22.data ? function(t3, i2, o2) {
            const r22 = e2.l({}, i2);
            for (const t4 of Object.keys(e2._.colorTheme))
              void 0 === r22[t4] && (r22[t4] = e2._.colorTheme[t4].default);
            const s2 = new e2.$(oo, t3, new Map(o2));
            return s2.setTransitionOrValue(r22, o2), s2.untransitioned().possiblyEvaluate(new e2.a3(0));
          }(this.scope, t22, this.options).get("data") : null;
        }
        _loadColorTheme(t22) {
          this._styleColorTheme.lutLoading = true, this._styleColorTheme.lutLoadingCorrelationID += 1;
          const i2 = this._styleColorTheme.lutLoadingCorrelationID;
          return new Promise((o2, r22) => {
            const s2 = "data:image/png;base64,";
            if (!t22 || 0 === t22.length)
              return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = false, void o2();
            let a2 = t22;
            a2.startsWith(s2) || (a2 = s2 + a2);
            const n22 = "mapbox-reserved-lut", l22 = new Image();
            l22.src = a2, l22.onerror = () => {
              this._styleColorTheme.lutLoading = false, r22(new Error("Failed to load image data"));
            }, l22.onload = () => {
              if (this._styleColorTheme.lutLoadingCorrelationID !== i2)
                return void o2();
              this._styleColorTheme.lutLoading = false;
              const { width: s3, height: a3, data: c22 } = e2.q.getImageData(l22);
              if (a3 > 32)
                return void r22(new Error("The height of the image must be less than or equal to 32 pixels."));
              if (s3 !== a3 * a3)
                return void r22(new Error("The width of the image must be equal to the height squared."));
              this.getImage(n22) && this.removeImage(n22), this.addImage(n22, { data: new e2.r({ width: s3, height: a3 }, c22), pixelRatio: 1, sdf: false, version: 0 });
              const h22 = this.imageManager.getImage(n22, this.scope);
              h22 ? (this._styleColorTheme.lut = { image: h22.data, data: t22 }, o2()) : r22(new Error("Missing LUT image."));
            };
          });
        }
        getLut(e22) {
          const t22 = this._styleColorThemeForScope[e22];
          return t22 ? t22.lut : null;
        }
        setProjection(e22) {
          e22 ? this.stylesheet.projection = e22 : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
        }
        applyProjectionUpdate() {
          this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
        }
        _updateMapProjection() {
          this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
        }
        _loadSprite(t22) {
          this._spriteRequest = function(t3, i2, o2) {
            let r22, s2, a2;
            const n22 = e2.q.devicePixelRatio > 1 ? "@2x" : "";
            let l22 = e2.n(i2.transformRequest(i2.normalizeSpriteURL(t3, n22, ".json"), e2.R.SpriteJSON), (e22, t4) => {
              l22 = null, a2 || (a2 = e22, r22 = t4, h22());
            }), c22 = e2.o(i2.transformRequest(i2.normalizeSpriteURL(t3, n22, ".png"), e2.R.SpriteImage), (e22, t4) => {
              c22 = null, a2 || (a2 = e22, s2 = t4, h22());
            });
            function h22() {
              if (a2)
                o2(a2);
              else if (r22 && s2) {
                const t4 = e2.q.getImageData(s2), i3 = {};
                for (const o3 in r22) {
                  const { width: s3, height: a3, x: n3, y: l3, sdf: c3, pixelRatio: h3, stretchX: u22, stretchY: d22, content: _2 } = r22[o3], p22 = new e2.r({ width: s3, height: a3 });
                  e2.r.copy(t4, p22, { x: n3, y: l3 }, { x: 0, y: 0 }, { width: s3, height: a3 }, null), i3[o3] = { data: p22, pixelRatio: h3, sdf: c3, stretchX: u22, stretchY: d22, content: _2 };
                }
                o2(null, i3);
              }
            }
            return { cancel() {
              l22 && (l22.cancel(), l22 = null), c22 && (c22.cancel(), c22 = null);
            } };
          }(t22, this.map._requestManager, (t3, i2) => {
            if (this._spriteRequest = null, t3)
              this.fire(new e2.t(t3));
            else if (i2)
              for (const e22 in i2)
                this.imageManager.addImage(e22, this.scope, i2[e22]);
            this.imageManager.setLoaded(true, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true }), this.fire(new e2.x("data", { dataType: "style" }));
          });
        }
        _validateLayer(t22) {
          const i2 = this.getOwnSource(t22.source);
          if (!i2)
            return;
          const o2 = t22.sourceLayer;
          o2 && ("geojson" === i2.type || i2.vectorLayerIds && -1 === i2.vectorLayerIds.indexOf(o2)) && this.fire(new e2.t(new Error('Source layer "'.concat(o2, '" does not exist on source "').concat(i2.id, '" as specified by style layer "').concat(t22.id, '"'))));
        }
        loaded() {
          if (!this._loaded)
            return false;
          if (Object.keys(this._changes.getUpdatedSourceCaches()).length)
            return false;
          for (const e22 in this._sourceCaches)
            if (!this._sourceCaches[e22].loaded())
              return false;
          if (!this.imageManager.isLoaded())
            return false;
          if (!this.modelManager.isLoaded())
            return false;
          if (this._styleColorTheme.lutLoading)
            return false;
          for (const { style: e22 } of this.fragments)
            if (!e22.loaded())
              return false;
          return true;
        }
        _serializeImports() {
          if (this.stylesheet.imports)
            return this.stylesheet.imports.map((e22, t22) => {
              const i2 = this.fragments[t22];
              return i2 && i2.style && (e22.data = i2.style.serialize()), e22;
            });
        }
        _serializeSources() {
          const e22 = {};
          for (const t22 in this._sourceCaches) {
            const i2 = this._sourceCaches[t22].getSource();
            e22[i2.id] || (e22[i2.id] = i2.serialize());
          }
          return e22;
        }
        _serializeLayers(e22) {
          const t22 = [];
          for (const i2 of e22) {
            const e3 = this._layers[i2];
            e3 && "custom" !== e3.type && t22.push(e3.serialize());
          }
          return t22;
        }
        hasLightTransitions() {
          return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
        }
        hasFogTransition() {
          return !!this.fog && this.fog.hasTransition();
        }
        hasTransitions() {
          if (this.hasLightTransitions())
            return true;
          if (this.hasFogTransition())
            return true;
          for (const e22 in this._sourceCaches)
            if (this._sourceCaches[e22].hasTransition())
              return true;
          for (const e22 in this._layers)
            if (this._layers[e22].hasTransition())
              return true;
          return false;
        }
        get order() {
          return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
        }
        isLayerDraped(e22) {
          return !!this.terrain && e22.isDraped(this.getLayerSourceCache(e22));
        }
        _checkLoaded() {
          if (!this._loaded)
            throw new Error("Style is not done loading");
        }
        _checkLayer(t22) {
          const i2 = this.getOwnLayer(t22);
          if (i2)
            return i2;
          this.fire(new e2.t(new Error("The layer '".concat(t22, "' does not exist in the map's style."))));
        }
        _checkSource(t22) {
          const i2 = this.getOwnSource(t22);
          if (i2)
            return i2;
          this.fire(new e2.t(new Error("The source '".concat(t22, "' does not exist in the map's style."))));
        }
        precompilePrograms(e22, t22) {
          const i2 = this.map.painter;
          if (i2)
            for (let o2 = e22.minzoom || 0; o2 < (e22.maxzoom || 25.5); o2++) {
              const o3 = e22.getProgramIds();
              if (o3)
                for (const r22 of o3) {
                  const o4 = e22.getDefaultProgramParams(r22, t22.zoom, this._styleColorTheme.lut);
                  o4 && (i2.style = this, this.fog && (i2._fogVisible = true, o4.overrideFog = true, i2.getOrCreateProgram(r22, o4)), i2._fogVisible = false, o4.overrideFog = false, i2.getOrCreateProgram(r22, o4), (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (o4.overrideRtt = true, i2.getOrCreateProgram(r22, o4)));
                }
            }
        }
        update(t22) {
          if (!this._loaded)
            return;
          this.ambientLight && this.ambientLight.recalculate(t22), this.directionalLight && this.directionalLight.recalculate(t22);
          const i2 = this.calculateLightsBrightness();
          t22.brightness = i2 || 0, i2 !== this._brightness && (this._brightness = i2, this.dispatcher.broadcast("setBrightness", i2));
          const o2 = this._changes.isDirty();
          let r22 = false;
          if (this._changes.isDirty()) {
            const e22 = this._changes.getLayerUpdatesByScope();
            for (const t3 in e22) {
              const { updatedIds: i3, removedIds: o3 } = e22[t3];
              (i3 || o3) && (this._updateWorkerLayers(t3, i3, o3), r22 = true);
            }
            this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t22), this.light && this.light.updateTransitions(t22), this.ambientLight && this.ambientLight.updateTransitions(t22), this.directionalLight && this.directionalLight.updateTransitions(t22), this.fog && this.fog.updateTransitions(t22), this._changes.reset();
          }
          const s2 = {};
          for (const e22 in this._mergedSourceCaches) {
            const t3 = this._mergedSourceCaches[e22];
            s2[e22] = t3.used, t3.used = false, t3.tileCoverLift = 0;
          }
          for (const e22 of this._mergedOrder) {
            const i3 = this._mergedLayers[e22];
            if (i3.recalculate(t22, this._availableImages), !i3.isHidden(t22.zoom)) {
              const e3 = this.getLayerSourceCache(i3);
              e3 && (e3.used = true, e3.tileCoverLift = Math.max(e3.tileCoverLift, i3.tileCoverLift()));
            }
            !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback(() => {
              this.precompilePrograms(i3, t22);
            }) : this.precompilePrograms(i3, t22));
          }
          this._shouldPrecompile && (this._precompileDone = true), this.terrain && r22 && this.mergeLayers();
          for (const t3 in s2) {
            const i3 = this._mergedSourceCaches[t3];
            s2[t3] !== i3.used && i3.getSource().fire(new e2.x("data", { sourceDataType: "visibility", dataType: "source", sourceId: i3.getSource().id }));
          }
          this.light && this.light.recalculate(t22), this.terrain && this.terrain.recalculate(t22), this.fog && this.fog.recalculate(t22), this.z = t22.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), o2 && this.fire(new e2.x("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const e22 = this._changes.getUpdatedImages();
          if (e22.length) {
            for (const t22 in this._sourceCaches)
              this._sourceCaches[t22].reloadTilesForDependencies(["icons", "patterns"], e22);
            this._changes.resetUpdatedImages();
          }
        }
        _updateWorkerLayers(e22, t22, i2) {
          const o2 = this.getFragmentStyle(e22);
          o2 && this.dispatcher.broadcast("updateLayers", { layers: t22 ? o2._serializeLayers(t22) : [], scope: e22, removedIds: i2 || [], options: o2.options });
        }
        setState(t22, i2) {
          if (this._checkLoaded(), ro(this, fe2(t22)))
            return false;
          (t22 = e2.cl(t22)).layers = Et(t22.layers);
          const o2 = function(t3, i3) {
            if (!t3)
              return [{ command: Ct.setStyle, args: [i3] }];
            let o3 = [];
            try {
              if (!e2.bh(t3.version, i3.version))
                return [{ command: Ct.setStyle, args: [i3] }];
              if (e2.bh(t3.center, i3.center) || o3.push({ command: Ct.setCenter, args: [i3.center] }), e2.bh(t3.zoom, i3.zoom) || o3.push({ command: Ct.setZoom, args: [i3.zoom] }), e2.bh(t3.bearing, i3.bearing) || o3.push({ command: Ct.setBearing, args: [i3.bearing] }), e2.bh(t3.pitch, i3.pitch) || o3.push({ command: Ct.setPitch, args: [i3.pitch] }), e2.bh(t3.sprite, i3.sprite) || o3.push({ command: Ct.setSprite, args: [i3.sprite] }), e2.bh(t3.glyphs, i3.glyphs) || o3.push({ command: Ct.setGlyphs, args: [i3.glyphs] }), e2.bh(t3.imports, i3.imports) || function(t4 = [], i4 = [], o4) {
                i4 = i4 || [];
                const r4 = (t4 = t4 || []).map(Lt), s4 = i4.map(Lt), a3 = t4.reduce(Pt, {}), n3 = i4.reduce(Pt, {}), l22 = r4.slice();
                let c22, h22, u22, d22;
                for (c22 = 0, h22 = 0; c22 < r4.length; c22++)
                  u22 = r4[c22], n3.hasOwnProperty(u22) ? h22++ : (o4.push({ command: Ct.removeImport, args: [u22] }), l22.splice(l22.indexOf(u22, h22), 1));
                for (c22 = 0, h22 = 0; c22 < s4.length; c22++)
                  u22 = s4[s4.length - 1 - c22], l22[l22.length - 1 - c22] !== u22 && (a3.hasOwnProperty(u22) ? (o4.push({ command: Ct.removeImport, args: [u22] }), l22.splice(l22.lastIndexOf(u22, l22.length - h22), 1)) : h22++, d22 = l22[l22.length - c22], o4.push({ command: Ct.addImport, args: [n3[u22], d22] }), l22.splice(l22.length - c22, 0, u22));
                for (const t5 of i4) {
                  const i5 = a3[t5.id];
                  i5 && !e2.bh(i5, t5) && o4.push({ command: Ct.updateImport, args: [t5.id, t5] });
                }
              }(t3.imports, i3.imports, o3), e2.bh(t3.transition, i3.transition) || o3.push({ command: Ct.setTransition, args: [i3.transition] }), e2.bh(t3.light, i3.light) || o3.push({ command: Ct.setLight, args: [i3.light] }), e2.bh(t3.fog, i3.fog) || o3.push({ command: Ct.setFog, args: [i3.fog] }), e2.bh(t3.projection, i3.projection) || o3.push({ command: Ct.setProjection, args: [i3.projection] }), e2.bh(t3.lights, i3.lights) || o3.push({ command: Ct.setLights, args: [i3.lights] }), e2.bh(t3.camera, i3.camera) || o3.push({ command: Ct.setCamera, args: [i3.camera] }), !e2.bh(t3["color-theme"], i3["color-theme"]))
                return [{ command: Ct.setStyle, args: [i3] }];
              const r3 = {}, s3 = [];
              !function(t4, i4, o4, r4) {
                let s4;
                for (s4 in i4 = i4 || {}, t4 = t4 || {})
                  t4.hasOwnProperty(s4) && (i4.hasOwnProperty(s4) || It(s4, o4, r4));
                for (s4 in i4) {
                  if (!i4.hasOwnProperty(s4))
                    continue;
                  const a3 = i4[s4];
                  t4.hasOwnProperty(s4) ? e2.bh(t4[s4], a3) || ("geojson" === t4[s4].type && "geojson" === a3.type && Rt(t4, i4, s4) ? o4.push({ command: Ct.setGeoJSONSourceData, args: [s4, a3.data] }) : Dt(s4, i4, o4, r4)) : St(s4, i4, o4);
                }
              }(t3.sources, i3.sources, s3, r3);
              const a2 = [];
              t3.layers && t3.layers.forEach((e22) => {
                e22.source && r3[e22.source] ? o3.push({ command: Ct.removeLayer, args: [e22.id] }) : a2.push(e22);
              });
              let n22 = t3.terrain;
              n22 && r3[n22.source] && (o3.push({ command: Ct.setTerrain, args: [void 0] }), n22 = void 0), o3 = o3.concat(s3), e2.bh(n22, i3.terrain) || o3.push({ command: Ct.setTerrain, args: [i3.terrain] }), function(t4, i4, o4) {
                i4 = i4 || [];
                const r4 = (t4 = t4 || []).map(Lt), s4 = i4.map(Lt), a3 = t4.reduce(Pt, {}), n3 = i4.reduce(Pt, {}), l22 = r4.slice(), c22 = /* @__PURE__ */ Object.create(null);
                let h22, u22, d22, _2, p22, m22, f22;
                for (h22 = 0, u22 = 0; h22 < r4.length; h22++)
                  d22 = r4[h22], n3.hasOwnProperty(d22) ? u22++ : (o4.push({ command: Ct.removeLayer, args: [d22] }), l22.splice(l22.indexOf(d22, u22), 1));
                for (h22 = 0, u22 = 0; h22 < s4.length; h22++)
                  d22 = s4[s4.length - 1 - h22], l22[l22.length - 1 - h22] !== d22 && (a3.hasOwnProperty(d22) ? (o4.push({ command: Ct.removeLayer, args: [d22] }), l22.splice(l22.lastIndexOf(d22, l22.length - u22), 1)) : u22++, m22 = l22[l22.length - h22], o4.push({ command: Ct.addLayer, args: [n3[d22], m22] }), l22.splice(l22.length - h22, 0, d22), c22[d22] = true);
                for (h22 = 0; h22 < s4.length; h22++)
                  if (d22 = s4[h22], _2 = a3[d22], p22 = n3[d22], !c22[d22] && !e2.bh(_2, p22))
                    if (e2.bh(_2.source, p22.source) && e2.bh(_2["source-layer"], p22["source-layer"]) && e2.bh(_2.type, p22.type)) {
                      for (f22 in At(_2.layout, p22.layout, o4, d22, null, Ct.setLayoutProperty), At(_2.paint, p22.paint, o4, d22, null, Ct.setPaintProperty), e2.bh(_2.slot, p22.slot) || o4.push({ command: Ct.setSlot, args: [d22, p22.slot] }), e2.bh(_2.filter, p22.filter) || o4.push({ command: Ct.setFilter, args: [d22, p22.filter] }), e2.bh(_2.minzoom, p22.minzoom) && e2.bh(_2.maxzoom, p22.maxzoom) || o4.push({ command: Ct.setLayerZoomRange, args: [d22, p22.minzoom, p22.maxzoom] }), _2)
                        _2.hasOwnProperty(f22) && "layout" !== f22 && "paint" !== f22 && "filter" !== f22 && "metadata" !== f22 && "minzoom" !== f22 && "maxzoom" !== f22 && "slot" !== f22 && (0 === f22.indexOf("paint.") ? At(_2[f22], p22[f22], o4, d22, f22.slice(6), Ct.setPaintProperty) : e2.bh(_2[f22], p22[f22]) || o4.push({ command: Ct.setLayerProperty, args: [d22, f22, p22[f22]] }));
                      for (f22 in p22)
                        p22.hasOwnProperty(f22) && !_2.hasOwnProperty(f22) && "layout" !== f22 && "paint" !== f22 && "filter" !== f22 && "metadata" !== f22 && "minzoom" !== f22 && "maxzoom" !== f22 && "slot" !== f22 && (0 === f22.indexOf("paint.") ? At(_2[f22], p22[f22], o4, d22, f22.slice(6), Ct.setPaintProperty) : e2.bh(_2[f22], p22[f22]) || o4.push({ command: Ct.setLayerProperty, args: [d22, f22, p22[f22]] }));
                    } else
                      o4.push({ command: Ct.removeLayer, args: [d22] }), m22 = l22[l22.lastIndexOf(d22) + 1], o4.push({ command: Ct.addLayer, args: [p22, m22] });
              }(a2, i3.layers, o3);
            } catch (e22) {
              console.warn("Unable to compute style diff:", e22), o3 = [{ command: Ct.setStyle, args: [i3] }];
            }
            return o3;
          }(this.serialize(), t22).filter((e22) => !(e22.command in ao));
          if (0 === o2.length)
            return false;
          const r22 = o2.filter((e22) => !(e22.command in so));
          if (r22.length > 0)
            throw new Error("Unimplemented: ".concat(r22.map((e22) => e22.command).join(", "), "."));
          const s2 = [];
          return o2.forEach((e22) => {
            s2.push(this[e22.command].apply(this, e22.args));
          }), i2 && Promise.all(s2).then(i2), this.stylesheet = t22, this.mergeAll(), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), true;
        }
        addImage(t22, i2) {
          return this.getImage(t22) ? this.fire(new e2.t(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t22, this.scope, i2), this._afterImageUpdated(t22), this);
        }
        updateImage(e22, t22) {
          this.imageManager.updateImage(e22, this.scope, t22);
        }
        getImage(e22) {
          return this.imageManager.getImage(e22, this.scope);
        }
        removeImage(t22) {
          return this.getImage(t22) ? (this.imageManager.removeImage(t22, this.scope), this._afterImageUpdated(t22), this) : this.fire(new e2.t(new Error("No image with this name exists.")));
        }
        _afterImageUpdated(t22) {
          this._availableImages = this.imageManager.listImages(this.scope), this._changes.updateImage(t22), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.fire(new e2.x("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this._availableImages.slice();
        }
        addModel(e22, t22, i2 = {}) {
          return this._checkLoaded(), this._validate(Se2, "models.".concat(e22), t22, null, i2) || (this.modelManager.addModel(e22, t22, this.scope), this._changes.setDirty()), this;
        }
        hasModel(e22) {
          return this.modelManager.hasModel(e22, this.scope);
        }
        removeModel(t22) {
          return this.hasModel(t22) ? (this.modelManager.removeModel(t22, this.scope), this) : this.fire(new e2.t(new Error("No model with this ID exists.")));
        }
        listModels() {
          return this._checkLoaded(), this.modelManager.listModels(this.scope);
        }
        addSource(t22, i2, o2 = {}) {
          if (this._checkLoaded(), void 0 !== this.getOwnSource(t22))
            throw new Error('There is already a source with ID "'.concat(t22, '".'));
          if (!i2.type)
            throw new Error("The type property must be defined, but only the following properties were given: ".concat(Object.keys(i2).join(", "), "."));
          if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(ge2, "sources.".concat(t22), i2, null, o2))
            return;
          this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
          const r22 = tt(t22, i2, this.dispatcher, this);
          r22.scope = this.scope, r22.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(r22.id), source: r22.serialize(), sourceId: r22.id }));
          const s2 = (t3) => {
            const i3 = (t3 ? "symbol:" : "other:") + r22.id, o3 = e2.av(i3, this.scope), s3 = this._sourceCaches[i3] = new vt(o3, r22, t3);
            (t3 ? this._symbolSourceCaches : this._otherSourceCaches)[r22.id] = s3, s3.onAdd(this.map);
          };
          s2(false), "vector" !== i2.type && "geojson" !== i2.type || s2(true), r22.onAdd && r22.onAdd(this.map), o2.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
        }
        removeSource(t22) {
          this._checkLoaded();
          const i2 = this.getOwnSource(t22);
          if (!i2)
            throw new Error("There is no source with this ID");
          for (const i3 in this._layers)
            if (this._layers[i3].source === t22)
              return this.fire(new e2.t(new Error('Source "'.concat(t22, '" cannot be removed while layer "').concat(i3, '" is using it.'))));
          if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t22)
            return this.fire(new e2.t(new Error('Source "'.concat(t22, '" cannot be removed while terrain is using it.'))));
          const o2 = this.getOwnSourceCaches(t22);
          for (const t3 of o2) {
            const i3 = e2.cm(t3.id);
            delete this._sourceCaches[i3], this._changes.discardSourceCacheUpdate(t3.id), t3.fire(new e2.x("data", { sourceDataType: "metadata", dataType: "source", sourceId: t3.getSource().id })), t3.setEventedParent(null), t3.clearTiles();
          }
          return delete this._otherSourceCaches[t22], delete this._symbolSourceCaches[t22], this.mergeSources(), i2.setEventedParent(null), i2.onRemove && i2.onRemove(this.map), this._changes.setDirty(), this;
        }
        setGeoJSONSourceData(e22, t22) {
          this._checkLoaded(), this.getOwnSource(e22).setData(t22), this._changes.setDirty();
        }
        getOwnSource(e22) {
          const t22 = this.getOwnSourceCache(e22);
          return t22 && t22.getSource();
        }
        getOwnSources() {
          const e22 = [];
          for (const t22 in this._otherSourceCaches) {
            const i2 = this.getOwnSourceCache(t22);
            i2 && e22.push(i2.getSource());
          }
          return e22;
        }
        areTilesLoaded() {
          const e22 = this._mergedSourceCaches;
          for (const t22 in e22) {
            const i2 = e22[t22]._tiles;
            for (const e3 in i2) {
              const t3 = i2[e3];
              if ("loaded" !== t3.state && "errored" !== t3.state)
                return false;
            }
          }
          return true;
        }
        setLights(t22) {
          if (this._checkLoaded(), !t22)
            return delete this.ambientLight, void delete this.directionalLight;
          const i2 = this._getTransitionParameters();
          for (const o3 of t22) {
            if (this._validate(xe, "lights", o3))
              return;
            switch (o3.type) {
              case "ambient":
                if (this.ambientLight) {
                  const e22 = this.ambientLight;
                  e22.set(o3), e22.updateTransitions(i2);
                } else
                  this.ambientLight = new je2(o3, Ve2 || (Ve2 = new e2.a0({ color: new e2.a1(e2._.properties_light_ambient.color), intensity: new e2.a1(e2._.properties_light_ambient.intensity) })), this.scope, this.options);
                break;
              case "directional":
                if (this.directionalLight) {
                  const e22 = this.directionalLight;
                  e22.set(o3), e22.updateTransitions(i2);
                } else
                  this.directionalLight = new je2(o3, qe2 || (qe2 = new e2.a0({ direction: new e2.ad(e2._.properties_light_directional.direction), color: new e2.a1(e2._.properties_light_directional.color), intensity: new e2.a1(e2._.properties_light_directional.intensity), "cast-shadows": new e2.a1(e2._.properties_light_directional["cast-shadows"]), "shadow-intensity": new e2.a1(e2._.properties_light_directional["shadow-intensity"]) })), this.scope, this.options);
            }
          }
          const o2 = new e2.a3(this.z || 0, i2);
          this.ambientLight && this.ambientLight.recalculate(o2), this.directionalLight && this.directionalLight.recalculate(o2), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
        }
        calculateLightsBrightness() {
          const t22 = this.directionalLight, i2 = this.ambientLight;
          if (!t22 || !i2)
            return;
          const o2 = (e22) => 0.2126 * (e22[0] <= 0.03928 ? e22[0] / 12.92 : Math.pow((e22[0] + 0.055) / 1.055, 2.4)) + 0.7152 * (e22[1] <= 0.03928 ? e22[1] / 12.92 : Math.pow((e22[1] + 0.055) / 1.055, 2.4)) + 0.0722 * (e22[2] <= 0.03928 ? e22[2] / 12.92 : Math.pow((e22[2] + 0.055) / 1.055, 2.4)), r22 = t22.properties.get("color").toRenderColor(null).toArray01(), s2 = t22.properties.get("intensity"), a2 = t22.properties.get("direction"), n22 = 1 - e2.c7(a2.x, a2.y, a2.z)[2] / 90, l22 = o2(r22) * s2 * n22, c22 = i2.properties.get("color").toRenderColor(null).toArray01(), h22 = i2.properties.get("intensity");
          return (l22 + o2(c22) * h22) / 2;
        }
        getBrightness() {
          return this._brightness;
        }
        getLights() {
          if (!this.enable3dLights())
            return null;
          const e22 = [];
          return this.directionalLight && e22.push(this.directionalLight.get()), this.ambientLight && e22.push(this.ambientLight.get()), e22;
        }
        enable3dLights() {
          return !!this.ambientLight && !!this.directionalLight;
        }
        getFragmentStyle(t22) {
          if (!t22)
            return this;
          if (e2.cn(t22)) {
            const i2 = e2.co(t22), o2 = this.fragments.find(({ id: e22 }) => e22 === i2);
            if (!o2)
              throw new Error("Style import not found: ".concat(t22));
            const r22 = e2.cm(t22);
            return o2.style.getFragmentStyle(r22);
          }
          {
            const e22 = this.fragments.find(({ id: e3 }) => e3 === t22);
            if (!e22)
              throw new Error("Style import not found: ".concat(t22));
            return e22.style;
          }
        }
        getConfigProperty(t22, i2) {
          const o2 = this.getFragmentStyle(t22);
          if (!o2)
            return null;
          const r22 = e2.av(i2, o2.scope), s2 = o2.options.get(r22), a2 = s2 ? s2.value || s2.default : null;
          return a2 ? a2.serialize() : null;
        }
        setConfigProperty(t22, i2, o2) {
          const r22 = this.getFragmentStyle(t22);
          if (!r22)
            return;
          const s2 = r22.stylesheet.schema;
          if (!s2 || !s2[i2])
            return;
          const a2 = e2.M(o2);
          if ("success" !== a2.result)
            return void ro(this, a2.value);
          const n22 = a2.value.expression, l22 = e2.av(i2, r22.scope), c22 = r22.options.get(l22);
          if (!c22)
            return;
          let h22;
          const { minValue: u22, maxValue: d22, stepValue: _2, type: p22, values: m22 } = s2[i2], f22 = e2.M(s2[i2].default);
          "success" === f22.result && (h22 = f22.value.expression), h22 ? (this.options.set(l22, { ...c22, value: n22, default: h22, minValue: u22, maxValue: d22, stepValue: _2, type: p22, values: m22 }), this.updateConfigDependencies(i2)) : this.fire(new e2.t(new Error('No schema defined for the config option "'.concat(i2, '" in the "').concat(t22, '" fragment.'))));
        }
        getConfig(t22) {
          const i2 = this.getFragmentStyle(t22);
          if (!i2)
            return null;
          const o2 = i2.stylesheet.schema;
          if (!o2)
            return null;
          const r22 = {};
          for (const t3 in o2) {
            const o3 = e2.av(t3, i2.scope), s2 = i2.options.get(o3), a2 = s2 ? s2.value || s2.default : null;
            r22[t3] = a2 ? a2.serialize() : null;
          }
          return r22;
        }
        setConfig(e22, t22) {
          const i2 = this.getFragmentStyle(e22);
          i2 && (i2.updateConfig(t22, i2.stylesheet.schema), this.updateConfigDependencies());
        }
        getSchema(e22) {
          const t22 = this.getFragmentStyle(e22);
          return t22 ? t22.stylesheet.schema : null;
        }
        setSchema(e22, t22) {
          const i2 = this.getFragmentStyle(e22);
          i2 && (i2.stylesheet.schema = t22, i2.updateConfig(i2._config, t22), this.updateConfigDependencies());
        }
        updateConfig(t22, i2) {
          if (this._config = t22, t22 || i2)
            if (i2)
              for (const o2 in i2) {
                let r22, s2;
                const a2 = e2.M(i2[o2].default);
                if ("success" === a2.result && (r22 = a2.value.expression), t22 && void 0 !== t22[o2]) {
                  const i3 = e2.M(t22[o2]);
                  "success" === i3.result && (s2 = i3.value.expression);
                }
                const { minValue: n22, maxValue: l22, stepValue: c22, type: h22, values: u22 } = i2[o2];
                if (r22) {
                  const t3 = e2.av(o2, this.scope);
                  this.options.set(t3, { default: r22, value: s2, minValue: n22, maxValue: l22, stepValue: c22, type: h22, values: u22 });
                } else
                  this.fire(new e2.t(new Error('No schema defined for config option "'.concat(o2, '".'))));
              }
            else
              this.fire(new e2.t(new Error("Attempting to set config for a style without schema.")));
        }
        updateConfigDependencies(e22) {
          for (const t22 of this._configDependentLayers) {
            const i2 = this.getLayer(t22);
            if (i2) {
              if (e22 && !i2.configDependencies.has(e22))
                continue;
              i2.possiblyEvaluateVisibility(), this._updateLayer(i2);
            }
          }
          this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.forEachFragmentStyle((e3) => {
            if (e3._styleColorTheme.colorTheme) {
              const t22 = e3._evaluateColorThemeData(e3._styleColorTheme.colorTheme);
              (!e3._styleColorTheme.lut && "" !== t22 || e3._styleColorTheme.lut && t22 !== e3._styleColorTheme.lut.data) && e3.setColorTheme(e3._styleColorTheme.colorTheme);
            }
          }), this._changes.setDirty();
        }
        addLayer(t22, i2, o2 = {}) {
          this._checkLoaded();
          const r22 = t22.id;
          if (this._layers[r22])
            return void this.fire(new e2.t(new Error('Layer with id "'.concat(r22, '" already exists on this map'))));
          let s2;
          if ("custom" === t22.type) {
            if (ro(this, e2.cp(t22)))
              return;
            s2 = e2.cq(t22, this.scope, this._styleColorTheme.lut, this.options);
          } else {
            if ("object" == typeof t22.source && (this.addSource(r22, t22.source), t22 = e2.cl(t22), t22 = e2.l(t22, { source: r22 })), this._validate(we2, "layers.".concat(r22), t22, { arrayIndex: -1 }, o2))
              return;
            s2 = e2.cq(t22, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(s2), s2.setEventedParent(this, { layer: { id: r22 } }), this._serializedLayers[s2.id] = s2.serialize();
          }
          0 !== s2.configDependencies.size && this._configDependentLayers.add(s2.fqid);
          let a2 = this._order.length;
          if (i2) {
            const t3 = this._order.indexOf(i2);
            if (-1 === t3)
              return void this.fire(new e2.t(new Error('Layer with id "'.concat(i2, '" does not exist on this map.'))));
            s2.slot === this._layers[i2].slot ? a2 = t3 : e2.w('Layer with id "'.concat(i2, '" has a different slot. Layers can only be rearranged within the same slot.'));
          }
          this._order.splice(a2, 0, r22), this._layerOrderChanged = true, this._layers[r22] = s2;
          const n22 = this.getOwnLayerSourceCache(s2), l22 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
          n22 && s2.canCastShadows() && l22 && (n22.castsShadows = true);
          const c22 = this._changes.getRemovedLayer(s2);
          if (c22 && s2.source && n22 && "custom" !== s2.type) {
            this._changes.discardLayerRemoval(s2);
            const t3 = e2.av(s2.source, s2.scope);
            c22.type !== s2.type ? this._changes.updateSourceCache(t3, "clear") : (this._changes.updateSourceCache(t3, "reload"), n22.pause());
          }
          this._updateLayer(s2), s2.onAdd && s2.onAdd(this.map), s2.scope = this.scope, this.mergeLayers();
        }
        moveLayer(t22, i2) {
          this._checkLoaded();
          const o2 = this._checkLayer(t22);
          if (!o2)
            return;
          if (t22 === i2)
            return;
          const r22 = this._order.indexOf(t22);
          this._order.splice(r22, 1);
          let s2 = this._order.length;
          if (i2) {
            const t3 = this._order.indexOf(i2);
            if (-1 === t3)
              return void this.fire(new e2.t(new Error('Layer with id "'.concat(i2, '" does not exist on this map.'))));
            o2.slot === this._layers[i2].slot ? s2 = t3 : e2.w('Layer with id "'.concat(i2, '" has a different slot. Layers can only be rearranged within the same slot.'));
          }
          this._order.splice(s2, 0, t22), this._changes.setDirty(), this._layerOrderChanged = true, this.mergeLayers();
        }
        removeLayer(e22) {
          this._checkLoaded();
          const t22 = this._checkLayer(e22);
          if (!t22)
            return;
          t22.setEventedParent(null);
          const i2 = this._order.indexOf(e22);
          this._order.splice(i2, 1), delete this._layers[e22], delete this._serializedLayers[e22], this._changes.setDirty(), this._layerOrderChanged = true, this._configDependentLayers.delete(t22.fqid), this._changes.removeLayer(t22);
          const o2 = this.getOwnLayerSourceCache(t22);
          if (o2 && o2.castsShadows) {
            let e3 = false;
            for (const i3 in this._layers)
              if (this._layers[i3].source === t22.source && this._layers[i3].canCastShadows()) {
                e3 = true;
                break;
              }
            o2.castsShadows = e3;
          }
          t22.onRemove && t22.onRemove(this.map), this.mergeLayers();
        }
        getOwnLayer(e22) {
          return this._layers[e22];
        }
        hasLayer(e22) {
          return e22 in this._mergedLayers;
        }
        hasLayerType(e22) {
          for (const t22 in this._layers)
            if (this._layers[t22].type === e22)
              return true;
          return false;
        }
        setLayerZoomRange(e22, t22, i2) {
          this._checkLoaded();
          const o2 = this._checkLayer(e22);
          o2 && (o2.minzoom === t22 && o2.maxzoom === i2 || (null != t22 && (o2.minzoom = t22), null != i2 && (o2.maxzoom = i2), this._updateLayer(o2)));
        }
        getSlots() {
          return this._checkLoaded(), this._mergedSlots;
        }
        setSlot(e22, t22) {
          this._checkLoaded();
          const i2 = this._checkLayer(e22);
          i2 && i2.slot !== t22 && (i2.slot = t22, this._updateLayer(i2));
        }
        setFilter(t22, i2, o2 = {}) {
          this._checkLoaded();
          const r22 = this._checkLayer(t22);
          if (r22 && !e2.bh(r22.filter, i2))
            return null == i2 ? (r22.filter = void 0, void this._updateLayer(r22)) : void (this._validate(Te2, "layers.".concat(r22.id, ".filter"), i2, { layerType: r22.type }, o2) || (r22.filter = e2.cl(i2), this._updateLayer(r22)));
        }
        getFilter(t22) {
          const i2 = this._checkLayer(t22);
          if (i2)
            return e2.cl(i2.filter);
        }
        setLayoutProperty(t22, i2, o2, r22 = {}) {
          this._checkLoaded();
          const s2 = this._checkLayer(t22);
          if (s2 && !e2.bh(s2.getLayoutProperty(i2), o2)) {
            if (null != o2 && (!r22 || false !== r22.validate) && ro(s2, Ce2.call(fe2, { key: "layers.".concat(t22, ".layout.").concat(i2), layerType: s2.type, objectKey: i2, value: o2, styleSpec: e2._, style: { glyphs: true, sprite: true } })))
              return;
            s2.setLayoutProperty(i2, o2), 0 !== s2.configDependencies.size && this._configDependentLayers.add(s2.fqid), this._updateLayer(s2);
          }
        }
        getLayoutProperty(e22, t22) {
          const i2 = this._checkLayer(e22);
          if (i2)
            return i2.getLayoutProperty(t22);
        }
        setPaintProperty(t22, i2, o2, r22 = {}) {
          this._checkLoaded();
          const s2 = this._checkLayer(t22);
          if (!s2)
            return;
          if (e2.bh(s2.getPaintProperty(i2), o2))
            return;
          if (null != o2 && (!r22 || false !== r22.validate) && ro(s2, Ee2.call(fe2, { key: "layers.".concat(t22, ".paint.").concat(i2), layerType: s2.type, objectKey: i2, value: o2, styleSpec: e2._ })))
            return;
          const a2 = s2.setPaintProperty(i2, o2);
          0 !== s2.configDependencies.size && this._configDependentLayers.add(s2.fqid), a2 && this._updateLayer(s2), this._changes.updatePaintProperties(s2);
        }
        getPaintProperty(e22, t22) {
          const i2 = this._checkLayer(e22);
          if (i2)
            return i2.getPaintProperty(t22);
        }
        setFeatureState(t22, i2) {
          this._checkLoaded();
          const o2 = t22.source, r22 = t22.sourceLayer, s2 = this._checkSource(o2);
          if (!s2)
            return;
          const a2 = s2.type;
          if ("geojson" === a2 && r22)
            return void this.fire(new e2.t(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
          if ("vector" === a2 && !r22)
            return void this.fire(new e2.t(new Error("The sourceLayer parameter must be provided for vector source types.")));
          void 0 === t22.id && this.fire(new e2.t(new Error("The feature id parameter must be provided.")));
          const n22 = this.getOwnSourceCaches(o2);
          for (const e22 of n22)
            e22.setFeatureState(r22, t22.id, i2);
        }
        removeFeatureState(t22, i2) {
          this._checkLoaded();
          const o2 = t22.source, r22 = this._checkSource(o2);
          if (!r22)
            return;
          const s2 = r22.type, a2 = "vector" === s2 ? t22.sourceLayer : void 0;
          if ("vector" === s2 && !a2)
            return void this.fire(new e2.t(new Error("The sourceLayer parameter must be provided for vector source types.")));
          if (i2 && "string" != typeof t22.id && "number" != typeof t22.id)
            return void this.fire(new e2.t(new Error("A feature id is required to remove its specific state property.")));
          const n22 = this.getOwnSourceCaches(o2);
          for (const e22 of n22)
            e22.removeFeatureState(a2, t22.id, i2);
        }
        getFeatureState(t22) {
          this._checkLoaded();
          const i2 = t22.source, o2 = t22.sourceLayer, r22 = this._checkSource(i2);
          if (r22) {
            if ("vector" !== r22.type || o2)
              return void 0 === t22.id && this.fire(new e2.t(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(i2)[0].getFeatureState(o2, t22.id);
            this.fire(new e2.t(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
        }
        setTransition(t22) {
          return this.stylesheet.transition = e2.l({}, this.stylesheet.transition, t22), this.transition = this.stylesheet.transition, this;
        }
        getTransition() {
          return e2.l({}, this.stylesheet.transition);
        }
        serialize() {
          this._checkLoaded();
          const t22 = this.getTerrain(), i2 = t22 && this.terrain && this.terrain.scope === this.scope ? t22 : this.stylesheet.terrain;
          return e2.cr({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, fragment: this.stylesheet.fragment, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: i2, fog: this.stylesheet.fog, center: this.stylesheet.center, "color-theme": this.stylesheet["color-theme"], zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, (e22) => void 0 !== e22);
        }
        _updateLayer(t22) {
          this._changes.updateLayer(t22);
          const i2 = this.getLayerSourceCache(t22), o2 = e2.av(t22.source, t22.scope), r22 = this._changes.getUpdatedSourceCaches();
          t22.source && !r22[o2] && i2 && "raster" !== i2.getSource().type && (this._changes.updateSourceCache(o2, "reload"), i2.pause()), t22.invalidateCompiledFilter();
        }
        _flattenAndSortRenderedFeatures(e22) {
          const t22 = (e3) => this._mergedLayers[e3].is3D(), i2 = this.order, o2 = {}, r22 = [];
          for (let s3 = i2.length - 1; s3 >= 0; s3--) {
            const a2 = i2[s3];
            if (t22(a2)) {
              o2[a2] = s3;
              for (const t3 of e22) {
                const e3 = t3[a2];
                if (e3)
                  for (const t4 of e3)
                    r22.push(t4);
              }
            }
          }
          r22.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
          const s2 = [];
          for (let a2 = i2.length - 1; a2 >= 0; a2--) {
            const n22 = i2[a2];
            if (t22(n22))
              for (let e3 = r22.length - 1; e3 >= 0; e3--) {
                const t3 = r22[e3].feature;
                if (t3.layer && o2[t3.layer.id] < a2)
                  break;
                s2.push(t3), r22.pop();
              }
            else
              for (const t3 of e22) {
                const e3 = t3[n22];
                if (e3)
                  for (const t4 of e3)
                    s2.push(t4.feature);
              }
          }
          return s2;
        }
        queryRenderedFeatures(t22, i2, o2) {
          i2 && i2.filter && this._validate(Te2, "queryRenderedFeatures.filter", i2.filter, null, i2), i2.scope = this.scope, i2.availableImages = this._availableImages, i2.serializedLayers = this._serializedLayers;
          const r22 = {};
          if (i2 && i2.layers) {
            if (!Array.isArray(i2.layers))
              return this.fire(new e2.t(new Error("parameters.layers must be an Array."))), [];
            for (const t3 of i2.layers) {
              const i3 = this._mergedLayers[t3];
              if (!i3)
                return this.fire(new e2.t(new Error("The layer '".concat(t3, "' does not exist in the map's style and cannot be queried for features.")))), [];
              r22[i3.source] = true;
            }
          }
          const s2 = [], a2 = i2.serializedLayers || {}, n22 = i2 && i2.layers ? i2.layers.some((e22) => {
            const t3 = this.getLayer(e22);
            return t3 && t3.is3D();
          }) : this.has3DLayers(), l22 = Ze2.createFromScreenPoints(t22, o2);
          for (const e22 in this._mergedSourceCaches) {
            const t3 = this._mergedSourceCaches[e22].getSource();
            if (!t3 || t3.scope !== i2.scope)
              continue;
            const c22 = this._mergedSourceCaches[e22].getSource().id;
            i2.layers && !r22[c22] || s2.push(ot(this._mergedSourceCaches[e22], this._mergedLayers, a2, l22, i2, o2, n22, !!this.map._showQueryGeometry));
          }
          return this.placement && s2.push(function(e22, t3, i3, o3, r3, s3, a3) {
            const n3 = {}, l3 = s3.queryRenderedSymbols(o3), c22 = [];
            for (const e3 of Object.keys(l3).map(Number))
              c22.push(a3[e3]);
            c22.sort(st);
            for (const i4 of c22) {
              const o4 = i4.featureIndex.lookupSymbolFeatures(l3[i4.bucketInstanceId], t3, i4.bucketIndex, i4.sourceLayerIndex, r3.filter, r3.layers, r3.availableImages, e22);
              for (const e3 in o4) {
                const t4 = n3[e3] = n3[e3] || [], r4 = o4[e3];
                r4.sort((e4, t5) => {
                  const o5 = i4.featureSortOrder;
                  if (o5) {
                    const i5 = o5.indexOf(e4.featureIndex);
                    return o5.indexOf(t5.featureIndex) - i5;
                  }
                  return t5.featureIndex - e4.featureIndex;
                });
                for (const e4 of r4)
                  t4.push(e4);
              }
            }
            for (const t4 in n3)
              n3[t4].forEach((o4) => {
                const r4 = o4.feature, s4 = i3(e22[t4]);
                if (!s4)
                  return;
                const a4 = s4.getFeatureState(r4.layer["source-layer"], r4.id);
                r4.source = r4.layer.source, r4.layer["source-layer"] && (r4.sourceLayer = r4.layer["source-layer"]), r4.state = a4;
              });
            return n3;
          }(this._mergedLayers, a2, this.getLayerSourceCache.bind(this), l22.screenGeometry, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(s2);
        }
        querySourceFeatures(e22, t22) {
          t22 && t22.filter && this._validate(Te2, "querySourceFeatures.filter", t22.filter, null, t22);
          const i2 = this.getOwnSourceCaches(e22);
          let o2 = [];
          for (const e3 of i2)
            o2 = o2.concat(rt(e3, t22));
          return o2;
        }
        addSourceType(e22, t22, i2) {
          return co.getSourceType(e22) ? i2(new Error('A source type called "'.concat(e22, '" already exists.'))) : (co.setSourceType(e22, t22), t22.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e22, url: t22.workerSourceURL }, i2) : i2(null, null));
        }
        getFlatLight() {
          return this.light.getLight();
        }
        setFlatLight(t22, i2, o2 = {}) {
          this._checkLoaded();
          const r22 = this.light.getLight();
          let s2 = false;
          for (const i3 in t22)
            if (!e2.bh(t22[i3], r22[i3])) {
              s2 = true;
              break;
            }
          if (!s2)
            return;
          const a2 = this._getTransitionParameters();
          this.light.setLight(t22, i2, o2), this.light.updateTransitions(a2);
        }
        getTerrain() {
          return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
        }
        setTerrainForDraping() {
          this.setTerrain({ source: "", exaggeration: 0 }, 0);
        }
        checkCanvasFingerprintNoise() {
          void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e2.q.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && e2.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."));
        }
        setTerrain(t22, i2 = 1) {
          if (this._checkLoaded(), !t22)
            return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), 0 === i2 && delete this.terrain, null === t22 ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
          this.checkCanvasFingerprintNoise();
          let o2 = t22;
          const r22 = null == t22.source;
          if (1 === i2) {
            if (this.disableElevatedTerrain)
              return;
            if ("object" == typeof o2.source) {
              const t4 = "terrain-dem-src";
              this.addSource(t4, o2.source), o2 = e2.cl(o2), o2 = e2.l(o2, { source: t4 });
            }
            const t3 = e2.l({}, o2), i3 = {};
            if (this.terrain && r22) {
              t3.source = this.terrain.get().source;
              const e22 = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
              e22 && (i3.style = e22.serialize());
            }
            if (this._validate(ye, "terrain", t3, i3))
              return;
          }
          if (!this.terrain || this.terrain.scope !== this.scope && !r22 || this.terrain && i2 !== this.terrain.drapeRenderMode) {
            if (!o2)
              return;
            this._createTerrain(o2, i2), this.fire(new e2.x("data", { dataType: "style" }));
          } else {
            const i3 = this.terrain, r3 = i3.get();
            for (const t3 of Object.keys(e2._.terrain))
              !o2.hasOwnProperty(t3) && e2._.terrain[t3].default && (o2[t3] = e2._.terrain[t3].default);
            for (const o3 in t22)
              if (!e2.bh(t22[o3], r3[o3])) {
                i3.set(t22, this.options), this.stylesheet.terrain = t22;
                const o4 = this._getTransitionParameters({ duration: 0 });
                i3.updateTransitions(o4), this.fire(new e2.x("data", { dataType: "style" }));
                break;
              }
          }
          this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = true;
        }
        _createFog(e22) {
          const t22 = this.fog = new Ge2(e22, this.map.transform, this.scope, this.options);
          this.stylesheet.fog = t22.get();
          const i2 = this._getTransitionParameters({ duration: 0 });
          t22.updateTransitions(i2);
        }
        _updateMarkersOpacity() {
          0 !== this.map._markers.length && this.map._requestDomTask(() => {
            for (const e22 of this.map._markers)
              e22._evaluateOpacity();
          });
        }
        getFog() {
          return this.fog ? this.fog.get() : null;
        }
        setFog(t22) {
          if (this._checkLoaded(), !t22)
            return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
          if (this.fog) {
            const i2 = this.fog;
            if (!e2.bh(i2.get(), t22)) {
              i2.set(t22, this.options), this.stylesheet.fog = i2.get();
              const e22 = this._getTransitionParameters({ duration: 0 });
              i2.updateTransitions(e22);
            }
          } else
            this._createFog(t22);
          this._markersNeedUpdate = true;
        }
        setColorTheme(t22) {
          this._checkLoaded();
          const i2 = () => {
            for (const e22 in this._layers)
              this._layers[e22].lut = this._styleColorTheme.lut;
            for (const e22 in this._sourceCaches)
              this._sourceCaches[e22].clearTiles();
          };
          if (this._styleColorTheme.colorTheme = t22, !t22)
            return this._styleColorTheme.lut = null, void i2();
          const o2 = this._evaluateColorThemeData(t22);
          this._loadColorTheme(o2).then(() => {
            this.fire(new e2.x("colorthemeset")), i2();
          }).catch((t3) => {
            e2.w("Couldn't set color theme: ".concat(t3));
          });
        }
        _getTransitionParameters(t22) {
          return { now: e2.q.now(), transition: e2.l(this.transition, t22) };
        }
        updateDrapeFirstLayers() {
          if (!this.terrain)
            return;
          const e22 = [], t22 = [];
          for (const i2 of this._mergedOrder)
            this.isLayerDraped(this._mergedLayers[i2]) ? e22.push(i2) : t22.push(i2);
          this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e22), this._drapedFirstOrder.push(...t22);
        }
        _createTerrain(e22, t22) {
          const i2 = this.terrain = new Pe2(e22, t22, this.scope, this.options);
          1 === t22 && (this.stylesheet.terrain = e22), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
          const o2 = this._getTransitionParameters({ duration: 0 });
          i2.updateTransitions(o2);
        }
        _force3DLayerUpdate() {
          for (const e22 in this._layers) {
            const t22 = this._layers[e22];
            "fill-extrusion" === t22.type && this._updateLayer(t22);
          }
        }
        _forceSymbolLayerUpdate() {
          for (const e22 in this._layers) {
            const t22 = this._layers[e22];
            "symbol" === t22.type && this._updateLayer(t22);
          }
        }
        _validate(t22, i2, o2, r22, s2 = {}) {
          if (s2 && false === s2.validate)
            return false;
          const a2 = e2.l({}, this.serialize());
          return ro(this, t22.call(fe2, e2.l({ key: i2, style: a2, value: o2, styleSpec: e2._ }, r22)));
        }
        _remove() {
          this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e2.cs.off("pluginStateChange", this._rtlTextPluginCallback);
          for (const e22 in this._mergedLayers)
            this._mergedLayers[e22].setEventedParent(null);
          for (const e22 in this._mergedSourceCaches)
            this._mergedSourceCaches[e22].clearTiles(), this._mergedSourceCaches[e22].setEventedParent(null);
          this.setEventedParent(null), delete this.fog, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());
        }
        clearSource(e22) {
          const t22 = this.getSourceCaches(e22);
          for (const e3 of t22)
            e3.clearTiles();
        }
        clearSources() {
          for (const e22 in this._mergedSourceCaches)
            this._mergedSourceCaches[e22].clearTiles();
        }
        reloadSource(e22) {
          const t22 = this.getSourceCaches(e22);
          for (const e3 of t22)
            e3.resume(), e3.reload();
        }
        reloadSources() {
          for (const e22 of this.getSources())
            e22.reload && e22.reload();
        }
        updateSources(e22) {
          let t22;
          this.directionalLight && (t22 = Qi2(this.directionalLight));
          for (const i2 in this._mergedSourceCaches)
            this._mergedSourceCaches[i2].update(e22, void 0, void 0, t22);
        }
        _generateCollisionBoxes() {
          for (const e22 in this._sourceCaches) {
            const t22 = this._sourceCaches[e22];
            t22.resume(), t22.reload();
          }
        }
        _updatePlacement(t22, i2, o2, r22, s2, a2, n22 = false) {
          let l22 = false, c22 = false;
          const h22 = {}, u22 = {};
          for (const t3 of this._mergedOrder) {
            const o3 = this._mergedLayers[t3];
            if ("symbol" !== o3.type)
              continue;
            const r3 = e2.av(o3.source, o3.scope);
            let s3 = h22[r3];
            if (!s3) {
              const e22 = this.getLayerSourceCache(o3);
              if (!e22)
                continue;
              const t4 = e22.getRenderableIds(true).map((t5) => e22.getTileByID(t5));
              u22[r3] = t4.slice(), s3 = h22[r3] = t4.sort((e3, t5) => t5.tileID.overscaledZ - e3.tileID.overscaledZ || (e3.tileID.isLessThan(t5.tileID) ? -1 : 1));
            }
            const a3 = this.crossTileSymbolIndex.addLayer(o3, s3, i2.center.lng, i2.projection);
            l22 = l22 || a3;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), n22 = n22 || this._layerOrderChanged || 0 === r22, this._layerOrderChanged && this.fire(new e2.x("neworder")), (n22 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e2.q.now(), i2.zoom)) && (this.pauseablePlacement = new Ti2(i2, this._mergedOrder, n22, o2, r22, s2, this.placement, this.fog && i2.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, h22, u22), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e2.q.now()), c22 = true), l22 && this.pauseablePlacement.placement.setStale()), c22 || l22) {
            this._buildingIndex.onNewFrame(i2.zoom);
            for (let t3 = 0; t3 < this._mergedOrder.length; t3++) {
              const i3 = this._mergedLayers[this._mergedOrder[t3]];
              if ("symbol" !== i3.type)
                continue;
              const o3 = this.isLayerClipped(i3);
              this.placement.updateLayerOpacities(i3, h22[e2.av(i3.source, i3.scope)], t3, o3 ? a2 : null);
            }
          }
          return { needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e2.q.now()) };
        }
        _releaseSymbolFadeTiles() {
          for (const e22 in this._sourceCaches)
            this._sourceCaches[e22].releaseSymbolFadeTiles();
        }
        addImport(t22, i2) {
          this._checkLoaded();
          const o2 = this.stylesheet.imports = this.stylesheet.imports || [];
          if (-1 !== o2.findIndex(({ id: e22 }) => e22 === t22.id))
            return void this.fire(new e2.t(new Error("Import with id '".concat(t22.id, "' already exists in the map's style."))));
          if (!i2)
            return o2.push(t22), this._loadImports([t22], true);
          const r22 = o2.findIndex(({ id: e22 }) => e22 === i2);
          return -1 === r22 && this.fire(new e2.t(new Error('Import with id "'.concat(i2, '" does not exist on this map.')))), this.stylesheet.imports = o2.slice(0, r22).concat(t22).concat(o2.slice(r22)), this._loadImports([t22], true, i2);
        }
        updateImport(t22, i2) {
          this._checkLoaded();
          const o2 = this.stylesheet.imports || [], r22 = this.getImportIndex(t22);
          return -1 === r22 ? this : "string" == typeof i2 ? (this.setImportUrl(t22, i2), this) : (i2.url && i2.url !== o2[r22].url && this.setImportUrl(t22, i2.url), e2.bh(i2.config, o2[r22].config) || this.setImportConfig(t22, i2.config), e2.bh(i2.data, o2[r22].data) || this.setImportData(t22, i2.data), this);
        }
        moveImport(e22, t22) {
          this._checkLoaded();
          let i2 = this.stylesheet.imports || [];
          const o2 = this.getImportIndex(e22);
          if (-1 === o2)
            return this;
          const r22 = this.getImportIndex(t22);
          if (-1 === r22)
            return this;
          const s2 = i2[o2], a2 = this.fragments[o2];
          return i2 = i2.filter(({ id: t3 }) => t3 !== e22), this.fragments = this.fragments.filter(({ id: t3 }) => t3 !== e22), this.stylesheet.imports = i2.slice(0, r22).concat(s2).concat(i2.slice(r22)), this.fragments = this.fragments.slice(0, r22).concat(a2).concat(this.fragments.slice(r22)), this.mergeLayers(), this;
        }
        setImportUrl(e22, t22) {
          this._checkLoaded();
          const i2 = this.stylesheet.imports || [], o2 = this.getImportIndex(e22);
          if (-1 === o2)
            return this;
          i2[o2].url = t22;
          const r22 = this.fragments[o2];
          return r22.style = this._createFragmentStyle(i2[o2]), r22.style.on("style.import.load", () => this.mergeAll()), r22.style.loadURL(t22), this;
        }
        setImportData(e22, t22) {
          this._checkLoaded();
          const i2 = this.getImportIndex(e22), o2 = this.stylesheet.imports || [];
          return -1 === i2 ? this : t22 ? (this.fragments[i2].style.setState(t22), this._reloadImports(), this) : (delete o2[i2].data, this.setImportUrl(e22, o2[i2].url));
        }
        setImportConfig(e22, t22) {
          this._checkLoaded();
          const i2 = this.getImportIndex(e22), o2 = this.stylesheet.imports || [];
          if (-1 === i2)
            return this;
          t22 ? o2[i2].config = t22 : delete o2[i2].config;
          const r22 = this.fragments[i2], s2 = r22.style.stylesheet && r22.style.stylesheet.schema;
          return r22.config = t22, r22.style.updateConfig(t22, s2), this.updateConfigDependencies(), this;
        }
        removeImport(e22) {
          this._checkLoaded();
          const t22 = this.stylesheet.imports || [], i2 = this.getImportIndex(e22);
          -1 !== i2 && (t22.splice(i2, 1), this.fragments[i2].style._remove(), this.fragments.splice(i2, 1), this._reloadImports());
        }
        getImportIndex(t22) {
          const i2 = (this.stylesheet.imports || []).findIndex((e22) => e22.id === t22);
          return -1 === i2 && this.fire(new e2.t(new Error("Import '".concat(t22, "' does not exist in the map's style and cannot be updated.")))), i2;
        }
        getLayer(e22) {
          return this._mergedLayers[e22];
        }
        getSources() {
          const e22 = [];
          for (const t22 in this._mergedOtherSourceCaches) {
            const i2 = this._mergedOtherSourceCaches[t22];
            i2 && e22.push(i2.getSource());
          }
          return e22;
        }
        getSource(e22, t22) {
          const i2 = this.getSourceCache(e22, t22);
          return i2 && i2.getSource();
        }
        getLayerSource(e22) {
          const t22 = this.getLayerSourceCache(e22);
          return t22 && t22.getSource();
        }
        getSourceCache(t22, i2) {
          const o2 = e2.av(t22, i2);
          return this._mergedOtherSourceCaches[o2];
        }
        getLayerSourceCache(t22) {
          const i2 = e2.av(t22.source, t22.scope);
          return "symbol" === t22.type ? this._mergedSymbolSourceCaches[i2] : this._mergedOtherSourceCaches[i2];
        }
        getSourceCaches(e22) {
          if (null == e22)
            return Object.values(this._mergedSourceCaches);
          const t22 = [];
          return this._mergedOtherSourceCaches[e22] && t22.push(this._mergedOtherSourceCaches[e22]), this._mergedSymbolSourceCaches[e22] && t22.push(this._mergedSymbolSourceCaches[e22]), t22;
        }
        updateSourceCaches() {
          const e22 = this._changes.getUpdatedSourceCaches();
          for (const t22 in e22) {
            const i2 = e22[t22];
            "reload" === i2 ? this.reloadSource(t22) : "clear" === i2 && this.clearSource(t22);
          }
        }
        updateLayers(e22) {
          const t22 = this._changes.getUpdatedPaintProperties();
          for (const i2 of t22) {
            const t3 = this.getLayer(i2);
            t3 && t3.updateTransitions(e22);
          }
        }
        getImages(e22, t22, i2) {
          this.imageManager.getImages(t22.icons, t22.scope, i2), this._updateTilesForChangedImages();
          const o2 = (e3) => {
            e3 && e3.setDependencies(t22.tileID.key, t22.type, t22.icons);
          };
          o2(this._otherSourceCaches[t22.source]), o2(this._symbolSourceCaches[t22.source]);
        }
        getGlyphs(e22, t22, i2) {
          this.glyphManager.getGlyphs(t22.stacks, t22.scope, i2);
        }
        getResource(t22, i2, o2) {
          return e2.ct(i2, o2);
        }
        getOwnSourceCache(e22) {
          return this._otherSourceCaches[e22];
        }
        getOwnLayerSourceCache(e22) {
          return "symbol" === e22.type ? this._symbolSourceCaches[e22.source] : this._otherSourceCaches[e22.source];
        }
        getOwnSourceCaches(e22) {
          const t22 = [];
          return this._otherSourceCaches[e22] && t22.push(this._otherSourceCaches[e22]), this._symbolSourceCaches[e22] && t22.push(this._symbolSourceCaches[e22]), t22;
        }
        _isSourceCacheLoaded(t22) {
          const i2 = this.getOwnSourceCaches(t22);
          return 0 === i2.length ? (this.fire(new e2.t(new Error("There is no source with ID '".concat(t22, "'")))), false) : i2.every((e22) => e22.loaded());
        }
        has3DLayers() {
          return this._has3DLayers;
        }
        hasSymbolLayers() {
          return this._hasSymbolLayers;
        }
        hasCircleLayers() {
          return this._hasCircleLayers;
        }
        isLayerClipped(e22, t22) {
          if (!this._clipLayerPresent && "fill-extrusion" !== e22.type)
            return false;
          const i2 = "fill-extrusion" === e22.type && "building" === e22.sourceLayer;
          if (e22.is3D()) {
            if (i2 || t22 && "batched-model" === t22.type)
              return true;
            if ("model" === e22.type)
              return true;
          } else if ("symbol" === e22.type)
            return true;
          return false;
        }
        _clearWorkerCaches() {
          this.dispatcher.broadcast("clearCaches");
        }
        destroy() {
          this._clearWorkerCaches(), this.fragments.forEach((e22) => {
            e22.style._remove();
          }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
        }
      }
      co.getSourceType = function(e22) {
        return et[e22];
      }, co.setSourceType = function(e22, t22) {
        et[e22] = t22;
      }, co.registerForPluginStateChange = e2.cc;
      var ho = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif", uo = "\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec2 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color) {\n#ifdef INDICATOR_CUTOUT\nfloat holeMinOpacity=u_indicator_cutout_params.x;float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}", _o = "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}", po = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", mo = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nvec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }\n#endif\n#ifdef DEPTH_OCCLUSION\nuniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;\n#ifdef DEPTH_D24\nfloat unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}\n#else\nhighp float unpack_depth_rgba(vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;\n#ifdef DEPTH_D24\nfloat depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);\n#else\nfloat depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));\n#endif\nreturn coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;\n#ifdef DEPTH_D24\nhighp vec4 depth=vec4(\ntexture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r\n);depth=unpack_depth4(depth);\n#else\nhighp vec4 depth=vec4(\nunpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))\n);\n#endif\nreturn depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));\n#endif\nres+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}\n#else\nbool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }\n#endif//DEPTH_OCCLUSION", fo = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", go = "highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {\n#ifdef FOG_DITHERING\nvec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);\n#else\nreturn color;\n#endif\n}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", vo = "#ifdef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif", xo = "#ifdef RASTER_ARRAY\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}\n#endif\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}", yo = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif//RENDER_SHADOWS", bo = "#ifdef RENDER_SHADOWS\n#ifdef DEPTH_TEXTURE\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\n#else\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\n#endif\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_1,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_0,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\n#ifdef NATIVE\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\n#else\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\n);\n#endif\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\n#ifdef SHADOWS_SINGLE_CASCADE\nlight_view_pos0.xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\n#else\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
      const wo = [];
      Do(ho, wo), Do(_o, wo), Do(uo, wo);
      const To = { "_prelude_fog.vertex.glsl": fo, "_prelude_terrain.vertex.glsl": mo, "_prelude_shadow.vertex.glsl": yo, "_prelude_fog.fragment.glsl": go, "_prelude_shadow.fragment.glsl": bo, "_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif//LIGHTING_3D_MODE", "_prelude_raster_array.glsl": vo, "_prelude_raster_particle.glsl": xo }, Eo = {};
      Ro("", mo), Ro(go, fo), Ro(bo, yo), Ro(vo, ""), Ro(xo, "");
      const Co = Ro(uo, _o), So = ho;
      var Io = { background: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), backgroundPattern: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), circle: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float opacity_t=smoothstep((1.0-blur_positive)*antialiased_blur,blur_positive*antialiased_blur,extrude_length-1.0)-smoothstep(0.0,antialiasblur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'), clippingMask: Ro("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Ro('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), heatmapTexture: Ro("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: Ro("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", '#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'), collisionCircle: Ro("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Ro("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", '#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'), fill: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\nuniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutline: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\nuniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutlinePattern: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;in highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\nout highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillPattern: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;in highp vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\nout highp vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillExtrusion: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nin float v_height;\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float emissive_strength\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor;\n#ifdef RENDER_CUTOFF\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\n#else\nshadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\n#endif\ncolor.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp float emissive_strength\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=cutoff_opacity(u_cutoff_params,ground.z);if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\ngl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);v_flat=vec4(linearProduct(color.rgb,vec3(calculate_NdotL(normal))),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), fillExtrusionDepth: Ro("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp vec4 color\nout highp float v_depth;void main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp vec4 color\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base);pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'), fillExtrusionPattern: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\nin highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nout highp vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\n#pragma mapbox: define highp float line_width\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\n#pragma mapbox: initialize highp float line_width\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'), groundShadow: Ro('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0)).r);\n#endif\nglFragColor=vec4(shadow,1.0);}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'), fillExtrusionGroundEffect: Ro("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;\n#endif\nHANDLE_WIREFRAME_DEBUG;\n#endif\n}", '#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'), hillshadePrepare: Ro("precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), line: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trim_alpha=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=out_color.a;}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color.rgb=mix(border_color.rgb*border_color.a*trim_alpha,out_color.rgb,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\nin float a_z_offset;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);\n#ifdef ELEVATED_ROADS\ngl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset+0.01*step(0.01,a_z_offset),1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 halfCellProgress=normal.yx*32.0;float ele0=elevation(pos);float ele_line=max(ele0,max(elevation(pos+halfCellProgress),elevation(pos-halfCellProgress)));float ele1=elevation(pos+offsetTile);float ele2=elevation(pos-offsetTile);float ele_max=max(ele_line,0.5*(ele1+ele2));float ele=ele_max-ele0+ele1+a_z_offset ;gl_Position=u_matrix*vec4(pos+offsetTile,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*0.1*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), linePattern: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform highp float u_device_pixel_ratio;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 v_uv;\n#endif\n#ifdef LINE_JOIN_NONE\nin vec2 v_pattern_data;\n#endif\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define mediump float pixel_ratio\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize mediump float pixel_ratio\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {color=vec4(0,0,0,0);}}\n#endif\n#ifdef LINE_JOIN_NONE\nfloat pattern_len=pattern_size/aspect;float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\n#endif\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_ground(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\nin float a_z_offset;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 a_packed;\n#endif\nin highp float a_linesofar;\n#ifdef LINE_JOIN_NONE\nin highp vec3 a_pattern_data;out vec2 v_pattern_data;\n#endif\nuniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nout highp vec4 v_uv;\n#endif\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\n#pragma mapbox: define mediump float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define mediump float floorwidth\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define mediump float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\n#pragma mapbox: initialize mediump float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize mediump float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);\n#ifdef ELEVATED_ROADS\ngl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset+0.01*step(0.01,a_z_offset),1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 halfCellProgress=normal.yx*32.0;float ele0=elevation(pos);float ele_line=max(ele0,max(elevation(pos+halfCellProgress),elevation(pos-halfCellProgress)));float ele1=elevation(pos+offsetTile);float ele2=elevation(pos-offsetTile);float ele_max=max(ele_line,0.5*(ele1+ele2));float ele=ele_max-ele0+ele1+a_z_offset ;gl_Position=u_matrix*vec4(pos+offsetTile,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*0.1*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nfloat a_uv_x=a_packed[0];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef LINE_JOIN_NONE\nv_width=floorwidth+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), raster: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nin float v_split_fade;\n#endif\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;\n#ifdef GLOBE_POLES\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\n#endif\nvec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef PROJECTION_GLOBE_VIEW\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\n#endif\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nout float v_split_fade;\n#endif\nvoid main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'), rasterParticle: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'), rasterParticleDraw: Ro("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", '#include "_prelude_raster_particle.glsl"\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}'), rasterParticleTexture: Ro("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"), rasterParticleUpdate: Ro('#include "_prelude_raster_particle.glsl"\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(\nlinearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)\n);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}', "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"), symbol: Ro('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\n#ifdef COLOR_ADJUSTMENT\nuniform mat4 u_color_adj_mat;\n#endif\nin vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\nin float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nin float is_sdf;in vec2 v_tex_a_icon;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];\n#ifdef RENDER_TEXT_AND_SYMBOL\nif (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}\n#endif\n#ifdef RENDER_SDF\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;\n#else\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\n#else\nout_color=texture(u_texture,v_tex_a);\n#endif\n#ifdef COLOR_ADJUSTMENT\nout_color=u_color_adj_mat*out_color;\n#endif\n#endif\nout_color*=opacity*fade_opacity;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_auto_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\n#ifdef OCCLUSION_QUERIES\nin float a_occlusion_query_opacity;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nout float is_sdf;out vec2 v_tex_a_icon;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\n#pragma mapbox: define lowp float occlusion_opacity\n#pragma mapbox: define lowp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\n#pragma mapbox: initialize lowp float occlusion_opacity\n#pragma mapbox: initialize lowp float z_offset\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_auto_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;\n#endif\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\n#ifdef Z_OFFSET\nz+=u_pitch_with_map ? a_auto_z_offset+(u_elevation_from_sea ? z_offset : z_offset) : 0.0;\n#else\nz+=u_pitch_with_map ? (u_elevation_from_sea ? z_offset : z_offset) : 0.0;\n#endif\nfloat occlusion_fade=globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;\n#ifdef DEPTH_OCCLUSION\nfloat depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;\n#endif\n#ifdef OCCLUSION_QUERIES\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;\n#endif\nfloat alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;\n#ifdef RENDER_TEXT_AND_SYMBOL\nis_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;\n#endif\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\n}'), terrainRaster: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\n#endif\n}'), terrainDepth: Ro("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'), skybox: Ro('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', po), skyboxGradient: Ro('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', po), skyboxCapture: Ro("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'), globeAtmosphere: Ro('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;\n#ifndef NATIVE\nc=dither(c,gl_FragCoord.xy+u_temporal_offset);\n#endif\nglFragColor=vec4(c*t,t);\n#endif\n}', "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"), model: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;\n#ifdef DEPTH_D24\nhighp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}\n#else\nhighp float unpack_depth_rgba(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depthTexture,coord).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));\n#endif\nreturn v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nvec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);\n#ifdef APPLY_LUT_ON_GPU\ncolor=applyLUT(u_lutTexture,color);\n#endif\nreturn color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\n#ifdef APPLY_LUT_ON_GPU\nfloat emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;\n#ifdef APPLY_LUT_ON_GPU\ncolor_mix=applyLUT(u_lutTexture,color_mix);\n#endif\ncolor=mix(color,color_mix,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\n#endif\n}'), modelDepth: Ro("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"), stars: Ro("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}"), occlusion: Ro("uniform vec4 u_color;void main() {glFragColor=u_color;}", '#include "_prelude_terrain.vertex.glsl"\nin highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;\n#ifdef TERRAIN\nfloat e=elevation(world_pos.xy);world_pos.z+=e;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}') };
      function Do(e22, t22) {
        const i2 = e22.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
        for (let e3 of i2)
          if (e3 = e3.trim(), "#" === e3[0] && e3.includes("if") && !e3.includes("endif")) {
            e3 = e3.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
            const i3 = e3.split(" ");
            for (const e4 of i3)
              t22.includes(e4) || t22.push(e4);
          }
      }
      function Ro(e22, t22) {
        const i2 = /#include\s+"([^"]+)"/g, o2 = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
        let r22 = t22.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
        r22 && (r22 = r22.map((e3) => {
          const t3 = e3.split(" ");
          return t3[t3.length - 1];
        }), r22 = [...new Set(r22)]);
        const s2 = {}, a2 = [], n22 = [];
        if (e22 = e22.replace(i2, (e3, t3) => (n22.push(t3), "")), (t22 = t22.replace(i2, (e3, t3) => (a2.push(t3), ""))).includes("flat out"))
          return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
        let l22 = [...wo];
        Do(e22, l22), Do(t22, l22);
        for (const e3 of [...a2, ...n22])
          To[e3] || console.error("Undefined include: ".concat(e3)), Eo[e3] || (Eo[e3] = [], Do(To[e3], Eo[e3])), l22 = [...l22, ...Eo[e3]];
        return { fragmentSource: e22 = e22.replace(o2, (e3, t3, i3, o3, r3) => (s2[r3] = true, "define" === t3 ? "\n#ifndef HAS_UNIFORM_u_".concat(r3, "\nin ").concat(i3, " ").concat(o3, " ").concat(r3, ";\n#else\nuniform ").concat(i3, " ").concat(o3, " u_").concat(r3, ";\n#endif\n") : "initialize" === t3 ? "\n#ifdef HAS_UNIFORM_u_".concat(r3, "\n    ").concat(i3, " ").concat(o3, " ").concat(r3, " = u_").concat(r3, ";\n#endif\n") : "define-attribute" === t3 ? "\n#ifdef HAS_ATTRIBUTE_a_".concat(r3, "\n    in ").concat(i3, " ").concat(o3, " ").concat(r3, ";\n#endif\n") : "initialize-attribute" === t3 ? "" : void 0)), vertexSource: t22 = t22.replace(o2, (e3, t3, i3, o3, r3) => {
          const a3 = "float" === o3 ? "vec2" : o3, n3 = r3.match(/color/) ? "color" : a3;
          return "define-attribute-vertex-shader-only" === t3 ? "\n#ifdef HAS_ATTRIBUTE_a_".concat(r3, "\nin ").concat(i3, " ").concat(o3, " a_").concat(r3, ";\n#endif\n") : s2[r3] ? "define" === t3 ? "\n#ifndef HAS_UNIFORM_u_".concat(r3, "\nuniform lowp float u_").concat(r3, "_t;\nin ").concat(i3, " ").concat(a3, " a_").concat(r3, ";\nout ").concat(i3, " ").concat(o3, " ").concat(r3, ";\n#else\nuniform ").concat(i3, " ").concat(o3, " u_").concat(r3, ";\n#endif\n") : "initialize" === t3 ? "vec4" === n3 ? "\n#ifndef HAS_UNIFORM_u_".concat(r3, "\n    ").concat(r3, " = a_").concat(r3, ";\n#else\n    ").concat(i3, " ").concat(o3, " ").concat(r3, " = u_").concat(r3, ";\n#endif\n") : "\n#ifndef HAS_UNIFORM_u_".concat(r3, "\n    ").concat(r3, " = unpack_mix_").concat(n3, "(a_").concat(r3, ", u_").concat(r3, "_t);\n#else\n    ").concat(i3, " ").concat(o3, " ").concat(r3, " = u_").concat(r3, ";\n#endif\n") : "define-attribute" === t3 ? "\n#ifdef HAS_ATTRIBUTE_a_".concat(r3, "\n    in ").concat(i3, " ").concat(o3, " a_").concat(r3, ";\n    out ").concat(i3, " ").concat(o3, " ").concat(r3, ";\n#endif\n") : "initialize-attribute" === t3 ? "\n#ifdef HAS_ATTRIBUTE_a_".concat(r3, "\n    ").concat(r3, " = a_").concat(r3, ";\n#endif\n") : void 0 : "define" === t3 ? "\n#ifndef HAS_UNIFORM_u_".concat(r3, "\nuniform lowp float u_").concat(r3, "_t;\nin ").concat(i3, " ").concat(a3, " a_").concat(r3, ";\n#else\nuniform ").concat(i3, " ").concat(o3, " u_").concat(r3, ";\n#endif\n") : "define-instanced" === t3 ? "mat4" === n3 ? "\n#ifdef INSTANCED_ARRAYS\nin vec4 a_".concat(r3, "0;\nin vec4 a_").concat(r3, "1;\nin vec4 a_").concat(r3, "2;\nin vec4 a_").concat(r3, "3;\n#else\nuniform ").concat(i3, " ").concat(o3, " u_").concat(r3, ";\n#endif\n") : "\n#ifdef INSTANCED_ARRAYS\nin ".concat(i3, " ").concat(a3, " a_").concat(r3, ";\n#else\nuniform ").concat(i3, " ").concat(o3, " u_").concat(r3, ";\n#endif\n") : "initialize-attribute-custom" === t3 ? "\n#ifdef HAS_ATTRIBUTE_a_".concat(r3, "\n    ").concat(i3, " ").concat(o3, " ").concat(r3, " = a_").concat(r3, ";\n#endif\n") : "vec4" === n3 ? "\n#ifndef HAS_UNIFORM_u_".concat(r3, "\n    ").concat(i3, " ").concat(o3, " ").concat(r3, " = a_").concat(r3, ";\n#else\n    ").concat(i3, " ").concat(o3, " ").concat(r3, " = u_").concat(r3, ";\n#endif\n") : "\n#ifndef HAS_UNIFORM_u_".concat(r3, "\n    ").concat(i3, " ").concat(o3, " ").concat(r3, " = unpack_mix_").concat(n3, "(a_").concat(r3, ", u_").concat(r3, "_t);\n#else\n    ").concat(i3, " ").concat(o3, " ").concat(r3, " = u_").concat(r3, ";\n#endif\n");
        }), staticAttributes: r22, usedDefines: l22, vertexIncludes: a2, fragmentIncludes: n22 };
      }
      class Ao {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
        }
        bind(e22, t22, i2, o2, r22, s2, a2, n22) {
          this.context = e22;
          let l22 = this.boundPaintVertexBuffers.length !== o2.length;
          for (let e3 = 0; !l22 && e3 < o2.length; e3++)
            this.boundPaintVertexBuffers[e3] !== o2[e3] && (l22 = true);
          let c22 = this.boundDynamicVertexBuffers.length !== a2.length;
          for (let e3 = 0; !c22 && e3 < a2.length; e3++)
            this.boundDynamicVertexBuffers[e3] !== a2[e3] && (c22 = true);
          if (!this.vao || this.boundProgram !== t22 || this.boundLayoutVertexBuffer !== i2 || l22 || c22 || this.boundIndexBuffer !== r22 || this.boundVertexOffset !== s2)
            this.freshBind(t22, i2, o2, r22, s2, a2, n22);
          else {
            e22.bindVertexArrayOES.set(this.vao);
            for (const i3 of a2)
              i3 && (i3.bind(), n22 && i3.instanceCount && i3.setVertexAttribDivisor(e22.gl, t22, n22));
            r22 && r22.dynamicDraw && r22.bind();
          }
        }
        freshBind(e22, t22, i2, o2, r22, s2, a2) {
          const n22 = e22.numAttributes, l22 = this.context, c22 = l22.gl;
          this.vao && this.destroy(), this.vao = l22.gl.createVertexArray(), l22.bindVertexArrayOES.set(this.vao), this.boundProgram = e22, this.boundLayoutVertexBuffer = t22, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = r22, this.boundDynamicVertexBuffers = s2, t22.enableAttributes(c22, e22), t22.bind(), t22.setVertexAttribPointers(c22, e22, r22);
          for (const t3 of i2)
            t3.enableAttributes(c22, e22), t3.bind(), t3.setVertexAttribPointers(c22, e22, r22);
          for (const t3 of s2)
            t3 && (t3.enableAttributes(c22, e22), t3.bind(), t3.setVertexAttribPointers(c22, e22, r22), a2 && t3.instanceCount && t3.setVertexAttribDivisor(c22, e22, a2));
          o2 && o2.bind(), l22.currentNumAttributes = n22;
        }
        destroy() {
          this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      function Lo(t22, i2) {
        const o2 = Math.pow(2, i2.canonical.z), r22 = i2.canonical.y;
        return [new e2.a5(0, r22 / o2).toLngLat().lat, new e2.a5(0, (r22 + 1) / o2).toLngLat().lat];
      }
      function Po(t22, i2, o2, r22, s2, a2, n22) {
        const l22 = t22.context, c22 = l22.gl, h22 = o2.hillshadeFBO;
        if (!h22)
          return;
        t22.prepareDrawTile();
        const u22 = t22.isTileAffectedByFog(i2), d22 = t22.getOrCreateProgram("hillshade", { overrideFog: u22 });
        l22.activeTexture.set(c22.TEXTURE0), c22.bindTexture(c22.TEXTURE_2D, h22.colorAttachment.get());
        const _2 = ((t3, i3, o3, r3) => {
          const s3 = o3.paint.get("hillshade-shadow-color"), a3 = o3.paint.get("hillshade-highlight-color"), n3 = o3.paint.get("hillshade-accent-color"), l3 = o3.paint.get("hillshade-emissive-strength");
          let c3 = e2.bB(o3.paint.get("hillshade-illumination-direction"));
          if ("viewport" === o3.paint.get("hillshade-illumination-anchor"))
            c3 -= t3.transform.angle;
          else if (t3.style && t3.style.enable3dLights() && t3.style.directionalLight) {
            const i4 = t3.style.directionalLight.properties.get("direction"), o4 = e2.c7(i4.x, i4.y, i4.z);
            c3 = e2.bB(o4[1]);
          }
          const h3 = !t3.options.moving;
          return { u_matrix: r3 || t3.transform.calculateProjMatrix(i3.tileID.toUnwrapped(), h3), u_image: 0, u_latrange: Lo(0, i3.tileID), u_light: [o3.paint.get("hillshade-exaggeration"), c3], u_shadow: s3.toRenderColor(o3.lut), u_highlight: a3.toRenderColor(o3.lut), u_emissive_strength: l3, u_accent: n3.toRenderColor(o3.lut) };
        })(t22, o2, r22, t22.terrain ? i2.projMatrix : null);
        t22.uploadCommonUniforms(l22, d22, i2.toUnwrapped());
        const { tileBoundsBuffer: p22, tileBoundsIndexBuffer: m22, tileBoundsSegments: f22 } = t22.getTileBoundsBuffers(o2);
        d22.draw(t22, c22.TRIANGLES, s2, a2, n22, Fi2.disabled, _2, r22.id, p22, m22, f22);
      }
      function Mo(t22, i2, o2) {
        if (!i2.needsDEMTextureUpload)
          return;
        const r22 = t22.context, s2 = r22.gl;
        r22.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t22.getTileTexture(o2.stride);
        const a2 = o2.getPixels();
        i2.demTexture ? i2.demTexture.update(a2, { premultiply: false }) : i2.demTexture = new e2.T(r22, a2, s2.R32F, { premultiply: false }), i2.needsDEMTextureUpload = false;
      }
      function zo(t22, i2, o2) {
        const r22 = t22.context, s2 = r22.gl;
        if (!i2.dem)
          return;
        const a2 = i2.dem;
        if (r22.activeTexture.set(s2.TEXTURE1), Mo(t22, i2, a2), !i2.demTexture)
          return;
        i2.demTexture.bind(s2.NEAREST, s2.CLAMP_TO_EDGE);
        const n22 = a2.dim;
        r22.activeTexture.set(s2.TEXTURE0);
        let l22 = i2.hillshadeFBO;
        if (!l22) {
          const t3 = new e2.T(r22, { width: n22, height: n22, data: null }, s2.RGBA8);
          t3.bind(s2.LINEAR, s2.CLAMP_TO_EDGE), l22 = i2.hillshadeFBO = r22.createFramebuffer(n22, n22, true, "renderbuffer"), l22.colorAttachment.set(t3.texture);
        }
        r22.bindFramebuffer.set(l22.framebuffer), r22.viewport.set([0, 0, n22, n22]);
        const { tileBoundsBuffer: c22, tileBoundsIndexBuffer: h22, tileBoundsSegments: u22 } = t22.getMercatorTileBoundsBuffers(), d22 = [];
        t22.linearFloatFilteringSupported() && d22.push("TERRAIN_DEM_FLOAT_FORMAT"), t22.getOrCreateProgram("hillshadePrepare", { defines: d22 }).draw(t22, s2.TRIANGLES, Li2.disabled, Mi2.disabled, Ai2.unblended, Fi2.disabled, ((t3, i3) => {
          const o3 = i3.stride, r3 = e2.a6.mat4.create();
          return e2.a6.mat4.ortho(r3, 0, e2.ab, -e2.ab, 0, 0, 1), e2.a6.mat4.translate(r3, r3, [0, -e2.ab, 0]), { u_matrix: r3, u_image: 1, u_dimension: [o3, o3], u_zoom: t3.overscaledZ };
        })(i2.tileID, a2), o2.id, c22, h22, u22), i2.needsHillshadePrepare = false;
      }
      class Oo {
        constructor(e22) {
          this.gl = e22.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        }
        get() {
          return this.current;
        }
        set(e22) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class Fo extends Oo {
        getDefault() {
          return e2.bz.transparent;
        }
        set(e22) {
          const t22 = this.current;
          (e22.r !== t22.r || e22.g !== t22.g || e22.b !== t22.b || e22.a !== t22.a || this.dirty) && (this.gl.clearColor(e22.r, e22.g, e22.b, e22.a), this.current = e22, this.dirty = false);
        }
      }
      class ko extends Oo {
        getDefault() {
          return 1;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.clearDepth(e22), this.current = e22, this.dirty = false);
        }
      }
      class Bo extends Oo {
        getDefault() {
          return 0;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.clearStencil(e22), this.current = e22, this.dirty = false);
        }
      }
      class No extends Oo {
        getDefault() {
          return [true, true, true, true];
        }
        set(e22) {
          const t22 = this.current;
          (e22[0] !== t22[0] || e22[1] !== t22[1] || e22[2] !== t22[2] || e22[3] !== t22[3] || this.dirty) && (this.gl.colorMask(e22[0], e22[1], e22[2], e22[3]), this.current = e22, this.dirty = false);
        }
      }
      class Uo extends Oo {
        getDefault() {
          return true;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.depthMask(e22), this.current = e22, this.dirty = false);
        }
      }
      class Go extends Oo {
        getDefault() {
          return 255;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.stencilMask(e22), this.current = e22, this.dirty = false);
        }
      }
      class jo extends Oo {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(e22) {
          const t22 = this.current;
          (e22.func !== t22.func || e22.ref !== t22.ref || e22.mask !== t22.mask || this.dirty) && (this.gl.stencilFunc(e22.func, e22.ref, e22.mask), this.current = e22, this.dirty = false);
        }
      }
      class Vo extends Oo {
        getDefault() {
          const e22 = this.gl;
          return [e22.KEEP, e22.KEEP, e22.KEEP];
        }
        set(e22) {
          const t22 = this.current;
          (e22[0] !== t22[0] || e22[1] !== t22[1] || e22[2] !== t22[2] || this.dirty) && (this.gl.stencilOp(e22[0], e22[1], e22[2]), this.current = e22, this.dirty = false);
        }
      }
      class qo extends Oo {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t22 = this.gl;
          e22 ? t22.enable(t22.STENCIL_TEST) : t22.disable(t22.STENCIL_TEST), this.current = e22, this.dirty = false;
        }
      }
      class Zo extends Oo {
        getDefault() {
          return [0, 1];
        }
        set(e22) {
          const t22 = this.current;
          (e22[0] !== t22[0] || e22[1] !== t22[1] || this.dirty) && (this.gl.depthRange(e22[0], e22[1]), this.current = e22, this.dirty = false);
        }
      }
      class Ho extends Oo {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t22 = this.gl;
          e22 ? t22.enable(t22.DEPTH_TEST) : t22.disable(t22.DEPTH_TEST), this.current = e22, this.dirty = false;
        }
      }
      class Wo extends Oo {
        getDefault() {
          return this.gl.LESS;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.depthFunc(e22), this.current = e22, this.dirty = false);
        }
      }
      class $o extends Oo {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t22 = this.gl;
          e22 ? t22.enable(t22.BLEND) : t22.disable(t22.BLEND), this.current = e22, this.dirty = false;
        }
      }
      class Xo extends Oo {
        getDefault() {
          const e22 = this.gl;
          return [e22.ONE, e22.ZERO, e22.ONE, e22.ZERO];
        }
        set(e22) {
          const t22 = this.current;
          (e22[0] !== t22[0] || e22[1] !== t22[1] || e22[2] !== t22[2] || e22[3] !== t22[3] || this.dirty) && (this.gl.blendFuncSeparate(e22[0], e22[1], e22[2], e22[3]), this.current = e22, this.dirty = false);
        }
      }
      class Yo extends Oo {
        getDefault() {
          return e2.bz.transparent;
        }
        set(e22) {
          const t22 = this.current;
          (e22.r !== t22.r || e22.g !== t22.g || e22.b !== t22.b || e22.a !== t22.a || this.dirty) && (this.gl.blendColor(e22.r, e22.g, e22.b, e22.a), this.current = e22, this.dirty = false);
        }
      }
      class Ko extends Oo {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e22, e22), this.current = e22, this.dirty = false);
        }
      }
      class Jo extends Oo {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t22 = this.gl;
          e22 ? t22.enable(t22.CULL_FACE) : t22.disable(t22.CULL_FACE), this.current = e22, this.dirty = false;
        }
      }
      class Qo extends Oo {
        getDefault() {
          return this.gl.BACK;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.cullFace(e22), this.current = e22, this.dirty = false);
        }
      }
      class er extends Oo {
        getDefault() {
          return this.gl.CCW;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.frontFace(e22), this.current = e22, this.dirty = false);
        }
      }
      let tr = class extends Oo {
        getDefault() {
          return null;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.useProgram(e22), this.current = e22, this.dirty = false);
        }
      };
      class ir extends Oo {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.activeTexture(e22), this.current = e22, this.dirty = false);
        }
      }
      class or extends Oo {
        getDefault() {
          const e22 = this.gl;
          return [0, 0, e22.drawingBufferWidth, e22.drawingBufferHeight];
        }
        set(e22) {
          const t22 = this.current;
          (e22[0] !== t22[0] || e22[1] !== t22[1] || e22[2] !== t22[2] || e22[3] !== t22[3] || this.dirty) && (this.gl.viewport(e22[0], e22[1], e22[2], e22[3]), this.current = e22, this.dirty = false);
        }
      }
      class rr extends Oo {
        getDefault() {
          return null;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t22 = this.gl;
          t22.bindFramebuffer(t22.FRAMEBUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class sr extends Oo {
        getDefault() {
          return null;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t22 = this.gl;
          t22.bindRenderbuffer(t22.RENDERBUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class ar extends Oo {
        getDefault() {
          return null;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t22 = this.gl;
          t22.bindTexture(t22.TEXTURE_2D, e22), this.current = e22, this.dirty = false;
        }
      }
      class nr extends Oo {
        getDefault() {
          return null;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t22 = this.gl;
          t22.bindBuffer(t22.ARRAY_BUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class lr extends Oo {
        getDefault() {
          return null;
        }
        set(e22) {
          const t22 = this.gl;
          t22.bindBuffer(t22.ELEMENT_ARRAY_BUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class cr extends Oo {
        getDefault() {
          return null;
        }
        set(e22) {
          this.gl && (e22 !== this.current || this.dirty) && (this.gl.bindVertexArray(e22), this.current = e22, this.dirty = false);
        }
      }
      class hr extends Oo {
        getDefault() {
          return 4;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t22 = this.gl;
          t22.pixelStorei(t22.UNPACK_ALIGNMENT, e22), this.current = e22, this.dirty = false;
        }
      }
      class ur extends Oo {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t22 = this.gl;
          t22.pixelStorei(t22.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e22), this.current = e22, this.dirty = false;
        }
      }
      class dr extends Oo {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t22 = this.gl;
          t22.pixelStorei(t22.UNPACK_FLIP_Y_WEBGL, e22), this.current = e22, this.dirty = false;
        }
      }
      class _r extends Oo {
        constructor(e22, t22) {
          super(e22), this.context = e22, this.parent = t22;
        }
        getDefault() {
          return null;
        }
      }
      class pr extends _r {
        setDirty() {
          this.dirty = true;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t22 = this.gl;
          t22.framebufferTexture2D(t22.FRAMEBUFFER, t22.COLOR_ATTACHMENT0, t22.TEXTURE_2D, e22, 0), this.current = e22, this.dirty = false;
        }
      }
      class mr extends _r {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t22 = this.gl;
          t22.framebufferRenderbuffer(t22.FRAMEBUFFER, this.attachment(), t22.RENDERBUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class fr extends _r {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t22 = this.gl;
          t22.framebufferTexture2D(t22.FRAMEBUFFER, this.attachment(), t22.TEXTURE_2D, e22, 0), this.current = e22, this.dirty = false;
        }
      }
      class gr extends mr {
        attachment() {
          return this.gl.DEPTH_STENCIL_ATTACHMENT;
        }
      }
      const vr = (e22, t22, i2) => ({ u_matrix: e22, u_image0: 0, u_skirt_height: t22, u_ground_shadow_factor: i2 }), xr = (e22, t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22, d22, _2, p22, m22) => ({ u_proj_matrix: Float32Array.from(e22), u_globe_matrix: t22, u_normalize_matrix: Float32Array.from(o2), u_merc_matrix: i2, u_zoom_transition: r22, u_merc_center: s2, u_image0: 0, u_frustum_tl: a2, u_frustum_tr: n22, u_frustum_br: l22, u_frustum_bl: c22, u_globe_pos: h22, u_globe_radius: u22, u_viewport: d22, u_grid_matrix: m22 ? Float32Array.from(m22) : new Float32Array(9), u_skirt_height: _2, u_far_z_cutoff: p22 });
      function yr(e22, t22) {
        return null != e22 && null != t22 && !(!e22.hasData() || !t22.hasData()) && null != e22.demTexture && null != t22.demTexture && e22.tileID.key !== t22.tileID.key;
      }
      const br = new class {
        constructor() {
          this.operations = {};
        }
        newMorphing(e22, t22, i2, o2, r22) {
          if (e22 in this.operations) {
            const t3 = this.operations[e22];
            t3.to.tileID.key !== i2.tileID.key && (t3.queued = i2);
          } else
            this.operations[e22] = { startTime: o2, phase: 0, duration: r22, from: t22, to: i2, queued: null };
        }
        getMorphValuesForProxy(e22) {
          if (!(e22 in this.operations))
            return null;
          const t22 = this.operations[e22];
          return { from: t22.from, to: t22.to, phase: t22.phase };
        }
        update(e22) {
          for (const t22 in this.operations) {
            const i2 = this.operations[t22];
            for (i2.phase = (e22 - i2.startTime) / i2.duration; i2.phase >= 1 || !this._validOp(i2); )
              if (!this._nextOp(i2, e22)) {
                delete this.operations[t22];
                break;
              }
          }
        }
        _nextOp(e22, t22) {
          return !!e22.queued && (e22.from = e22.to, e22.to = e22.queued, e22.queued = null, e22.phase = 0, e22.startTime = t22, true);
        }
        _validOp(e22) {
          return e22.from.hasData() && e22.to.hasData();
        }
      }(), wr = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
      function Tr(e22, t22, i2) {
        if (0 === t22)
          return 0;
        const o2 = t22 < 1 && 514 === i2 ? 0.25 / t22 : 1;
        return 6 * Math.pow(1.5, 22 - e22) * Math.max(t22, 1) * o2;
      }
      function Er(e22, t22) {
        const i2 = 1 << e22.z;
        return !t22 && (0 === e22.x || e22.x === i2 - 1) || 0 === e22.y || e22.y === i2 - 1;
      }
      const Cr = (e22) => ({ u_matrix: e22 });
      function Sr(t22, i2, o2, r22, s2) {
        if (s2 > 0) {
          const a2 = e2.q.now(), n22 = (a2 - t22.timeAdded) / s2, l22 = i2 ? (a2 - i2.timeAdded) / s2 : -1, c22 = o2.getSource(), h22 = r22.coveringZoomLevel({ tileSize: c22.tileSize, roundZoom: c22.roundZoom }), u22 = !i2 || Math.abs(i2.tileID.overscaledZ - h22) > Math.abs(t22.tileID.overscaledZ - h22), d22 = u22 && t22.refreshedUponExpiration ? 1 : e2.ap(u22 ? n22 : 1 - l22, 0, 1);
          return t22.refreshedUponExpiration && n22 >= 1 && (t22.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - d22 } : { opacity: d22, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      class Ir extends vt {
        constructor(t22) {
          const i2 = { type: "raster-dem", maxzoom: t22.transform.maxZoom }, o2 = new e2.cd(e2.ce(), null), r22 = tt("mock-dem", i2, o2, t22.style);
          super("mock-dem", r22, false), r22.setEventedParent(this), this._sourceLoaded = true;
        }
        _loadTile(e22, t22) {
          e22.state = "loaded", t22(null);
        }
      }
      class Dr extends vt {
        constructor(t22) {
          const i2 = tt("proxy", { type: "geojson", maxzoom: t22.transform.maxZoom }, new e2.cd(e2.ce(), null), t22.style);
          super("proxy", i2, false), i2.setEventedParent(this), this.map = this.getSource().map = t22, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
        update(e22, t22, i2) {
          if (e22.freezeTileCoverage)
            return;
          this.transform = e22;
          const o2 = e22.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((t3, i3) => {
            if (t3[i3.key] = "", !this._tiles[i3.key]) {
              const t4 = new pt(i3, this._source.tileSize * i3.overscaleFactor(), e22.tileZoom);
              t4.state = "loaded", this._tiles[i3.key] = t4;
            }
            return t3;
          }, {});
          for (const e3 in this._tiles)
            e3 in o2 || (this.freeFBO(e3), this._tiles[e3].unloadVectorData(), delete this._tiles[e3]);
        }
        freeFBO(e22) {
          const t22 = this.proxyCachedFBO[e22];
          if (void 0 !== t22) {
            const i2 = Object.values(t22);
            this.renderCachePool.push(...i2), delete this.proxyCachedFBO[e22];
          }
        }
        deallocRenderCache() {
          this.renderCache.forEach((e22) => e22.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
      }
      class Rr extends e2.aA {
        constructor(e22, t22, i2) {
          super(e22.overscaledZ, e22.wrap, e22.canonical.z, e22.canonical.x, e22.canonical.y), this.proxyTileKey = t22, this.projMatrix = i2;
        }
      }
      class Ar extends e2.cE {
        constructor(t22, i2) {
          super(), this._debugParams = { sortTilesHiZFirst: true, disableRenderCache: false }, t22.tp.registerParameter(this._debugParams, ["Terrain"], "sortTilesHiZFirst", {}, () => {
            this._style.map.triggerRepaint();
          }), t22.tp.registerParameter(this._debugParams, ["Terrain"], "disableRenderCache", {}, () => {
            this._style.map.triggerRepaint();
          }), t22.tp.registerButton(["Terrain"], "Invalidate Render Cache", () => {
            this.invalidateRenderCache = true, this._style.map.triggerRepaint();
          }), this.painter = t22, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
          const [o2, r22, s2] = function(t3) {
            const i3 = new e2.a_(), o3 = new e2.aO(), r3 = 131;
            i3.reserve(17161), o3.reserve(33800);
            const s3 = e2.ab / 128, a3 = e2.ab + s3 / 2, n3 = a3 + s3;
            for (let t4 = -s3; t4 < n3; t4 += s3)
              for (let o4 = -s3; o4 < n3; o4 += s3) {
                const r4 = o4 < 0 || o4 > a3 || t4 < 0 || t4 > a3 ? 24575 : 0, s4 = e2.ap(Math.round(o4), 0, e2.ab), n4 = e2.ap(Math.round(t4), 0, e2.ab);
                i3.emplaceBack(s4 + r4, n4);
              }
            const l22 = (e22, t4) => {
              const i4 = t4 * r3 + e22;
              o3.emplaceBack(i4 + 1, i4, i4 + r3), o3.emplaceBack(i4 + r3, i4 + r3 + 1, i4 + 1);
            };
            for (let e22 = 1; e22 < 129; e22++)
              for (let t4 = 1; t4 < 129; t4++)
                l22(t4, e22);
            return [0, 129].forEach((e22) => {
              for (let t4 = 0; t4 < 130; t4++)
                l22(t4, e22), l22(e22, t4);
            }), [i3, o3, 32768];
          }(), a2 = t22.context;
          this.gridBuffer = a2.createVertexBuffer(o2, e2.b0.members), this.gridIndexBuffer = a2.createIndexBuffer(r22), this.gridSegments = e2.b1.simpleSegment(0, 0, o2.length, r22.length), this.gridNoSkirtSegments = e2.b1.simpleSegment(0, 0, o2.length, s2), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Dr(i2.map), this.orthoMatrix = e2.a6.mat4.create(), e2.a6.mat4.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, e2.ab, 0, e2.ab, 0, 1);
          const n22 = a2.gl;
          this._overlapStencilMode = new Mi2({ func: n22.GEQUAL, mask: 255 }, 0, 255, n22.KEEP, n22.KEEP, n22.REPLACE), this._previousZoom = t22.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i2, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new Ir(i2.map), this._pendingGroundEffectLayers = [];
        }
        set style(e22) {
          e22.on("data", this._onStyleDataEvent.bind(this)), this._style = e22, this._style.map.on("moveend", () => {
            this._clearLineLayersFromRenderCache();
          });
        }
        update(t22, i2, o2) {
          if (t22 && t22.terrain) {
            this._style !== t22 && (this.style = t22, this._evaluationZoom = void 0);
            const r22 = t22.terrain.properties, s2 = 0 === t22.terrain.drapeRenderMode, a2 = t22.terrain.isZoomDependent();
            this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e2.q.now();
            const n22 = t22.terrain && t22.terrain.scope, l22 = r22.get("source"), c22 = s2 ? this._mockSourceCache : t22.getSourceCache(l22, n22);
            if (!c22)
              return void e2.w("Couldn't find terrain source \"".concat(l22, '".'));
            if (this.sourceCache = c22, this._exaggeration = a2 ? this.calculateExaggeration(i2) : r22.get("exaggeration"), !i2.projection.requiresDraping && a2 && 0 === this._exaggeration)
              return void this._disable();
            this.enabled = true;
            const h22 = () => {
              this.sourceCache.used && e2.w("Raster DEM source '".concat(this.sourceCache.id, "' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source."));
              const t3 = this.getScaledDemTileSize();
              this.sourceCache.update(i2, t3, true), this.resetTileLookupCache(this.sourceCache.id);
            };
            this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, h22(), this._initializing = true), h22(), i2.updateElevation(true, o2), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i2), this._emptyDEMTextureDirty = true, this._previousZoom = i2.zoom;
          } else
            this._disable();
        }
        calculateExaggeration(t22) {
          const i2 = this._previousCameraAltitude, o2 = t22.getFreeCameraOptions().position.z / t22.pixelsPerMeter * t22.worldSize;
          this._previousCameraAltitude = o2;
          const r22 = null != i2 ? o2 - i2 : Number.MAX_VALUE;
          if (Math.abs(r22) < 2)
            return this._exaggeration;
          const s2 = t22.zoom, a2 = this._style.terrain;
          if (!this._previousUpdateTimestamp)
            return a2.getExaggeration(s2);
          let n22 = s2 - this._previousZoom;
          const l22 = this._previousUpdateTimestamp;
          let c22 = s2;
          null != this._evaluationZoom && (c22 = this._evaluationZoom, Math.abs(s2 - c22) > 0.5 && (n22 = 0.5 * (s2 - c22 + n22)), n22 * r22 < 0 && (c22 += n22)), this._evaluationZoom = c22;
          const h22 = a2.getExaggeration(c22), u22 = h22 === a2.getExaggeration(Math.max(0, c22 - 0.1));
          if (u22 && Math.abs(h22 - this._exaggeration) < 0.01)
            return h22;
          let d22 = Math.min(0.1, 375e-5 * (this._updateTimestamp - l22));
          return (u22 || h22 < 0.1 || Math.abs(n22) < 1e-4) && (d22 = Math.min(0.2, 4 * d22)), e2.aa(this._exaggeration, h22, d22);
        }
        resetTileLookupCache(e22) {
          this._findCoveringTileCache[e22] = {};
        }
        getScaledDemTileSize() {
          return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
        }
        _onStyleDataEvent(e22) {
          e22.coord && "source" === e22.dataType ? this._clearRenderCacheForTile(e22.sourceCacheId, e22.coord) : "style" === e22.dataType && (this.invalidateRenderCache = true, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
        }
        _disable() {
          if (this.enabled && (this.enabled = false, this._emptyDEMTextureDirty = true, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
            for (const e22 in this._style._mergedSourceCaches)
              this._style._mergedSourceCaches[e22].usedForTerrain = false;
        }
        destroy() {
          this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach((e22) => e22.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
        }
        _source() {
          return this.enabled ? this.sourceCache : null;
        }
        isUsingMockSource() {
          return this.sourceCache === this._mockSourceCache;
        }
        exaggeration() {
          return this.enabled ? this._exaggeration : 0;
        }
        get visibleDemTiles() {
          return this._visibleDemTiles;
        }
        get drapeBufferSize() {
          const e22 = 2 * this.proxySourceCache.getSource().tileSize;
          return [e22, e22];
        }
        set useVertexMorphing(e22) {
          this._useVertexMorphing = e22;
        }
        updateTileBinding(t22) {
          if (!this.enabled)
            return;
          this.prevTerrainTileForTile = this.terrainTileForTile;
          const i2 = this.proxySourceCache, o2 = this.painter.transform;
          this._initializing && (this._initializing = 0 === o2._centerAltitude && -1 === this.getAtPointOrZero(e2.a5.fromLngLat(o2.center), -1), this._emptyDEMTextureDirty = !this._initializing);
          const r22 = this.proxyCoords = i2.getIds().map((e22) => {
            const t3 = i2.getTileByID(e22).tileID;
            return t3.projMatrix = o2.calculateProjMatrix(t3.toUnwrapped()), t3;
          });
          !function(t3, i3) {
            const o3 = i3.transform.pointCoordinate(i3.transform.getCameraPoint()), r3 = new e2.P(o3.x, o3.y);
            t3.sort((t4, i4) => {
              if (i4.overscaledZ - t4.overscaledZ)
                return i4.overscaledZ - t4.overscaledZ;
              const o4 = new e2.P(t4.canonical.x + (1 << t4.canonical.z) * t4.wrap, t4.canonical.y), s3 = new e2.P(i4.canonical.x + (1 << i4.canonical.z) * i4.wrap, i4.canonical.y), a3 = r3.mult(1 << t4.canonical.z);
              return a3.x -= 0.5, a3.y -= 0.5, a3.distSqr(o4) - a3.distSqr(s3);
            });
          }(r22, this.painter);
          const s2 = this.proxyToSource || {};
          this.proxyToSource = {}, r22.forEach((e22) => {
            this.proxyToSource[e22.key] = {};
          }), this.terrainTileForTile = {};
          const a2 = this._style._mergedSourceCaches;
          for (const e22 in a2) {
            const i3 = a2[e22];
            if (!i3.used)
              continue;
            if (i3 !== this.sourceCache && this.resetTileLookupCache(i3.id), this._setupProxiedCoordsForOrtho(i3, t22[e22], s2), i3.usedForTerrain)
              continue;
            const o3 = t22[e22];
            i3.getSource().reparseOverscaled && this._assignTerrainTiles(o3);
          }
          this.proxiedCoords[i2.id] = r22.map((e22) => new Rr(e22, e22.key, this.orthoMatrix)), this._assignTerrainTiles(r22), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(s2), this.renderingToTexture = false;
          const n22 = {};
          this._visibleDemTiles = [];
          for (const e22 of this.proxyCoords) {
            const t3 = this.terrainTileForTile[e22.key];
            if (!t3)
              continue;
            const i3 = t3.tileID.key;
            i3 in n22 || (this._visibleDemTiles.push(t3), n22[i3] = i3);
          }
        }
        _assignTerrainTiles(e22) {
          this._initializing || e22.forEach((e3) => {
            if (this.terrainTileForTile[e3.key])
              return;
            const t22 = this._findTileCoveringTileID(e3, this.sourceCache);
            t22 && (this.terrainTileForTile[e3.key] = t22);
          });
        }
        _prepareDEMTextures() {
          const e22 = this.painter.context, t22 = e22.gl;
          for (const i2 in this.terrainTileForTile) {
            const o2 = this.terrainTileForTile[i2], r22 = o2.dem;
            !r22 || o2.demTexture && !o2.needsDEMTextureUpload || (e22.activeTexture.set(t22.TEXTURE1), Mo(this.painter, o2, r22));
          }
        }
        _prepareDemTileUniforms(e22, t22, i2, o2) {
          if (!t22 || null == t22.demTexture)
            return false;
          const r22 = e22.tileID.canonical, s2 = Math.pow(2, t22.tileID.canonical.z - r22.z), a2 = o2 || "";
          return i2["u_dem_tl".concat(a2)] = [r22.x * s2 % 1, r22.y * s2 % 1], i2["u_dem_scale".concat(a2)] = s2, true;
        }
        get emptyDEMTexture() {
          return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
        }
        _getLoadedAreaMinimum() {
          if (!this.enabled)
            return 0;
          let e22 = 0;
          const t22 = this._visibleDemTiles.reduce((t3, i2) => {
            if (!i2.dem)
              return t3;
            const o2 = i2.dem.tree.minimums[0];
            return o2 > 0 && e22++, t3 + o2;
          }, 0);
          return e22 ? t22 / e22 : 0;
        }
        _updateEmptyDEMTexture() {
          const t22 = this.painter.context, i2 = t22.gl;
          t22.activeTexture.set(i2.TEXTURE2);
          const o2 = this._getLoadedAreaMinimum(), r22 = new e2.cF({ width: 1, height: 1 }, new Float32Array([o2]));
          this._emptyDEMTextureDirty = false;
          let s2 = this._emptyDEMTexture;
          return s2 ? s2.update(r22, { premultiply: false }) : s2 = this._emptyDEMTexture = new e2.T(t22, r22, i2.R32F, { premultiply: false }), s2;
        }
        setupElevationDraw(t22, i2, o2) {
          const r22 = this.painter.context, s2 = r22.gl, a2 = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 };
          a2.u_exaggeration = this.exaggeration();
          let n22 = null, l22 = null, c22 = 1;
          if (o2 && o2.morphing && this._useVertexMorphing) {
            const e22 = o2.morphing.srcDemTile, i3 = o2.morphing.dstDemTile;
            c22 = o2.morphing.phase, e22 && i3 && (this._prepareDemTileUniforms(t22, e22, a2, "_prev") && (l22 = e22), this._prepareDemTileUniforms(t22, i3, a2) && (n22 = i3));
          }
          const h22 = (e22) => e22 && e22.demTexture && this.painter.linearFloatFilteringSupported() ? s2.LINEAR : s2.NEAREST;
          let u22 = null;
          var d22;
          if (this.enabled ? l22 && n22 ? (u22 = n22.demTexture, r22.activeTexture.set(s2.TEXTURE4), l22.demTexture.bind(h22(l22), s2.CLAMP_TO_EDGE), a2.u_dem_lerp = c22) : (n22 = this.terrainTileForTile[t22.tileID.key], u22 = this._prepareDemTileUniforms(t22, n22, a2) ? n22.demTexture : this.emptyDEMTexture) : u22 = this.emptyDEMTexture, r22.activeTexture.set(s2.TEXTURE2), u22 && (a2.u_dem_size = 1 === (d22 = u22).size[0] ? 1 : d22.size[0] - 2, u22.bind(h22(n22), s2.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(o2 && o2.useDepthForOcclusion, i2, a2), o2 && o2.useMeterToDem && n22) {
            const t3 = (1 << n22.tileID.canonical.z) * e2.bD(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
            a2.u_meter_to_dem = t3;
          }
          if (o2 && o2.labelPlaneMatrixInv && (a2.u_label_plane_matrix_inv = o2.labelPlaneMatrixInv), i2.setTerrainUniformValues(r22, a2), "globe" === this.painter.transform.projection.name) {
            const e22 = this.globeUniformValues(this.painter.transform, t22.tileID.canonical, o2 && o2.useDenormalizedUpVectorScale);
            i2.setGlobeUniformValues(r22, e22);
          }
        }
        globeUniformValues(t22, i2, o2) {
          const r22 = t22.projection;
          return { u_tile_tl_up: r22.upVector(i2, 0, 0), u_tile_tr_up: r22.upVector(i2, e2.ab, 0), u_tile_br_up: r22.upVector(i2, e2.ab, e2.ab), u_tile_bl_up: r22.upVector(i2, 0, e2.ab), u_tile_up_scale: o2 ? e2.cG(1) : r22.upVectorScale(i2, t22.center.lat, t22.worldSize).metersToTile };
        }
        renderToBackBuffer(t22) {
          const i2 = this.painter, o2 = this.painter.context;
          0 !== t22.length && (o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), i2.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(t3, i3, o3, r22, s2) {
            if ("globe" === t3.transform.projection.name)
              !function(t4, i4, o4, r3, s3) {
                const a2 = t4.context, n22 = a2.gl;
                let l22, c22;
                const h22 = t4.transform, u22 = e2.cx(t4, a2, h22), d22 = (e22, i5) => {
                  if (c22 === i5)
                    return;
                  const o5 = [wr[i5], "PROJECTION_GLOBE_VIEW"];
                  u22 && o5.push("CUSTOM_ANTIALIASING");
                  const r4 = t4.isTileAffectedByFog(e22);
                  l22 = t4.getOrCreateProgram("globeRaster", { defines: o5, overrideFog: r4 }), c22 = i5;
                }, _2 = t4.colorModeForRenderPass(), p22 = new Li2(n22.LEQUAL, Li2.ReadWrite, t4.depthRangeFor3D);
                br.update(s3);
                const m22 = e2.cy(h22), f22 = [e2.am(h22.center.lng), e2.at(h22.center.lat)], g22 = t4.globeSharedBuffers, v22 = [h22.width * e2.q.devicePixelRatio, h22.height * e2.q.devicePixelRatio], x22 = Float32Array.from(h22.globeMatrix), y22 = { useDenormalizedUpVectorScale: true };
                {
                  const h3 = t4.transform, u3 = Tr(h3.zoom, i4.exaggeration(), i4.sourceCache._source.tileSize);
                  c22 = -1;
                  const b22 = n22.TRIANGLES;
                  for (const c3 of r3) {
                    const r4 = o4.getTile(c3), w22 = Mi2.disabled, T22 = i4.prevTerrainTileForTile[c3.key], E22 = i4.terrainTileForTile[c3.key];
                    yr(T22, E22) && br.newMorphing(c3.key, T22, E22, s3, 250), a2.activeTexture.set(n22.TEXTURE0), r4.texture && r4.texture.bind(n22.LINEAR, n22.CLAMP_TO_EDGE);
                    const C22 = br.getMorphValuesForProxy(c3.key), S22 = C22 ? 1 : 0;
                    C22 && e2.C(y22, { morphing: { srcDemTile: C22.from, dstDemTile: C22.to, phase: e2.cw(C22.phase) } });
                    const I22 = e2.cz(c3.canonical), D22 = e2.cA(I22.getCenter().lat), R22 = e2.cB(c3.canonical, I22, D22, h3.worldSize / h3._pixelsPerMercatorPixel), A22 = e2.b5(e2.cC(c3.canonical)), L22 = xr(h3.expandedFarZProjMatrix, x22, m22, A22, e2.a9(h3.zoom), f22, h3.frustumCorners.TL, h3.frustumCorners.TR, h3.frustumCorners.BR, h3.frustumCorners.BL, h3.globeCenterInViewSpace, h3.globeRadius, v22, u3, h3._farZ, R22);
                    if (d22(c3, S22), l22 && (i4.setupElevationDraw(r4, l22, y22), t4.uploadCommonUniforms(a2, l22, c3.toUnwrapped()), g22)) {
                      const [e22, i5, o5] = g22.getGridBuffers(D22, 0 !== u3);
                      l22.draw(t4, b22, p22, w22, _2, Fi2.backCCW, L22, "globe_raster", e22, i5, o5);
                    }
                  }
                }
                if (g22 && (t4.renderDefaultNorthPole || t4.renderDefaultSouthPole)) {
                  const s4 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                  u22 && s4.push("CUSTOM_ANTIALIASING"), l22 = t4.getOrCreateProgram("globeRaster", { defines: s4 });
                  for (const s5 of r3) {
                    const { x: r4, y: c3, z: u3 } = s5.canonical, d3 = 0 === c3, m3 = c3 === (1 << u3) - 1, [x3, b22, w22, T22] = g22.getPoleBuffers(u3, false);
                    if (T22 && (d3 || m3)) {
                      const c4 = o4.getTile(s5);
                      a2.activeTexture.set(n22.TEXTURE0), c4.texture && c4.texture.bind(n22.LINEAR, n22.CLAMP_TO_EDGE);
                      let g3 = e2.cD(u3, r4, h22);
                      const E22 = e2.b5(e2.cC(s5.canonical)), C22 = (e22, i5) => e22.draw(t4, n22.TRIANGLES, p22, Mi2.disabled, _2, Fi2.disabled, xr(h22.expandedFarZProjMatrix, g3, g3, E22, 0, f22, h22.frustumCorners.TL, h22.frustumCorners.TR, h22.frustumCorners.BR, h22.frustumCorners.BL, h22.globeCenterInViewSpace, h22.globeRadius, v22, 0, h22._farZ), "globe_pole_raster", i5, w22, T22);
                      i4.setupElevationDraw(c4, l22, y22), t4.uploadCommonUniforms(a2, l22, s5.toUnwrapped()), d3 && t4.renderDefaultNorthPole && C22(l22, x3), m3 && t4.renderDefaultSouthPole && (g3 = e2.a6.mat4.scale(e2.a6.mat4.create(), g3, [1, -1, 1]), C22(l22, b22));
                    }
                  }
                }
              }(t3, i3, o3, r22, s2);
            else {
              const a2 = t3.context, n22 = a2.gl;
              let l22, c22;
              const h22 = t3.shadowRenderer, u22 = Wi2(t3, t3.longestCutoffRange), d22 = (e22) => {
                if (c22 === e22)
                  return;
                const i4 = [];
                i4.push(wr[e22]), u22.shouldRenderCutoff && i4.push("RENDER_CUTOFF"), l22 = t3.getOrCreateProgram("terrainRaster", { defines: i4 }), c22 = e22;
              }, _2 = t3.colorModeForRenderPass(), p22 = new Li2(n22.LEQUAL, Li2.ReadWrite, t3.depthRangeFor3D);
              br.update(s2);
              const m22 = t3.transform, f22 = Tr(m22.zoom, i3.exaggeration(), i3.sourceCache._source.tileSize);
              let g22 = [0, 0, 0];
              if (h22) {
                const e22 = t3.style.directionalLight, i4 = t3.style.ambientLight;
                e22 && i4 && (g22 = eo(t3.style, e22, i4));
              }
              {
                c22 = -1;
                const v22 = n22.TRIANGLES, [x22, y22] = [i3.gridIndexBuffer, i3.gridSegments];
                for (const c3 of r22) {
                  const r3 = o3.getTile(c3), b22 = Mi2.disabled, w22 = i3.prevTerrainTileForTile[c3.key], T22 = i3.terrainTileForTile[c3.key];
                  yr(w22, T22) && br.newMorphing(c3.key, w22, T22, s2, 250), a2.activeTexture.set(n22.TEXTURE0), r3.texture && r3.texture.bind(n22.LINEAR, n22.CLAMP_TO_EDGE);
                  const E22 = br.getMorphValuesForProxy(c3.key), C22 = E22 ? 1 : 0;
                  let S22;
                  E22 && (S22 = { morphing: { srcDemTile: E22.from, dstDemTile: E22.to, phase: e2.cw(E22.phase) } });
                  const I22 = vr(c3.projMatrix, Er(c3.canonical, m22.renderWorldCopies) ? f22 / 10 : f22, g22);
                  if (d22(C22), !l22)
                    continue;
                  i3.setupElevationDraw(r3, l22, S22);
                  const D22 = c3.toUnwrapped();
                  h22 && h22.setupShadows(D22, l22), t3.uploadCommonUniforms(a2, l22, D22, null, u22), l22.draw(t3, v22, p22, b22, _2, Fi2.backCCW, I22, "terrain_raster", i3.gridBuffer, x22, y22);
                }
              }
            }
          }(i2, this, this.proxySourceCache, t22, this._updateTimestamp), this.renderingToTexture = true, i2.gpuTimingDeferredRenderEnd(), t22.splice(0, t22.length));
        }
        renderBatch(t22) {
          if (0 === this._drapedRenderBatches.length)
            return t22 + 1;
          this.renderingToTexture = true;
          const i2 = this.painter, o2 = this.painter.context, r22 = this.proxySourceCache, s2 = this.proxiedCoords[r22.id], a2 = this._drapedRenderBatches.shift(), n22 = i2.style.order, l22 = [];
          let c22 = 0;
          for (const h22 of s2) {
            const s3 = r22.getTileByID(h22.proxyTileKey), u22 = r22.proxyCachedFBO[h22.key] ? r22.proxyCachedFBO[h22.key][t22] : void 0, d22 = void 0 !== u22 ? r22.renderCache[u22] : this.pool[c22++], _2 = void 0 !== u22;
            if (s3.texture = d22.tex, _2 && !d22.dirty) {
              l22.push(s3.tileID);
              continue;
            }
            let p22;
            o2.bindFramebuffer.set(d22.fb.framebuffer), this.renderedToTile = false, d22.dirty && (o2.clear({ color: e2.bz.transparent, stencil: 0 }), d22.dirty = false);
            for (let e22 = a2.start; e22 <= a2.end; ++e22) {
              const t3 = i2.style._mergedLayers[n22[e22]];
              if (t3.isHidden(i2.transform.zoom))
                continue;
              const r3 = i2.style.getLayerSourceCache(t3), s4 = r3 ? this.proxyToSource[h22.key][r3.id] : [h22];
              if (!s4)
                continue;
              const a3 = s4;
              o2.viewport.set([0, 0, d22.fb.width, d22.fb.height]), p22 !== (r3 ? r3.id : null) && (this._setupStencil(d22, s4, t3, r3), p22 = r3 ? r3.id : null), i2.renderLayer(i2, r3, t3, a3);
            }
            if (0 === this._drapedRenderBatches.length)
              for (const e22 of this._pendingGroundEffectLayers) {
                const t3 = i2.style._mergedLayers[n22[e22]];
                if (t3.isHidden(i2.transform.zoom))
                  continue;
                const r3 = i2.style.getLayerSourceCache(t3), s4 = r3 ? this.proxyToSource[h22.key][r3.id] : [h22];
                if (!s4)
                  continue;
                const a3 = s4;
                o2.viewport.set([0, 0, d22.fb.width, d22.fb.height]), p22 !== (r3 ? r3.id : null) && (this._setupStencil(d22, s4, t3, r3), p22 = r3 ? r3.id : null), i2.renderLayer(i2, r3, t3, a3);
              }
            this.renderedToTile ? (d22.dirty = true, l22.push(s3.tileID)) : _2 || --c22, 5 === c22 && (c22 = 0, this.renderToBackBuffer(l22));
          }
          return this.renderToBackBuffer(l22), this.renderingToTexture = false, o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), a2.end + 1;
        }
        postRender() {
        }
        isLayerOrderingCorrect(e22) {
          const t22 = e22.order.length;
          let i2 = -1, o2 = t22;
          for (let r22 = 0; r22 < t22; ++r22)
            this._style.isLayerDraped(e22._mergedLayers[e22.order[r22]]) ? i2 = Math.max(i2, r22) : o2 = Math.min(o2, r22);
          return o2 > i2;
        }
        getMinElevationBelowMSL() {
          let e22 = 0;
          return this._visibleDemTiles.filter((e3) => e3.dem).forEach((t22) => {
            e22 = Math.min(e22, t22.dem.tree.minimums[0]);
          }), 0 === e22 ? e22 : (e22 - 30) * this._exaggeration;
        }
        raycast(e22, t22, i2) {
          if (!this._visibleDemTiles)
            return null;
          const o2 = this._visibleDemTiles.filter((e3) => e3.dem).map((o3) => {
            const r22 = o3.tileID, s2 = 1 << r22.overscaledZ, { x: a2, y: n22 } = r22.canonical, l22 = a2 / s2, c22 = (a2 + 1) / s2, h22 = n22 / s2, u22 = (n22 + 1) / s2;
            return { minx: l22, miny: h22, maxx: c22, maxy: u22, t: o3.dem.tree.raycastRoot(l22, h22, c22, u22, e22, t22, i2), tile: o3 };
          });
          o2.sort((e3, t3) => (null !== e3.t ? e3.t : Number.MAX_VALUE) - (null !== t3.t ? t3.t : Number.MAX_VALUE));
          for (const r22 of o2) {
            if (null == r22.t)
              return null;
            const o3 = r22.tile.dem.tree.raycast(r22.minx, r22.miny, r22.maxx, r22.maxy, e22, t22, i2);
            if (null != o3)
              return o3;
          }
          return null;
        }
        _createFBO() {
          const t22 = this.painter.context, i2 = t22.gl, o2 = this.drapeBufferSize;
          t22.activeTexture.set(i2.TEXTURE0);
          const r22 = new e2.T(t22, { width: o2[0], height: o2[1], data: null }, i2.RGBA8);
          r22.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
          const s2 = t22.createFramebuffer(o2[0], o2[1], true, null);
          return s2.colorAttachment.set(r22.texture), s2.depthAttachment = new gr(t22, s2.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t22.createRenderbuffer(t22.gl.DEPTH_STENCIL, o2[0], o2[1]), this._stencilRef = 0, s2.depthAttachment.set(this._sharedDepthStencil), t22.clear({ stencil: 0 })) : s2.depthAttachment.set(this._sharedDepthStencil), t22.extTextureFilterAnisotropic && i2.texParameterf(i2.TEXTURE_2D, t22.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t22.extTextureFilterAnisotropicMax), { fb: s2, tex: r22, dirty: false };
        }
        _initFBOPool() {
          for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
            this.pool.push(this._createFBO());
        }
        _shouldDisableRenderCache() {
          if (this._debugParams.disableRenderCache)
            return true;
          if (this._style.hasLightTransitions())
            return true;
          for (const e22 in this._style._mergedSourceCaches)
            if (this._style._mergedSourceCaches[e22].hasTransition())
              return true;
          return this._style.order.some((e22) => {
            const t22 = this._style._mergedLayers[e22], i2 = t22.isHidden(this.painter.transform.zoom);
            return "hillshade" === t22.type || "custom" === t22.type ? !i2 && t22.shouldRedrape() : !i2 && t22.hasTransition();
          });
        }
        _clearLineLayersFromRenderCache() {
          let t22 = false;
          for (const e22 of this._style.getSources())
            if (e22 instanceof Ke2) {
              t22 = true;
              break;
            }
          if (!t22)
            return;
          const i2 = {};
          for (let t3 = 0; t3 < this._style.order.length; ++t3) {
            const o2 = this._style._mergedLayers[this._style.order[t3]], r22 = this._style.getLayerSourceCache(o2);
            if (r22 && !i2[r22.id] && !o2.isHidden(this.painter.transform.zoom) && "line" === o2.type && o2.widthExpression() instanceof e2.a4) {
              i2[r22.id] = true;
              for (const e22 of this.proxyCoords) {
                const t4 = this.proxyToSource[e22.key][r22.id];
                if (t4)
                  for (const e3 of t4)
                    this._clearRenderCacheForTile(r22.id, e3);
              }
            }
          }
        }
        _clearRasterLayersFromRenderCache() {
          let e22 = false;
          for (const t3 in this._style._mergedSourceCaches)
            if (this._style._mergedSourceCaches[t3]._source instanceof Je2) {
              e22 = true;
              break;
            }
          if (!e22)
            return;
          const t22 = {};
          for (let e3 = 0; e3 < this._style.order.length; ++e3) {
            const i2 = this._style._mergedLayers[this._style.order[e3]], o2 = this._style.getLayerSourceCache(i2);
            if (!o2 || t22[o2.id])
              continue;
            if (i2.isHidden(this.painter.transform.zoom) || "raster" !== i2.type)
              continue;
            const r22 = i2.paint.get("raster-fade-duration");
            for (const e4 of this.proxyCoords) {
              const t3 = this.proxyToSource[e4.key][o2.id];
              if (t3)
                for (const e5 of t3) {
                  const t4 = Sr(o2.getTile(e5), o2.findLoadedParent(e5, 0), o2, this.painter.transform, r22);
                  (1 !== t4.opacity || 0 !== t4.mix) && this._clearRenderCacheForTile(o2.id, e5);
                }
            }
          }
        }
        _setupDrapedRenderBatches() {
          const t22 = this._style.order, i2 = t22.length;
          if (0 === i2)
            return;
          const o2 = [];
          this._pendingGroundEffectLayers = [];
          let r22, s2 = 0, a2 = this._style._mergedLayers[t22[s2]];
          for (; !this._style.isLayerDraped(a2) && a2.isHidden(this.painter.transform.zoom) && ++s2 < i2; )
            a2 = this._style._mergedLayers[t22[s2]];
          for (; s2 < i2; ++s2) {
            const e22 = this._style._mergedLayers[t22[s2]];
            e22.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e22) ? void 0 === r22 && (r22 = s2) : ("fill-extrusion" === e22.type && this._pendingGroundEffectLayers.push(s2), void 0 !== r22 && (o2.push({ start: r22, end: s2 - 1 }), r22 = void 0)));
          }
          if (void 0 !== r22 && o2.push({ start: r22, end: s2 - 1 }), 0 !== o2.length) {
            const t3 = o2[o2.length - 1];
            this._pendingGroundEffectLayers.every((e22) => e22 > t3.end) || e2.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
          }
          this._drapedRenderBatches = o2;
        }
        _setupRenderCache(e22) {
          const t22 = this.proxySourceCache;
          if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
            if (this.invalidateRenderCache = false, t22.renderCache.length > t22.renderCachePool.length) {
              const e3 = Object.values(t22.proxyCachedFBO);
              t22.proxyCachedFBO = {};
              for (let i3 = 0; i3 < e3.length; ++i3) {
                const o3 = Object.values(e3[i3]);
                t22.renderCachePool.push(...o3);
              }
            }
            return;
          }
          this._clearRasterLayersFromRenderCache();
          const i2 = this.proxyCoords, o2 = this._tilesDirty;
          for (let r3 = i2.length - 1; r3 >= 0; r3--) {
            const s2 = i2[r3];
            if (t22.getTileByID(s2.key), void 0 !== t22.proxyCachedFBO[s2.key]) {
              const i3 = e22[s2.key], r4 = this.proxyToSource[s2.key];
              let a2 = 0;
              for (const e3 in r4) {
                const t3 = r4[e3], s3 = i3[e3];
                if (!s3 || s3.length !== t3.length || t3.some((t4, i4) => t4 !== s3[i4] || o2[e3] && o2[e3].hasOwnProperty(t4.key))) {
                  a2 = -1;
                  break;
                }
                ++a2;
              }
              for (const e3 in t22.proxyCachedFBO[s2.key])
                t22.renderCache[t22.proxyCachedFBO[s2.key][e3]].dirty = a2 < 0 || a2 !== Object.values(i3).length;
            }
          }
          const r22 = [...this._drapedRenderBatches];
          r22.sort((e3, t3) => t3.end - t3.start - (e3.end - e3.start));
          for (const e3 of r22)
            for (const o3 of i2) {
              if (t22.proxyCachedFBO[o3.key])
                continue;
              let i3 = t22.renderCachePool.pop();
              void 0 === i3 && t22.renderCache.length < 50 && (i3 = t22.renderCache.length, t22.renderCache.push(this._createFBO())), void 0 !== i3 && (t22.proxyCachedFBO[o3.key] = {}, t22.proxyCachedFBO[o3.key][e3.start] = i3, t22.renderCache[i3].dirty = true);
            }
          this._tilesDirty = {};
        }
        _setupStencil(e22, t22, i2, o2) {
          if (!o2 || !this._sourceTilesOverlap[o2.id])
            return void (this._overlapStencilType && (this._overlapStencilType = false));
          const r22 = this.painter.context, s2 = r22.gl;
          if (t22.length <= 1)
            return void (this._overlapStencilType = false);
          let a2;
          if (i2.isTileClipped())
            a2 = t22.length, this._overlapStencilMode.test = { func: s2.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
          else {
            if (!(t22[0].overscaledZ > t22[t22.length - 1].overscaledZ))
              return void (this._overlapStencilType = false);
            a2 = 1, this._overlapStencilMode.test = { func: s2.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
          }
          this._stencilRef + a2 > 255 && (r22.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += a2, this._overlapStencilMode.ref = this._stencilRef, i2.isTileClipped() && this._renderTileClippingMasks(t22, this._overlapStencilMode.ref);
        }
        clipOrMaskOverlapStencilType() {
          return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
        }
        stencilModeForRTTOverlap(e22) {
          return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e22.key]), this._overlapStencilMode) : Mi2.disabled;
        }
        _renderTileClippingMasks(e22, t22) {
          const i2 = this.painter, o2 = this.painter.context, r22 = o2.gl;
          i2._tileClippingMaskIDs = {}, o2.setColorMode(Ai2.disabled), o2.setDepthMode(Li2.disabled);
          const s2 = i2.getOrCreateProgram("clippingMask");
          for (const o3 of e22) {
            const e3 = i2._tileClippingMaskIDs[o3.key] = --t22;
            s2.draw(i2, r22.TRIANGLES, Li2.disabled, new Mi2({ func: r22.ALWAYS, mask: 0 }, e3, 255, r22.KEEP, r22.KEEP, r22.REPLACE), Ai2.disabled, Fi2.disabled, Cr(o3.projMatrix), "$clipping", i2.tileExtentBuffer, i2.quadTriangleIndexBuffer, i2.tileExtentSegments);
          }
        }
        pointCoordinate(t22) {
          const i2 = this.painter.transform;
          if (t22.x < 0 || t22.x > i2.width || t22.y < 0 || t22.y > i2.height)
            return null;
          const o2 = [t22.x, t22.y, 1, 1];
          e2.a6.vec4.transformMat4(o2, o2, i2.pixelMatrixInverse), e2.a6.vec4.scale(o2, o2, 1 / o2[3]), o2[0] /= i2.worldSize, o2[1] /= i2.worldSize;
          const r22 = i2._camera.position, s2 = e2.bD(1, i2.center.lat), a2 = [r22[0], r22[1], r22[2] / s2, 0], n22 = e2.a6.vec3.subtract([], o2.slice(0, 3), a2);
          e2.a6.vec3.normalize(n22, n22);
          const l22 = this.raycast(a2, n22, this._exaggeration);
          return null !== l22 && l22 ? (e2.a6.vec3.scaleAndAdd(a2, a2, n22, l22), a2[3] = a2[2], a2[2] *= s2, a2) : null;
        }
        _setupProxiedCoordsForOrtho(t22, i2, o2) {
          if (t22.getSource() instanceof e2.aD)
            return this._setupProxiedCoordsForImageSource(t22, i2, o2);
          this._findCoveringTileCache[t22.id] = this._findCoveringTileCache[t22.id] || {};
          const r22 = this.proxiedCoords[t22.id] = [], s2 = this.proxyCoords;
          for (let e22 = 0; e22 < s2.length; e22++) {
            const i3 = s2[e22], a3 = this._findTileCoveringTileID(i3, t22);
            if (a3) {
              const e3 = this._createProxiedId(i3, a3, o2[i3.key] && o2[i3.key][t22.id]);
              r22.push(e3), this.proxyToSource[i3.key][t22.id] = [e3];
            }
          }
          let a2 = false;
          const n22 = /* @__PURE__ */ new Set();
          for (let e22 = 0; e22 < i2.length; e22++) {
            const s3 = t22.getTile(i2[e22]);
            if (!s3 || !s3.hasData())
              continue;
            const l22 = this._findTileCoveringTileID(s3.tileID, this.proxySourceCache);
            if (l22 && l22.tileID.canonical.z !== s3.tileID.canonical.z) {
              const e3 = this.proxyToSource[l22.tileID.key][t22.id], i3 = this._createProxiedId(l22.tileID, s3, o2[l22.tileID.key] && o2[l22.tileID.key][t22.id]);
              e3 ? e3.splice(e3.length - 1, 0, i3) : this.proxyToSource[l22.tileID.key][t22.id] = [i3];
              const c22 = this.proxyToSource[l22.tileID.key][t22.id];
              n22.has(c22) || n22.add(c22), r22.push(i3), a2 = true;
            }
          }
          if (this._sourceTilesOverlap[t22.id] = a2, a2 && this._debugParams.sortTilesHiZFirst)
            for (const e22 of n22)
              e22.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ);
        }
        _setupProxiedCoordsForImageSource(t22, i2, o2) {
          if (!t22.getSource().loaded())
            return;
          const r22 = this.proxiedCoords[t22.id] = [], s2 = this.proxyCoords, a2 = t22.getSource(), n22 = a2.tileID;
          if (!n22)
            return;
          const l22 = new e2.P(n22.x, n22.y)._div(1 << n22.z), c22 = a2.coordinates.map(e2.a5.fromLngLat).reduce((e22, t3) => (e22.min.x = Math.min(e22.min.x, t3.x - l22.x), e22.min.y = Math.min(e22.min.y, t3.y - l22.y), e22.max.x = Math.max(e22.max.x, t3.x - l22.x), e22.max.y = Math.max(e22.max.y, t3.y - l22.y), e22), { min: new e2.P(Number.MAX_VALUE, Number.MAX_VALUE), max: new e2.P(-Number.MAX_VALUE, -Number.MAX_VALUE) }), h22 = (t3, i3) => {
            const o3 = t3.wrap + t3.canonical.x / (1 << t3.canonical.z), r3 = t3.canonical.y / (1 << t3.canonical.z), s3 = e2.ab / (1 << t3.canonical.z), a3 = i3.wrap + i3.canonical.x / (1 << i3.canonical.z), n3 = i3.canonical.y / (1 << i3.canonical.z);
            return o3 + s3 < a3 + c22.min.x || o3 > a3 + c22.max.x || r3 + s3 < n3 + c22.min.y || r3 > n3 + c22.max.y;
          };
          for (let e22 = 0; e22 < s2.length; e22++) {
            const a3 = s2[e22];
            for (let e3 = 0; e3 < i2.length; e3++) {
              const s3 = t22.getTile(i2[e3]);
              if (!s3 || !s3.hasData())
                continue;
              if (h22(a3, s3.tileID))
                continue;
              const n3 = this._createProxiedId(a3, s3, o2[a3.key] && o2[a3.key][t22.id]), l3 = this.proxyToSource[a3.key][t22.id];
              l3 ? l3.push(n3) : this.proxyToSource[a3.key][t22.id] = [n3], r22.push(n3);
            }
          }
        }
        _createProxiedId(t22, i2, o2) {
          let r22 = this.orthoMatrix;
          if (o2) {
            const e22 = o2.find((e3) => e3.key === i2.tileID.key);
            if (e22)
              return e22;
          }
          if (i2.tileID.key !== t22.key) {
            const o3 = t22.canonical.z - i2.tileID.canonical.z;
            let s2, a2, n22;
            r22 = e2.a6.mat4.create();
            const l22 = i2.tileID.wrap - t22.wrap << t22.overscaledZ;
            o3 > 0 ? (s2 = e2.ab >> o3, a2 = s2 * ((i2.tileID.canonical.x << o3) - t22.canonical.x + l22), n22 = s2 * ((i2.tileID.canonical.y << o3) - t22.canonical.y)) : (s2 = e2.ab << -o3, a2 = e2.ab * (i2.tileID.canonical.x - (t22.canonical.x + l22 << -o3)), n22 = e2.ab * (i2.tileID.canonical.y - (t22.canonical.y << -o3))), e2.a6.mat4.ortho(r22, 0, s2, 0, s2, 0, 1), e2.a6.mat4.translate(r22, r22, [a2, n22, 0]);
          }
          return new Rr(i2.tileID, t22.key, r22);
        }
        _findTileCoveringTileID(t22, i2) {
          let o2 = i2.getTile(t22);
          if (o2 && o2.hasData())
            return o2;
          const r22 = this._findCoveringTileCache[i2.id], s2 = r22[t22.key];
          if (o2 = s2 ? i2.getTileByID(s2) : null, o2 && o2.hasData() || null === s2)
            return o2;
          let a2 = o2 ? o2.tileID : t22, n22 = a2.overscaledZ;
          const l22 = i2.getSource().minzoom, c22 = [];
          if (!s2) {
            const r3 = i2.getSource().maxzoom;
            if (t22.canonical.z >= r3) {
              const o3 = t22.canonical.z - r3;
              i2.getSource().reparseOverscaled ? (n22 = Math.max(t22.canonical.z + 2, i2.transform.tileZoom), a2 = new e2.aA(n22, t22.wrap, r3, t22.canonical.x >> o3, t22.canonical.y >> o3)) : 0 !== o3 && (n22 = r3, a2 = new e2.aA(n22, t22.wrap, r3, t22.canonical.x >> o3, t22.canonical.y >> o3));
            }
            a2.key !== t22.key && (c22.push(a2.key), o2 = i2.getTile(a2));
          }
          const h22 = (e22) => {
            c22.forEach((t3) => {
              r22[t3] = e22;
            }), c22.length = 0;
          };
          for (n22 -= 1; n22 >= l22 && (!o2 || !o2.hasData()); n22--) {
            o2 && h22(o2.tileID.key);
            const e22 = a2.calculateScaledKey(n22);
            if (o2 = i2.getTileByID(e22), o2 && o2.hasData())
              break;
            const t3 = r22[e22];
            if (null === t3)
              break;
            void 0 === t3 ? c22.push(e22) : o2 = i2.getTileByID(t3);
          }
          return h22(o2 ? o2.tileID.key : null), o2 && o2.hasData() ? o2 : null;
        }
        findDEMTileFor(e22) {
          return this.enabled ? this._findTileCoveringTileID(e22, this.sourceCache) : null;
        }
        prepareDrawTile() {
          this.renderedToTile = true;
        }
        _clearRenderCacheForTile(e22, t22) {
          let i2 = this._tilesDirty[e22];
          i2 || (i2 = this._tilesDirty[e22] = {}), i2[t22.key] = true;
        }
      }
      function Lr(t22, i2, o2) {
        const r22 = function(t3, i3, o3) {
          const r3 = e2.a6.vec3.dot(i3, t3), s3 = e2.a6.vec3.dot(o3, [0.2126, 0.7152, 0.0722]), a3 = (e22, t4, i4) => (1 - i4) * e22 + i4 * t4, n3 = a3(1 - 0.3 * Math.min(s3, 1), 1, Math.min(r3 + 1, 1));
          return a3(0.92, 1, Math.asin(e2.ap(i3[2], -1, 1)) / Math.PI + 0.5) * n3;
        }(t22, [0, 0, 1], i2), s2 = [0, 0, 0];
        e2.a6.vec3.scale(s2, o2.slice(0, 3), r22);
        const a2 = [0, 0, 0];
        e2.a6.vec3.scale(a2, i2.slice(0, 3), t22[2]);
        const n22 = [0, 0, 0];
        return e2.a6.vec3.add(n22, s2, a2), e2.cb(n22);
      }
      const Pr = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"], Mr = ["stars", "fillExtrusion", "fillExtrusionGroundEffect", "model", "symbol"];
      class zr {
        static cacheKey(e22, t22, i2, o2) {
          let r22 = "".concat(t22).concat(o2 ? o2.cacheKey : "");
          for (const t3 of i2)
            e22.usedDefines.includes(t3) && (r22 += "/".concat(t3));
          return r22;
        }
        constructor(t22, i2, o2, r22, s2, a2) {
          const n22 = t22.gl;
          this.program = n22.createProgram(), this.configuration = r22, this.name = i2, this.fixedDefines = [...a2];
          const l22 = r22 ? r22.getBinderAttributes() : [], c22 = (o2.staticAttributes || []).concat(l22);
          let h22 = r22 ? r22.defines() : [];
          h22 = h22.concat(a2.map((e22) => "#define ".concat(e22)));
          const u22 = "#version 300 es\n";
          let d22 = u22 + h22.concat("precision mediump float;", So, Co.fragmentSource).join("\n");
          for (const e22 of o2.fragmentIncludes)
            d22 += "\n".concat(To[e22]);
          d22 += "\n".concat(o2.fragmentSource);
          let _2 = u22 + h22.concat("precision highp float;", So, Co.vertexSource).join("\n");
          for (const e22 of o2.vertexIncludes)
            _2 += "\n".concat(To[e22]);
          _2 += "\n".concat(o2.vertexSource);
          const p22 = n22.createShader(n22.FRAGMENT_SHADER);
          if (n22.isContextLost())
            return void (this.failedToCreate = true);
          n22.shaderSource(p22, d22), n22.compileShader(p22), n22.attachShader(this.program, p22);
          const m22 = n22.createShader(n22.VERTEX_SHADER);
          if (n22.isContextLost())
            this.failedToCreate = true;
          else {
            n22.shaderSource(m22, _2), n22.compileShader(m22), n22.attachShader(this.program, m22), this.attributes = {}, this.numAttributes = c22.length;
            for (let e22 = 0; e22 < this.numAttributes; e22++)
              if (c22[e22]) {
                const t3 = c22[e22].startsWith("a_") ? c22[e22] : "a_".concat(c22[e22]);
                n22.bindAttribLocation(this.program, e22, t3), this.attributes[t3] = e22;
              }
            n22.linkProgram(this.program), n22.deleteShader(m22), n22.deleteShader(p22), this.fixedUniforms = s2(t22), this.binderUniforms = r22 ? r22.getUniforms(t22) : [], (a2.includes("TERRAIN") || -1 !== i2.indexOf("symbol") || -1 !== i2.indexOf("circle")) && (this.terrainUniforms = ((t3) => ({ u_dem: new e2.bJ(t3), u_dem_prev: new e2.bJ(t3), u_dem_tl: new e2.bG(t3), u_dem_scale: new e2.bI(t3), u_dem_tl_prev: new e2.bG(t3), u_dem_scale_prev: new e2.bI(t3), u_dem_size: new e2.bI(t3), u_dem_lerp: new e2.bI(t3), u_exaggeration: new e2.bI(t3), u_depth: new e2.bJ(t3), u_depth_size_inv: new e2.bG(t3), u_depth_range_unpack: new e2.bG(t3), u_occluder_half_size: new e2.bI(t3), u_occlusion_depth_offset: new e2.bI(t3), u_meter_to_dem: new e2.bI(t3), u_label_plane_matrix_inv: new e2.bF(t3) }))(t22)), a2.includes("GLOBE") && (this.globeUniforms = ((t3) => ({ u_tile_tl_up: new e2.bH(t3), u_tile_tr_up: new e2.bH(t3), u_tile_br_up: new e2.bH(t3), u_tile_bl_up: new e2.bH(t3), u_tile_up_scale: new e2.bI(t3) }))(t22)), a2.includes("FOG") && (this.fogUniforms = ((t3) => ({ u_fog_matrix: new e2.bF(t3), u_fog_range: new e2.bG(t3), u_fog_color: new e2.c6(t3), u_fog_horizon_blend: new e2.bI(t3), u_fog_vertical_limit: new e2.bG(t3), u_fog_temporal_offset: new e2.bI(t3), u_frustum_tl: new e2.bH(t3), u_frustum_tr: new e2.bH(t3), u_frustum_br: new e2.bH(t3), u_frustum_bl: new e2.bH(t3), u_globe_pos: new e2.bH(t3), u_globe_radius: new e2.bI(t3), u_globe_transition: new e2.bI(t3), u_is_globe: new e2.bJ(t3), u_viewport: new e2.bG(t3) }))(t22)), a2.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((t3) => ({ u_cutoff_params: new e2.c6(t3) }))(t22)), a2.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((t3) => ({ u_lighting_ambient_color: new e2.bH(t3), u_lighting_directional_dir: new e2.bH(t3), u_lighting_directional_color: new e2.bH(t3), u_ground_radiance: new e2.bH(t3) }))(t22)), a2.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((t3) => ({ u_light_matrix_0: new e2.bF(t3), u_light_matrix_1: new e2.bF(t3), u_fade_range: new e2.bG(t3), u_shadow_normal_offset: new e2.bH(t3), u_shadow_intensity: new e2.bI(t3), u_shadow_texel_size: new e2.bI(t3), u_shadow_map_resolution: new e2.bI(t3), u_shadow_direction: new e2.bH(t3), u_shadow_bias: new e2.bH(t3), u_shadowmap_0: new e2.bJ(t3), u_shadowmap_1: new e2.bJ(t3) }))(t22));
          }
        }
        setTerrainUniformValues(e22, t22) {
          if (!this.terrainUniforms)
            return;
          const i2 = this.terrainUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t22)
              i2[e3] && i2[e3].set(this.program, e3, t22[e3]);
          }
        }
        setGlobeUniformValues(e22, t22) {
          if (!this.globeUniforms)
            return;
          const i2 = this.globeUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t22)
              i2[e3] && i2[e3].set(this.program, e3, t22[e3]);
          }
        }
        setFogUniformValues(e22, t22) {
          if (!this.fogUniforms)
            return;
          const i2 = this.fogUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t22)
              i2[e3].set(this.program, e3, t22[e3]);
          }
        }
        setCutoffUniformValues(e22, t22) {
          if (!this.cutoffUniforms)
            return;
          const i2 = this.cutoffUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t22)
              i2[e3].set(this.program, e3, t22[e3]);
          }
        }
        setLightsUniformValues(e22, t22) {
          if (!this.lightsUniforms)
            return;
          const i2 = this.lightsUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t22)
              i2[e3].set(this.program, e3, t22[e3]);
          }
        }
        setShadowUniformValues(e22, t22) {
          if (this.failedToCreate || !this.shadowUniforms)
            return;
          const i2 = this.shadowUniforms;
          e22.program.set(this.program);
          for (const e3 in t22)
            i2[e3].set(this.program, e3, t22[e3]);
        }
        _drawDebugWireframe(t22, i2, o2, r22, s2, a2, n22, l22, c22, h22) {
          const u22 = t22.options.wireframe;
          if (false === u22.terrain && false === u22.layers2D && false === u22.layers3D)
            return;
          const d22 = t22.context;
          if (!(() => !(!u22.terrain || "terrainRaster" !== this.name && "globeRaster" !== this.name) || !(!u22.layers2D || t22._terrain && t22._terrain.renderingToTexture || !Pr.includes(this.name)) || !(!u22.layers3D || !Mr.includes(this.name)))())
            return;
          const _2 = d22.gl, p22 = t22.wireframeDebugCache.getLinesFromTrianglesBuffer(t22.frameCounter, s2, d22);
          if (!p22)
            return;
          const m22 = [...this.fixedDefines];
          m22.push("DEBUG_WIREFRAME");
          const f22 = t22.getOrCreateProgram(this.name, { config: this.configuration, defines: m22 });
          d22.program.set(f22.program);
          const g22 = (e22, t3, i3) => {
            if (t3[e22] && i3[e22])
              for (const o3 in t3[e22])
                i3[e22][o3] && i3[e22][o3].set(i3.program, o3, t3[e22][o3].current);
          };
          c22 && c22.setUniforms(f22.program, d22, f22.binderUniforms, n22, { zoom: l22 }), g22("fixedUniforms", this, f22), g22("terrainUniforms", this, f22), g22("globeUniforms", this, f22), g22("fogUniforms", this, f22), g22("lightsUniforms", this, f22), g22("shadowUniforms", this, f22), p22.bind(), d22.setColorMode(new Ai2([_2.ONE, _2.ONE_MINUS_SRC_ALPHA, _2.ZERO, _2.ONE], e2.bz.transparent, [true, true, true, false])), d22.setDepthMode(new Li2(i2.func === _2.LESS ? _2.LEQUAL : i2.func, Li2.ReadOnly, i2.range)), d22.setStencilMode(Mi2.disabled);
          const v22 = 3 * a2.primitiveLength * 2, x22 = 3 * a2.primitiveOffset * 2 * 2;
          h22 && h22 > 1 ? _2.drawElementsInstanced(_2.LINES, v22, _2.UNSIGNED_SHORT, x22, h22) : _2.drawElements(_2.LINES, v22, _2.UNSIGNED_SHORT, x22), s2.bind(), d22.program.set(this.program), d22.setDepthMode(i2), d22.setStencilMode(o2), d22.setColorMode(r22);
        }
        draw(e22, t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22, d22, _2, p22, m22) {
          const f22 = e22.context, g22 = f22.gl;
          if (this.failedToCreate)
            return;
          f22.program.set(this.program), f22.setDepthMode(i2), f22.setStencilMode(o2), f22.setColorMode(r22), f22.setCullFace(s2);
          for (const e3 of Object.keys(this.fixedUniforms))
            this.fixedUniforms[e3].set(this.program, e3, a2[e3]);
          _2 && _2.setUniforms(this.program, f22, this.binderUniforms, u22, { zoom: d22 });
          const v22 = { [g22.POINTS]: 1, [g22.LINES]: 2, [g22.TRIANGLES]: 3, [g22.LINE_STRIP]: 1 }[t22], x22 = m22 && m22 > 0 ? 1 : void 0;
          for (const s3 of h22.get()) {
            const a3 = s3.vaos || (s3.vaos = {});
            (a3[n22] || (a3[n22] = new Ao())).bind(f22, this, l22, _2 ? _2.getPaintVertexBuffers() : [], c22, s3.vertexOffset, p22 || [], x22), m22 && m22 > 1 ? g22.drawElementsInstanced(t22, s3.primitiveLength * v22, g22.UNSIGNED_SHORT, s3.primitiveOffset * v22 * 2, m22) : c22 ? g22.drawElements(t22, s3.primitiveLength * v22, g22.UNSIGNED_SHORT, s3.primitiveOffset * v22 * 2) : g22.drawArrays(t22, s3.vertexOffset, s3.vertexLength), t22 === g22.TRIANGLES && c22 && this._drawDebugWireframe(e22, i2, o2, r22, c22, s3, u22, d22, _2, m22);
          }
        }
      }
      function Or(t22, i2) {
        const o2 = Math.pow(2, i2.tileID.overscaledZ), r22 = i2.tileSize * Math.pow(2, t22.transform.tileZoom) / o2, s2 = r22 * (i2.tileID.canonical.x + i2.tileID.wrap * o2), a2 = r22 * i2.tileID.canonical.y;
        return { u_image: 0, u_texsize: i2.imageAtlasTexture ? i2.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / e2.ak(i2, 1, t22.transform.tileZoom), u_pixel_coord_upper: [s2 >> 16, a2 >> 16], u_pixel_coord_lower: [65535 & s2, 65535 & a2] };
      }
      const Fr = e2.a6.mat4.create(), kr = (t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22, d22, _2, p22, m22, f22) => {
        const g22 = i2.style.light, v22 = g22.properties.get("position"), x22 = [v22.x, v22.y, v22.z], y22 = e2.a6.mat3.create();
        "viewport" === g22.properties.get("anchor") && (e2.a6.mat3.fromRotation(y22, -i2.transform.angle), e2.a6.vec3.transformMat3(x22, x22, y22));
        const b22 = g22.properties.get("color"), w22 = i2.transform, T22 = { u_matrix: t22, u_lightpos: x22, u_lightintensity: g22.properties.get("intensity"), u_lightcolor: [b22.r, b22.g, b22.b], u_vertical_gradient: +o2, u_opacity: r22, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Fr, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: s2, u_edge_radius: a2, u_width_scale: n22, u_flood_light_color: _2, u_vertical_scale: p22, u_flood_light_intensity: m22, u_ground_shadow_factor: f22 };
        return "globe" === w22.projection.name && (T22.u_tile_id = [l22.canonical.x, l22.canonical.y, 1 << l22.canonical.z], T22.u_zoom_transition = h22, T22.u_inv_rot_matrix = d22, T22.u_merc_center = u22, T22.u_up_dir = w22.projection.upVector(new e2.bP(0, 0, 0), u22[0] * e2.ab, u22[1] * e2.ab), T22.u_height_lift = c22), T22;
      }, Br = (e22, t22, i2, o2) => ({ u_matrix: e22, u_edge_radius: t22, u_width_scale: i2, u_vertical_scale: o2 }), Nr = (t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22, d22, _2, p22, m22) => {
        const f22 = kr(t22, i2, o2, r22, s2, a2, n22, l22, h22, u22, d22, _2, p22, m22, 1, [0, 0, 0]), g22 = { u_height_factor: -Math.pow(2, l22.overscaledZ) / c22.tileSize / 8 };
        return e2.l(f22, Or(i2, c22), g22);
      }, Ur = (e22, t22) => ({ u_matrix: e22, u_emissive_strength: t22 }), Gr = (t22, i2, o2, r22) => e2.l(Ur(t22, i2), Or(o2, r22)), jr = (e22, t22, i2) => ({ u_matrix: e22, u_world: i2, u_emissive_strength: t22 }), Vr = (t22, i2, o2, r22, s2) => e2.l(Gr(t22, i2, o2, r22), { u_world: s2 }), qr = (t22, i2, o2, r22) => {
        const s2 = e2.ab / o2.tileSize;
        return { u_matrix: t22, u_camera_to_center_distance: i2.getCameraToCenterDistance(r22), u_extrude_scale: [i2.pixelsToGLUnits[0] / s2, i2.pixelsToGLUnits[1] / s2] };
      }, Zr = (e22, t22, i2 = 1) => ({ u_matrix: e22, u_color: t22.toRenderColor(null), u_overlay: 0, u_overlay_scale: i2 }), Hr = e2.a6.mat4.create(), Wr = (t22, i2, o2, r22, s2, a2, n22) => {
        const l22 = t22.transform, c22 = "globe" === l22.projection.name, h22 = c22 ? e2.cI(l22.zoom, i2.canonical) * l22._pixelsPerMercatorPixel : e2.ak(o2, 1, a2), u22 = { u_matrix: i2.projMatrix, u_extrude_scale: h22, u_intensity: n22, u_inv_rot_matrix: Hr, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
        if (c22) {
          u22.u_inv_rot_matrix = r22, u22.u_merc_center = s2, u22.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], u22.u_zoom_transition = e2.a9(l22.zoom);
          const t3 = s2[0] * e2.ab, o3 = s2[1] * e2.ab;
          u22.u_up_dir = l22.projection.upVector(new e2.bP(0, 0, 0), t3, o3);
        }
        return u22;
      };
      function $r(e22, [t22, i2, o2, r22], [s2, a2]) {
        if (s2 === a2)
          return [0, 0, 0, 0];
        const n22 = 255 * (e22 - 1) / (e22 * (a2 - s2));
        return [t22 * n22, i2 * n22, o2 * n22, r22 * n22];
      }
      function Xr(e22, t22, [i2, o2]) {
        return i2 === o2 ? 0 : 0.5 / e22 + (t22 - i2) * (e22 - 1) / (e22 * (o2 - i2));
      }
      const Yr = (t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22, d22, _2, p22, m22, f22, g22, v22, x22, y22, b22) => ({ u_matrix: t22, u_normalize_matrix: i2, u_globe_matrix: o2, u_merc_matrix: r22, u_grid_matrix: s2, u_tl_parent: a2, u_scale_parent: h22, u_fade_t: u22.mix, u_opacity: u22.opacity * d22.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: d22.paint.get("raster-brightness-min"), u_brightness_high: d22.paint.get("raster-brightness-max"), u_saturation_factor: e2.cJ(d22.paint.get("raster-saturation")), u_contrast_factor: e2.cK(d22.paint.get("raster-contrast")), u_spin_weights: Kr(d22.paint.get("raster-hue-rotate")), u_perspective_transform: _2, u_raster_elevation: p22, u_zoom_transition: n22, u_merc_center: l22, u_cutoff_params: c22, u_colorization_mix: $r(e2.cL, f22, v22), u_colorization_offset: Xr(e2.cL, g22, v22), u_color_ramp: m22, u_texture_offset: [y22 / (x22 + 2 * y22), x22 / (x22 + 2 * y22)], u_texture_res: [x22 + 2 * y22, x22 + 2 * y22], u_emissive_strength: b22 });
      function Kr(e22) {
        e22 *= Math.PI / 180;
        const t22 = Math.sin(e22), i2 = Math.cos(e22);
        return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t22 - i2 + 1) / 3, (Math.sqrt(3) * t22 - i2 + 1) / 3];
      }
      const Jr = 0.05, Qr = (e22, t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22) => ({ u_matrix: e22, u_normalize_matrix: t22, u_globe_matrix: i2, u_merc_matrix: o2, u_grid_matrix: r22, u_tl_parent: s2, u_scale_parent: c22, u_fade_t: h22.mix, u_opacity: h22.opacity, u_image0: 0, u_image1: 1, u_raster_elevation: u22, u_zoom_transition: a2, u_merc_center: n22, u_cutoff_params: l22 }), es = (e22, t22, i2, o2, r22, s2, a2, n22, l22, c22) => ({ u_particle_texture: e22, u_particle_texture_side_len: t22, u_tile_offset: i2, u_velocity: o2, u_color_ramp: s2, u_velocity_res: r22, u_max_speed: a2, u_uv_offset: n22, u_data_scale: [255 * l22[0], 255 * l22[1]], u_data_offset: c22, u_particle_pos_scale: 1.1, u_particle_pos_offset: [Jr, Jr] }), ts = (e22, t22, i2, o2, r22, s2, a2, n22, l22, c22) => ({ u_particle_texture: e22, u_particle_texture_side_len: t22, u_velocity: i2, u_velocity_res: o2, u_max_speed: r22, u_speed_factor: s2, u_reset_rate: a2, u_rand_seed: Math.random(), u_uv_offset: n22, u_data_scale: [255 * l22[0], 255 * l22[1]], u_data_offset: c22, u_particle_pos_scale: 1.1, u_particle_pos_offset: [Jr, Jr] }), is = e2.a6.mat4.create(), os = (t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22, d22, _2, p22, m22, f22, g22, v22, x22, y22, b22) => {
        const w22 = s2.transform, T22 = { u_is_size_zoom_constant: +("constant" === t22 || "source" === t22), u_is_size_feature_constant: +("constant" === t22 || "camera" === t22), u_size_t: i2 ? i2.uSizeT : 0, u_size: i2 ? i2.uSize : 0, u_camera_to_center_distance: w22.getCameraToCenterDistance(x22), u_rotate_symbol: +o2, u_aspect_ratio: w22.width / w22.height, u_fade_change: s2.options.fadeDuration ? s2.symbolFadeChange : 1, u_matrix: a2, u_label_plane_matrix: n22, u_coord_matrix: l22, u_is_text: +h22, u_elevation_from_sea: c22 ? 1 : 0, u_pitch_with_map: +r22, u_texsize: u22, u_texsize_icon: d22, u_texture: 0, u_texture_icon: 1, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: is, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: is, u_up_vector: [0, -1, 0], u_color_adj_mat: y22, u_icon_transition: b22 || 0, u_gamma_scale: r22 ? s2.transform.getCameraToCenterDistance(x22) * Math.cos(s2.terrain ? 0 : s2.transform._pitch) : 1, u_device_pixel_ratio: e2.q.devicePixelRatio, u_is_halo: +_2 };
        return "globe" === x22.name && (T22.u_tile_id = [p22.canonical.x, p22.canonical.y, 1 << p22.canonical.z], T22.u_zoom_transition = m22, T22.u_inv_rot_matrix = g22, T22.u_merc_center = f22, T22.u_camera_forward = w22._camera.forward(), T22.u_ecef_origin = e2.cM(w22.globeMatrix, p22.toUnwrapped()), T22.u_tile_matrix = Float32Array.from(w22.globeMatrix), T22.u_up_vector = v22), T22;
      }, rs = (e22, t22, i2, o2) => ({ u_matrix: e22, u_emissive_strength: t22, u_opacity: i2, u_color: o2 }), ss = (t22, i2, o2, r22, s2, a2, n22, l22, c22) => e2.l(function(t3, i3, o3, r3, s3, a3) {
        const { width: n3, height: l3 } = r3.imageManager.getPixelSize(i3), c3 = Math.pow(2, a3.tileID.overscaledZ), h22 = a3.tileSize * Math.pow(2, r3.transform.tileZoom) / c3, u22 = h22 * (a3.tileID.canonical.x + a3.tileID.wrap * c3), d22 = h22 * a3.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl: o3.tl, u_pattern_br: o3.br, u_texsize: [n3, l3], u_pattern_size: o3.displaySize, u_pattern_units_to_pixels: s3 ? [r3.transform.width, -1 * r3.transform.height] : [1 / e2.ak(a3, 1, r3.transform.tileZoom), 1 / e2.ak(a3, 1, r3.transform.tileZoom)], u_pixel_coord_upper: [u22 >> 16, d22 >> 16], u_pixel_coord_lower: [65535 & u22, 65535 & d22] };
      }(0, a2, n22, r22, l22, c22), { u_matrix: t22, u_emissive_strength: i2, u_opacity: o2 }), as = new Float32Array(e2.a6.mat4.identity([])), ns = (t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22, d22, _2, p22 = [0, 0, 0], m22) => {
        const f22 = s2.style.light, g22 = f22.properties.get("position"), v22 = [-g22.x, -g22.y, g22.z], x22 = e2.a6.mat3.create();
        "viewport" === f22.properties.get("anchor") && (e2.a6.mat3.fromRotation(x22, -s2.transform.angle), e2.a6.vec3.transformMat3(v22, v22, x22));
        const y22 = "MASK" === u22.alphaMode, b22 = f22.properties.get("color").toRenderColor(null), w22 = _2.paint.get("model-ambient-occlusion-intensity"), T22 = _2.paint.get("model-color").constantOr(e2.bz.white).toRenderColor(null), E22 = _2.paint.get("model-color-mix-intensity").constantOr(0);
        return { u_matrix: t22, u_lighting_matrix: i2, u_normal_matrix: o2, u_node_matrix: r22 || as, u_lightpos: v22, u_lightintensity: f22.properties.get("intensity"), u_lightcolor: [b22.r, b22.g, b22.b], u_camera_pos: p22, u_opacity: a2, u_baseTextureIsAlpha: 0, u_alphaMask: +y22, u_alphaCutoff: u22.alphaCutoff, u_baseColorFactor: [n22.r, n22.g, n22.b, n22.a], u_emissiveFactor: [l22[0], l22[1], l22[2], 1], u_metallicFactor: c22, u_roughnessFactor: h22, u_baseColorTexture: ji2.BaseColor, u_metallicRoughnessTexture: ji2.MetallicRoughness, u_normalTexture: ji2.Normal, u_occlusionTexture: ji2.Occlusion, u_emissionTexture: ji2.Emission, u_lutTexture: ji2.LUT, u_color_mix: [T22.r, T22.g, T22.b, E22], u_aoIntensity: w22, u_emissive_strength: d22, u_occlusionTextureTransform: m22 || [0, 0, 0, 0] };
      }, ls = (e22, t22 = as, i2 = as) => ({ u_matrix: e22, u_instance: t22, u_node_matrix: i2 }), cs = { fillExtrusion: (t22) => ({ u_matrix: new e2.bF(t22), u_lightpos: new e2.bH(t22), u_lightintensity: new e2.bI(t22), u_lightcolor: new e2.bH(t22), u_vertical_gradient: new e2.bI(t22), u_opacity: new e2.bI(t22), u_edge_radius: new e2.bI(t22), u_width_scale: new e2.bI(t22), u_ao: new e2.bG(t22), u_tile_id: new e2.bH(t22), u_zoom_transition: new e2.bI(t22), u_inv_rot_matrix: new e2.bF(t22), u_merc_center: new e2.bG(t22), u_up_dir: new e2.bH(t22), u_height_lift: new e2.bI(t22), u_flood_light_color: new e2.bH(t22), u_vertical_scale: new e2.bI(t22), u_flood_light_intensity: new e2.bI(t22), u_ground_shadow_factor: new e2.bH(t22) }), fillExtrusionDepth: (t22) => ({ u_matrix: new e2.bF(t22), u_edge_radius: new e2.bI(t22), u_width_scale: new e2.bI(t22), u_vertical_scale: new e2.bI(t22) }), fillExtrusionPattern: (t22) => ({ u_matrix: new e2.bF(t22), u_lightpos: new e2.bH(t22), u_lightintensity: new e2.bI(t22), u_lightcolor: new e2.bH(t22), u_vertical_gradient: new e2.bI(t22), u_height_factor: new e2.bI(t22), u_edge_radius: new e2.bI(t22), u_width_scale: new e2.bI(t22), u_ao: new e2.bG(t22), u_tile_id: new e2.bH(t22), u_zoom_transition: new e2.bI(t22), u_inv_rot_matrix: new e2.bF(t22), u_merc_center: new e2.bG(t22), u_up_dir: new e2.bH(t22), u_height_lift: new e2.bI(t22), u_image: new e2.bJ(t22), u_texsize: new e2.bG(t22), u_pixel_coord_upper: new e2.bG(t22), u_pixel_coord_lower: new e2.bG(t22), u_tile_units_to_pixels: new e2.bI(t22), u_opacity: new e2.bI(t22) }), fillExtrusionGroundEffect: (t22) => ({ u_matrix: new e2.bF(t22), u_opacity: new e2.bI(t22), u_ao_pass: new e2.bI(t22), u_meter_to_tile: new e2.bI(t22), u_ao: new e2.bG(t22), u_flood_light_intensity: new e2.bI(t22), u_flood_light_color: new e2.bH(t22), u_attenuation: new e2.bI(t22), u_edge_radius: new e2.bI(t22), u_fb: new e2.bJ(t22), u_fb_size: new e2.bI(t22), u_dynamic_offset: new e2.bI(t22) }), fill: (t22) => ({ u_matrix: new e2.bF(t22), u_emissive_strength: new e2.bI(t22) }), fillPattern: (t22) => ({ u_matrix: new e2.bF(t22), u_emissive_strength: new e2.bI(t22), u_image: new e2.bJ(t22), u_texsize: new e2.bG(t22), u_pixel_coord_upper: new e2.bG(t22), u_pixel_coord_lower: new e2.bG(t22), u_tile_units_to_pixels: new e2.bI(t22) }), fillOutline: (t22) => ({ u_matrix: new e2.bF(t22), u_emissive_strength: new e2.bI(t22), u_world: new e2.bG(t22) }), fillOutlinePattern: (t22) => ({ u_matrix: new e2.bF(t22), u_emissive_strength: new e2.bI(t22), u_world: new e2.bG(t22), u_image: new e2.bJ(t22), u_texsize: new e2.bG(t22), u_pixel_coord_upper: new e2.bG(t22), u_pixel_coord_lower: new e2.bG(t22), u_tile_units_to_pixels: new e2.bI(t22) }), circle: e2.cN, collisionBox: (t22) => ({ u_matrix: new e2.bF(t22), u_camera_to_center_distance: new e2.bI(t22), u_extrude_scale: new e2.bG(t22) }), collisionCircle: (t22) => ({ u_matrix: new e2.bF(t22), u_inv_matrix: new e2.bF(t22), u_camera_to_center_distance: new e2.bI(t22), u_viewport_size: new e2.bG(t22) }), debug: (t22) => ({ u_color: new e2.cu(t22), u_matrix: new e2.bF(t22), u_overlay: new e2.bJ(t22), u_overlay_scale: new e2.bI(t22) }), clippingMask: (t22) => ({ u_matrix: new e2.bF(t22) }), heatmap: (t22) => ({ u_extrude_scale: new e2.bI(t22), u_intensity: new e2.bI(t22), u_matrix: new e2.bF(t22), u_inv_rot_matrix: new e2.bF(t22), u_merc_center: new e2.bG(t22), u_tile_id: new e2.bH(t22), u_zoom_transition: new e2.bI(t22), u_up_dir: new e2.bH(t22) }), heatmapTexture: (t22) => ({ u_image: new e2.bJ(t22), u_color_ramp: new e2.bJ(t22), u_opacity: new e2.bI(t22) }), hillshade: (t22) => ({ u_matrix: new e2.bF(t22), u_image: new e2.bJ(t22), u_latrange: new e2.bG(t22), u_light: new e2.bG(t22), u_shadow: new e2.cu(t22), u_highlight: new e2.cu(t22), u_emissive_strength: new e2.bI(t22), u_accent: new e2.cu(t22) }), hillshadePrepare: (t22) => ({ u_matrix: new e2.bF(t22), u_image: new e2.bJ(t22), u_dimension: new e2.bG(t22), u_zoom: new e2.bI(t22) }), line: e2.cO, linePattern: e2.cP, raster: (t22) => ({ u_matrix: new e2.bF(t22), u_normalize_matrix: new e2.bF(t22), u_globe_matrix: new e2.bF(t22), u_merc_matrix: new e2.bF(t22), u_grid_matrix: new e2.cv(t22), u_tl_parent: new e2.bG(t22), u_scale_parent: new e2.bI(t22), u_fade_t: new e2.bI(t22), u_opacity: new e2.bI(t22), u_image0: new e2.bJ(t22), u_image1: new e2.bJ(t22), u_brightness_low: new e2.bI(t22), u_brightness_high: new e2.bI(t22), u_saturation_factor: new e2.bI(t22), u_contrast_factor: new e2.bI(t22), u_spin_weights: new e2.bH(t22), u_perspective_transform: new e2.bG(t22), u_raster_elevation: new e2.bI(t22), u_zoom_transition: new e2.bI(t22), u_merc_center: new e2.bG(t22), u_cutoff_params: new e2.c6(t22), u_colorization_mix: new e2.c6(t22), u_colorization_offset: new e2.bI(t22), u_color_ramp: new e2.bJ(t22), u_texture_offset: new e2.bG(t22), u_texture_res: new e2.bG(t22), u_emissive_strength: new e2.bI(t22) }), rasterParticle: (t22) => ({ u_matrix: new e2.bF(t22), u_normalize_matrix: new e2.bF(t22), u_globe_matrix: new e2.bF(t22), u_merc_matrix: new e2.bF(t22), u_grid_matrix: new e2.cv(t22), u_tl_parent: new e2.bG(t22), u_scale_parent: new e2.bI(t22), u_fade_t: new e2.bI(t22), u_opacity: new e2.bI(t22), u_image0: new e2.bJ(t22), u_image1: new e2.bJ(t22), u_raster_elevation: new e2.bI(t22), u_zoom_transition: new e2.bI(t22), u_merc_center: new e2.bG(t22), u_cutoff_params: new e2.c6(t22) }), rasterParticleTexture: (t22) => ({ u_texture: new e2.bJ(t22), u_opacity: new e2.bI(t22) }), rasterParticleDraw: (t22) => ({ u_particle_texture: new e2.bJ(t22), u_particle_texture_side_len: new e2.bI(t22), u_tile_offset: new e2.bG(t22), u_velocity: new e2.bJ(t22), u_color_ramp: new e2.bJ(t22), u_velocity_res: new e2.bG(t22), u_max_speed: new e2.bI(t22), u_uv_offset: new e2.bG(t22), u_data_scale: new e2.bG(t22), u_data_offset: new e2.bI(t22), u_particle_pos_scale: new e2.bI(t22), u_particle_pos_offset: new e2.bG(t22) }), rasterParticleUpdate: (t22) => ({ u_particle_texture: new e2.bJ(t22), u_particle_texture_side_len: new e2.bI(t22), u_velocity: new e2.bJ(t22), u_velocity_res: new e2.bG(t22), u_max_speed: new e2.bI(t22), u_speed_factor: new e2.bI(t22), u_reset_rate: new e2.bI(t22), u_rand_seed: new e2.bI(t22), u_uv_offset: new e2.bG(t22), u_data_scale: new e2.bG(t22), u_data_offset: new e2.bI(t22), u_particle_pos_scale: new e2.bI(t22), u_particle_pos_offset: new e2.bG(t22) }), symbol: (t22) => ({ u_is_size_zoom_constant: new e2.bJ(t22), u_is_size_feature_constant: new e2.bJ(t22), u_size_t: new e2.bI(t22), u_size: new e2.bI(t22), u_camera_to_center_distance: new e2.bI(t22), u_rotate_symbol: new e2.bJ(t22), u_aspect_ratio: new e2.bI(t22), u_fade_change: new e2.bI(t22), u_matrix: new e2.bF(t22), u_label_plane_matrix: new e2.bF(t22), u_coord_matrix: new e2.bF(t22), u_is_text: new e2.bJ(t22), u_elevation_from_sea: new e2.bJ(t22), u_pitch_with_map: new e2.bJ(t22), u_texsize: new e2.bG(t22), u_texsize_icon: new e2.bG(t22), u_texture: new e2.bJ(t22), u_texture_icon: new e2.bJ(t22), u_gamma_scale: new e2.bI(t22), u_device_pixel_ratio: new e2.bI(t22), u_tile_id: new e2.bH(t22), u_zoom_transition: new e2.bI(t22), u_inv_rot_matrix: new e2.bF(t22), u_merc_center: new e2.bG(t22), u_camera_forward: new e2.bH(t22), u_tile_matrix: new e2.bF(t22), u_up_vector: new e2.bH(t22), u_ecef_origin: new e2.bH(t22), u_is_halo: new e2.bJ(t22), u_icon_transition: new e2.bI(t22), u_color_adj_mat: new e2.bF(t22) }), background: (t22) => ({ u_matrix: new e2.bF(t22), u_emissive_strength: new e2.bI(t22), u_opacity: new e2.bI(t22), u_color: new e2.cu(t22) }), backgroundPattern: (t22) => ({ u_matrix: new e2.bF(t22), u_emissive_strength: new e2.bI(t22), u_opacity: new e2.bI(t22), u_image: new e2.bJ(t22), u_pattern_tl: new e2.bG(t22), u_pattern_br: new e2.bG(t22), u_texsize: new e2.bG(t22), u_pattern_size: new e2.bG(t22), u_pixel_coord_upper: new e2.bG(t22), u_pixel_coord_lower: new e2.bG(t22), u_pattern_units_to_pixels: new e2.bG(t22) }), terrainRaster: (t22) => ({ u_matrix: new e2.bF(t22), u_image0: new e2.bJ(t22), u_skirt_height: new e2.bI(t22), u_ground_shadow_factor: new e2.bH(t22) }), skybox: (t22) => ({ u_matrix: new e2.bF(t22), u_sun_direction: new e2.bH(t22), u_cubemap: new e2.bJ(t22), u_opacity: new e2.bI(t22), u_temporal_offset: new e2.bI(t22) }), skyboxGradient: (t22) => ({ u_matrix: new e2.bF(t22), u_color_ramp: new e2.bJ(t22), u_center_direction: new e2.bH(t22), u_radius: new e2.bI(t22), u_opacity: new e2.bI(t22), u_temporal_offset: new e2.bI(t22) }), skyboxCapture: (t22) => ({ u_matrix_3f: new e2.cv(t22), u_sun_direction: new e2.bH(t22), u_sun_intensity: new e2.bI(t22), u_color_tint_r: new e2.c6(t22), u_color_tint_m: new e2.c6(t22), u_luminance: new e2.bI(t22) }), globeRaster: (t22) => ({ u_proj_matrix: new e2.bF(t22), u_globe_matrix: new e2.bF(t22), u_normalize_matrix: new e2.bF(t22), u_merc_matrix: new e2.bF(t22), u_zoom_transition: new e2.bI(t22), u_merc_center: new e2.bG(t22), u_image0: new e2.bJ(t22), u_grid_matrix: new e2.cv(t22), u_skirt_height: new e2.bI(t22), u_far_z_cutoff: new e2.bI(t22), u_frustum_tl: new e2.bH(t22), u_frustum_tr: new e2.bH(t22), u_frustum_br: new e2.bH(t22), u_frustum_bl: new e2.bH(t22), u_globe_pos: new e2.bH(t22), u_globe_radius: new e2.bI(t22), u_viewport: new e2.bG(t22) }), globeAtmosphere: (t22) => ({ u_frustum_tl: new e2.bH(t22), u_frustum_tr: new e2.bH(t22), u_frustum_br: new e2.bH(t22), u_frustum_bl: new e2.bH(t22), u_horizon: new e2.bI(t22), u_transition: new e2.bI(t22), u_fadeout_range: new e2.bI(t22), u_color: new e2.c6(t22), u_high_color: new e2.c6(t22), u_space_color: new e2.c6(t22), u_temporal_offset: new e2.bI(t22), u_horizon_angle: new e2.bI(t22) }), model: (t22) => ({ u_matrix: new e2.bF(t22), u_lighting_matrix: new e2.bF(t22), u_normal_matrix: new e2.bF(t22), u_node_matrix: new e2.bF(t22), u_lightpos: new e2.bH(t22), u_lightintensity: new e2.bI(t22), u_lightcolor: new e2.bH(t22), u_camera_pos: new e2.bH(t22), u_opacity: new e2.bI(t22), u_baseColorFactor: new e2.c6(t22), u_emissiveFactor: new e2.c6(t22), u_metallicFactor: new e2.bI(t22), u_roughnessFactor: new e2.bI(t22), u_baseTextureIsAlpha: new e2.bJ(t22), u_alphaMask: new e2.bJ(t22), u_alphaCutoff: new e2.bI(t22), u_baseColorTexture: new e2.bJ(t22), u_metallicRoughnessTexture: new e2.bJ(t22), u_normalTexture: new e2.bJ(t22), u_occlusionTexture: new e2.bJ(t22), u_emissionTexture: new e2.bJ(t22), u_lutTexture: new e2.bJ(t22), u_color_mix: new e2.c6(t22), u_aoIntensity: new e2.bI(t22), u_emissive_strength: new e2.bI(t22), u_occlusionTextureTransform: new e2.c6(t22) }), modelDepth: (t22) => ({ u_matrix: new e2.bF(t22), u_instance: new e2.bF(t22), u_node_matrix: new e2.bF(t22) }), groundShadow: (t22) => ({ u_matrix: new e2.bF(t22), u_ground_shadow_factor: new e2.bH(t22) }), stars: (t22) => ({ u_matrix: new e2.bF(t22), u_up: new e2.bH(t22), u_right: new e2.bH(t22), u_intensity_multiplier: new e2.bI(t22) }), occlusion: (t22) => ({ u_matrix: new e2.bF(t22), u_anchorPos: new e2.bH(t22), u_screenSizePx: new e2.bG(t22), u_occluderSizePx: new e2.bG(t22), u_color: new e2.c6(t22) }) };
      class hs {
        constructor(e22, t22, i2, o2) {
          this.id = hs.uniqueIdxCounter, hs.uniqueIdxCounter++, this.context = e22;
          const r22 = e22.gl;
          this.buffer = r22.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e22.bindElementBuffer.set(this.buffer), r22.bufferData(r22.ELEMENT_ARRAY_BUFFER, t22.arrayBuffer, this.dynamicDraw ? r22.DYNAMIC_DRAW : r22.STATIC_DRAW), this.dynamicDraw || o2 || t22.destroy();
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(e22) {
          this.id = hs.uniqueIdxCounter, hs.uniqueIdxCounter++;
          const t22 = this.context.gl;
          this.context.unbindVAO(), this.bind(), t22.bufferSubData(t22.ELEMENT_ARRAY_BUFFER, 0, e22.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      hs.uniqueIdxCounter = 0;
      const us = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class ds {
        constructor(e22, t22, i2, o2, r22, s2) {
          this.length = t22.length, this.attributes = i2, this.itemSize = t22.bytesPerElement, this.dynamicDraw = o2, this.instanceCount = s2, this.context = e22;
          const a2 = e22.gl;
          this.buffer = a2.createBuffer(), e22.bindVertexBuffer.set(this.buffer), a2.bufferData(a2.ARRAY_BUFFER, t22.arrayBuffer, this.dynamicDraw ? a2.DYNAMIC_DRAW : a2.STATIC_DRAW), this.dynamicDraw || r22 || t22.destroy();
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(e22) {
          const t22 = this.context.gl;
          this.bind(), t22.bufferSubData(t22.ARRAY_BUFFER, 0, e22.arrayBuffer);
        }
        enableAttributes(e22, t22) {
          for (let i2 = 0; i2 < this.attributes.length; i2++) {
            const o2 = t22.attributes[this.attributes[i2].name];
            void 0 !== o2 && e22.enableVertexAttribArray(o2);
          }
        }
        setVertexAttribPointers(e22, t22, i2) {
          for (let o2 = 0; o2 < this.attributes.length; o2++) {
            const r22 = this.attributes[o2], s2 = t22.attributes[r22.name];
            void 0 !== s2 && e22.vertexAttribPointer(s2, r22.components, e22[us[r22.type]], false, this.itemSize, r22.offset + this.itemSize * (i2 || 0));
          }
        }
        setVertexAttribDivisor(e22, t22, i2) {
          for (let o2 = 0; o2 < this.attributes.length; o2++) {
            const r22 = t22.attributes[this.attributes[o2].name];
            void 0 !== r22 && this.instanceCount && this.instanceCount > 0 && e22.vertexAttribDivisor(r22, i2);
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class _s {
        constructor(e22, t22, i2, o2, r22) {
          this.context = e22, this.width = t22, this.height = i2;
          const s2 = this.framebuffer = e22.gl.createFramebuffer();
          o2 && (this.colorAttachment = new pr(e22, s2)), r22 && (this.depthAttachmentType = r22, this.depthAttachment = "renderbuffer" === r22 ? new mr(e22, s2) : new fr(e22, s2));
        }
        destroy() {
          const e22 = this.context.gl;
          if (this.colorAttachment) {
            const t22 = this.colorAttachment.get();
            t22 && e22.deleteTexture(t22);
          }
          if (this.depthAttachment && this.depthAttachmentType)
            if ("renderbuffer" === this.depthAttachmentType) {
              const t22 = this.depthAttachment.get();
              t22 && e22.deleteRenderbuffer(t22);
            } else {
              const t22 = this.depthAttachment.get();
              t22 && e22.deleteTexture(t22);
            }
          e22.deleteFramebuffer(this.framebuffer);
        }
      }
      class ps {
        constructor(e22, t22) {
          this.gl = e22, this.clearColor = new Fo(this), this.clearDepth = new ko(this), this.clearStencil = new Bo(this), this.colorMask = new No(this), this.depthMask = new Uo(this), this.stencilMask = new Go(this), this.stencilFunc = new jo(this), this.stencilOp = new Vo(this), this.stencilTest = new qo(this), this.depthRange = new Zo(this), this.depthTest = new Ho(this), this.depthFunc = new Wo(this), this.blend = new $o(this), this.blendFunc = new Xo(this), this.blendColor = new Yo(this), this.blendEquation = new Ko(this), this.cullFace = new Jo(this), this.cullFaceSide = new Qo(this), this.frontFace = new er(this), this.program = new tr(this), this.activeTexture = new ir(this), this.viewport = new or(this), this.bindFramebuffer = new rr(this), this.bindRenderbuffer = new sr(this), this.bindTexture = new ar(this), this.bindVertexBuffer = new nr(this), this.bindElementBuffer = new lr(this), this.bindVertexArrayOES = new cr(this), this.pixelStoreUnpack = new hr(this), this.pixelStoreUnpackPremultiplyAlpha = new ur(this), this.pixelStoreUnpackFlipY = new dr(this), this.options = t22 ? { ...t22 } : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e22.getExtension("EXT_texture_filter_anisotropic") || e22.getExtension("MOZ_EXT_texture_filter_anisotropic") || e22.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e22.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e22.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e22.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e22.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e22.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = e22.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = e22.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = e22.getParameter(e22.MAX_TEXTURE_SIZE), this.maxPointSize = e22.getParameter(e22.ALIASED_POINT_SIZE_RANGE)[1];
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArrayOES.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }
        createIndexBuffer(e22, t22, i2) {
          return new hs(this, e22, t22, i2);
        }
        createVertexBuffer(e22, t22, i2, o2, r22) {
          return new ds(this, e22, t22, i2, o2, r22);
        }
        createRenderbuffer(e22, t22, i2) {
          const o2 = this.gl, r22 = o2.createRenderbuffer();
          return this.bindRenderbuffer.set(r22), o2.renderbufferStorage(o2.RENDERBUFFER, e22, t22, i2), this.bindRenderbuffer.set(null), r22;
        }
        createFramebuffer(e22, t22, i2, o2) {
          return new _s(this, e22, t22, i2, o2);
        }
        clear({ color: e22, depth: t22, stencil: i2, colorMask: o2 }) {
          const r22 = this.gl;
          let s2 = 0;
          e22 && (s2 |= r22.COLOR_BUFFER_BIT, this.clearColor.set(e22), this.colorMask.set(o2 || [true, true, true, true])), void 0 !== t22 && (s2 |= r22.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t22), this.depthMask.set(true)), void 0 !== i2 && (s2 |= r22.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), r22.clear(s2);
        }
        setCullFace(e22) {
          false === e22.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e22.mode), this.frontFace.set(e22.frontFace));
        }
        setDepthMode(e22) {
          e22.func !== this.gl.ALWAYS || e22.mask ? (this.depthTest.set(true), this.depthFunc.set(e22.func), this.depthMask.set(e22.mask), this.depthRange.set(e22.range)) : this.depthTest.set(false);
        }
        setStencilMode(e22) {
          e22.test.func !== this.gl.ALWAYS || e22.mask ? (this.stencilTest.set(true), this.stencilMask.set(e22.mask), this.stencilOp.set([e22.fail, e22.depthFail, e22.pass]), this.stencilFunc.set({ func: e22.test.func, ref: e22.ref, mask: e22.test.mask })) : this.stencilTest.set(false);
        }
        setColorMode(t22) {
          e2.bh(t22.blendFunction, Ai2.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t22.blendFunction), this.blendColor.set(t22.blendColor), t22.blendEquation ? this.blendEquation.set(t22.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t22.mask);
        }
        unbindVAO() {
          this.bindVertexArrayOES.set(null);
        }
      }
      let ms;
      function fs(t22, i2, o2, r22, s2, a2, n22) {
        const l22 = t22.context, c22 = l22.gl, h22 = t22.transform, u22 = t22.getOrCreateProgram("collisionBox"), d22 = [];
        let _2 = 0, p22 = 0;
        for (let l3 = 0; l3 < r22.length; l3++) {
          const m3 = r22[l3], f3 = i2.getTile(m3), g3 = f3.getBucket(o2);
          if (!g3)
            continue;
          const v3 = ti2(m3, g3, h22);
          let x3 = v3;
          0 === s2[0] && 0 === s2[1] || (x3 = t22.translatePosMatrix(v3, f3, s2, a2));
          const y3 = n22 ? g3.textCollisionBox : g3.iconCollisionBox, b22 = g3.collisionCircleArray;
          if (b22.length > 0) {
            const t3 = e2.a6.mat4.create(), i3 = x3;
            e2.a6.mat4.mul(t3, g3.placementInvProjMatrix, h22.glCoordMatrix), e2.a6.mat4.mul(t3, t3, g3.placementViewportMatrix), d22.push({ circleArray: b22, circleOffset: p22, transform: i3, invTransform: t3, projection: g3.getProjection() }), _2 += b22.length / 4, p22 = _2;
          }
          y3 && (t22.terrain && t22.terrain.setupElevationDraw(f3, u22), u22.draw(t22, c22.LINES, Li2.disabled, Mi2.disabled, t22.colorModeForRenderPass(), Fi2.disabled, qr(x3, h22, f3, g3.getProjection()), o2.id, y3.layoutVertexBuffer, y3.indexBuffer, y3.segments, null, h22.zoom, null, [y3.collisionVertexBuffer, y3.collisionVertexBufferExt]));
        }
        if (!n22 || !d22.length)
          return;
        const m22 = t22.getOrCreateProgram("collisionCircle"), f22 = new e2.cQ();
        f22.resize(4 * _2), f22._trim();
        let g22 = 0;
        for (const e22 of d22)
          for (let t3 = 0; t3 < e22.circleArray.length / 4; t3++) {
            const i3 = 4 * t3, o3 = e22.circleArray[i3 + 0], r3 = e22.circleArray[i3 + 1], s3 = e22.circleArray[i3 + 2], a3 = e22.circleArray[i3 + 3];
            f22.emplace(g22++, o3, r3, s3, a3, 0), f22.emplace(g22++, o3, r3, s3, a3, 1), f22.emplace(g22++, o3, r3, s3, a3, 2), f22.emplace(g22++, o3, r3, s3, a3, 3);
          }
        (!ms || ms.length < 2 * _2) && (ms = function(t3) {
          const i3 = 2 * t3, o3 = new e2.aO();
          o3.resize(i3), o3._trim();
          for (let e22 = 0; e22 < i3; e22++) {
            const t4 = 6 * e22;
            o3.uint16[t4 + 0] = 4 * e22 + 0, o3.uint16[t4 + 1] = 4 * e22 + 1, o3.uint16[t4 + 2] = 4 * e22 + 2, o3.uint16[t4 + 3] = 4 * e22 + 2, o3.uint16[t4 + 4] = 4 * e22 + 3, o3.uint16[t4 + 5] = 4 * e22 + 0;
          }
          return o3;
        }(_2));
        const v22 = l22.createIndexBuffer(ms, true), x22 = l22.createVertexBuffer(f22, e2.cR.members, true);
        for (const i3 of d22) {
          const r3 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (y22 = h22).getCameraToCenterDistance(i3.projection), u_viewport_size: [y22.width, y22.height] };
          m22.draw(t22, c22.TRIANGLES, Li2.disabled, Mi2.disabled, t22.colorModeForRenderPass(), Fi2.disabled, r3, o2.id, x22, v22, e2.b1.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, h22.zoom);
        }
        var y22;
        x22.destroy(), v22.destroy();
      }
      const gs = e2.a6.mat4.create();
      function vs(t22) {
        const i2 = t22._camera.getWorldToCamera(t22.worldSize, 1), o2 = e2.a6.mat4.multiply([], i2, t22.globeMatrix);
        e2.a6.mat4.invert(o2, o2);
        const r22 = [0, 0, 0], s2 = [0, 1, 0, 0];
        return e2.a6.vec4.transformMat4(s2, s2, o2), r22[0] = s2[0], r22[1] = s2[1], r22[2] = s2[2], e2.a6.vec3.normalize(r22, r22), r22;
      }
      function xs({ width: t22, height: i2, anchor: o2, textOffset: r22, textScale: s2 }, a2) {
        const { horizontalAlign: n22, verticalAlign: l22 } = e2.bx(o2), c22 = -(n22 - 0.5) * t22, h22 = -(l22 - 0.5) * i2, u22 = e2.bw(o2, r22);
        return new e2.P((c22 / s2 + u22[0]) * a2, (h22 / s2 + u22[1]) * a2);
      }
      function ys(t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22) {
        const d22 = t22.text.placedSymbolArray, _2 = t22.text.dynamicLayoutVertexArray, p22 = t22.icon.dynamicLayoutVertexArray, m22 = {}, f22 = t22.getProjection(), g22 = ii2(l22, f22, a2), v22 = a2.elevation, x22 = f22.upVectorScale(l22.canonical, a2.center.lat, a2.worldSize).metersToTile;
        _2.clear();
        for (let p3 = 0; p3 < d22.length; p3++) {
          const y22 = d22.get(p3), { tileAnchorX: b22, tileAnchorY: w22, numGlyphs: T22 } = y22, E22 = y22.hidden || !y22.crossTileID || t22.allowVerticalPlacement && !y22.placedOrientation ? null : r22[y22.crossTileID];
          if (E22) {
            let r3 = 0, d3 = 0, p4 = 0;
            if (v22) {
              const e22 = v22 ? v22.getAtTileOffset(l22, b22, w22) : 0, [t3, i3, o3] = f22.upVector(l22.canonical, b22, w22);
              r3 = e22 * t3 * x22, d3 = e22 * i3 * x22, p4 = e22 * o3 * x22;
            }
            let [C22, S22, I22, D22] = Ut(y22.projectedAnchorX + r3, y22.projectedAnchorY + d3, y22.projectedAnchorZ + p4, o2 ? g22 : n22);
            const R22 = Gt(a2.getCameraToCenterDistance(f22), D22);
            let A22 = s2.evaluateSizeForFeature(t22.textSizeData, h22, y22) * R22 / e2.bq;
            o2 && (A22 *= t22.tilePixelRatio / c22);
            const L22 = xs(E22, A22);
            o2 ? ({ x: C22, y: S22, z: I22 } = f22.projectTilePoint(b22 + L22.x, w22 + L22.y, l22.canonical), [C22, S22, I22] = Ut(C22 + r3, S22 + d3, I22 + p4, n22)) : (i2 && L22._rotate(-a2.angle), C22 += L22.x, S22 += L22.y, I22 = 0);
            const P22 = t22.allowVerticalPlacement && y22.placedOrientation === e2.bk.vertical ? Math.PI / 2 : 0;
            for (let t3 = 0; t3 < T22; t3++)
              e2.bn(_2, C22, S22, I22, P22);
            u22 && y22.associatedIconIndex >= 0 && (m22[y22.associatedIconIndex] = { x: C22, y: S22, z: I22, angle: P22 });
          } else
            Yt(T22, _2);
        }
        if (u22) {
          p22.clear();
          const i3 = t22.icon.placedSymbolArray;
          for (let t3 = 0; t3 < i3.length; t3++) {
            const o3 = i3.get(t3), { numGlyphs: r3 } = o3, s3 = m22[t3];
            if (o3.hidden || !s3)
              Yt(r3, p22);
            else {
              const { x: t4, y: i4, z: o4, angle: a3 } = s3;
              for (let s4 = 0; s4 < r3; s4++)
                e2.bn(p22, t4, i4, o4, a3);
            }
          }
          t22.icon.dynamicLayoutVertexBuffer.updateData(p22);
        }
        t22.text.dynamicLayoutVertexBuffer.updateData(_2);
      }
      function bs(t22, i2, o2, r22, s2, a2, n22 = {}) {
        const l22 = o2.paint.get("icon-translate"), c22 = o2.paint.get("text-translate"), h22 = o2.paint.get("icon-translate-anchor"), u22 = o2.paint.get("text-translate-anchor"), d22 = o2.layout.get("icon-rotation-alignment"), _2 = o2.layout.get("text-rotation-alignment"), p22 = o2.layout.get("icon-pitch-alignment"), m22 = o2.layout.get("text-pitch-alignment"), f22 = o2.layout.get("icon-keep-upright"), g22 = o2.layout.get("text-keep-upright"), v22 = o2.paint.get("icon-color-saturation"), x22 = o2.paint.get("icon-color-contrast"), y22 = o2.paint.get("icon-color-brightness-min"), b22 = o2.paint.get("icon-color-brightness-max"), w22 = "sea" === o2.paint.get("symbol-elevation-reference"), T22 = o2.paint.get("text-occlusion-opacity").constantOr(0), E22 = t22.context, C22 = E22.gl, S22 = t22.transform, I22 = "map" === d22, D22 = "map" === _2, R22 = "map" === p22, A22 = "map" === m22, L22 = void 0 !== o2.layout.get("symbol-sort-key").constantOr(1);
        let P22 = false;
        const M22 = t22.depthModeForSublayer(0, Li2.ReadOnly), z22 = [e2.am(S22.center.lng), e2.at(S22.center.lat)], O22 = o2.layout.get("text-variable-anchor"), F22 = "globe" === S22.projection.name, k22 = [], B22 = [0, -1, 0];
        for (const s3 of r22) {
          const r3 = i2.getTile(s3), a3 = r3.getBucket(o2);
          if (!a3)
            continue;
          if ("mercator" === a3.projection.name && F22)
            continue;
          if (a3.fullyClipped)
            continue;
          const d3 = "globe" === a3.projection.name, _3 = d3 ? e2.a9(S22.zoom) : 0, p3 = ii2(s3, a3.getProjection(), S22), m3 = S22.calculatePixelsToTileUnitsMatrix(r3), E3 = O22 && a3.hasTextData(), M3 = a3.hasIconTextFit() && E3 && a3.hasIconData(), N22 = a3.getProjection().createInversionMatrix(S22, s3.canonical), U22 = (e22) => {
            S22.depthOcclusionForSymbolsAndCircles && (o2.hasInitialOcclusionOpacityProperties || t22.terrain) && (e22.push("DEPTH_D24"), e22.push("DEPTH_OCCLUSION"));
          }, G22 = () => {
            const i3 = I22 && "point" !== o2.layout.get("symbol-placement"), n3 = [];
            U22(n3);
            const c3 = i3 || M3, u3 = o2.paint.get("icon-image-cross-fade").constantOr(0);
            t22.terrainRenderModeElevated() && R22 && n3.push("PITCH_WITH_MAP_TERRAIN"), d3 && (n3.push("PROJECTION_GLOBE_VIEW"), c3 && n3.push("PROJECTED_POS_ON_VIEWPORT")), u3 > 0 && n3.push("ICON_TRANSITION"), a3.icon.zOffsetVertexBuffer && n3.push("Z_OFFSET"), 0 === v22 && 0 === x22 && 0 === y22 && 1 === b22 || n3.push("COLOR_ADJUSTMENT"), a3.sdfIcons && n3.push("RENDER_SDF");
            const g3 = a3.icon.programConfigurations.get(o2.id), T3 = t22.getOrCreateProgram("symbol", { config: g3, defines: n3 }), E4 = r3.imageAtlasTexture ? r3.imageAtlasTexture.size : [0, 0], D3 = a3.iconSizeData, A3 = e2.bj(D3, S22.zoom), L3 = R22 || 0 !== S22.pitch, P3 = kt(p3, r3.tileID.canonical, R22, I22, S22, a3.getProjection(), m3), O3 = Nt(p3, r3.tileID.canonical, R22, I22, S22, a3.getProjection(), m3), k3 = t22.translatePosMatrix(O3, r3, l22, h22, true), G3 = t22.translatePosMatrix(p3, r3, l22, h22), j3 = c3 ? gs : P3, V3 = I22 && !R22 && !i3;
            let q3 = B22;
            !F22 && !S22.mercatorFromTransition || I22 || (q3 = vs(S22));
            const Z3 = d3 ? q3 : B22, H3 = o2.getColorAdjustmentMatrix(v22, x22, y22, b22), W3 = os(D3.kind, A3, V3, R22, t22, G3, j3, k3, w22, false, E4, [0, 0], true, s3, _3, z22, N22, Z3, a3.getProjection(), H3, u3), $3 = r3.imageAtlasTexture ? r3.imageAtlasTexture : null, X22 = 1 !== o2.layout.get("icon-size").constantOr(0) || a3.iconsNeedLinear, Y22 = a3.sdfIcons || t22.options.rotating || t22.options.zooming || X22 || L3 ? C22.LINEAR : C22.NEAREST, K22 = a3.sdfIcons && 0 !== o2.paint.get("icon-halo-width").constantOr(1), J22 = t22.terrain && R22 && i3 ? e2.a6.mat4.invert(e2.a6.mat4.create(), P3) : gs;
            if (i3 && a3.icon) {
              const e22 = S22.elevation, i4 = e22 ? e22.getAtTileOffsetFunc(s3, S22.center.lat, S22.worldSize, a3.getProjection()) : null, o3 = Bt(p3, r3.tileID.canonical, R22, I22, S22, a3.getProjection(), m3);
              Vt(a3, p3, t22, false, o3, O3, R22, f22, i4, s3);
            }
            return { program: T3, buffers: a3.icon, uniformValues: W3, atlasTexture: $3, atlasTextureIcon: null, atlasInterpolation: Y22, atlasInterpolationIcon: null, isSDF: a3.sdfIcons, hasHalo: K22, tile: r3, labelPlaneMatrixInv: J22 };
          }, j2 = () => {
            const i3 = D22 && "point" !== o2.layout.get("symbol-placement"), n3 = [], l3 = i3 || O22 || M3;
            t22.terrainRenderModeElevated() && A22 && n3.push("PITCH_WITH_MAP_TERRAIN"), d3 && (n3.push("PROJECTION_GLOBE_VIEW"), l3 && n3.push("PROJECTED_POS_ON_VIEWPORT")), a3.text.zOffsetVertexBuffer && n3.push("Z_OFFSET"), a3.iconsInText && n3.push("RENDER_TEXT_AND_SYMBOL"), n3.push("RENDER_SDF"), U22(n3);
            const h3 = a3.text.programConfigurations.get(o2.id), f3 = t22.getOrCreateProgram("symbol", { config: h3, defines: n3 });
            let v3, x3 = [0, 0], y3 = null;
            const b3 = a3.textSizeData;
            a3.iconsInText && (x3 = r3.imageAtlasTexture ? r3.imageAtlasTexture.size : [0, 0], y3 = r3.imageAtlasTexture ? r3.imageAtlasTexture : null, v3 = A22 || 0 !== S22.pitch || t22.options.rotating || t22.options.zooming || "composite" === b3.kind || "camera" === b3.kind ? C22.LINEAR : C22.NEAREST);
            const E4 = r3.glyphAtlasTexture ? r3.glyphAtlasTexture.size : [0, 0], I3 = e2.bj(b3, S22.zoom), R3 = kt(p3, r3.tileID.canonical, A22, D22, S22, a3.getProjection(), m3), L3 = Nt(p3, r3.tileID.canonical, A22, D22, S22, a3.getProjection(), m3), P3 = t22.translatePosMatrix(L3, r3, c22, u22, true), k3 = t22.translatePosMatrix(p3, r3, c22, u22), G3 = l3 ? gs : R3, j3 = D22 && !A22 && !i3;
            let V3 = B22;
            !F22 && !S22.mercatorFromTransition || D22 || (V3 = vs(S22));
            const q3 = os(b3.kind, I3, j3, A22, t22, k3, G3, P3, w22, true, E4, x3, true, s3, _3, z22, N22, d3 ? V3 : B22, a3.getProjection(), T22), Z3 = r3.glyphAtlasTexture ? r3.glyphAtlasTexture : null, H3 = C22.LINEAR, W3 = 0 !== o2.paint.get("text-halo-width").constantOr(1), $3 = t22.terrain && A22 && i3 ? e2.a6.mat4.invert(e2.a6.mat4.create(), R3) : gs;
            if (i3 && a3.text) {
              const e22 = S22.elevation, i4 = e22 ? e22.getAtTileOffsetFunc(s3, S22.center.lat, S22.worldSize, a3.getProjection()) : null, o3 = Bt(p3, r3.tileID.canonical, A22, D22, S22, a3.getProjection(), m3);
              Vt(a3, p3, t22, true, o3, L3, A22, g22, i4, s3);
            }
            return { program: f3, buffers: a3.text, uniformValues: q3, atlasTexture: Z3, atlasTextureIcon: y3, atlasInterpolation: H3, atlasInterpolationIcon: v3, isSDF: true, hasHalo: W3, tile: r3, labelPlaneMatrixInv: $3 };
          }, V22 = a3.icon.segments.get().length, q22 = a3.text.segments.get().length, Z22 = V22 && !n22.onlyText ? G22() : null, H22 = q22 && !n22.onlyIcons ? j2() : null, W22 = o2.paint.get("icon-opacity").constantOr(1), $2 = o2.paint.get("text-opacity").constantOr(1);
          if (L22 && a3.canOverlap) {
            P22 = true;
            const t3 = W22 && !n22.onlyText ? a3.icon.segments.get() : [], i3 = $2 && !n22.onlyIcons ? a3.text.segments.get() : [];
            for (const i4 of t3)
              k22.push({ segments: new e2.b1([i4]), sortKey: i4.sortKey, state: Z22 });
            for (const t4 of i3)
              k22.push({ segments: new e2.b1([t4]), sortKey: t4.sortKey, state: H22 });
          } else
            n22.onlyText || k22.push({ segments: W22 ? a3.icon.segments : new e2.b1([]), sortKey: 0, state: Z22 }), n22.onlyIcons || k22.push({ segments: $2 ? a3.text.segments : new e2.b1([]), sortKey: 0, state: H22 });
        }
        P22 && k22.sort((e22, t3) => e22.sortKey - t3.sortKey);
        for (const e22 of k22) {
          const i3 = e22.state;
          if (i3)
            if (t22.terrain ? t22.terrain.setupElevationDraw(i3.tile, i3.program, { useDepthForOcclusion: S22.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: i3.labelPlaneMatrixInv }) : t22.setupDepthForOcclusion(S22.depthOcclusionForSymbolsAndCircles, i3.program), E22.activeTexture.set(C22.TEXTURE0), i3.atlasTexture && i3.atlasTexture.bind(i3.atlasInterpolation, C22.CLAMP_TO_EDGE, true), i3.atlasTextureIcon && (E22.activeTexture.set(C22.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, C22.CLAMP_TO_EDGE, true)), t22.uploadCommonLightUniforms(t22.context, i3.program), i3.hasHalo) {
              const r3 = i3.uniformValues;
              r3.u_is_halo = 1, ws(i3.buffers, e22.segments, o2, t22, i3.program, M22, s2, a2, r3, 2), r3.u_is_halo = 0;
            } else {
              if (i3.isSDF) {
                const r3 = i3.uniformValues;
                i3.hasHalo && (r3.u_is_halo = 1, ws(i3.buffers, e22.segments, o2, t22, i3.program, M22, s2, a2, r3, 1)), r3.u_is_halo = 0;
              }
              ws(i3.buffers, e22.segments, o2, t22, i3.program, M22, s2, a2, i3.uniformValues, 1);
            }
        }
      }
      function ws(e22, t22, i2, o2, r22, s2, a2, n22, l22, c22) {
        const h22 = [e22.dynamicLayoutVertexBuffer, e22.opacityVertexBuffer, e22.iconTransitioningVertexBuffer, e22.globeExtVertexBuffer, e22.zOffsetVertexBuffer];
        r22.draw(o2, o2.context.gl.TRIANGLES, s2, a2, n22, Fi2.disabled, l22, i2.id, e22.layoutVertexBuffer, e22.indexBuffer, t22, i2.paint, o2.transform.zoom, e22.programConfigurations.get(i2.id), h22, c22);
      }
      function Ts(e22, t22, i2, o2, r22, s2, a2) {
        const n22 = e22.context.gl, l22 = i2.paint.get("fill-pattern"), c22 = i2.is3D(), h22 = c22 ? e22.stencilModeFor3D() : Mi2.disabled, u22 = l22 && l22.constantOr(1);
        let d22, _2, p22, m22, f22;
        a2 ? (_2 = u22 && !i2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", d22 = n22.LINES) : (_2 = u22 ? "fillPattern" : "fill", d22 = n22.TRIANGLES);
        for (const g22 of o2) {
          const o3 = t22.getTile(g22);
          if (u22 && !o3.patternsLoaded())
            continue;
          const v22 = o3.getBucket(i2);
          if (!v22)
            continue;
          e22.prepareDrawTile();
          const x22 = v22.programConfigurations.get(i2.id), y22 = e22.isTileAffectedByFog(g22), b22 = e22.getOrCreateProgram(_2, { config: x22, overrideFog: y22 });
          u22 && (e22.context.activeTexture.set(n22.TEXTURE0), o3.imageAtlasTexture && o3.imageAtlasTexture.bind(n22.LINEAR, n22.CLAMP_TO_EDGE), x22.updatePaintBuffers());
          const w22 = l22.constantOr(null);
          if (w22 && o3.imageAtlas) {
            const e3 = o3.imageAtlas.patternPositions[w22.toString()];
            e3 && x22.setConstantPatternPositions(e3);
          }
          const T22 = e22.translatePosMatrix(g22.projMatrix, o3, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor")), E22 = i2.paint.get("fill-emissive-strength");
          if (a2) {
            m22 = v22.indexBuffer2, f22 = v22.segments2;
            const t3 = e22.terrain && e22.terrain.renderingToTexture ? e22.terrain.drapeBufferSize : [n22.drawingBufferWidth, n22.drawingBufferHeight];
            p22 = "fillOutlinePattern" === _2 && u22 ? Vr(T22, E22, e22, o3, t3) : jr(T22, E22, t3);
          } else
            m22 = v22.indexBuffer, f22 = v22.segments, p22 = u22 ? Gr(T22, E22, e22, o3) : Ur(T22, E22);
          e22.uploadCommonUniforms(e22.context, b22, g22.toUnwrapped()), b22.draw(e22, d22, r22, c22 ? h22 : e22.stencilModeForClipping(g22), s2, Fi2.disabled, p22, i2.id, v22.layoutVertexBuffer, m22, f22, i2.paint, e22.transform.zoom, x22, void 0);
        }
      }
      function Es(t22, i2, o2, r22, s2, a2, n22, l22) {
        o2.resetLayerRenderingStats(t22);
        const c22 = t22.context, h22 = c22.gl, u22 = t22.transform, d22 = o2.paint.get("fill-extrusion-pattern"), _2 = d22.constantOr(1), p22 = o2.paint.get("fill-extrusion-opacity"), m22 = t22.style.enable3dLights(), f22 = o2.paint.get(m22 && !_2 ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), g22 = [o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), f22], v22 = o2.layout.get("fill-extrusion-edge-radius"), x22 = v22 > 0 && !o2.paint.get("fill-extrusion-rounded-roof"), y22 = x22 ? 0 : v22, b22 = "globe" === u22.projection.name ? e2.c_() : 0, w22 = "globe" === u22.projection.name, T22 = w22 ? e2.a9(u22.zoom) : 0, E22 = [e2.am(u22.center.lng), e2.at(u22.center.lat)], C22 = o2.paint.get("fill-extrusion-flood-light-color").toRenderColor(o2.lut).toArray01().slice(0, 3), S22 = o2.paint.get("fill-extrusion-flood-light-intensity"), I22 = o2.paint.get("fill-extrusion-vertical-scale"), D22 = 0 !== o2.paint.get("fill-extrusion-line-width").constantOr(1), R22 = Wi2(t22, o2.paint.get("fill-extrusion-cutoff-fade-range")), A22 = [];
        let L22;
        w22 && A22.push("PROJECTION_GLOBE_VIEW"), g22[0] > 0 && A22.push("FAUX_AO"), x22 && A22.push("ZERO_ROOF_RADIUS"), l22 && A22.push("HAS_CENTROID"), S22 > 0 && A22.push("FLOOD_LIGHT"), R22.shouldRenderCutoff && A22.push("RENDER_CUTOFF"), D22 && A22.push("RENDER_WALL_MODE");
        const P22 = "shadow" === t22.renderPass, M22 = t22.shadowRenderer, z22 = P22 && !!M22;
        t22.shadowRenderer && (t22.shadowRenderer.useNormalOffset = true);
        let O22 = [0, 0, 0];
        if (M22) {
          const e22 = t22.style.directionalLight, i3 = t22.style.ambientLight;
          e22 && i3 && (O22 = eo(t22.style, e22, i3)), L22 = A22.concat(["SHADOWS_SINGLE_CASCADE"]);
        }
        const F22 = z22 ? "fillExtrusionDepth" : _2 ? "fillExtrusionPattern" : "fillExtrusion", k22 = o2.getLayerRenderingStats();
        for (const e22 of r22) {
          const r3 = i2.getTile(e22), m3 = r3.getBucket(o2);
          if (!m3 || m3.projection.name !== u22.projection.name)
            continue;
          let f3 = false;
          M22 && (f3 = 0 === M22.getMaxCascadeForTile(e22.toUnwrapped()));
          const v3 = t22.isTileAffectedByFog(e22), x3 = m3.programConfigurations.get(o2.id), z3 = t22.getOrCreateProgram(F22, { config: x3, defines: f3 ? L22 : A22, overrideFog: v3 });
          if (t22.terrain && t22.terrain.setupElevationDraw(r3, z3, { useMeterToDem: true }), !m3.centroidVertexBuffer) {
            const e3 = z3.attributes.a_centroid_pos;
            void 0 !== e3 && h22.vertexAttrib2f(e3, 0, 0);
          }
          !P22 && M22 && M22.setupShadows(r3.tileID.toUnwrapped(), z3, "vector-tile", r3.tileID.overscaledZ), _2 && (t22.context.activeTexture.set(h22.TEXTURE0), r3.imageAtlasTexture && r3.imageAtlasTexture.bind(h22.LINEAR, h22.CLAMP_TO_EDGE), x3.updatePaintBuffers());
          const B22 = d22.constantOr(null);
          if (B22 && r3.imageAtlas) {
            const e3 = r3.imageAtlas.patternPositions[B22.toString()];
            e3 && x3.setConstantPatternPositions(e3);
          }
          const N22 = o2.paint.get("fill-extrusion-vertical-gradient"), U22 = 1 / m3.tileToMeter;
          let G22;
          if (P22 && M22) {
            if (As(r3.tileID, m3, t22))
              continue;
            const e3 = M22.calculateShadowPassMatrixFromTile(r3.tileID.toUnwrapped());
            G22 = Br(e3, y22, U22, I22);
          } else {
            const i3 = t22.translatePosMatrix(e22.expandedProjMatrix, r3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), s3 = u22.projection.createInversionMatrix(u22, e22.canonical);
            G22 = _2 ? Nr(i3, t22, N22, p22, g22, y22, U22, e22, r3, b22, T22, E22, s3, C22, I22) : kr(i3, t22, N22, p22, g22, y22, U22, e22, b22, T22, E22, s3, C22, I22, S22, O22);
          }
          t22.uploadCommonUniforms(c22, z3, e22.toUnwrapped(), null, R22);
          let j2 = m3.segments;
          if ("mercator" === u22.projection.name && !P22 && (j2 = m3.getVisibleSegments(r3.tileID, t22.terrain, t22.transform.getFrustum(0)), !j2.get().length))
            continue;
          if (k22)
            if (P22)
              for (const e3 of j2.get())
                k22.numRenderedVerticesInShadowPass += e3.primitiveLength;
            else
              for (const e3 of j2.get())
                k22.numRenderedVerticesInTransparentPass += e3.primitiveLength;
          const V22 = [];
          (t22.terrain || l22) && V22.push(m3.centroidVertexBuffer), w22 && V22.push(m3.layoutVertexExtBuffer), D22 && V22.push(m3.wallVertexBuffer), z3.draw(t22, c22.gl.TRIANGLES, s2, a2, n22, Fi2.backCCW, G22, o2.id, m3.layoutVertexBuffer, m3.indexBuffer, j2, o2.paint, t22.transform.zoom, x3, V22);
        }
        t22.shadowRenderer && (t22.shadowRenderer.useNormalOffset = false);
      }
      function Cs(t22, i2, o2, r22, s2, a2, n22, l22, c22, h22, u22, d22, _2, p22, m22, f22, g22, v22, x22) {
        const y22 = t22.context, b22 = y22.gl, w22 = t22.transform, T22 = t22.transform.zoom, E22 = [], C22 = Wi2(t22, o2.paint.get("fill-extrusion-cutoff-fade-range"));
        "clear" === h22 ? (E22.push("CLEAR_SUBPASS"), x22 && (E22.push("CLEAR_FROM_TEXTURE"), y22.activeTexture.set(b22.TEXTURE0), x22.bind(b22.LINEAR, b22.CLAMP_TO_EDGE))) : "sdf" === h22 && E22.push("SDF_SUBPASS"), g22 && E22.push("HAS_CENTROID"), C22.shouldRenderCutoff && E22.push("RENDER_CUTOFF");
        const S22 = o2.layout.get("fill-extrusion-edge-radius"), I22 = (e22, i3, r3, h3, v3) => {
          const b3 = i3.programConfigurations.get(o2.id), w3 = t22.isTileAffectedByFog(e22), I3 = t22.getOrCreateProgram("fillExtrusionGroundEffect", { config: b3, defines: E22, overrideFog: w3 }), D22 = /* @__PURE__ */ ((e3, t3, i4, o3, r4, s3, a3, n3, l3, c3, h4) => ({ u_matrix: t3, u_opacity: i4, u_ao_pass: o3 ? 1 : 0, u_meter_to_tile: r4, u_ao: s3, u_flood_light_intensity: a3, u_flood_light_color: n3, u_attenuation: l3, u_edge_radius: c3, u_fb: 0, u_fb_size: h4, u_dynamic_offset: 1 }))(0, h3, u22, c22, v3, [d22, _2 * v3], p22, m22, f22, T22 >= 17 ? 0 : S22 * v3, x22 ? x22.size[0] : 0), R22 = [];
          g22 && R22.push(i3.hiddenByLandmarkVertexBuffer), t22.uploadCommonUniforms(y22, I3, e22.toUnwrapped(), null, C22), I3.draw(t22, y22.gl.TRIANGLES, s2, a2, n22, l22, D22, o2.id, i3.vertexBuffer, i3.indexBuffer, r3, o2.paint, T22, b3, R22);
        };
        for (const s3 of r22) {
          const r3 = i2.getTile(s3), a3 = r3.getBucket(o2);
          if (!a3 || a3.projection.name !== w22.projection.name || !a3.groundEffect || a3.groundEffect && !a3.groundEffect.hasData())
            continue;
          const n3 = a3.groundEffect, l3 = 1 / a3.tileToMeter;
          {
            const e22 = t22.translatePosMatrix(s3.projMatrix, r3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), i3 = n3.getDefaultSegment();
            I22(s3, n3, i3, e22, l3);
          }
          if (v22)
            for (let a4 = 0; a4 < 4; a4++) {
              const n4 = e2.c$[a4](s3), c3 = i2.getTile(n4);
              if (!c3)
                continue;
              const h3 = c3.getBucket(o2);
              if (!h3 || h3.projection.name !== w22.projection.name || !h3.groundEffect || h3.groundEffect && !h3.groundEffect.hasData())
                continue;
              const u3 = h3.groundEffect;
              let d3, _3;
              0 === a4 ? (d3 = [-e2.ab, 0, 0], _3 = 1) : 1 === a4 ? (d3 = [e2.ab, 0, 0], _3 = 0) : 2 === a4 ? (d3 = [0, -e2.ab, 0], _3 = 3) : (d3 = [0, e2.ab, 0], _3 = 2);
              const p3 = u3.regionSegments[_3];
              if (!p3)
                continue;
              const m3 = new Float32Array(16);
              e2.a6.mat4.translate(m3, s3.projMatrix, d3), I22(s3, u3, p3, t22.translatePosMatrix(m3, r3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), l3);
            }
        }
      }
      function Ss(t22, i2, o2, r22, s2, a2, n22) {
        0 === r22.centroidVertexArray.length && r22.createCentroidsBuffer();
        const l22 = a2 ? a2.findDEMTileFor(o2) : null;
        if (!(l22 && l22.dem || n22))
          return;
        const c22 = (t3) => new e2.P(Math.ceil((t3 + e2.d2) * e2.d3), 0), h22 = (e22) => {
          const t3 = i2.getSource().minzoom, o3 = (e3) => {
            const t4 = i2.getTileByID(e3);
            if (t4 && t4.hasData())
              return t4.getBucket(s2);
          }, r3 = [0, -1, 1];
          for (const i3 of r3) {
            if (e22.overscaledZ + i3 < t3)
              continue;
            const r4 = o3(e22.calculateScaledKey(e22.overscaledZ + i3));
            if (r4)
              return r4;
          }
        }, u22 = [0, 0, 0], d22 = (t3, i3) => (u22[0] = Math.min(t3.min.y, i3.min.y), u22[1] = Math.max(t3.max.y, i3.max.y), u22[2] = e2.ab - i3.min.x > t3.max.x ? i3.min.x - e2.ab : t3.max.x, u22), _2 = (t3, i3) => (u22[0] = Math.min(t3.min.x, i3.min.x), u22[1] = Math.max(t3.max.x, i3.max.x), u22[2] = e2.ab - i3.min.y > t3.max.y ? i3.min.y - e2.ab : t3.max.y, u22), p22 = [(e22, t3) => d22(e22, t3), (e22, t3) => d22(t3, e22), (e22, t3) => _2(e22, t3), (e22, t3) => _2(t3, e22)], m22 = (t3, i3, r3, s3, n3, c3, h3) => {
          if (!a2)
            return 0;
          const u3 = [[c3 ? r3 : t3, c3 ? t3 : r3, 0], [c3 ? r3 : i3, c3 ? i3 : r3, 0]], d3 = h3 < 0 ? e2.ab + h3 : h3, _3 = [c3 ? d3 : (t3 + i3) / 2, c3 ? (t3 + i3) / 2 : d3, 0];
          return 0 === r3 && h3 < 0 || 0 !== r3 && h3 > 0 ? a2.getForTilePoints(n3, [_3], true, s3) : u3.push(_3), a2.getForTilePoints(o2, u3, true, l22), Math.max(u3[0][2], u3[1][2], _3[2]) / a2.exaggeration();
        };
        for (let t3 = 0; t3 < 4; t3++) {
          const i3 = r22.borderFeatureIndices[t3];
          if (0 === i3.length)
            continue;
          const s3 = e2.c$[t3](o2), l3 = h22(s3);
          if (!(l3 && l3 instanceof e2.d0))
            continue;
          if (r22.borderDoneWithNeighborZ[t3] === l3.canonical.z)
            continue;
          0 === l3.centroidVertexArray.length && l3.createCentroidsBuffer();
          const u3 = a2 ? a2.findDEMTileFor(s3) : null;
          if (!(u3 && u3.dem || n22))
            continue;
          const d3 = (t3 < 2 ? 1 : 5) - t3, _3 = l3.borderDoneWithNeighborZ[d3] !== r22.canonical.z, v22 = l3.borderFeatureIndices[d3];
          let x22 = 0;
          if (r22.canonical.z !== l3.canonical.z) {
            for (const e22 of i3)
              r22.showCentroid(r22.featuresOnBorder[e22]);
            if (_3)
              for (const e22 of v22)
                l3.showCentroid(l3.featuresOnBorder[e22]);
            r22.borderDoneWithNeighborZ[t3] = l3.canonical.z, l3.borderDoneWithNeighborZ[d3] = r22.canonical.z;
          }
          for (const o3 of i3) {
            const i4 = r22.featuresOnBorder[o3], a3 = r22.centroidData[i4.centroidDataIndex], h3 = i4.borders[t3];
            let _4;
            for (; x22 < v22.length; ) {
              _4 = l3.featuresOnBorder[v22[x22]];
              const e22 = _4.borders[d3];
              if (e22[1] > h3[0] + 3 || e22[0] > h3[0] - 3)
                break;
              l3.showCentroid(_4), x22++;
            }
            if (_4 && x22 < v22.length) {
              const o4 = x22;
              let y22 = 0;
              for (; !(_4.borders[d3][0] > h3[1] - 3) && (y22++, ++x22 !== v22.length); )
                _4 = l3.featuresOnBorder[v22[x22]];
              _4 = l3.featuresOnBorder[v22[o4]];
              let b22 = false;
              if (y22 >= 1) {
                const e22 = _4.borders[d3];
                Math.abs(h3[0] - e22[0]) < 3 && Math.abs(h3[1] - e22[1]) < 3 && (y22 = 1, b22 = true, x22 = o4 + 1);
              } else if (0 === y22) {
                r22.showCentroid(i4);
                continue;
              }
              const w22 = l3.centroidData[_4.centroidDataIndex];
              n22 && b22 && (((f22 = a3).flags | (g22 = w22).flags) & e2.d1 ? (f22.flags |= e2.d1, g22.flags |= e2.d1) : (f22.flags &= ~e2.d1, g22.flags &= ~e2.d1));
              const T22 = i4.intersectsCount() > 1 || _4.intersectsCount() > 1;
              if (y22 > 1)
                x22 = o4, a3.centroidXY = w22.centroidXY = new e2.P(0, 0);
              else if (u3 && u3.dem && !T22) {
                const i5 = p22[t3](a3, w22), o5 = t3 % 2 ? e2.ab - 1 : 0, r3 = m22(i5[0], Math.min(e2.ab - 1, i5[1]), o5, u3, s3, t3 < 2, i5[2]);
                a3.centroidXY = w22.centroidXY = c22(r3);
              } else
                T22 ? a3.centroidXY = w22.centroidXY = new e2.P(0, 0) : (a3.centroidXY = r22.encodeBorderCentroid(i4), w22.centroidXY = l3.encodeBorderCentroid(_4));
              r22.writeCentroidToBuffer(a3), l3.writeCentroidToBuffer(w22);
            } else
              r22.showCentroid(i4);
          }
          r22.borderDoneWithNeighborZ[t3] = l3.canonical.z, l3.borderDoneWithNeighborZ[d3] = r22.canonical.z;
        }
        var f22, g22;
        (r22.needsCentroidUpdate || !r22.centroidVertexBuffer && 0 !== r22.centroidVertexArray.length) && r22.uploadCentroid(t22);
      }
      const Is = [1, 0, 0], Ds = [0, 1, 0], Rs = [0, 0, 1];
      function As(t22, i2, o2) {
        const r22 = o2.transform, s2 = o2.shadowRenderer;
        if (!s2)
          return true;
        const a2 = t22.toUnwrapped(), n22 = r22.tileSize * s2._cascades[o2.currentShadowCascade].scale;
        let l22 = i2.maxHeight;
        if (r22.elevation) {
          const e22 = r22.elevation.getMinMaxForTile(t22);
          e22 && (l22 += e22.max);
        }
        const c22 = [...s2.shadowDirection];
        c22[2] = -c22[2];
        const h22 = s2.computeSimplifiedTileShadowVolume(a2, l22, n22, c22);
        if (!h22)
          return false;
        const u22 = [Is, Ds, Rs, c22, [c22[0], 0, c22[2]], [0, c22[1], c22[2]]], d22 = "globe" === r22.projection.name, _2 = r22.scaleZoom(n22), p22 = e2.bN.fromInvProjectionMatrix(r22.invProjMatrix, r22.worldSize, _2, !d22), m22 = s2.getCurrentCascadeFrustum();
        return 0 === p22.intersectsPrecise(h22.vertices, h22.planes, u22) || 0 === m22.intersectsPrecise(h22.vertices, h22.planes, u22);
      }
      function Ls(t22) {
        return [t22[0] * e2.d4, t22[1] * e2.d4, t22[2] * e2.d4, 0];
      }
      function Ps(t22, i2, o2, r22, s2, a2, n22, l22, c22) {
        const h22 = r22.getSource(), u22 = o2.globeSharedBuffers;
        if (!u22)
          return;
        let d22, _2, p22;
        if (i2 && (d22 = r22.getTile(i2)), h22 instanceof e2.aD ? (_2 = h22.texture, p22 = e2.cD(0, 0, o2.transform)) : d22 && i2 && (_2 = d22.texture, p22 = e2.cD(i2.canonical.z, i2.canonical.x, o2.transform)), !_2 || !p22)
          return;
        t22 || (p22 = e2.a6.mat4.scale(e2.a6.mat4.create(), p22, [1, -1, 1]));
        const m22 = o2.context, f22 = m22.gl, g22 = "nearest" === s2.paint.get("raster-resampling") ? f22.NEAREST : f22.LINEAR, v22 = o2.colorModeForDrapableLayerRenderPass(a2), x22 = n22.defines;
        x22.push("GLOBE_POLES");
        const y22 = new Li2(f22.LEQUAL, Li2.ReadWrite, o2.depthRangeFor3D), b22 = Float32Array.from(o2.transform.expandedFarZProjMatrix), w22 = Float32Array.from(e2.b5(e2.cC(new e2.bP(0, 0, 0))));
        o2.terrain && o2.terrain.prepareDrawTile(), m22.activeTexture.set(f22.TEXTURE0), _2.bind(g22, f22.CLAMP_TO_EDGE), m22.activeTexture.set(f22.TEXTURE1), _2.bind(g22, f22.CLAMP_TO_EDGE), _2.useMipmap && m22.extTextureFilterAnisotropic && o2.transform.pitch > 20 && f22.texParameterf(f22.TEXTURE_2D, m22.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, m22.extTextureFilterAnisotropicMax);
        const [T22, E22, C22, S22] = i2 ? u22.getPoleBuffers(i2.canonical.z, false) : u22.getPoleBuffers(0, true), I22 = s2.paint.get("raster-elevation");
        let D22;
        t22 ? (D22 = T22, o2.renderDefaultNorthPole = 0 !== I22) : (D22 = E22, o2.renderDefaultSouthPole = 0 !== I22);
        const R22 = Ls(n22.mix), A22 = ((e22, t3, i3, o3, r3, s3, a3, n3, l3, c3, h3, u3, d3) => Yr(e22, t3, i3, new Float32Array(16), new Float32Array(9), [0, 0], o3, [0, 0], [0, 0, 0, 0], 1, { opacity: 1, mix: 0 }, s3, [0, 0], n3, 2, c3, h3, u3, 1, 0, d3))(b22, w22, p22, e2.a9(o2.transform.zoom), 0, s2, 0, I22, 0, R22, n22.offset, n22.range, a2), L22 = o2.getOrCreateProgram("raster", { defines: x22 });
        o2.uploadCommonUniforms(m22, L22, null), L22.draw(o2, f22.TRIANGLES, y22, c22, v22, l22, A22, s2.id, D22, C22, S22);
      }
      function Ms(e22) {
        const t22 = e22._nearZ, i2 = e22.projection.farthestPixelDistance(e22), o2 = i2 - t22, r22 = 0.2 * e22.height, s2 = t22 + r22;
        return [t22, i2, (s2 - r22 - t22) / o2, (s2 - t22) / o2];
      }
      function zs(e22, t22, i2, o2) {
        if (e22)
          return t22 instanceof Qe2 && e22 instanceof mt ? t22.getTextureDescriptor(e22, i2, true) : { texture: e22.texture, mix: Ls(o2.mix), offset: o2.offset, buffer: 0, tileSize: 1 };
      }
      var Os = e2.d5([{ name: "a_index", type: "Int16", components: 1 }]);
      class Fs {
        constructor(t22, i2, o2, r22) {
          const s2 = { width: o2[0], height: o2[1], data: null }, a2 = t22.gl;
          this.targetColorTexture = new e2.T(t22, s2, a2.RGBA8, { useMipmap: false }), this.backgroundColorTexture = new e2.T(t22, s2, a2.RGBA8, { useMipmap: false }), this.context = t22, this.updateParticleTexture(i2, r22), this.lastInvalidatedAt = 0;
        }
        updateParticleTexture(t22, i2) {
          if (this.particleTextureDimension === i2.width)
            return;
          (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
          const o2 = this.context.gl, r22 = i2.width * i2.height;
          this.particleTexture0 = new e2.T(this.context, i2, o2.RGBA8, { premultiply: false, useMipmap: false }), this.particleTexture1 = new e2.T(this.context, i2, o2.RGBA8, { premultiply: false, useMipmap: false });
          const s2 = new e2.d6();
          s2.reserve(r22);
          for (let e22 = 0; e22 < r22; e22++)
            s2.emplaceBack(e22);
          this.particleIndexBuffer = this.context.createVertexBuffer(s2, Os.members, true), this.particleSegment = e2.b1.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = i2.width;
        }
        update(t22) {
          return !(this.lastInvalidatedAt < t22 && (this.lastInvalidatedAt = e2.q.now(), 1));
        }
        destroy() {
          this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
        }
      }
      function ks(t22, i2, o2) {
        if (!t22)
          return null;
        const r22 = i2.getTextureDescriptor(t22, o2, true);
        if (!r22)
          return null;
        let { texture: s2, mix: a2, offset: n22, tileSize: l22, buffer: c22, format: h22 } = r22;
        if (!s2 || !h22)
          return null;
        let u22 = false;
        return "uint32" === h22 && (u22 = true, a2[3] = 0, a2 = $r(e2.d7, a2, [0, o2.paint.get("raster-particle-max-speed")]), n22 = Xr(e2.d7, n22, [0, o2.paint.get("raster-particle-max-speed")])), { texture: s2, textureOffset: [c22 / (l22 + 2 * c22), l22 / (l22 + 2 * c22)], tileSize: l22, scalarData: u22, scale: a2, offset: n22, defines: ["RASTER_ARRAY", { uint8: "DATA_FORMAT_UINT8", uint16: "DATA_FORMAT_UINT16", uint32: "DATA_FORMAT_UINT32" }[h22]] };
      }
      function Bs(e22) {
        const t22 = e22._nearZ, i2 = e22.projection.farthestPixelDistance(e22), o2 = i2 - t22, r22 = 0.2 * e22.height, s2 = t22 + r22;
        return [t22, i2, (s2 - r22 - t22) / o2, (s2 - t22) / o2];
      }
      const Ns = new e2.bz(1, 0, 0, 1), Us = new e2.bz(0, 1, 0, 1), Gs = new e2.bz(0, 0, 1, 1), js = new e2.bz(1, 0, 1, 1), Vs = new e2.bz(0, 1, 1, 1);
      function qs(t22, i2, o2, r22, s2, a2, n22) {
        const l22 = t22.context, c22 = t22.transform, h22 = l22.gl, u22 = "globe" === c22.projection.name, d22 = u22 ? ["PROJECTION_GLOBE_VIEW"] : [];
        let _2 = e2.a6.mat4.clone(o2.projMatrix);
        if (u22 && e2.a9(c22.zoom) > 0) {
          const t3 = e2.b4(o2.canonical, c22), i3 = e2.d8(t3);
          _2 = e2.a6.mat4.multiply(new Float32Array(16), c22.globeMatrix, i3), e2.a6.mat4.multiply(_2, c22.projMatrix, _2);
        }
        const p22 = e2.a6.mat4.create();
        p22[12] += 2 * s2 / (e2.q.devicePixelRatio * c22.width), p22[13] += 2 * a2 / (e2.q.devicePixelRatio * c22.height), e2.a6.mat4.multiply(_2, p22, _2);
        const m22 = t22.getOrCreateProgram("debug", { defines: d22 }), f22 = i2.getTileByID(o2.key);
        t22.terrain && t22.terrain.setupElevationDraw(f22, m22);
        const g22 = Li2.disabled, v22 = Mi2.disabled, x22 = t22.colorModeForRenderPass(), y22 = "$debug";
        l22.activeTexture.set(h22.TEXTURE0), t22.emptyTexture.bind(h22.LINEAR, h22.CLAMP_TO_EDGE), u22 ? f22._makeGlobeTileDebugBuffers(t22.context, c22) : f22._makeDebugTileBoundsBuffers(t22.context, c22.projection);
        const b22 = f22._tileDebugBuffer || t22.debugBuffer, w22 = f22._tileDebugIndexBuffer || t22.debugIndexBuffer, T22 = f22._tileDebugSegments || t22.debugSegments;
        if (m22.draw(t22, h22.LINE_STRIP, g22, v22, x22, Fi2.disabled, Zr(_2, r22), y22, b22, w22, T22, null, null, null, [f22._globeTileDebugBorderBuffer]), n22) {
          const e22 = f22.latestRawTileData, i3 = Math.floor((e22 && e22.byteLength || 0) / 1024);
          let r3 = o2.canonical.toString();
          o2.overscaledZ !== o2.canonical.z && (r3 += " => ".concat(o2.overscaledZ)), r3 += " ".concat(f22.state), r3 += " ".concat(i3, "kb"), function(e3, t3) {
            e3.initDebugOverlayCanvas();
            const i4 = e3.debugOverlayCanvas, o3 = e3.context.gl, r4 = e3.debugOverlayCanvas.getContext("2d");
            r4.clearRect(0, 0, i4.width, i4.height), r4.shadowColor = "white", r4.shadowBlur = 2, r4.lineWidth = 1.5, r4.strokeStyle = "white", r4.textBaseline = "top", r4.font = "bold 36px Open Sans, sans-serif", r4.fillText(t3, 5, 5), r4.strokeText(t3, 5, 5), e3.debugOverlayTexture.update(i4), e3.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
          }(t22, r3);
        }
        const E22 = i2.getTile(o2).tileSize, C22 = 512 / Math.min(E22, 512) * (o2.overscaledZ / c22.zoom) * 0.5, S22 = f22._tileDebugTextBuffer || t22.debugBuffer, I22 = f22._tileDebugTextIndexBuffer || t22.quadTriangleIndexBuffer, D22 = f22._tileDebugTextSegments || t22.debugSegments;
        m22.draw(t22, h22.TRIANGLES, g22, v22, Ai2.alphaBlended, Fi2.disabled, Zr(_2, e2.bz.transparent, C22), y22, S22, I22, D22, null, null, null, [f22._globeTileDebugTextBuffer]);
      }
      function Zs(e22, t22, i2, o2) {
        Ws(e22, 0, t22 + i2 / 2, e22.transform.width, i2, o2);
      }
      function Hs(e22, t22, i2, o2) {
        Ws(e22, t22 - i2 / 2, 0, i2, e22.transform.height, o2);
      }
      function Ws(t22, i2, o2, r22, s2, a2) {
        const n22 = t22.context, l22 = n22.gl;
        l22.enable(l22.SCISSOR_TEST), l22.scissor(i2 * e2.q.devicePixelRatio, o2 * e2.q.devicePixelRatio, r22 * e2.q.devicePixelRatio, s2 * e2.q.devicePixelRatio), n22.clear({ color: a2 }), l22.disable(l22.SCISSOR_TEST);
      }
      const $s = e2.d5([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: Xs } = $s;
      function Ys(e22, t22, i2, o2) {
        e22.emplaceBack(t22, i2, o2);
      }
      class Ks {
        constructor(t22) {
          this.vertexArray = new e2.d9(), this.indices = new e2.aO(), Ys(this.vertexArray, -1, -1, 1), Ys(this.vertexArray, 1, -1, 1), Ys(this.vertexArray, -1, 1, 1), Ys(this.vertexArray, 1, 1, 1), Ys(this.vertexArray, -1, -1, -1), Ys(this.vertexArray, 1, -1, -1), Ys(this.vertexArray, -1, 1, -1), Ys(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t22.createVertexBuffer(this.vertexArray, Xs), this.indexBuffer = t22.createIndexBuffer(this.indices), this.segment = e2.b1.simpleSegment(0, 0, 36, 12);
        }
      }
      function Js(t22, i2, o2, r22, s2, a2) {
        const n22 = t22.context.gl, l22 = i2.paint.get("sky-atmosphere-color"), c22 = i2.paint.get("sky-atmosphere-halo-color"), h22 = i2.paint.get("sky-atmosphere-sun-intensity"), u22 = ((e22, t3, i3, o3, r3) => ({ u_matrix_3f: e22, u_sun_direction: t3, u_sun_intensity: i3, u_color_tint_r: [o3.r, o3.g, o3.b, o3.a], u_color_tint_m: [r3.r, r3.g, r3.b, r3.a], u_luminance: 5e-5 }))(e2.a6.mat3.fromMat4(e2.a6.mat3.create(), r22), s2, h22, l22, c22);
        n22.framebufferTexture2D(n22.FRAMEBUFFER, n22.COLOR_ATTACHMENT0, n22.TEXTURE_CUBE_MAP_POSITIVE_X + a2, i2.skyboxTexture, 0), o2.draw(t22, n22.TRIANGLES, Li2.disabled, Mi2.disabled, Ai2.unblended, Fi2.frontCW, u22, "skyboxCapture", i2.skyboxGeometry.vertexBuffer, i2.skyboxGeometry.indexBuffer, i2.skyboxGeometry.segment);
      }
      const Qs = e2.d5([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
      class ea2 {
        constructor(t22) {
          const i2 = new e2.da();
          i2.emplaceBack(-1, 1, 1, 0, 0), i2.emplaceBack(1, 1, 1, 1, 0), i2.emplaceBack(1, -1, 1, 1, 1), i2.emplaceBack(-1, -1, 1, 0, 1);
          const o2 = new e2.aO();
          o2.emplaceBack(0, 1, 2), o2.emplaceBack(2, 3, 0), this.vertexBuffer = t22.createVertexBuffer(i2, Qs.members), this.indexBuffer = t22.createIndexBuffer(o2), this.segments = e2.b1.simpleSegment(0, 0, 4, 2);
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
        }
      }
      const ta2 = e2.d5([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_size_scale", components: 1 }, { type: "Float32", name: "a_fade_opacity", components: 1 }]);
      class ia2 {
        constructor() {
          this.starsCount = 16e3, this.sizeMultiplier = 0.15, this.sizeRange = 100, this.intensityRange = 200;
        }
      }
      class oa2 {
        constructor(t22) {
          this.colorModeAlphaBlendedWriteRGB = new Ai2([1, Ri2, 1, Ri2], e2.bz.transparent, [true, true, true, false]), this.colorModeWriteAlpha = new Ai2([1, 0, 1, 0], e2.bz.transparent, [false, false, false, true]), this.params = new ia2(), this.updateNeeded = true, t22.tp.registerParameter(this.params, ["Stars"], "starsCount", { min: 100, max: 16e3, step: 1 }, () => {
            this.updateNeeded = true;
          }), t22.tp.registerParameter(this.params, ["Stars"], "sizeMultiplier", { min: 0.01, max: 2, step: 0.01 }), t22.tp.registerParameter(this.params, ["Stars"], "sizeRange", { min: 0, max: 200, step: 1 }, () => {
            this.updateNeeded = true;
          }), t22.tp.registerParameter(this.params, ["Stars"], "intensityRange", { min: 0, max: 200, step: 1 }, () => {
            this.updateNeeded = true;
          });
        }
        update(t22) {
          const i2 = t22.context;
          if (!this.atmosphereBuffer || this.updateNeeded) {
            this.updateNeeded = false, this.atmosphereBuffer = new ea2(i2);
            const t3 = this.params.sizeRange, o2 = this.params.intensityRange, r22 = function(t4) {
              const i3 = e2.dd(30), o3 = [];
              for (let r3 = 0; r3 < t4; ++r3) {
                const t5 = 2 * Math.PI * i3(), r4 = Math.acos(1 - 2 * i3()) - 0.5 * Math.PI;
                o3.push(e2.a6.vec3.fromValues(Math.cos(r4) * Math.cos(t5), Math.cos(r4) * Math.sin(t5), Math.sin(r4)));
              }
              return o3;
            }(this.params.starsCount), s2 = e2.dd(300), a2 = new e2.db(), n22 = new e2.aO();
            let l22 = 0;
            for (let i3 = 0; i3 < r22.length; ++i3) {
              const c22 = e2.a6.vec3.scale([], r22[i3], 200), h22 = Math.max(0, 1 + 0.01 * t3 * (1 * s2() - 0.5)), u22 = Math.max(0, 1 + 0.01 * o2 * (1 * s2() - 0.5));
              a2.emplaceBack(c22[0], c22[1], c22[2], -1, -1, h22, u22), a2.emplaceBack(c22[0], c22[1], c22[2], 1, -1, h22, u22), a2.emplaceBack(c22[0], c22[1], c22[2], 1, 1, h22, u22), a2.emplaceBack(c22[0], c22[1], c22[2], -1, 1, h22, u22), n22.emplaceBack(l22 + 0, l22 + 1, l22 + 2), n22.emplaceBack(l22 + 0, l22 + 2, l22 + 3), l22 += 4;
            }
            this.starsVx = i2.createVertexBuffer(a2, ta2.members), this.starsIdx = i2.createIndexBuffer(n22), this.starsSegments = e2.b1.simpleSegment(0, 0, a2.length, n22.length);
          }
        }
        destroy() {
          this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
        }
        drawAtmosphereGlow(t22, i2) {
          const o2 = t22.context, r22 = o2.gl, s2 = t22.transform, a2 = new Li2(r22.LEQUAL, Li2.ReadOnly, [0, 1]), n22 = e2.a9(s2.zoom), l22 = t22.style.getLut(i2.scope), c22 = i2.properties.get("color").toRenderColor(l22).toArray01(), h22 = i2.properties.get("high-color").toRenderColor(l22).toArray01(), u22 = i2.properties.get("space-color").toRenderColor(l22).toArray01PremultipliedAlpha(), d22 = 5e-4, _2 = e2.dc(i2.properties.get("horizon-blend"), 0, 1, d22, 0.25), p22 = e2.cx(t22, o2, s2) && _2 === d22 ? s2.worldSize / (2 * Math.PI * 1.025) - 1 : s2.globeRadius, m22 = t22.frameCounter / 1e3 % 1, f22 = e2.a6.vec3.length(s2.globeCenterInViewSpace), g22 = Math.sqrt(Math.pow(f22, 2) - Math.pow(p22, 2)), v22 = Math.acos(g22 / f22), x22 = (e22) => {
            const i3 = "globe" === s2.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
            e22 && i3.push("ALPHA_PASS");
            const l3 = t22.getOrCreateProgram("globeAtmosphere", { defines: i3 }), d3 = /* @__PURE__ */ ((e3, t3, i4, o3, r3, s3, a3, n3, l4, c3, h3, u3) => ({ u_frustum_tl: e3, u_frustum_tr: t3, u_frustum_br: i4, u_frustum_bl: o3, u_horizon: r3, u_transition: s3, u_fadeout_range: a3, u_color: n3, u_high_color: l4, u_space_color: c3, u_temporal_offset: h3, u_horizon_angle: u3 }))(s2.frustumCorners.TL, s2.frustumCorners.TR, s2.frustumCorners.BR, s2.frustumCorners.BL, s2.frustumCorners.horizon, n22, _2, c22, h22, u22, m22, v22);
            t22.uploadCommonUniforms(o2, l3);
            const p3 = this.atmosphereBuffer;
            p3 && l3.draw(t22, r22.TRIANGLES, a2, Mi2.disabled, e22 ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, Fi2.backCW, d3, e22 ? "atmosphere_glow_alpha" : "atmosphere_glow", p3.vertexBuffer, p3.indexBuffer, p3.segments);
          };
          x22(false), x22(true);
        }
        drawStars(t22, i2) {
          const o2 = e2.ap(i2.properties.get("star-intensity"), 0, 1);
          if (0 === o2)
            return;
          const r22 = t22.context, s2 = r22.gl, a2 = t22.transform, n22 = t22.getOrCreateProgram("stars"), l22 = e2.a6.quat.identity([]);
          e2.a6.quat.rotateX(l22, l22, -a2._pitch), e2.a6.quat.rotateZ(l22, l22, -a2.angle), e2.a6.quat.rotateX(l22, l22, e2.bB(a2._center.lat)), e2.a6.quat.rotateY(l22, l22, -e2.bB(a2._center.lng));
          const c22 = e2.a6.mat4.fromQuat(new Float32Array(16), l22), h22 = e2.a6.mat4.multiply([], a2.starsProjMatrix, c22), u22 = e2.a6.mat3.fromMat4([], c22), d22 = e2.a6.mat3.invert([], u22), _2 = [0, 1, 0];
          e2.a6.vec3.transformMat3(_2, _2, d22), e2.a6.vec3.scale(_2, _2, this.params.sizeMultiplier);
          const p22 = [1, 0, 0];
          e2.a6.vec3.transformMat3(p22, p22, d22), e2.a6.vec3.scale(p22, p22, this.params.sizeMultiplier);
          const m22 = (f22 = _2, g22 = p22, v22 = o2, { u_matrix: Float32Array.from(h22), u_up: f22, u_right: g22, u_intensity_multiplier: v22 });
          var f22, g22, v22;
          t22.uploadCommonUniforms(r22, n22), this.starsVx && this.starsIdx && n22.draw(t22, s2.TRIANGLES, Li2.disabled, Mi2.disabled, this.colorModeAlphaBlendedWriteRGB, Fi2.disabled, m22, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
        }
      }
      function ra2(t22, i2) {
        const o2 = [...t22], r22 = i2.cameraWorldSizeForFog / i2.worldSize, s2 = e2.a6.mat4.identity([]);
        return e2.a6.mat4.scale(s2, s2, [r22, r22, 1]), e2.a6.mat4.multiply(o2, s2, o2), e2.a6.mat4.multiply(o2, i2.worldToFogMatrix, o2), o2;
      }
      function sa2(t22, i2, o2, r22, s2) {
        const a2 = o2.material, n22 = r22.context, { baseColorTexture: l22, metallicRoughnessTexture: c22 } = a2.pbrMetallicRoughness, { normalTexture: h22, occlusionTexture: u22, emissionTexture: d22 } = a2;
        function _2(e22, i3, o3) {
          if (e22 && (t22.push(i3), n22.activeTexture.set(n22.gl.TEXTURE0 + o3), e22.gfxTexture)) {
            const { minFilter: t3, magFilter: i4, wrapS: o4, wrapT: r3 } = e22.sampler;
            e22.gfxTexture.bindExtraParam(t3, i4, o4, r3);
          }
        }
        _2(l22, "HAS_TEXTURE_u_baseColorTexture", ji2.BaseColor), _2(c22, "HAS_TEXTURE_u_metallicRoughnessTexture", ji2.MetallicRoughness), _2(h22, "HAS_TEXTURE_u_normalTexture", ji2.Normal), _2(u22, "HAS_TEXTURE_u_occlusionTexture", ji2.Occlusion), _2(d22, "HAS_TEXTURE_u_emissionTexture", ji2.Emission), s2 && (s2.texture || (s2.texture = new e2.df(r22.context, s2.image, [s2.image.height, s2.image.height, s2.image.height], n22.gl.RGBA8)), n22.activeTexture.set(n22.gl.TEXTURE0 + ji2.LUT), s2.texture && s2.texture.bind(n22.gl.LINEAR, n22.gl.CLAMP_TO_EDGE), t22.push("APPLY_LUT_ON_GPU")), o2.texcoordBuffer && (t22.push("HAS_ATTRIBUTE_a_uv_2f"), i2.push(o2.texcoordBuffer)), o2.colorBuffer && (t22.push(12 === o2.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), i2.push(o2.colorBuffer)), o2.normalBuffer && (t22.push("HAS_ATTRIBUTE_a_normal_3f"), i2.push(o2.normalBuffer)), o2.pbrBuffer && (t22.push("HAS_ATTRIBUTE_a_pbr"), t22.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), i2.push(o2.pbrBuffer)), "OPAQUE" !== a2.alphaMode && "MASK" !== a2.alphaMode || t22.push("UNPREMULT_TEXTURE_IN_SHADER"), a2.defined || t22.push("DIFFUSE_SHADED"), t22.push("USE_STANDARD_DERIVATIVES");
      }
      function aa2(t22, i2, o2, r22, s2, a2) {
        const n22 = o2.paint.get("model-opacity"), l22 = i2.context, c22 = new Li2(i2.context.gl.LEQUAL, Li2.ReadWrite, i2.depthRangeFor3D), h22 = i2.transform, u22 = t22.mesh, d22 = u22.material, _2 = d22.pbrMetallicRoughness, p22 = i2.style.fog;
        let m22;
        m22 = "pixels" === i2.transform.projection.zAxisUnit ? [...t22.nodeModelMatrix] : e2.a6.mat4.multiply([], r22.zScaleMatrix, t22.nodeModelMatrix), e2.a6.mat4.multiply(m22, r22.negCameraPosMatrix, m22);
        const f22 = e2.a6.mat4.invert([], m22);
        e2.a6.mat4.transpose(f22, f22);
        const g22 = o2.paint.get("model-emissive-strength").constantOr(0), v22 = ns(new Float32Array(t22.worldViewProjection), new Float32Array(m22), new Float32Array(f22), null, i2, n22, _2.baseColorFactor.toRenderColor(null), d22.emissiveFactor, _2.metallicFactor, _2.roughnessFactor, d22, g22, o2), x22 = { defines: [] }, y22 = [];
        sa2(x22.defines, y22, u22, i2, o2.lut);
        const b22 = i2.shadowRenderer;
        b22 && (b22.useNormalOffset = false);
        let w22 = null;
        if (p22) {
          const e22 = ra2(t22.nodeModelMatrix, i2.transform);
          if (w22 = new Float32Array(e22), "globe" !== h22.projection.name) {
            const t3 = u22.aabb.min, i3 = u22.aabb.max, [o3, r3] = p22.getOpacityForBounds(e22, t3[0], t3[1], i3[0], i3[1]);
            x22.overrideFog = o3 >= Oe2 || r3 >= Oe2;
          }
        }
        const T22 = Wi2(i2, o2.paint.get("model-cutoff-fade-range"));
        T22.shouldRenderCutoff && x22.defines.push("RENDER_CUTOFF");
        const E22 = i2.getOrCreateProgram("model", x22);
        i2.uploadCommonUniforms(l22, E22, null, w22, T22), "shadow" !== i2.renderPass && b22 && b22.setupShadowsFromMatrix(t22.nodeModelMatrix, E22), E22.draw(i2, l22.gl.TRIANGLES, c22, s2, a2, u22.material.doubleSided ? Fi2.disabled : Fi2.backCCW, v22, o2.id, u22.vertexBuffer, u22.indexBuffer, u22.segments, o2.paint, i2.transform.zoom, void 0, y22);
      }
      function na(t22, i2, o2, r22, s2, a2, n22) {
        let l22;
        l22 = "globe" === t22.projection.name ? e2.dg(o2, t22) : [...o2], e2.a6.mat4.multiply(l22, l22, i2.matrix);
        const c22 = e2.a6.mat4.multiply([], r22, l22);
        if (i2.meshes)
          for (const t3 of i2.meshes) {
            if ("BLEND" !== t3.material.alphaMode) {
              n22.push({ mesh: t3, depth: 0, modelIndex: s2, worldViewProjection: c22, nodeModelMatrix: l22 });
              continue;
            }
            const i3 = e2.a6.vec3.transformMat4([], t3.centroid, c22);
            i3[2] > 0 && a2.push({ mesh: t3, depth: i3[2], modelIndex: s2, worldViewProjection: c22, nodeModelMatrix: l22 });
          }
        if (i2.children)
          for (const e22 of i2.children)
            na(t22, e22, o2, r22, s2, a2, n22);
      }
      function la2(e22, t22, i2, o2) {
        const r22 = i2.shadowRenderer;
        if (!r22)
          return;
        const s2 = r22.getShadowPassDepthMode(), a2 = r22.getShadowPassColorMode(), n22 = r22.calculateShadowPassMatrixFromMatrix(t22), l22 = ls(n22);
        i2.getOrCreateProgram("modelDepth", { defines: i2._shadowMapDebug ? [] : ["DEPTH_TEXTURE"] }).draw(i2, i2.context.gl.TRIANGLES, s2, Mi2.disabled, a2, Fi2.backCCW, l22, o2.id, e22.vertexBuffer, e22.indexBuffer, e22.segments, o2.paint, i2.transform.zoom, void 0, void 0);
      }
      function ca2(t22, i2, o2) {
        const r22 = i2.updateZoomBasedPaintProperties(), s2 = function(t3, i3, o3) {
          let r3, s3, a2, n22 = t3.terrain ? t3.terrain.exaggeration() : 0;
          if (t3.terrain && n22 > 0) {
            const i4 = t3.terrain, s4 = i4.findDEMTileFor(o3);
            s4 && s4.dem ? r3 = e2.di.create(i4, o3, s4) : n22 = 0;
          }
          if (0 === n22 && (i3.terrainElevationMin = 0, i3.terrainElevationMax = 0), n22 === i3.validForExaggeration && (0 === n22 || r3 && r3._demTile && r3._demTile.tileID === i3.validForDEMTile.id && r3._dem._timestamp === i3.validForDEMTile.timestamp))
            return false;
          for (const e22 in i3.instancesPerModel) {
            const t4 = i3.instancesPerModel[e22];
            for (let e3 = 0; e3 < t4.instancedDataArray.length; ++e3) {
              const o4 = (r3 ? n22 * r3.getElevationAt(0 | t4.instancedDataArray.float32[16 * e3], 0 | t4.instancedDataArray.float32[16 * e3 + 1], true, true) : 0) + t4.instancesEvaluatedElevation[e3];
              t4.instancedDataArray.float32[16 * e3 + 6] = o4, s3 = s3 ? Math.min(i3.terrainElevationMin, o4) : o4, a2 = a2 ? Math.max(i3.terrainElevationMax, o4) : o4;
            }
          }
          return i3.terrainElevationMin = s3 || 0, i3.terrainElevationMax = a2 || 0, i3.validForExaggeration = n22, i3.validForDEMTile = r3 && r3._demTile ? { id: r3._demTile.tileID, timestamp: r3._dem._timestamp } : { id: void 0, timestamp: 0 }, true;
        }(t22, i2, o2);
        (r22 || s2) && (i2.uploaded = false, i2.upload(t22.context));
      }
      const ha2 = { shadowUniformsInitialized: false, useSingleShadowCascade: false, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new e2.c9([0, 0, 0], [e2.ab, e2.ab, 0]) };
      function ua2(t22, i2) {
        const o2 = 1 << t22.canonical.z, r22 = i2.getFreeCameraOptions().position, s2 = i2.elevation, a2 = t22.canonical.x / o2, n22 = (t22.canonical.x + 1) / o2, l22 = t22.canonical.y / o2, c22 = (t22.canonical.y + 1) / o2;
        let h22 = i2._centerAltitude;
        if (s2) {
          const e22 = s2.getMinMaxForTile(t22);
          e22 && e22.max > h22 && (h22 = e22.max);
        }
        const u22 = e2.ap(r22.x, a2, n22) - r22.x, d22 = e2.ap(r22.y, l22, c22) - r22.y, _2 = e2.bD(h22, i2.center.lat) - r22.z;
        return i2._zoomFromMercatorZ(Math.sqrt(u22 * u22 + d22 * d22 + _2 * _2));
      }
      function da2(e22, t22, i2, o2, r22, s2, a2) {
        const n22 = e22.context, l22 = "shadow" === e22.renderPass, c22 = e22.shadowRenderer, h22 = l22 && c22 ? c22.getShadowPassDepthMode() : new Li2(n22.gl.LEQUAL, Li2.ReadWrite, e22.depthRangeFor3D), u22 = e22.isTileAffectedByFog(s2);
        if (i2.meshes)
          for (const d22 of i2.meshes) {
            const _2 = ["MODEL_POSITION_ON_GPU"], p22 = [];
            let m22, f22, g22;
            o2.instancedDataArray.length > 20 && _2.push("INSTANCED_ARRAYS");
            const v22 = Wi2(e22, t22.paint.get("model-cutoff-fade-range"));
            if (v22.shouldRenderCutoff && _2.push("RENDER_CUTOFF"), l22 && c22)
              m22 = e22.getOrCreateProgram("modelDepth", { defines: _2 }), f22 = ls(a2.shadowTileMatrix, a2.shadowTileMatrix, Float32Array.from(i2.matrix)), g22 = c22.getShadowPassColorMode();
            else {
              sa2(_2, p22, d22, e22, t22.lut), m22 = e22.getOrCreateProgram("model", { defines: _2, overrideFog: u22 });
              const o3 = d22.material, l3 = o3.pbrMetallicRoughness, h3 = t22.paint.get("model-opacity"), x3 = t22.paint.get("model-emissive-strength").constantOr(0);
              f22 = ns(s2.expandedProjMatrix, Float32Array.from(i2.matrix), new Float32Array(16), null, e22, h3, l3.baseColorFactor.toRenderColor(null), o3.emissiveFactor, l3.metallicFactor, l3.roughnessFactor, o3, x3, t22, r22), c22 && (a2.shadowUniformsInitialized ? m22.setShadowUniformValues(n22, c22.getShadowUniformValues()) : (c22.setupShadows(s2.toUnwrapped(), m22, "model-tile", s2.overscaledZ), a2.shadowUniformsInitialized = true)), g22 = v22.shouldRenderCutoff || h3 < 1 || "OPAQUE" !== o3.alphaMode ? Ai2.alphaBlended : Ai2.unblended;
            }
            e22.uploadCommonUniforms(n22, m22, s2.toUnwrapped(), null, v22);
            const x22 = d22.material.doubleSided ? Fi2.disabled : Fi2.backCCW;
            if (o2.instancedDataArray.length > 20)
              p22.push(o2.instancedDataBuffer), m22.draw(e22, n22.gl.TRIANGLES, h22, Mi2.disabled, g22, x22, f22, t22.id, d22.vertexBuffer, d22.indexBuffer, d22.segments, t22.paint, e22.transform.zoom, void 0, p22, o2.instancedDataArray.length);
            else {
              const i3 = l22 ? "u_instance" : "u_normal_matrix";
              for (let r3 = 0; r3 < o2.instancedDataArray.length; ++r3)
                f22[i3] = new Float32Array(o2.instancedDataArray.arrayBuffer, 64 * r3, 16), m22.draw(e22, n22.gl.TRIANGLES, h22, Mi2.disabled, g22, x22, f22, t22.id, d22.vertexBuffer, d22.indexBuffer, d22.segments, t22.paint, e22.transform.zoom, void 0, p22);
            }
          }
        if (i2.children)
          for (const n3 of i2.children)
            da2(e22, t22, n3, o2, r22, s2, a2);
      }
      const _a = [1, -1, 1];
      function pa2(t22, i2, o2, r22) {
        if (!o2.modelManager)
          return true;
        const s2 = o2.modelManager;
        if (!o2.shadowRenderer)
          return true;
        const a2 = o2.shadowRenderer, n22 = i2.aabb;
        let l22 = true, c22 = t22.maxHeight;
        if (0 === c22) {
          let e22 = 0;
          for (const i3 in t22.instancesPerModel) {
            const t3 = s2.getModel(i3, r22);
            t3 ? e22 = Math.max(e22, Math.max(Math.max(t3.aabb.max[0], t3.aabb.max[1]), t3.aabb.max[2])) : l22 = false;
          }
          c22 = t22.maxScale * e22 * 1.41 + t22.maxVerticalOffset, l22 && (t22.maxHeight = c22);
        }
        n22.max[2] = c22, n22.min[2] += t22.terrainElevationMin, n22.max[2] += t22.terrainElevationMax, e2.a6.vec3.transformMat4(n22.min, n22.min, i2.tileMatrix), e2.a6.vec3.transformMat4(n22.max, n22.max, i2.tileMatrix);
        const h22 = n22.intersects(a2.getCurrentCascadeFrustum());
        return 0 === o2.currentShadowCascade && (t22.isInsideFirstShadowMapFrustum = 2 === h22), 0 === h22;
      }
      function ma2(t22, i2) {
        const o2 = t22.uniformValues.u_cutoff_params[0], r22 = t22.uniformValues.u_cutoff_params[1], s2 = t22.uniformValues.u_cutoff_params[2], a2 = t22.uniformValues.u_cutoff_params[3];
        return r22 === o2 || a2 === s2 ? 1 : e2.ap(((i2 - o2) / (r22 - o2) - s2) / (a2 - s2), 0, 1);
      }
      function fa2(t22, i2, o2, r22) {
        if (i2.pitch < 20)
          return 1;
        const s2 = i2.getWorldToCameraMatrix();
        e2.a6.mat4.multiply(s2, s2, t22);
        const a2 = e2.a6.vec4.fromValues(o2.min[0], o2.min[1], o2.min[2], 1);
        let n22 = e2.a6.vec4.transformMat4(e2.a6.vec4.create(), a2, s2), l22 = n22, c22 = n22;
        a2[1] = o2.max[1], n22 = e2.a6.vec4.transformMat4(e2.a6.vec4.create(), a2, s2), l22 = n22[1] < l22[1] ? n22 : l22, c22 = n22[1] > c22[1] ? n22 : c22, a2[0] = o2.max[0], n22 = e2.a6.vec4.transformMat4(e2.a6.vec4.create(), a2, s2), l22 = n22[1] < l22[1] ? n22 : l22, c22 = n22[1] > c22[1] ? n22 : c22, a2[1] = o2.min[1], n22 = e2.a6.vec4.transformMat4(e2.a6.vec4.create(), a2, s2), l22 = n22[1] < l22[1] ? n22 : l22, c22 = n22[1] > c22[1] ? n22 : c22;
        const h22 = e2.ap(r22[0], 0, 1), u22 = 100 * i2.pixelsPerMeter * e2.ap(r22[1], 0, 1), d22 = e2.ap(r22[2], 0, 1), _2 = e2.a6.vec4.lerp(e2.a6.vec4.create(), l22, c22, h22), p22 = Math.tan(0.5 * i2.fovX), m22 = -_2[2] * p22;
        if (0 === u22)
          return _2[1] < -Math.abs(m22) ? d22 : 1;
        const f22 = (-Math.abs(m22) - _2[1]) / u22, g22 = (e22, t3, i3) => (1 - i3) * e22 + i3 * t3, v22 = e2.ap(g22(1, d22, f22), d22, 1);
        return g22(1, v22, e2.ap((i2.pitch - 20) / 20, 0, 1));
      }
      class ga {
      }
      class va2 {
        constructor() {
          this._storage = /* @__PURE__ */ new Map();
        }
        getLinesFromTrianglesBuffer(t22, i2, o2) {
          {
            const e22 = this._storage.get(i2.id);
            if (e22)
              return e22.lastUsedFrameIdx = t22, e22.buf;
          }
          const r22 = o2.gl, s2 = r22.getBufferParameter(r22.ELEMENT_ARRAY_BUFFER, r22.BUFFER_SIZE), a2 = new ArrayBuffer(s2), n22 = new Int16Array(a2);
          r22.getBufferSubData(r22.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(a2));
          const l22 = new e2.dk();
          for (let e22 = 0; e22 < s2 / 2; e22 += 3) {
            const t3 = n22[e22], i3 = n22[e22 + 1], o3 = n22[e22 + 2];
            l22.emplaceBack(t3, i3), l22.emplaceBack(i3, o3), l22.emplaceBack(o3, t3);
          }
          const c22 = o2.bindVertexArrayOES.current, h22 = new ga();
          return h22.buf = new hs(o2, l22), h22.lastUsedFrameIdx = t22, this._storage.set(i2.id, h22), o2.bindVertexArrayOES.set(c22), h22.buf;
        }
        update(e22) {
          for (const [t22, i2] of this._storage)
            e22 - i2.lastUsedFrameIdx > 30 && (i2.buf.destroy(), this._storage.delete(t22));
        }
        destroy() {
          for (const [e22, t22] of this._storage)
            t22.buf.destroy(), this._storage.delete(e22);
        }
      }
      class xa {
        constructor(e22) {
          this.occluderSize = 30, this.depthOffset = -1e-4, e22.registerParameter(this, ["Occlusion"], "occluderSize", { min: 1, max: 100, step: 1 }), e22.registerParameter(this, ["Occlusion"], "depthOffset", { min: -0.05, max: 0, step: 1e-5 });
        }
      }
      const ya2 = { symbol: function(t22, i2, o2, r22, s2) {
        if ("translucent" !== t22.renderPass)
          return;
        const a2 = Mi2.disabled, n22 = t22.colorModeForRenderPass();
        o2.layout.get("text-variable-anchor") && function(t3, i3, o3, r3, s3, a3, n3) {
          const l3 = i3.transform, c3 = "map" === s3, h22 = "map" === a3;
          for (const i4 of t3) {
            const t4 = r3.getTile(i4), s4 = t4.getBucket(o3);
            if (!s4 || !s4.text || !s4.text.segments.get().length)
              continue;
            const a4 = e2.bj(s4.textSizeData, l3.zoom), u22 = ii2(i4, s4.getProjection(), l3), d22 = l3.calculatePixelsToTileUnitsMatrix(t4), _2 = kt(u22, t4.tileID.canonical, h22, c3, l3, s4.getProjection(), d22), p22 = s4.hasIconTextFit() && s4.hasIconData();
            if (a4) {
              const o4 = Math.pow(2, l3.zoom - t4.tileID.overscaledZ);
              ys(s4, c3, h22, n3, e2.cS, l3, _2, i4, o4, a4, p22);
            }
          }
        }(r22, t22, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), s2);
        const l22 = 0 !== o2.paint.get("icon-opacity").constantOr(1), c22 = 0 !== o2.paint.get("text-opacity").constantOr(1);
        void 0 !== o2.layout.get("symbol-sort-key").constantOr(1) && (l22 || c22) ? bs(t22, i2, o2, r22, a2, n22) : (l22 && bs(t22, i2, o2, r22, a2, n22, { onlyIcons: true }), c22 && bs(t22, i2, o2, r22, a2, n22, { onlyText: true })), i2.map.showCollisionBoxes && (fs(t22, i2, o2, r22, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), fs(t22, i2, o2, r22, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
      }, circle: function(t22, i2, o2, r22) {
        if ("translucent" !== t22.renderPass)
          return;
        const s2 = o2.paint.get("circle-opacity"), a2 = o2.paint.get("circle-stroke-width"), n22 = o2.paint.get("circle-stroke-opacity"), l22 = void 0 !== o2.layout.get("circle-sort-key").constantOr(1), c22 = o2.paint.get("circle-emissive-strength");
        if (0 === s2.constantOr(1) && (0 === a2.constantOr(1) || 0 === n22.constantOr(1)))
          return;
        const h22 = t22.context, u22 = h22.gl, d22 = t22.transform, _2 = t22.depthModeForSublayer(0, Li2.ReadOnly), p22 = Mi2.disabled, m22 = t22.colorModeForDrapableLayerRenderPass(c22), f22 = "globe" === d22.projection.name, g22 = [e2.am(d22.center.lng), e2.at(d22.center.lat)], v22 = [];
        for (let s3 = 0; s3 < r22.length; s3++) {
          const a3 = r22[s3], n3 = i2.getTile(a3), c3 = n3.getBucket(o2);
          if (!c3 || c3.projection.name !== d22.projection.name)
            continue;
          const h3 = c3.programConfigurations.get(o2.id), u3 = e2.cT(o2), _3 = t22.isTileAffectedByFog(a3);
          f22 && u3.push("PROJECTION_GLOBE_VIEW"), u3.push("DEPTH_D24"), t22.terrain && d22.depthOcclusionForSymbolsAndCircles && u3.push("DEPTH_OCCLUSION");
          const p3 = t22.getOrCreateProgram("circle", { config: h3, defines: u3, overrideFog: _3 }), m3 = c3.layoutVertexBuffer, x3 = c3.globeExtVertexBuffer, y22 = c3.indexBuffer, b22 = d22.projection.createInversionMatrix(d22, a3.canonical), w22 = { programConfiguration: h3, program: p3, layoutVertexBuffer: m3, globeExtVertexBuffer: x3, indexBuffer: y22, uniformValues: e2.cU(t22, a3, n3, b22, g22, o2), tile: n3 };
          if (l22) {
            const t3 = c3.segments.get();
            for (const i3 of t3)
              v22.push({ segments: new e2.b1([i3]), sortKey: i3.sortKey, state: w22 });
          } else
            v22.push({ segments: c3.segments, sortKey: 0, state: w22 });
        }
        l22 && v22.sort((e22, t3) => e22.sortKey - t3.sortKey);
        const x22 = { useDepthForOcclusion: d22.depthOcclusionForSymbolsAndCircles };
        for (const e22 of v22) {
          const { programConfiguration: i3, program: r3, layoutVertexBuffer: s3, globeExtVertexBuffer: a3, indexBuffer: n3, uniformValues: l3, tile: c3 } = e22.state, f3 = e22.segments;
          t22.terrain && t22.terrain.setupElevationDraw(c3, r3, x22), t22.uploadCommonUniforms(h22, r3, c3.tileID.toUnwrapped()), r3.draw(t22, u22.TRIANGLES, _2, p22, m22, Fi2.disabled, l3, o2.id, s3, n3, f3, o2.paint, d22.zoom, i3, [a3]);
        }
      }, heatmap: function(t22, i2, o2, r22) {
        if (0 !== o2.paint.get("heatmap-opacity"))
          if ("offscreen" === t22.renderPass) {
            const s2 = t22.context, a2 = s2.gl, n22 = Mi2.disabled, l22 = new Ai2([a2.ONE, a2.ONE, a2.ONE, a2.ONE], e2.bz.transparent, [true, true, true, true]);
            !function(e22, t3, i3, o3) {
              const r3 = e22.gl, s3 = t3.width * o3, a3 = t3.height * o3;
              e22.activeTexture.set(r3.TEXTURE1), e22.viewport.set([0, 0, s3, a3]);
              let n3 = i3.heatmapFbo;
              if (!n3 || n3 && (n3.width !== s3 || n3.height !== a3)) {
                n3 && n3.destroy();
                const t4 = r3.createTexture();
                r3.bindTexture(r3.TEXTURE_2D, t4), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_S, r3.CLAMP_TO_EDGE), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_T, r3.CLAMP_TO_EDGE), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MIN_FILTER, r3.LINEAR), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MAG_FILTER, r3.LINEAR), n3 = i3.heatmapFbo = e22.createFramebuffer(s3, a3, true, null), function(e3, t5, i4, o4, r4, s4) {
                  const a4 = e3.gl;
                  a4.texImage2D(a4.TEXTURE_2D, 0, e3.extRenderToTextureHalfFloat ? a4.RGBA16F : a4.RGBA, r4, s4, 0, a4.RGBA, e3.extRenderToTextureHalfFloat ? a4.HALF_FLOAT : a4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                }(e22, 0, t4, n3, s3, a3);
              } else
                r3.bindTexture(r3.TEXTURE_2D, n3.colorAttachment.get()), e22.bindFramebuffer.set(n3.framebuffer);
            }(s2, t22, o2, "globe" === t22.transform.projection.name ? 0.5 : 0.25), s2.clear({ color: e2.bz.transparent });
            const c22 = t22.transform, h22 = "globe" === c22.projection.name, u22 = h22 ? ["PROJECTION_GLOBE_VIEW"] : [], d22 = h22 ? Fi2.frontCCW : Fi2.disabled, _2 = [e2.am(c22.center.lng), e2.at(c22.center.lat)];
            for (let e22 = 0; e22 < r22.length; e22++) {
              const p22 = r22[e22];
              if (i2.hasRenderableParent(p22))
                continue;
              const m22 = i2.getTile(p22), f22 = m22.getBucket(o2);
              if (!f22 || f22.projection.name !== c22.projection.name)
                continue;
              const g22 = t22.isTileAffectedByFog(p22), v22 = f22.programConfigurations.get(o2.id), x22 = t22.getOrCreateProgram("heatmap", { config: v22, defines: u22, overrideFog: g22 }), { zoom: y22 } = t22.transform;
              t22.terrain && t22.terrain.setupElevationDraw(m22, x22), t22.uploadCommonUniforms(s2, x22, p22.toUnwrapped());
              const b22 = c22.projection.createInversionMatrix(c22, p22.canonical);
              x22.draw(t22, a2.TRIANGLES, Li2.disabled, n22, l22, d22, Wr(t22, p22, m22, b22, _2, y22, o2.paint.get("heatmap-intensity")), o2.id, f22.layoutVertexBuffer, f22.indexBuffer, f22.segments, o2.paint, t22.transform.zoom, v22, h22 ? [f22.globeExtVertexBuffer] : null);
            }
            s2.viewport.set([0, 0, t22.width, t22.height]);
          } else
            "translucent" === t22.renderPass && (t22.context.setColorMode(t22.colorModeForRenderPass()), function(t3, i3) {
              const o3 = t3.context, r3 = o3.gl, s2 = i3.heatmapFbo;
              if (!s2)
                return;
              o3.activeTexture.set(r3.TEXTURE0), r3.bindTexture(r3.TEXTURE_2D, s2.colorAttachment.get()), o3.activeTexture.set(r3.TEXTURE1);
              let a2 = i3.colorRampTexture;
              a2 || (a2 = i3.colorRampTexture = new e2.T(o3, i3.colorRamp, r3.RGBA8)), a2.bind(r3.LINEAR, r3.CLAMP_TO_EDGE), t3.getOrCreateProgram("heatmapTexture").draw(t3, r3.TRIANGLES, Li2.disabled, Mi2.disabled, t3.colorModeForRenderPass(), Fi2.disabled, ((e22, t4, i4, o4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t4.paint.get("heatmap-opacity") }))(0, i3), i3.id, t3.viewportBuffer, t3.quadTriangleIndexBuffer, t3.viewportSegments, i3.paint, t3.transform.zoom);
            }(t22, o2));
      }, line: function(t22, i2, o2, r22) {
        if ("translucent" !== t22.renderPass)
          return;
        const s2 = o2.paint.get("line-opacity"), a2 = o2.paint.get("line-width");
        if (0 === s2.constantOr(1) || 0 === a2.constantOr(1))
          return;
        const n22 = o2.paint.get("line-emissive-strength"), l22 = o2.paint.get("line-occlusion-opacity"), c22 = t22.context, h22 = c22.gl, u22 = o2.layout.get("line-z-offset"), d22 = !u22.isConstant() || !!u22.constantOr(0), _2 = d22 ? new Li2(t22.depthOcclusion ? h22.GREATER : h22.LEQUAL, Li2.ReadOnly, t22.depthRangeFor3D) : t22.depthModeForSublayer(0, Li2.ReadOnly), p22 = t22.colorModeForDrapableLayerRenderPass(n22), m22 = t22.terrain && t22.terrain.renderingToTexture, f22 = m22 ? 1 : e2.q.devicePixelRatio, g22 = o2.paint.get("line-dasharray"), v22 = g22.constantOr(1), x22 = o2.layout.get("line-cap"), y22 = g22.constantOr(null), b22 = x22.constantOr(null), w22 = o2.paint.get("line-pattern"), T22 = w22.constantOr(1), E22 = w22.constantOr(null), C22 = o2.paint.get("line-opacity").constantOr(1);
        let S22 = !T22 && 1 !== C22 || t22.depthOcclusion && l22 > 0 && l22 < 1;
        const I22 = o2.paint.get("line-gradient"), D22 = T22 ? "linePattern" : "line", R22 = e2.cV(o2);
        let A22;
        if (m22 && t22.terrain && t22.terrain.clipOrMaskOverlapStencilType() && (S22 = false), 0 !== l22 && t22.depthOcclusion) {
          const t3 = o2.paint._values["line-opacity"];
          t3 && t3.value && "constant" === t3.value.kind ? A22 = t3.value : e2.w("Occlusion opacity for layer ".concat(o2.id, " is supported only when line-opacity isn't data-driven."));
        }
        if (d22 && (t22.forceTerrainMode = true), !d22 && 0 !== l22 && t22.terrain && !m22)
          return void e2.w("Occlusion opacity for layer ".concat(o2.id, " is supported on terrain only if the layer has non-zero line-z-offset."));
        const L22 = S22 && d22 ? t22.stencilModeFor3D() : Mi2.disabled;
        for (const s3 of r22) {
          const r3 = i2.getTile(s3);
          if (T22 && !r3.patternsLoaded())
            continue;
          const a3 = r3.getBucket(o2);
          if (!a3)
            continue;
          t22.prepareDrawTile();
          const n3 = a3.programConfigurations.get(o2.id), u3 = t22.isTileAffectedByFog(s3), g3 = t22.getOrCreateProgram(D22, { config: n3, defines: d22 ? [...R22, "ELEVATED"] : R22, overrideFog: u3 });
          if (E22 && r3.imageAtlas) {
            const e22 = r3.imageAtlas.patternPositions[E22.toString()];
            e22 && n3.setConstantPatternPositions(e22);
          }
          if (!T22 && y22 && b22 && r3.lineAtlas) {
            const e22 = r3.lineAtlas.getDash(y22, b22);
            e22 && n3.setConstantPatternPositions(e22);
          }
          let [x3, w3] = o2.paint.get("line-trim-offset");
          if ("round" === b22 || "square" === b22) {
            const e22 = 1;
            x3 !== w3 && (0 === x3 && (x3 -= e22), 1 === w3 && (w3 += e22));
          }
          const P22 = m22 ? s3.projMatrix : null, M22 = T22 ? e2.cW(t22, r3, o2, P22, f22, [x3, w3]) : e2.cX(t22, r3, o2, P22, a3.lineClipsArray.length, f22, [x3, w3]);
          if (I22) {
            const r4 = a3.gradients[o2.id];
            let n4 = r4.texture;
            if (o2.gradientVersion !== r4.version) {
              let l3 = 256;
              if (o2.stepInterpolant) {
                const o3 = i2.getSource().maxzoom, r5 = s3.canonical.z === o3 ? Math.ceil(1 << t22.transform.maxZoom - s3.canonical.z) : 1;
                l3 = e2.ap(e2.cY(a3.maxLineLength / e2.ab * 1024 * r5), 256, c22.maxTextureSize);
              }
              r4.gradient = e2.cZ({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: r4.gradient || void 0, clips: a3.lineClipsArray }), r4.texture ? r4.texture.update(r4.gradient) : r4.texture = new e2.T(c22, r4.gradient, h22.RGBA8), r4.version = o2.gradientVersion, n4 = r4.texture;
            }
            c22.activeTexture.set(h22.TEXTURE1), n4.bind(o2.stepInterpolant ? h22.NEAREST : h22.LINEAR, h22.CLAMP_TO_EDGE);
          }
          v22 && (c22.activeTexture.set(h22.TEXTURE0), r3.lineAtlasTexture && r3.lineAtlasTexture.bind(h22.LINEAR, h22.REPEAT), n3.updatePaintBuffers()), T22 && (c22.activeTexture.set(h22.TEXTURE0), r3.imageAtlasTexture && r3.imageAtlasTexture.bind(h22.LINEAR, h22.CLAMP_TO_EDGE), n3.updatePaintBuffers()), d22 && t22.terrain.setupElevationDraw(r3, g3), t22.uploadCommonUniforms(c22, g3, s3.toUnwrapped());
          const z22 = (e22) => {
            null != A22 && (A22.value = C22 * l22), g3.draw(t22, h22.TRIANGLES, _2, e22, p22, Fi2.disabled, M22, o2.id, a3.layoutVertexBuffer, a3.indexBuffer, a3.segments, o2.paint, t22.transform.zoom, n3, [a3.layoutVertexBuffer2, a3.patternVertexBuffer, a3.zOffsetVertexBuffer]), null != A22 && (A22.value = C22);
          };
          if (S22 && !d22) {
            const e22 = t22.stencilModeForClipping(s3).ref;
            0 === e22 && m22 && c22.clear({ stencil: 0 });
            const i3 = { func: h22.EQUAL, mask: 255 };
            M22.u_alpha_discard_threshold = 0.8, z22(new Mi2(i3, e22, 255, h22.KEEP, h22.KEEP, h22.INVERT)), M22.u_alpha_discard_threshold = 0, z22(new Mi2(i3, e22, 255, h22.KEEP, h22.KEEP, h22.KEEP));
          } else
            S22 && d22 && (M22.u_alpha_discard_threshold = 1e-3), z22(d22 ? L22 : t22.stencilModeForClipping(s3));
        }
        S22 && (t22.resetStencilClippingMasks(), m22 && c22.clear({ stencil: 0 })), 0 === l22 || t22.depthOcclusion || m22 || t22.layersWithOcclusionOpacity.push(t22.currentLayer), d22 && (t22.forceTerrainMode = false);
      }, fill: function(t22, i2, o2, r22) {
        const s2 = o2.paint.get("fill-color"), a2 = o2.paint.get("fill-opacity"), n22 = o2.is3D(), l22 = new Li2(t22.context.gl.LEQUAL, Li2.ReadWrite, t22.depthRangeFor3D);
        if (0 === a2.constantOr(1))
          return;
        const c22 = o2.paint.get("fill-emissive-strength"), h22 = t22.colorModeForDrapableLayerRenderPass(c22), u22 = o2.paint.get("fill-pattern"), d22 = t22.opaquePassEnabledForLayer() && !u22.constantOr(1) && 1 === s2.constantOr(e2.bz.transparent).a && 1 === a2.constantOr(0) ? "opaque" : "translucent";
        if (t22.renderPass === d22) {
          const e22 = n22 ? l22 : t22.depthModeForSublayer(1, "opaque" === t22.renderPass ? Li2.ReadWrite : Li2.ReadOnly);
          Ts(t22, i2, o2, r22, e22, h22, false);
        }
        if (!n22 && "translucent" === t22.renderPass && o2.paint.get("fill-antialias")) {
          const e22 = n22 ? l22 : t22.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, Li2.ReadOnly);
          Ts(t22, i2, o2, r22, e22, h22, true);
        }
      }, "fill-extrusion": function(t22, i2, o2, r22) {
        const s2 = o2.paint.get("fill-extrusion-opacity"), a2 = t22.context, n22 = a2.gl, l22 = t22.terrain, c22 = l22 && l22.renderingToTexture;
        if (0 === s2)
          return;
        const h22 = t22.conflationActive && t22.style.isLayerClipped(o2, i2.getSource()), u22 = t22.style.order.indexOf(o2.fqid);
        if (h22 && function(e22, t3, i3, o3, r3) {
          for (const s3 of o3) {
            const o4 = t3.getTile(s3).getBucket(i3);
            o4 && (o4.updateReplacement(s3, e22.replacementSource, r3), o4.uploadCentroid(e22.context));
          }
        }(t22, i2, o2, r22, u22), l22 || h22)
          for (const e22 of r22) {
            const r3 = i2.getTile(e22).getBucket(o2);
            r3 && Ss(t22.context, i2, e22, r3, o2, l22, h22);
          }
        if ("shadow" === t22.renderPass && t22.shadowRenderer) {
          const a3 = t22.shadowRenderer;
          if (l22 && s2 < 0.65 && o2._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof e2.a4)
            return;
          const n3 = a3.getShadowPassDepthMode(), c3 = a3.getShadowPassColorMode();
          Es(t22, i2, o2, r22, n3, Mi2.disabled, c3, h22);
        } else if ("translucent" === t22.renderPass) {
          const u3 = !o2.paint.get("fill-extrusion-pattern").constantOr(1), d22 = o2.paint.get("fill-extrusion-color").constantOr(e2.bz.white);
          if (!c22 && 0 !== d22.a) {
            const e22 = new Li2(t22.context.gl.LEQUAL, Li2.ReadWrite, t22.depthRangeFor3D);
            1 === s2 && u3 ? Es(t22, i2, o2, r22, e22, Mi2.disabled, Ai2.unblended, h22) : (Es(t22, i2, o2, r22, e22, Mi2.disabled, Ai2.disabled, h22), Es(t22, i2, o2, r22, e22, t22.stencilModeFor3D(), t22.colorModeForRenderPass(), h22), t22.resetStencilClippingMasks());
          }
          if (t22.style.enable3dLights() && u3 && (!l22 && "globe" !== t22.transform.projection.name || c22)) {
            const s3 = o2.paint.get("fill-extrusion-opacity"), u4 = o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), d3 = o2.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), _2 = o2.paint.get("fill-extrusion-flood-light-intensity"), p22 = o2.paint.get("fill-extrusion-flood-light-color").toRenderColor(o2.lut).toArray01().slice(0, 3), m22 = u4 > 0 && d3 > 0, f22 = _2 > 0, g22 = (e22, t3, i3) => (1 - i3) * e22 + i3 * t3, v22 = (a3) => {
              const l3 = t22.depthModeForSublayer(1, Li2.ReadOnly, n22.LEQUAL, true), c3 = o2.paint.get(a3 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), m3 = g22(0.1, 3, c3), f3 = t22._showOverdrawInspector;
              if (!f3) {
                const c4 = new Mi2({ func: n22.ALWAYS, mask: 255 }, 255, 255, n22.KEEP, n22.KEEP, n22.REPLACE), f4 = new Ai2([n22.ONE, n22.ONE, n22.ONE, n22.ONE], e2.bz.transparent, [false, false, false, true], n22.MIN);
                Cs(t22, i2, o2, r22, l3, c4, f4, Fi2.disabled, a3, "sdf", s3, u4, d3, _2, p22, m3, h22, false);
              }
              {
                const c4 = f3 ? Mi2.disabled : new Mi2({ func: n22.EQUAL, mask: 255 }, 255, 255, n22.KEEP, n22.DECR, n22.DECR), g3 = f3 ? t22.colorModeForRenderPass() : new Ai2([n22.ONE_MINUS_DST_ALPHA, n22.DST_ALPHA, n22.ONE, n22.ONE], e2.bz.transparent, [true, true, true, true]);
                Cs(t22, i2, o2, r22, l3, c4, g3, Fi2.disabled, a3, "color", s3, u4, d3, _2, p22, m3, h22, false);
              }
            };
            if (c22) {
              const c3 = (a3, l3, c4) => {
                const m3 = t22.depthModeForSublayer(1, Li2.ReadOnly, n22.LEQUAL, false), f3 = o2.paint.get(a3 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), v3 = g22(0.1, 3, f3);
                {
                  const c5 = new Ai2([n22.ONE, n22.ONE, n22.ONE, n22.ONE], e2.bz.transparent, [false, false, false, true]);
                  Cs(t22, i2, o2, r22, m3, Mi2.disabled, c5, Fi2.disabled, a3, "clear", s3, u4, d3, _2, p22, v3, h22, l3);
                }
                {
                  const c5 = new Mi2({ func: n22.ALWAYS, mask: 255 }, 255, 255, n22.KEEP, n22.KEEP, n22.REPLACE), f4 = new Ai2([n22.ONE, n22.ONE, n22.ONE, n22.ONE], e2.bz.transparent, [false, false, false, true], n22.MIN);
                  Cs(t22, i2, o2, r22, m3, c5, f4, Fi2.disabled, a3, "sdf", s3, u4, d3, _2, p22, v3, h22, l3);
                }
                {
                  const c5 = a3 ? n22.ZERO : n22.ONE_MINUS_DST_ALPHA, f4 = new Mi2({ func: n22.EQUAL, mask: 255 }, 255, 255, n22.KEEP, n22.DECR, n22.DECR), g3 = new Ai2([c5, n22.DST_ALPHA, n22.ONE_MINUS_DST_ALPHA, n22.ZERO], e2.bz.transparent, [true, true, true, true]);
                  Cs(t22, i2, o2, r22, m3, f4, g3, Fi2.disabled, a3, "color", s3, u4, d3, _2, p22, v3, h22, l3);
                }
                {
                  const f4 = new Ai2([n22.ONE, n22.ONE, n22.ONE, a3 ? n22.ZERO : n22.ONE], e2.bz.transparent, [false, false, false, true], a3 ? n22.FUNC_ADD : n22.MAX);
                  Cs(t22, i2, o2, r22, m3, Mi2.disabled, f4, Fi2.disabled, a3, "clear", s3, u4, d3, _2, p22, v3, h22, l3, c4);
                }
              };
              if (m22 || f22) {
                let i3;
                if (t22.prepareDrawTile(), l22) {
                  const t3 = l22.drapeBufferSize[0], o3 = l22.drapeBufferSize[1];
                  i3 = l22.framebufferCopyTexture, i3 && (!i3 || i3.size[0] === t3 && i3.size[1] === o3) || (i3 && i3.destroy(), i3 = l22.framebufferCopyTexture = new e2.T(a2, new e2.r({ width: t3, height: o3 }), n22.RGBA8)), i3.bind(n22.LINEAR, n22.CLAMP_TO_EDGE), n22.copyTexImage2D(n22.TEXTURE_2D, 0, n22.RGBA, 0, 0, t3, o3, 0);
                }
                m22 && c3(true, false, i3), f22 && c3(false, true, i3);
              }
            } else
              m22 && v22(true), f22 && v22(false), (m22 || f22) && t22.resetStencilClippingMasks();
          }
        }
      }, hillshade: function(e22, t22, i2, o2) {
        if ("offscreen" !== e22.renderPass && "translucent" !== e22.renderPass)
          return;
        if (e22.style.disableElevatedTerrain)
          return;
        const r22 = e22.context, s2 = e22.terrain && e22.terrain.renderingToTexture, [a2, n22] = "translucent" !== e22.renderPass || s2 ? [{}, o2] : e22.stencilConfigForOverlap(o2);
        for (const o3 of n22) {
          const r3 = t22.getTile(o3);
          if (r3.needsHillshadePrepare && "offscreen" === e22.renderPass)
            zo(e22, r3, i2);
          else if ("translucent" === e22.renderPass) {
            const t3 = e22.depthModeForSublayer(0, Li2.ReadOnly), n3 = i2.paint.get("hillshade-emissive-strength"), l22 = e22.colorModeForDrapableLayerRenderPass(n3), c22 = s2 && e22.terrain ? e22.terrain.stencilModeForRTTOverlap(o3) : a2[o3.overscaledZ];
            Po(e22, o3, r3, i2, t3, c22, l22);
          }
        }
        r22.viewport.set([0, 0, e22.width, e22.height]), e22.resetStencilClippingMasks();
      }, raster: function(t22, i2, o2, r22, s2, a2) {
        if ("translucent" !== t22.renderPass)
          return;
        if (0 === o2.paint.get("raster-opacity"))
          return;
        const n22 = "globe" === t22.transform.projection.name, l22 = 0 !== o2.paint.get("raster-elevation"), c22 = l22 && n22;
        if (t22.renderElevatedRasterBackface && !c22)
          return;
        const h22 = t22.context, u22 = h22.gl, d22 = i2.getSource(), _2 = function(t3, i3, o3, r3) {
          const s3 = i3.paint.get("raster-color"), a3 = "raster-array" === t3.type, n3 = [], l3 = i3.paint.get("raster-resampling"), c3 = i3.paint.get("raster-color-mix");
          let h3 = i3.paint.get("raster-color-range");
          const u3 = [c3[0], c3[1], c3[2], 0], d3 = c3[3];
          let _3 = "nearest" === l3 ? r3.NEAREST : r3.LINEAR;
          if (a3 && (n3.push("RASTER_ARRAY"), s3 || n3.push("RASTER_COLOR"), "linear" === l3 && n3.push("RASTER_ARRAY_LINEAR"), _3 = r3.NEAREST, !h3 && t3.rasterLayers)) {
            const e22 = t3.rasterLayers.find(({ id: e3 }) => e3 === i3.sourceLayer);
            e22 && e22.fields && e22.fields.range && (h3 = e22.fields.range);
          }
          if (h3 = h3 || [0, 1], s3) {
            n3.push("RASTER_COLOR"), o3.activeTexture.set(r3.TEXTURE2), i3.updateColorRamp(h3);
            let t4 = i3.colorRampTexture;
            t4 || (t4 = i3.colorRampTexture = new e2.T(o3, i3.colorRamp, r3.RGBA8)), t4.bind(r3.LINEAR, r3.CLAMP_TO_EDGE);
          }
          return { mix: u3, range: h3, offset: d3, defines: n3, resampling: _3 };
        }(d22, o2, h22, u22);
        if (d22 instanceof e2.aD && !r22.length && !n22)
          return;
        const p22 = o2.paint.get("raster-emissive-strength"), m22 = t22.colorModeForDrapableLayerRenderPass(p22), f22 = t22.terrain && t22.terrain.renderingToTexture, g22 = !t22.options.moving, v22 = "nearest" === o2.paint.get("raster-resampling") ? u22.NEAREST : u22.LINEAR;
        if (d22 instanceof e2.aD && !r22.length && (d22.onNorthPole || d22.onSouthPole)) {
          const e22 = l22 ? t22.stencilModeFor3D() : Mi2.disabled;
          return void Ps(!!d22.onNorthPole, null, t22, i2, o2, p22, _2, Fi2.disabled, e22);
        }
        if (!r22.length)
          return;
        const [x22, y22] = d22 instanceof e2.aD || f22 ? [{}, r22] : t22.stencilConfigForOverlap(r22), b22 = y22[y22.length - 1].overscaledZ;
        c22 && _2.defines.push("PROJECTION_GLOBE_VIEW"), l22 && _2.defines.push("RENDER_CUTOFF");
        const w22 = (r3, s3, y3) => {
          for (const w3 of r3) {
            const r4 = w3.toUnwrapped(), T22 = i2.getTile(w3);
            if (f22 && (!T22 || !T22.hasData()))
              continue;
            h22.activeTexture.set(u22.TEXTURE0);
            const E22 = zs(T22, d22, o2, _2);
            if (!E22 || !E22.texture)
              continue;
            const { texture: C22, mix: S22, offset: I22, tileSize: D22, buffer: R22 } = E22;
            let A22, L22;
            f22 ? (A22 = Li2.disabled, L22 = w3.projMatrix) : l22 ? (A22 = new Li2(u22.LEQUAL, Li2.ReadWrite, t22.depthRangeFor3D), L22 = n22 ? Float32Array.from(t22.transform.expandedFarZProjMatrix) : t22.transform.calculateProjMatrix(r4, g22)) : (A22 = t22.depthModeForSublayer(w3.overscaledZ - b22, 1 === o2.paint.get("raster-opacity") ? Li2.ReadWrite : Li2.ReadOnly, u22.LESS), L22 = t22.transform.calculateProjMatrix(r4, g22));
            const P22 = t22.terrain && f22 ? t22.terrain.stencilModeForRTTOverlap(w3) : x22[w3.overscaledZ], M22 = a2 ? 0 : o2.paint.get("raster-fade-duration");
            T22.registerFadeDuration(M22);
            const z22 = i2.findLoadedParent(w3, 0), O22 = Sr(T22, z22, i2, t22.transform, M22);
            let F22, k22;
            t22.terrain && t22.terrain.prepareDrawTile(), h22.activeTexture.set(u22.TEXTURE0), C22.bind(v22, u22.CLAMP_TO_EDGE), h22.activeTexture.set(u22.TEXTURE1), z22 ? (z22.texture && z22.texture.bind(v22, u22.CLAMP_TO_EDGE), F22 = Math.pow(2, z22.tileID.overscaledZ - T22.tileID.overscaledZ), k22 = [T22.tileID.canonical.x * F22 % 1, T22.tileID.canonical.y * F22 % 1]) : C22.bind(v22, u22.CLAMP_TO_EDGE), C22.useMipmap && h22.extTextureFilterAnisotropic && t22.transform.pitch > 20 && u22.texParameterf(u22.TEXTURE_2D, h22.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h22.extTextureFilterAnisotropicMax);
            const B22 = t22.transform;
            let N22;
            const U22 = l22 ? Ms(B22) : [0, 0, 0, 0];
            let G22, j2, V22, q22, Z22, H22 = 0;
            if (c22 && d22 instanceof e2.aD && d22.coordinates.length > 3)
              G22 = Float32Array.from(e2.b5(e2.cC(new e2.bP(0, 0, 0)))), j2 = Float32Array.from(B22.globeMatrix), V22 = Float32Array.from(e2.cy(B22)), q22 = [e2.am(B22.center.lng), e2.at(B22.center.lat)], N22 = d22.elevatedGlobePerspectiveTransform, Z22 = d22.elevatedGlobeGridMatrix || new Float32Array(9);
            else if (c22) {
              const t3 = e2.cz(w3.canonical);
              H22 = e2.cA(t3.getCenter().lat), G22 = Float32Array.from(e2.b5(e2.cC(w3.canonical))), j2 = Float32Array.from(B22.globeMatrix), V22 = Float32Array.from(e2.cy(B22)), q22 = [e2.am(B22.center.lng), e2.at(B22.center.lat)], N22 = [0, 0], Z22 = Float32Array.from(e2.cB(w3.canonical, t3, H22, B22.worldSize / B22._pixelsPerMercatorPixel));
            } else
              N22 = d22 instanceof e2.aD ? d22.perspectiveTransform : [0, 0], G22 = new Float32Array(16), j2 = new Float32Array(9), V22 = new Float32Array(16), q22 = [0, 0], Z22 = new Float32Array(9);
            const W22 = Yr(L22, G22, j2, V22, Z22, k22 || [0, 0], e2.a9(t22.transform.zoom), q22, U22, F22 || 1, O22, o2, N22, l22 ? o2.paint.get("raster-elevation") : 0, 2, S22, I22, _2.range, D22, R22, p22), $2 = t22.isTileAffectedByFog(w3), X22 = t22.getOrCreateProgram("raster", { defines: _2.defines, overrideFog: $2 });
            if (t22.uploadCommonUniforms(h22, X22, r4), d22 instanceof e2.aD) {
              const i3 = d22.elevatedGlobeVertexBuffer, r5 = d22.elevatedGlobeIndexBuffer;
              if (f22 || !n22)
                d22.boundsBuffer && d22.boundsSegments && X22.draw(t22, u22.TRIANGLES, A22, Mi2.disabled, m22, Fi2.disabled, W22, o2.id, d22.boundsBuffer, t22.quadTriangleIndexBuffer, d22.boundsSegments);
              else if (i3 && r5) {
                const a3 = B22.zoom <= e2.c2 ? d22.elevatedGlobeSegments : d22.getSegmentsForLongitude(B22.center.lng);
                a3 && X22.draw(t22, u22.TRIANGLES, A22, Mi2.disabled, m22, s3, W22, o2.id, i3, r5, a3);
              }
            } else if (c22) {
              A22 = new Li2(u22.LEQUAL, Li2.ReadOnly, t22.depthRangeFor3D);
              const e22 = t22.globeSharedBuffers;
              if (e22) {
                const [i3, r5, a3] = e22.getGridBuffers(H22, false);
                X22.draw(t22, u22.TRIANGLES, A22, y3 || P22, t22.colorModeForRenderPass(), s3, W22, o2.id, i3, r5, a3);
              }
            } else {
              const { tileBoundsBuffer: e22, tileBoundsIndexBuffer: i3, tileBoundsSegments: r5 } = t22.getTileBoundsBuffers(T22);
              X22.draw(t22, u22.TRIANGLES, A22, P22, m22, Fi2.disabled, W22, o2.id, e22, i3, r5);
            }
          }
          if (!(d22 instanceof e2.aD) && c22)
            for (const e22 of r3) {
              const r4 = e22.canonical.y === (1 << e22.canonical.z) - 1;
              0 === e22.canonical.y && Ps(true, e22, t22, i2, o2, p22, _2, s3, y3 || Mi2.disabled), r4 && Ps(false, e22, t22, i2, o2, p22, _2, s3 === Fi2.frontCW ? Fi2.backCW : Fi2.frontCW, y3 || Mi2.disabled);
            }
        };
        c22 ? w22(y22, t22.renderElevatedRasterBackface ? Fi2.backCW : Fi2.frontCW, t22.stencilModeFor3D()) : w22(y22, Fi2.disabled, void 0), t22.resetStencilClippingMasks();
      }, "raster-particle": function(t22, i2, o2, r22, s2, a2) {
        "offscreen" === t22.renderPass && function(t3, i3, o3, r3) {
          if (!r3.length)
            return;
          const s3 = t3.context, a3 = s3.gl, n22 = i3.getSource();
          if (!(n22 instanceof Qe2))
            return;
          const l22 = Math.ceil(Math.sqrt(o3.paint.get("raster-particle-count")));
          let c22 = o3.particlePositionRGBAImage;
          if (!c22 || c22.width !== l22) {
            const t4 = function(e22) {
              const t5 = e22 * e22, i4 = new Uint8Array(4 * t5), o4 = function(e3) {
                return e3 |= 0, e3 = Math.imul(2747636419 ^ e3, 2654435769), e3 = Math.imul(e3 ^ e3 >>> 16, 2654435769), ((e3 = Math.imul(e3 ^ e3 >>> 16, 2654435769)) >>> 0) / 4294967296;
              }, r4 = 1 / 1.1;
              for (let e3 = 0; e3 < t5; e3++) {
                const t6 = r4 * (o4(2 * e3 + 0) + Jr), s4 = r4 * (o4(2 * e3 + 1) + Jr), a4 = 255 * t6 % 1, n3 = 255 * s4 % 1, l3 = a4, c3 = s4 - n3 / 255, h3 = n3;
                i4[4 * e3 + 0] = 255 * (t6 - a4 / 255), i4[4 * e3 + 1] = 255 * l3, i4[4 * e3 + 2] = 255 * c3, i4[4 * e3 + 3] = 255 * h3;
              }
              return i4;
            }(l22);
            c22 = o3.particlePositionRGBAImage = new e2.r({ width: l22, height: l22 }, t4);
          }
          let h22 = o3.particleFramebuffer;
          h22 ? h22.width !== l22 && (h22.destroy(), h22 = o3.particleFramebuffer = s3.createFramebuffer(l22, l22, true, null)) : h22 = o3.particleFramebuffer = s3.createFramebuffer(l22, l22, true, null);
          const u22 = [];
          for (const e22 of r3) {
            const t4 = i3.getTile(e22);
            if (!(t4 instanceof mt))
              continue;
            const r4 = ks(t4, n22, o3);
            if (!r4)
              continue;
            const a4 = [t4.tileSize, t4.tileSize];
            let h3 = o3.tileFramebuffer;
            h3 || (h3 = o3.tileFramebuffer = s3.createFramebuffer(a4[0], a4[1], true, null));
            let d3 = t4.rasterParticleState;
            d3 || (d3 = t4.rasterParticleState = new Fs(s3, e22, a4, c22));
            const _3 = d3.update(o3.lastInvalidatedAt);
            d3.particleTextureDimension !== l22 && d3.updateParticleTexture(e22, c22);
            const p22 = d3.targetColorTexture;
            d3.targetColorTexture = d3.backgroundColorTexture, d3.backgroundColorTexture = p22;
            const m22 = d3.particleTexture0;
            d3.particleTexture0 = d3.particleTexture1, d3.particleTexture1 = m22, u22.push([e22, r4, d3, _3]);
          }
          if (0 === u22.length)
            return;
          const d22 = e2.q.now(), _2 = o3.previousDrawTimestamp ? 1e-3 * (d22 - o3.previousDrawTimestamp) : 0.0167;
          if (o3.previousDrawTimestamp = d22, o3.hasColorMap()) {
            s3.activeTexture.set(a3.TEXTURE0 + 2);
            let t4 = o3.colorRampTexture;
            t4 || (t4 = o3.colorRampTexture = new e2.T(s3, o3.colorRamp, a3.RGBA8)), t4.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
          }
          s3.bindFramebuffer.set(o3.tileFramebuffer.framebuffer), function(t4, i4, o4) {
            const r4 = t4.context, s4 = r4.gl, a4 = i4.tileFramebuffer;
            r4.activeTexture.set(s4.TEXTURE0);
            const n3 = { u_texture: 0, u_opacity: 1.05 * (c3 = i4.paint.get("raster-particle-fade-opacity-factor")) / (c3 + 0.05) }, l3 = t4.getOrCreateProgram("rasterParticleTexture", { defines: [], overrideFog: false });
            var c3;
            for (const c4 of o4) {
              const [, , o5, h3] = c4;
              a4.colorAttachment.set(o5.targetColorTexture.texture), r4.viewport.set([0, 0, a4.width, a4.height]), r4.clear({ color: e2.bz.transparent }), h3 && (o5.backgroundColorTexture.bind(s4.NEAREST, s4.CLAMP_TO_EDGE), l3.draw(t4, s4.TRIANGLES, Li2.disabled, Mi2.disabled, Ai2.alphaBlended, Fi2.disabled, n3, i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments));
            }
          }(t3, o3, u22), function(t4, i4, o4, r4) {
            const s4 = t4.context, a4 = s4.gl, n3 = o4.tileFramebuffer, l3 = "globe" === t4.transform.projection.name, c3 = o4.paint.get("raster-particle-max-speed");
            for (const h3 of r4) {
              const [r5, u3, d3] = h3;
              s4.activeTexture.set(a4.TEXTURE0 + 0), u3.texture.bind(a4.LINEAR, a4.CLAMP_TO_EDGE), n3.colorAttachment.set(d3.targetColorTexture.texture);
              const _3 = t4.getOrCreateProgram("rasterParticleDraw", { defines: u3.defines, overrideFog: false });
              s4.activeTexture.set(a4.TEXTURE0 + 1);
              const p22 = u3.scalarData ? [] : [0, 1, 2, 3].map((t5) => e2.c$[t5](r5));
              p22.push(r5);
              const m22 = r5.canonical.x, f22 = r5.canonical.y;
              for (const e22 of p22) {
                const s5 = i4.getTile(l3 ? e22.wrapped() : e22);
                if (!s5)
                  continue;
                const n4 = s5.rasterParticleState;
                if (!n4)
                  continue;
                const h4 = e22.canonical.x + (1 << e22.canonical.z) * (e22.wrap - r5.wrap), d4 = e22.canonical.y;
                n4.particleTexture0.bind(a4.NEAREST, a4.CLAMP_TO_EDGE);
                const p3 = es(1, n4.particleTexture0.size[0], [h4 - m22, d4 - f22], 0, u3.texture.size, 2, c3, u3.textureOffset, u3.scale, u3.offset);
                _3.draw(t4, a4.POINTS, Li2.disabled, Mi2.disabled, Ai2.alphaBlended, Fi2.disabled, p3, o4.id, n4.particleIndexBuffer, void 0, n4.particleSegment);
              }
            }
          }(t3, i3, o3, u22), s3.bindFramebuffer.set(o3.particleFramebuffer.framebuffer), function(t4, i4, o4, r4) {
            const s4 = t4.context, a4 = s4.gl, n3 = i4.paint.get("raster-particle-max-speed"), l3 = r4 * i4.paint.get("raster-particle-speed-factor") * 0.15, c3 = function(e22) {
              return Math.pow(e22, 6);
            }(0.01 + 1 * i4.paint.get("raster-particle-reset-rate-factor")), h3 = i4.particleFramebuffer;
            s4.viewport.set([0, 0, h3.width, h3.height]);
            for (const r5 of o4) {
              const [, o5, u3] = r5;
              s4.activeTexture.set(a4.TEXTURE0 + 0), o5.texture.bind(a4.LINEAR, a4.CLAMP_TO_EDGE), s4.activeTexture.set(a4.TEXTURE0 + 1);
              const d3 = u3.particleTexture0;
              d3.bind(a4.NEAREST, a4.CLAMP_TO_EDGE);
              const _3 = ts(1, d3.size[0], 0, o5.texture.size, n3, l3, c3, o5.textureOffset, o5.scale, o5.offset);
              h3.colorAttachment.set(u3.particleTexture1.texture), s4.clear({ color: e2.bz.transparent }), t4.getOrCreateProgram("rasterParticleUpdate", { defines: o5.defines }).draw(t4, a4.TRIANGLES, Li2.disabled, Mi2.disabled, Ai2.unblended, Fi2.disabled, _3, i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments);
            }
          }(t3, o3, u22, _2);
        }(t22, i2, o2, r22), "translucent" === t22.renderPass && (function(t3, i3, o3, r3, s3) {
          const a3 = t3.context, n22 = a3.gl, l22 = i3.getSource().tileSize, c22 = 5 * (1 - e2.a7(e2.bU, e2.bU + 1, t3.transform.zoom)) * l22 + o3.paint.get("raster-particle-elevation"), h22 = !t3.options.moving, u22 = "globe" === t3.transform.projection.name;
          if (!r3.length)
            return;
          const [d22, _2] = t3.stencilConfigForOverlap(r3), p22 = [];
          u22 && p22.push("PROJECTION_GLOBE_VIEW");
          const m22 = t3.stencilModeFor3D();
          for (const r4 of _2) {
            const s4 = r4.toUnwrapped(), l3 = i3.getTile(r4);
            if (!l3.rasterParticleState)
              continue;
            const _3 = l3.rasterParticleState, f22 = 100;
            l3.registerFadeDuration(f22);
            const g22 = i3.findLoadedParent(r4, 0), v22 = Sr(l3, g22, i3, t3.transform, f22);
            let x22, y22;
            t3.terrain && t3.terrain.prepareDrawTile(), a3.activeTexture.set(n22.TEXTURE0), _3.targetColorTexture.bind(n22.LINEAR, n22.CLAMP_TO_EDGE), a3.activeTexture.set(n22.TEXTURE1), g22 && g22.rasterParticleState ? (g22.rasterParticleState.targetColorTexture.bind(n22.LINEAR, n22.CLAMP_TO_EDGE), x22 = Math.pow(2, g22.tileID.overscaledZ - l3.tileID.overscaledZ), y22 = [l3.tileID.canonical.x * x22 % 1, l3.tileID.canonical.y * x22 % 1]) : _3.targetColorTexture.bind(n22.LINEAR, n22.CLAMP_TO_EDGE);
            const b22 = u22 ? Float32Array.from(t3.transform.expandedFarZProjMatrix) : t3.transform.calculateProjMatrix(s4, h22), w22 = t3.transform, T22 = Bs(w22), E22 = e2.cz(r4.canonical), C22 = e2.cA(E22.getCenter().lat);
            let S22, I22, D22, R22, A22;
            u22 ? (S22 = Float32Array.from(e2.b5(e2.cC(r4.canonical))), I22 = Float32Array.from(w22.globeMatrix), D22 = Float32Array.from(e2.cy(w22)), R22 = [e2.am(w22.center.lng), e2.at(w22.center.lat)], A22 = Float32Array.from(e2.cB(r4.canonical, E22, C22, w22.worldSize / w22._pixelsPerMercatorPixel))) : (S22 = new Float32Array(16), I22 = new Float32Array(9), D22 = new Float32Array(16), R22 = [0, 0], A22 = new Float32Array(9));
            const L22 = Qr(b22, S22, I22, D22, A22, y22 || [0, 0], e2.a9(t3.transform.zoom), R22, T22, x22 || 1, v22, c22), P22 = t3.isTileAffectedByFog(r4), M22 = t3.getOrCreateProgram("rasterParticle", { defines: p22, overrideFog: P22 });
            if (t3.uploadCommonUniforms(a3, M22, s4), u22) {
              const e22 = new Li2(n22.LEQUAL, Li2.ReadOnly, t3.depthRangeFor3D), i4 = 0, r5 = t3.globeSharedBuffers;
              if (r5) {
                const [s5, a4, l4] = r5.getGridBuffers(C22, 0 !== i4);
                M22.draw(t3, n22.TRIANGLES, e22, m22, Ai2.alphaBlended, t3.renderElevatedRasterBackface ? Fi2.frontCCW : Fi2.backCCW, L22, o3.id, s5, a4, l4);
              }
            } else {
              const e22 = t3.depthModeForSublayer(0, Li2.ReadOnly), i4 = d22[r4.overscaledZ], { tileBoundsBuffer: s5, tileBoundsIndexBuffer: a4, tileBoundsSegments: c3 } = t3.getTileBoundsBuffers(l3);
              M22.draw(t3, n22.TRIANGLES, e22, i4, Ai2.alphaBlended, Fi2.disabled, L22, o3.id, s5, a4, c3);
            }
          }
          t3.resetStencilClippingMasks();
        }(t22, i2, o2, r22), t22.style.map.triggerRepaint());
      }, background: function(t22, i2, o2, r22) {
        const s2 = o2.paint.get("background-color"), a2 = o2.paint.get("background-opacity"), n22 = o2.paint.get("background-emissive-strength"), l22 = "viewport" === o2.paint.get("background-pitch-alignment");
        if (0 === a2)
          return;
        const c22 = t22.context, h22 = c22.gl, u22 = t22.transform, d22 = u22.tileSize, _2 = o2.paint.get("background-pattern");
        let p22;
        if (void 0 !== _2) {
          if (null === _2)
            return;
          if (p22 = t22.imageManager.getPattern(_2.toString(), o2.scope, t22.style.getLut(o2.scope)), !p22)
            return;
        }
        const m22 = !_2 && 1 === s2.a && 1 === a2 && t22.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (t22.renderPass !== m22)
          return;
        const f22 = Mi2.disabled, g22 = t22.depthModeForSublayer(0, "opaque" === m22 ? Li2.ReadWrite : Li2.ReadOnly), v22 = t22.colorModeForDrapableLayerRenderPass(n22), x22 = _2 ? "backgroundPattern" : "background";
        let y22, b22 = r22;
        if (b22 || (y22 = t22.getBackgroundTiles(), b22 = Object.values(y22).map((e22) => e22.tileID)), _2 && (c22.activeTexture.set(h22.TEXTURE0), t22.imageManager.bind(t22.context, o2.scope)), l22) {
          const i3 = t22.getOrCreateProgram(x22, { overrideFog: false, overrideRtt: true }), r3 = new Float32Array(e2.a6.mat4.identity([])), c3 = new e2.aA(0, 0, 0, 0, 0), u3 = _2 ? ss(r3, n22, a2, t22, 0, o2.scope, p22, l22, { tileID: c3, tileSize: d22 }) : rs(r3, n22, a2, s2.toRenderColor(o2.lut));
          i3.draw(t22, h22.TRIANGLES, g22, f22, v22, Fi2.disabled, u3, o2.id, t22.viewportBuffer, t22.quadTriangleIndexBuffer, t22.viewportSegments);
        } else
          for (const e22 of b22) {
            const m3 = t22.isTileAffectedByFog(e22), b3 = t22.getOrCreateProgram(x22, { overrideFog: m3 }), w22 = e22.toUnwrapped(), T22 = r22 ? e22.projMatrix : t22.transform.calculateProjMatrix(w22);
            t22.prepareDrawTile();
            const E22 = i2 ? i2.getTile(e22) : y22 ? y22[e22.key] : new pt(e22, d22, u22.zoom, t22), C22 = _2 ? ss(T22, n22, a2, t22, 0, o2.scope, p22, l22, { tileID: e22, tileSize: d22 }) : rs(T22, n22, a2, s2.toRenderColor(o2.lut));
            t22.uploadCommonUniforms(c22, b3, w22);
            const { tileBoundsBuffer: S22, tileBoundsIndexBuffer: I22, tileBoundsSegments: D22 } = t22.getTileBoundsBuffers(E22);
            b3.draw(t22, h22.TRIANGLES, g22, f22, v22, Fi2.disabled, C22, o2.id, S22, I22, D22);
          }
      }, sky: function(t22, i2, o2) {
        const r22 = t22._atmosphere ? e2.a9(t22.transform.zoom) : 1, s2 = o2.paint.get("sky-opacity") * r22;
        if (0 === s2)
          return;
        const a2 = t22.context, n22 = o2.paint.get("sky-type"), l22 = new Li2(a2.gl.LEQUAL, Li2.ReadOnly, [0, 1]), c22 = t22.frameCounter / 1e3 % 1;
        "atmosphere" === n22 ? "offscreen" === t22.renderPass ? o2.needsSkyboxCapture(t22) && (function(t3, i3, o3, r3) {
          const s3 = t3.context, a3 = s3.gl;
          let n3 = i3.skyboxFbo;
          if (!n3) {
            n3 = i3.skyboxFbo = s3.createFramebuffer(32, 32, true, null), i3.skyboxGeometry = new Ks(s3), i3.skyboxTexture = s3.gl.createTexture(), a3.bindTexture(a3.TEXTURE_CUBE_MAP, i3.skyboxTexture), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_WRAP_S, a3.CLAMP_TO_EDGE), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_WRAP_T, a3.CLAMP_TO_EDGE), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_MIN_FILTER, a3.LINEAR), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_MAG_FILTER, a3.LINEAR);
            for (let e22 = 0; e22 < 6; ++e22)
              a3.texImage2D(a3.TEXTURE_CUBE_MAP_POSITIVE_X + e22, 0, a3.RGBA, 32, 32, 0, a3.RGBA, a3.UNSIGNED_BYTE, null);
          }
          s3.bindFramebuffer.set(n3.framebuffer), s3.viewport.set([0, 0, 32, 32]);
          const l3 = i3.getCenter(t3, true), c3 = t3.getOrCreateProgram("skyboxCapture"), h22 = new Float64Array(16);
          e2.a6.mat4.identity(h22), e2.a6.mat4.rotateY(h22, h22, 0.5 * -Math.PI), Js(t3, i3, c3, h22, l3, 0), e2.a6.mat4.identity(h22), e2.a6.mat4.rotateY(h22, h22, 0.5 * Math.PI), Js(t3, i3, c3, h22, l3, 1), e2.a6.mat4.identity(h22), e2.a6.mat4.rotateX(h22, h22, 0.5 * -Math.PI), Js(t3, i3, c3, h22, l3, 2), e2.a6.mat4.identity(h22), e2.a6.mat4.rotateX(h22, h22, 0.5 * Math.PI), Js(t3, i3, c3, h22, l3, 3), e2.a6.mat4.identity(h22), Js(t3, i3, c3, h22, l3, 4), e2.a6.mat4.identity(h22), e2.a6.mat4.rotateY(h22, h22, Math.PI), Js(t3, i3, c3, h22, l3, 5), s3.viewport.set([0, 0, t3.width, t3.height]);
        }(t22, o2), o2.markSkyboxValid(t22)) : "sky" === t22.renderPass && function(e22, t3, i3, o3, r3) {
          const s3 = e22.context, a3 = s3.gl, n3 = e22.transform, l3 = e22.getOrCreateProgram("skybox");
          s3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_CUBE_MAP, t3.skyboxTexture);
          const c3 = /* @__PURE__ */ ((e3, t4, i4, o4, r4) => ({ u_matrix: e3, u_sun_direction: t4, u_cubemap: 0, u_opacity: o4, u_temporal_offset: r4 }))(n3.skyboxMatrix, t3.getCenter(e22, false), 0, o3, r3);
          e22.uploadCommonUniforms(s3, l3), l3.draw(e22, a3.TRIANGLES, i3, Mi2.disabled, e22.colorModeForRenderPass(), Fi2.backCW, c3, "skybox", t3.skyboxGeometry.vertexBuffer, t3.skyboxGeometry.indexBuffer, t3.skyboxGeometry.segment);
        }(t22, o2, l22, s2, c22) : "gradient" === n22 && "sky" === t22.renderPass && function(t3, i3, o3, r3, s3) {
          const a3 = t3.context, n3 = a3.gl, l3 = t3.transform, c3 = t3.getOrCreateProgram("skyboxGradient");
          i3.skyboxGeometry || (i3.skyboxGeometry = new Ks(a3)), a3.activeTexture.set(n3.TEXTURE0);
          let h22 = i3.colorRampTexture;
          h22 || (h22 = i3.colorRampTexture = new e2.T(a3, i3.colorRamp, n3.RGBA8)), h22.bind(n3.LINEAR, n3.CLAMP_TO_EDGE);
          const u22 = ((t4, i4, o4, r4, s4) => ({ u_matrix: t4, u_color_ramp: 0, u_center_direction: i4, u_radius: e2.bB(o4), u_opacity: r4, u_temporal_offset: s4 }))(l3.skyboxMatrix, i3.getCenter(t3, false), i3.paint.get("sky-gradient-radius"), r3, s3);
          t3.uploadCommonUniforms(a3, c3), c3.draw(t3, n3.TRIANGLES, o3, Mi2.disabled, t3.colorModeForRenderPass(), Fi2.backCW, u22, "skyboxGradient", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
        }(t22, o2, l22, s2, c22);
      }, debug: function(t22, i2, o2, r22, s2, a2) {
        for (let n22 = 0; n22 < o2.length; n22++)
          if (s2) {
            const s3 = 1, l22 = 0.8, c22 = new e2.bz(r22.r * l22, r22.g * l22, r22.b * l22, 1);
            qs(t22, i2, o2[n22], r22, -s3, -s3, a2), qs(t22, i2, o2[n22], r22, -s3, s3, a2), qs(t22, i2, o2[n22], r22, s3, s3, a2), qs(t22, i2, o2[n22], r22, s3, -s3, a2), qs(t22, i2, o2[n22], c22, 0, 0, a2);
          } else
            qs(t22, i2, o2[n22], r22, 0, 0, a2);
      }, custom: function(t22, i2, o2, r22) {
        const s2 = t22.context, a2 = o2.implementation;
        if (!t22.transform.projection.unsupportedLayers || !t22.transform.projection.unsupportedLayers.includes("custom") || t22.terrain && (t22.terrain.renderingToTexture || "offscreen" === t22.renderPass) && o2.isDraped(i2)) {
          if ("offscreen" === t22.renderPass) {
            const i3 = a2.prerender;
            if (i3) {
              if (t22.setCustomLayerDefaults(), s2.setColorMode(t22.colorModeForRenderPass()), "globe" === t22.transform.projection.name) {
                const o3 = t22.transform.pointMerc;
                i3.call(a2, s2.gl, t22.transform.customLayerMatrix(), t22.transform.getProjection(), t22.transform.globeToMercatorMatrix(), e2.a9(t22.transform.zoom), [o3.x, o3.y], t22.transform.pixelsPerMeterRatio);
              } else
                i3.call(a2, s2.gl, t22.transform.customLayerMatrix());
              s2.setDirty(), t22.setBaseState();
            }
          } else if ("translucent" === t22.renderPass) {
            if (t22.terrain && t22.terrain.renderingToTexture) {
              const i4 = a2.renderToTile;
              if (i4) {
                const o3 = r22[0].canonical, n22 = new e2.a5(o3.x + r22[0].wrap * (1 << o3.z), o3.y, o3.z);
                s2.setDepthMode(Li2.disabled), s2.setStencilMode(Mi2.disabled), s2.setColorMode(t22.colorModeForRenderPass()), t22.setCustomLayerDefaults(), i4.call(a2, s2.gl, n22), s2.setDirty(), t22.setBaseState();
              }
              return;
            }
            t22.setCustomLayerDefaults(), s2.setColorMode(t22.colorModeForRenderPass()), s2.setStencilMode(Mi2.disabled);
            const i3 = "3d" === a2.renderingMode ? new Li2(t22.context.gl.LEQUAL, Li2.ReadWrite, t22.depthRangeFor3D) : t22.depthModeForSublayer(0, Li2.ReadOnly);
            if (s2.setDepthMode(i3), "globe" === t22.transform.projection.name) {
              const i4 = t22.transform.pointMerc;
              a2.render(s2.gl, t22.transform.customLayerMatrix(), t22.transform.getProjection(), t22.transform.globeToMercatorMatrix(), e2.a9(t22.transform.zoom), [i4.x, i4.y], t22.transform.pixelsPerMeterRatio);
            } else
              a2.render(s2.gl, t22.transform.customLayerMatrix());
            s2.setDirty(), t22.setBaseState(), s2.bindFramebuffer.set(null);
          }
        } else
          e2.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
      }, model: function(t22, i2, o2, r22) {
        if ("opaque" === t22.renderPass)
          return;
        const s2 = o2.paint.get("model-opacity");
        if (0 === s2)
          return;
        const a2 = o2.paint.get("model-cast-shadows");
        if ("shadow" === t22.renderPass) {
          if (!a2)
            return;
          if (t22.terrain && s2 < 0.65 && o2._transitionablePaint._values["model-opacity"].value.expression instanceof e2.a4)
            return;
        }
        const n22 = t22.shadowRenderer, l22 = o2.paint.get("model-receive-shadows");
        n22 && (n22.useNormalOffset = true, l22 || (n22.enabled = false));
        const c22 = () => {
          n22 && (n22.useNormalOffset = true, l22 || (n22.enabled = true));
        }, h22 = i2.getSource();
        if ("light-beam" === t22.renderPass && "batched-model" !== h22.type)
          return;
        if ("vector" === h22.type || "geojson" === h22.type)
          return function(t3, i3, o3, r3, s3) {
            const a3 = t3.transform;
            if ("mercator" !== a3.projection.name)
              return void e2.w("Drawing 3D models for ".concat(a3.projection.name, " projection is not yet implemented"));
            const n3 = a3.getFreeCameraOptions().position;
            if (!t3.modelManager)
              return;
            const l3 = t3.modelManager;
            o3.modelManager = l3;
            const c3 = t3.shadowRenderer;
            if (!o3._unevaluatedLayout._values.hasOwnProperty("model-id"))
              return;
            const h3 = o3._unevaluatedLayout._values["model-id"], u3 = { ...o3.layout.get("model-id").parameters }, d3 = t3.style.order.indexOf(o3.fqid);
            for (const _3 of r3) {
              const r4 = i3.getTile(_3).getBucket(o3);
              if (!r4 || r4.projection.name !== a3.projection.name)
                continue;
              const p3 = r4.getModelUris();
              p3 && !r4.modelsRequested && (l3.addModelsFromBucket(p3, s3), r4.modelsRequested = true);
              const m3 = ua2(_3, a3);
              u3.zoom = m3;
              const f3 = h3.possiblyEvaluate(u3);
              if (ca2(t3, r4, _3), ha2.shadowUniformsInitialized = false, ha2.useSingleShadowCascade = !!c3 && 0 === c3.getMaxCascadeForTile(_3.toUnwrapped()), "shadow" === t3.renderPass && c3) {
                if (1 === t3.currentShadowCascade && r4.isInsideFirstShadowMapFrustum)
                  continue;
                const i4 = a3.calculatePosMatrix(_3.toUnwrapped(), a3.worldSize);
                if (ha2.tileMatrix.set(i4), ha2.shadowTileMatrix = Float32Array.from(c3.calculateShadowPassMatrixFromMatrix(i4)), ha2.aabb.min.fill(0), ha2.aabb.max[0] = ha2.aabb.max[1] = e2.ab, ha2.aabb.max[2] = 0, pa2(r4, ha2, t3, o3.scope))
                  continue;
              }
              const g3 = 1 << _3.canonical.z, v22 = [((n3.x - _3.wrap) * g3 - _3.canonical.x) * e2.ab, (n3.y * g3 - _3.canonical.y) * e2.ab, n3.z * g3 * e2.ab];
              t3.conflationActive && Object.keys(r4.instancesPerModel).length > 0 && t3.style.isLayerClipped(o3, i3.getSource()) && r4.updateReplacement(_3, t3.replacementSource, d3, s3) && (r4.uploaded = false, r4.upload(t3.context));
              for (let e22 in r4.instancesPerModel) {
                const i4 = r4.instancesPerModel[e22];
                i4.features.length > 0 && (e22 = f3.evaluate(i4.features[0].feature, {}));
                const a4 = l3.getModel(e22, s3);
                if (a4 && a4.uploaded)
                  for (const e3 of a4.nodes)
                    da2(t3, o3, e3, i4, v22, _3, ha2);
              }
            }
          }(t22, i2, o2, r22, "vector" === h22.type ? o2.scope : ""), void c22();
        if (!h22.loaded())
          return;
        if ("batched-model" === h22.type)
          return function(t3, i3, o3, r3) {
            o3.resetLayerRenderingStats(t3);
            const s3 = t3.context, a3 = t3.transform, n3 = t3.style.fog, l3 = t3.shadowRenderer;
            if ("mercator" !== a3.projection.name)
              return void e2.w("Drawing 3D landmark models for ".concat(a3.projection.name, " projection is not yet implemented"));
            const c3 = t3.transform.getFreeCameraOptions().position, h3 = e2.a6.vec3.scale([], [c3.x, c3.y, c3.z], t3.transform.worldSize), u3 = e2.a6.vec3.negate([], h3), d3 = e2.a6.mat4.identity([]), _3 = e2.de(a3.center.lat, a3.zoom), p3 = e2.a6.mat4.fromScaling([], [1, 1, 1 / _3]);
            e2.a6.mat4.translate(d3, d3, u3);
            const m3 = o3.paint.get("model-opacity"), f3 = new Li2(s3.gl.LEQUAL, Li2.ReadWrite, t3.depthRangeFor3D), g3 = new Li2(s3.gl.LEQUAL, Li2.ReadOnly, t3.depthRangeFor3D), v22 = new e2.c9([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), x22 = "shadow" === t3.renderPass, y22 = x22 && l3 ? l3.getCurrentCascadeFrustum() : a3.getFrustum(a3.scaleZoom(a3.worldSize)), b22 = o3.paint.get("model-front-cutoff"), w22 = b22[2] < 1, T22 = Wi2(t3, o3.paint.get("model-cutoff-fade-range")), E22 = o3.getLayerRenderingStats();
            (function(e22, t4, i4, o4) {
              const r4 = e22.terrain ? e22.terrain.exaggeration() : 0, s4 = e22.transform.zoom;
              for (const a4 of o4) {
                const o5 = t4.getTile(a4).getBucket(i4);
                o5 && (e22.conflationActive && o5.updateReplacement(a4, e22.replacementSource), o5.evaluateScale(e22, i4), e22.terrain && r4 > 0 && o5.elevationUpdate(e22.terrain, r4, a4, i4.source), o5.needsReEvaluation(e22, s4, i4) && o5.evaluate(i4));
              }
            })(t3, i3, o3, r3), function() {
              let c4, u4, C22;
              w22 ? (c4 = r3.length - 1, u4 = -1, C22 = -1) : (c4 = 0, u4 = r3.length, C22 = 1);
              const S22 = new Float64Array(16), I22 = e2.a6.vec3.create(), D22 = new e2.P(0, 0);
              for (let R22 = c4; R22 !== u4; R22 += C22) {
                const c5 = r3[R22], u5 = i3.getTile(c5).getBucket(o3);
                if (!u5 || !u5.uploaded)
                  continue;
                let C3 = false;
                l3 && (C3 = 0 === l3.getMaxCascadeForTile(c5.toUnwrapped()));
                const A22 = a3.calculatePosMatrix(c5.toUnwrapped(), a3.worldSize), L22 = u5.modelTraits;
                !x22 && w22 && (e2.a6.mat4.invert(S22, A22), e2.a6.vec3.transformMat4(I22, h3, S22), D22.x = I22[0], D22.y = I22[1]);
                const P22 = [];
                for (const i4 of u5.getNodesInfo()) {
                  if (i4.hiddenByReplacement)
                    continue;
                  if (!i4.node.meshes)
                    continue;
                  const o4 = i4.node;
                  let r4 = 0;
                  t3.terrain && o4.elevation && (r4 = o4.elevation * t3.terrain.exaggeration());
                  const s4 = (() => {
                    const t4 = i4.aabb;
                    return v22.min = [...t4.min], v22.max = [...t4.max], v22.min[2] += r4, v22.max[2] += r4, e2.a6.vec3.transformMat4(v22.min, v22.min, A22), e2.a6.vec3.transformMat4(v22.max, v22.max, A22), v22;
                  })(), n4 = i4.evaluatedScale;
                  if (n4[0] <= 1 && n4[1] <= 1 && n4[2] <= 1 && 0 === s4.intersects(y22))
                    continue;
                  if (!x22 && w22) {
                    const t4 = 1 / 6;
                    i4.cameraCollisionOpacity = h3[0] > s4.min[0] && h3[0] < s4.max[0] && h3[1] > s4.min[1] && h3[1] < s4.max[1] && h3[2] * _3 < s4.max[2] && o4.footprint && e2.bu(D22, o4.footprint) ? Math.max(i4.cameraCollisionOpacity - t4, 0) : Math.min(1, i4.cameraCollisionOpacity + t4);
                  }
                  const l4 = [...A22], c6 = o4.anchor ? o4.anchor[0] : 0, u6 = o4.anchor ? o4.anchor[1] : 0;
                  e2.a6.mat4.translate(l4, l4, [c6 * (n4[0] - 1), u6 * (n4[1] - 1), r4]), e2.a6.vec3.exactEquals(n4, e2.dh) || e2.a6.mat4.scale(l4, l4, n4);
                  const d4 = e2.a6.mat4.multiply([], l4, o4.matrix), p4 = e2.a6.mat4.multiply([], a3.expandedFarZProjMatrix, d4), f4 = e2.a6.mat4.multiply([], a3.expandedFarZProjMatrix, l4), g4 = e2.a6.vec4.transformMat4([], [c6, u6, r4, 1], p4)[2];
                  o4.hidden = false;
                  let E3 = m3;
                  x22 || (w22 && (E3 *= i4.cameraCollisionOpacity, E3 *= fa2(l4, a3, i4.aabb, b22)), E3 *= ma2(T22, g4)), 0 !== E3 ? P22.push({ nodeInfo: i4, depth: g4, opacity: E3, wvpForNode: p4, wvpForTile: f4, nodeModelMatrix: d4, tileModelMatrix: l4 }) : o4.hidden = true;
                }
                x22 || P22.sort((e22, t4) => !w22 || 1 === e22.opacity && 1 === t4.opacity ? e22.depth < t4.depth ? -1 : 1 : 1 === e22.opacity ? -1 : 1 === t4.opacity ? 1 : e22.depth > t4.depth ? -1 : 1);
                for (const i4 of P22) {
                  const r4 = i4.nodeInfo, c6 = r4.node;
                  let h4 = e2.a6.mat4.multiply([], p3, i4.tileModelMatrix);
                  e2.a6.mat4.multiply(h4, d3, h4);
                  const u6 = e2.a6.mat4.invert([], h4);
                  e2.a6.mat4.transpose(u6, u6), e2.a6.mat4.scale(u6, u6, _a), h4 = e2.a6.mat4.multiply(h4, h4, c6.matrix);
                  const _4 = "light-beam" === t3.renderPass, m4 = L22 & e2.dj.HasMapboxMeshFeatures, v3 = m4 ? 0 : r4.evaluatedRMEA[0][2];
                  for (let e22 = 0; e22 < c6.meshes.length; ++e22) {
                    const d4 = c6.meshes[e22], p4 = e22 === c6.lightMeshIndex;
                    let y3 = i4.wvpForNode;
                    if (p4) {
                      if (!_4 && !t3.terrain && t3.shadowRenderer) {
                        t3.currentLayer < t3.firstLightBeamLayer && (t3.firstLightBeamLayer = t3.currentLayer);
                        continue;
                      }
                      y3 = i4.wvpForTile;
                    } else if (_4)
                      continue;
                    const b3 = { defines: [] }, w3 = [];
                    if (sa2(b3.defines, w3, d4, t3, o3.lut), m4 || b3.defines.push("DIFFUSE_SHADED"), C3 && b3.defines.push("SHADOWS_SINGLE_CASCADE"), E22 && (x22 ? E22.numRenderedVerticesInShadowPass += d4.vertexArray.length : E22.numRenderedVerticesInTransparentPass += d4.vertexArray.length), x22) {
                      la2(d4, i4.nodeModelMatrix, t3, o3);
                      continue;
                    }
                    let T3 = null;
                    if (n3) {
                      const e3 = ra2(i4.nodeModelMatrix, t3.transform);
                      if (T3 = new Float32Array(e3), "globe" !== a3.projection.name) {
                        const t4 = d4.aabb.min, i5 = d4.aabb.max, [o4, r5] = n3.getOpacityForBounds(e3, t4[0], t4[1], i5[0], i5[1]);
                        b3.overrideFog = o4 >= Oe2 || r5 >= Oe2;
                      }
                    }
                    const S3 = d4.material;
                    let I3;
                    S3.occlusionTexture && S3.occlusionTexture.offsetScale && (I3 = S3.occlusionTexture.offsetScale, b3.defines.push("OCCLUSION_TEXTURE_TRANSFORM")), !x22 && l3 && (l3.useNormalOffset = !!d4.normalBuffer);
                    const D3 = t3.getOrCreateProgram("model", b3);
                    !x22 && l3 && l3.setupShadowsFromMatrix(i4.tileModelMatrix, D3, l3.useNormalOffset), t3.uploadCommonUniforms(s3, D3, null, T3);
                    const R3 = S3.pbrMetallicRoughness;
                    R3.metallicFactor = 0.9, R3.roughnessFactor = 0.5;
                    const A3 = ns(new Float32Array(y3), new Float32Array(h4), new Float32Array(u6), new Float32Array(c6.matrix), t3, i4.opacity, R3.baseColorFactor.toRenderColor(null), S3.emissiveFactor, R3.metallicFactor, R3.roughnessFactor, S3, v3, o3, [0, 0, 0], I3);
                    !p4 && (r4.hasTranslucentParts || i4.opacity < 1) && D3.draw(t3, s3.gl.TRIANGLES, f3, Mi2.disabled, Ai2.disabled, Fi2.backCCW, A3, o3.id, d4.vertexBuffer, d4.indexBuffer, d4.segments, o3.paint, t3.transform.zoom, void 0, w3), D3.draw(t3, s3.gl.TRIANGLES, p4 ? g3 : f3, Mi2.disabled, p4 || i4.opacity < 1 || r4.hasTranslucentParts ? Ai2.alphaBlended : Ai2.unblended, Fi2.backCCW, A3, o3.id, d4.vertexBuffer, d4.indexBuffer, d4.segments, o3.paint, t3.transform.zoom, void 0, w3);
                  }
                }
              }
            }();
          }(t22, i2, o2, r22), void c22();
        if ("model" !== h22.type)
          return;
        const u22 = h22.getModels(), d22 = [], _2 = t22.transform.getFreeCameraOptions().position, p22 = e2.a6.vec3.scale([], [_2.x, _2.y, _2.z], t22.transform.worldSize);
        e2.a6.vec3.negate(p22, p22);
        const m22 = [], f22 = [];
        let g22 = 0;
        for (const i3 of u22) {
          const r3 = o2.paint.get("model-rotation").constantOr(null), s3 = o2.paint.get("model-scale").constantOr(null), a3 = o2.paint.get("model-translation").constantOr(null);
          i3.computeModelMatrix(t22, r3, s3, a3, true, true, false);
          const n3 = e2.a6.mat4.identity([]), l3 = e2.de(i3.position.lat, t22.transform.zoom), c3 = e2.a6.mat4.fromScaling([], [1, 1, 1 / l3]);
          e2.a6.mat4.translate(n3, n3, p22), d22.push({ zScaleMatrix: c3, negCameraPosMatrix: n3 });
          for (const e22 of i3.nodes)
            na(t22.transform, e22, i3.matrix, t22.transform.expandedFarZProjMatrix, g22, m22, f22);
          g22++;
        }
        if (m22.sort((e22, t3) => t3.depth - e22.depth), "shadow" !== t22.renderPass) {
          if (1 === s2)
            for (const e22 of f22)
              aa2(e22, t22, o2, d22[e22.modelIndex], Mi2.disabled, t22.colorModeForRenderPass());
          else {
            for (const e22 of f22)
              aa2(e22, t22, o2, d22[e22.modelIndex], Mi2.disabled, Ai2.disabled);
            for (const e22 of f22)
              aa2(e22, t22, o2, d22[e22.modelIndex], t22.stencilModeFor3D(), t22.colorModeForRenderPass());
            t22.resetStencilClippingMasks();
          }
          for (const e22 of m22)
            aa2(e22, t22, o2, d22[e22.modelIndex], Mi2.disabled, t22.colorModeForRenderPass());
          c22();
        } else {
          for (const e22 of f22)
            la2(e22.mesh, e22.nodeModelMatrix, t22, o2);
          for (const e22 of m22)
            la2(e22.mesh, e22.nodeModelMatrix, t22, o2);
          c22();
        }
      } }, ba = { model: function(e22, t22, i2) {
        const o2 = t22.getSource();
        if (!o2.loaded())
          return;
        if ("vector" === o2.type || "geojson" === o2.type)
          return void (i2.modelManager && i2.modelManager.upload(i2, "vector" === o2.type ? e22.scope : ""));
        if ("batched-model" === o2.type)
          return;
        if ("model" !== o2.type)
          return;
        const r22 = o2.getModels();
        for (const e3 of r22)
          e3.upload(i2.context);
      }, raster: function(e22, t22, i2) {
        const o2 = t22.getSource();
        if (!(o2 instanceof Qe2 && o2.loaded()))
          return;
        const r22 = e22.sourceLayer || o2.rasterLayerIds && o2.rasterLayerIds[0];
        if (!r22)
          return;
        const s2 = e22.paint.get("raster-array-band") || o2.getInitialBand(r22);
        if (null == s2)
          return;
        const a2 = t22.getIds().map((e3) => t22.getTileByID(e3));
        for (const e3 of a2)
          e3.updateNeeded(r22, s2) && o2.prepareTile(e3, r22, s2);
      }, "raster-particle": function(e22, t22, i2) {
        const o2 = t22.getSource();
        if (!(o2 instanceof Qe2 && o2.loaded()))
          return;
        const r22 = e22.sourceLayer || o2.rasterLayerIds && o2.rasterLayerIds[0];
        if (!r22)
          return;
        const s2 = e22.paint.get("raster-particle-array-band") || o2.getInitialBand(r22);
        if (null == s2)
          return;
        const a2 = t22.getIds().map((e3) => t22.getTileByID(e3));
        for (const e3 of a2)
          e3.updateNeeded(r22, s2) && o2.prepareTile(e3, r22, s2);
      } };
      class wa2 {
        constructor(t22, i2, o2, r22) {
          this.context = new ps(t22, i2), this.transform = o2, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = r22, this._timeStamp = e2.q.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = { showTerrainProxyTiles: false, fpsWindow: 30, continousRedraw: false, enabledLayers: {} };
          const s2 = ["fill", "line", "symbol", "circle", "heatmap", "fill-extrusion", "raster", "raster-particle", "hillshade", "model", "background", "sky"];
          for (const e22 of s2)
            this._debugParams.enabledLayers[e22] = true;
          r22.registerParameter(this._debugParams, ["Terrain"], "showTerrainProxyTiles", {}, () => {
            this.style.map.triggerRepaint();
          }), r22.registerParameter(this._debugParams, ["FPS"], "fpsWindow", { min: 1, max: 100, step: 1 }), r22.registerBinding(this._debugParams, ["FPS"], "continousRedraw", { readonly: true, label: "continuous redraw" }), r22.registerBinding(this, ["FPS"], "_averageFPS", { readonly: true, label: "value" }), r22.registerBinding(this, ["FPS"], "_averageFPS", { readonly: true, label: "graph", view: "graph", min: 0, max: 200 });
          for (const e22 of s2)
            r22.registerParameter(this._debugParams.enabledLayers, ["Debug", "Layers"], e22);
          this.occlusionParams = new xa(r22), this.setup(), this.numSublayers = vt.maxUnderzooming + vt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = false, this.replacementSource = new e2.dl(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = false, this._cachedTileFogOpacities = {}, this._shadowRenderer = new Ki2(this), this._wireframeDebugCache = new va2(), this.renderDefaultNorthPole = true, this.renderDefaultSouthPole = true, this.layersWithOcclusionOpacity = [];
          const a2 = new e2.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0));
          this.emptyDepthTexture = new e2.T(this.context, a2, t22.RGBA8), this._clippingActiveLastFrame = false;
        }
        updateTerrain(e22, t22) {
          const i2 = !!e22 && !!e22.terrain && this.transform.projection.supportsTerrain;
          if (!(i2 || this._terrain && this._terrain.enabled))
            return;
          this._terrain || (this._terrain = new Ar(this, e22));
          const o2 = this._terrain;
          this.transform.elevation = i2 ? o2 : null, o2.update(e22, this.transform, t22), this.transform.elevation && !o2.enabled && (this.transform.elevation = null);
        }
        _updateFog(e22) {
          const t22 = e22.fog;
          if (!t22 || "globe" === this.transform.projection.name || t22.getOpacity(this.transform.pitch) < 1 || t22.properties.get("horizon-blend") < 0.03)
            return void (this.transform.fogCullDistSq = null);
          const [i2, o2] = t22.getFovAdjustedRange(this.transform._fov);
          if (i2 > o2)
            return void (this.transform.fogCullDistSq = null);
          const r22 = i2 + 0.78 * (o2 - i2);
          this.transform.fogCullDistSq = r22 * r22;
        }
        get terrain() {
          return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;
        }
        get forceTerrainMode() {
          return this._forceTerrainMode;
        }
        set forceTerrainMode(e22) {
          e22 && !this._terrain && (this._terrain = new Ar(this, this.style)), this._forceTerrainMode = e22;
        }
        get shadowRenderer() {
          return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
        }
        get wireframeDebugCache() {
          return this._wireframeDebugCache;
        }
        resize(t22, i2) {
          if (this.width = t22 * e2.q.devicePixelRatio, this.height = i2 * e2.q.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (const e22 of this.style.order)
              this.style._mergedLayers[e22].resize();
        }
        setup() {
          const t22 = this.context, i2 = new e2.a_();
          i2.emplaceBack(0, 0), i2.emplaceBack(e2.ab, 0), i2.emplaceBack(0, e2.ab), i2.emplaceBack(e2.ab, e2.ab), this.tileExtentBuffer = t22.createVertexBuffer(i2, e2.b0.members), this.tileExtentSegments = e2.b1.simpleSegment(0, 0, 4, 2);
          const o2 = new e2.a_();
          o2.emplaceBack(0, 0), o2.emplaceBack(e2.ab, 0), o2.emplaceBack(0, e2.ab), o2.emplaceBack(e2.ab, e2.ab), this.debugBuffer = t22.createVertexBuffer(o2, e2.b0.members), this.debugSegments = e2.b1.simpleSegment(0, 0, 4, 5);
          const r22 = new e2.a_();
          r22.emplaceBack(-1, -1), r22.emplaceBack(1, -1), r22.emplaceBack(-1, 1), r22.emplaceBack(1, 1), this.viewportBuffer = t22.createVertexBuffer(r22, e2.b0.members), this.viewportSegments = e2.b1.simpleSegment(0, 0, 4, 2);
          const s2 = new e2.aN();
          s2.emplaceBack(0, 0, 0, 0), s2.emplaceBack(e2.ab, 0, e2.ab, 0), s2.emplaceBack(0, e2.ab, 0, e2.ab), s2.emplaceBack(e2.ab, e2.ab, e2.ab, e2.ab), this.mercatorBoundsBuffer = t22.createVertexBuffer(s2, e2.b3.members), this.mercatorBoundsSegments = e2.b1.simpleSegment(0, 0, 4, 2);
          const a2 = new e2.aO();
          a2.emplaceBack(0, 1, 2), a2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t22.createIndexBuffer(a2);
          const n22 = new e2.a$();
          for (const e22 of [0, 1, 3, 2, 0])
            n22.emplaceBack(e22);
          this.debugIndexBuffer = t22.createIndexBuffer(n22), this.emptyTexture = new e2.T(t22, new e2.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t22.gl.RGBA8), this.identityMat = e2.a6.mat4.create();
          const l22 = this.context.gl;
          this.stencilClearMode = new Mi2({ func: l22.ALWAYS, mask: 0 }, 0, 255, l22.ZERO, l22.ZERO, l22.ZERO), this.loadTimeStamps.push(performance.now());
        }
        getMercatorTileBoundsBuffers() {
          return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
        }
        getTileBoundsBuffers(e22) {
          return e22._makeTileBoundsBuffers(this.context, this.transform.projection), e22._tileBoundsBuffer ? { tileBoundsBuffer: e22._tileBoundsBuffer, tileBoundsIndexBuffer: e22._tileBoundsIndexBuffer, tileBoundsSegments: e22._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
        }
        clearStencil() {
          const e22 = this.context.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, e22.TRIANGLES, Li2.disabled, this.stencilClearMode, Ai2.disabled, Fi2.disabled, Cr(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        resetStencilClippingMasks() {
          this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
        }
        _renderTileClippingMasks(e22, t22, i2) {
          if (!t22 || this.currentStencilSource === t22.id || !e22.isTileClipped() || !i2 || 0 === i2.length)
            return;
          if (this._tileClippingMaskIDs && !this.terrain) {
            let e3 = false;
            for (const t3 of i2)
              if (void 0 === this._tileClippingMaskIDs[t3.key]) {
                e3 = true;
                break;
              }
            if (!e3)
              return;
          }
          this.currentStencilSource = t22.id;
          const o2 = this.context, r22 = o2.gl;
          this.nextStencilID + i2.length > 256 && this.clearStencil(), o2.setColorMode(Ai2.disabled), o2.setDepthMode(Li2.disabled);
          const s2 = this.getOrCreateProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const e3 of i2) {
            const i3 = t22.getTile(e3), o3 = this._tileClippingMaskIDs[e3.key] = this.nextStencilID++, { tileBoundsBuffer: a2, tileBoundsIndexBuffer: n22, tileBoundsSegments: l22 } = this.getTileBoundsBuffers(i3);
            s2.draw(this, r22.TRIANGLES, Li2.disabled, new Mi2({ func: r22.ALWAYS, mask: 0 }, o3, 255, r22.KEEP, r22.KEEP, r22.REPLACE), Ai2.disabled, Fi2.disabled, Cr(e3.projMatrix), "$clipping", a2, n22, l22);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const e22 = this.nextStencilID++, t22 = this.context.gl;
          return new Mi2({ func: t22.NOTEQUAL, mask: 255 }, e22, 255, t22.KEEP, t22.KEEP, t22.REPLACE);
        }
        stencilModeForClipping(e22) {
          if (this.terrain)
            return this.terrain.stencilModeForRTTOverlap(e22);
          const t22 = this.context.gl;
          return new Mi2({ func: t22.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e22.key], 0, t22.KEEP, t22.KEEP, t22.REPLACE);
        }
        stencilConfigForOverlap(e22) {
          const t22 = this.context.gl, i2 = e22.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ), o2 = i2[i2.length - 1].overscaledZ, r22 = i2[0].overscaledZ - o2 + 1;
          if (r22 > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + r22 > 256 && this.clearStencil();
            const e3 = {};
            for (let i3 = 0; i3 < r22; i3++)
              e3[i3 + o2] = new Mi2({ func: t22.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, t22.KEEP, t22.KEEP, t22.REPLACE);
            return this.nextStencilID += r22, [e3, i2];
          }
          return [{ [o2]: Mi2.disabled }, i2];
        }
        colorModeForRenderPass() {
          const t22 = this.context.gl;
          if (this._showOverdrawInspector) {
            const i2 = 1 / 8;
            return new Ai2([t22.CONSTANT_COLOR, t22.ONE, t22.CONSTANT_COLOR, t22.ONE], new e2.bz(i2, i2, i2, 0), [true, true, true, true]);
          }
          return "opaque" === this.renderPass ? Ai2.unblended : Ai2.alphaBlended;
        }
        colorModeForDrapableLayerRenderPass(t22) {
          const i2 = this.context.gl;
          return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && "translucent" === this.renderPass ? new Ai2([i2.ONE, i2.ONE_MINUS_SRC_ALPHA, i2.CONSTANT_ALPHA, i2.ONE_MINUS_SRC_ALPHA], new e2.bz(0, 0, 0, void 0 === t22 ? 0 : t22), [true, true, true, true]) : this.colorModeForRenderPass();
        }
        depthModeForSublayer(e22, t22, i2, o2 = false) {
          if (this.depthOcclusion)
            return new Li2(this.context.gl.GREATER, Li2.ReadOnly, this.depthRangeFor3D);
          if (!this.opaquePassEnabledForLayer() && !o2)
            return Li2.disabled;
          const r22 = 1 - ((1 + this.currentLayer) * this.numSublayers + e22) * this.depthEpsilon;
          return new Li2(i2 || this.context.gl.LEQUAL, t22, [r22, r22]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        blitDepth() {
          const t22 = this.context.gl, i2 = Math.ceil(this.width), o2 = Math.ceil(this.height), r22 = this.context.bindFramebuffer.get(), s2 = t22.getParameter(t22.TEXTURE_BINDING_2D);
          this.depthFBO && this.depthFBO.width === i2 && this.depthFBO.height === o2 || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), 0 !== i2 && 0 !== o2 && (this.depthFBO = new _s(this.context, i2, o2, false, "texture"), this.depthTexture = new e2.T(this.context, { width: i2, height: o2, data: null }, t22.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(r22), t22.bindTexture(t22.TEXTURE_2D, s2), this.depthFBO && (t22.bindFramebuffer(t22.READ_FRAMEBUFFER, null), t22.bindFramebuffer(t22.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t22.blitFramebuffer(0, 0, i2, o2, 0, 0, i2, o2, t22.DEPTH_BUFFER_BIT, t22.NEAREST), t22.bindFramebuffer(t22.FRAMEBUFFER, this.context.bindFramebuffer.current));
        }
        updateAverageFPS() {
          this._fpsHistory.push(0 === this._dt ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((e22, t22) => e22 + t22 / this._fpsHistory.length, 0));
        }
        render(t22, i2) {
          const o2 = e2.q.now();
          this._dt = o2 - this._timeStamp, this._timeStamp = o2, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t22.map.repaint, this.style = t22, this.options = i2;
          const r22 = this.style._mergedLayers, s2 = this.style.order.filter((e22) => {
            const t3 = r22[e22];
            return !(t3.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[t3.type];
          });
          let a2 = false, n22 = false;
          for (const e22 of s2) {
            const t3 = r22[e22];
            "circle" === t3.type && (a2 = true), "symbol" === t3.type && (t3.hasInitialOcclusionOpacityProperties ? n22 = true : a2 = true);
          }
          const l22 = s2.map((e22) => r22[e22]), c22 = this.style._mergedSourceCaches;
          this.imageManager = t22.imageManager, this.modelManager = t22.modelManager, this.symbolFadeChange = t22.placement.symbolFadeChange(e2.q.now()), this.imageManager.beginFrame();
          let h22 = 0, u22 = false;
          for (const e22 in c22) {
            const t3 = c22[e22];
            t3.used && (t3.prepare(this.context), t3.getSource().usedInConflation && ++h22);
          }
          let d22 = false;
          for (const e22 of l22)
            e22.isHidden(this.transform.zoom) || ("clip" === e22.type && (d22 = true), this.prepareLayer(e22));
          const _2 = {}, p22 = {}, m22 = {}, f22 = {}, g22 = {};
          for (const e22 in c22) {
            const t3 = c22[e22];
            _2[e22] = t3.getVisibleCoordinates(), p22[e22] = _2[e22].slice().reverse(), m22[e22] = t3.getVisibleCoordinates(true).reverse(), f22[e22] = t3.getShadowCasterCoordinates(), g22[e22] = t3.sortCoordinatesByDistance(_2[e22]);
          }
          const v22 = (e22) => {
            const t3 = this.style.getLayerSourceCache(e22);
            return t3 && t3.used ? t3.getSource() : null;
          };
          if (h22 || d22 || this._clippingActiveLastFrame) {
            const t3 = [], i3 = [];
            let o3 = 0;
            for (const e22 of l22)
              this.isSourceForClippingOrConflation(e22, v22(e22)) && (t3.push(e22), i3.push(o3)), o3++;
            if (t3 && (d22 || t3.length > 1) || this._clippingActiveLastFrame) {
              d22 = false;
              const o4 = [];
              for (let r3 = 0; r3 < t3.length; r3++) {
                const s3 = t3[r3], a3 = i3[r3], n3 = this.style.getLayerSourceCache(s3);
                if (!n3 || !n3.used || !n3.getSource().usedInConflation && "clip" !== s3.type)
                  continue;
                let l3 = e2.dn, c3 = e2.bs.None;
                const h3 = [];
                let u3 = true;
                if ("clip" === s3.type) {
                  l3 = a3;
                  for (const t4 of s3.layout.get("clip-layer-types"))
                    c3 |= "model" === t4 ? e2.bs.Model : "symbol" === t4 ? e2.bs.Symbol : e2.bs.FillExtrusion;
                  for (const e22 of s3.layout.get("clip-layer-scope"))
                    h3.push(e22);
                  s3.isHidden(this.transform.zoom) ? u3 = false : d22 = true;
                }
                u3 && o4.push({ layer: s3.fqid, cache: n3, order: l3, clipMask: c3, clipScope: h3 });
              }
              this.replacementSource.setSources(o4), u22 = true;
            }
          }
          this._clippingActiveLastFrame = d22, u22 || this.replacementSource.clear(), this.conflationActive = u22, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
          for (let e22 = 0; e22 < l22.length; e22++) {
            const t3 = l22[e22], i3 = t3.cutoffRange();
            if (this.longestCutoffRange = Math.max(i3, this.longestCutoffRange), i3 > 0) {
              const e3 = v22(t3);
              e3 && (this.minCutoffZoom = Math.max(e3.minzoom, this.minCutoffZoom)), t3.minzoom && (this.minCutoffZoom = Math.max(t3.minzoom, this.minCutoffZoom));
            }
            t3.is3D() && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = e22), this._lastOcclusionLayer = e22);
          }
          const x22 = this.style && this.style.fog;
          x22 ? (this._fogVisible = 0 !== x22.getOpacity(this.transform.pitch), this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = x22.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = false, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(m22), this.opaquePassCutoff = 0);
          const y22 = this._shadowRenderer;
          if (y22) {
            y22.updateShadowParameters(this.transform, this.style.directionalLight);
            for (const e22 in c22)
              for (const t3 of _2[e22]) {
                let e3 = { min: 0, max: 0 };
                this.terrain && (e3 = this.terrain.getMinMaxForTile(t3) || e3), y22.addShadowReceiver(t3.toUnwrapped(), e3.min, e3.max);
              }
          }
          if ("globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e2.dm(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new oa2(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), !U2.has(this.context.gl))
            return;
          this.renderPass = "offscreen";
          for (const e22 of l22) {
            const i3 = t22.getLayerSourceCache(e22);
            if (!e22.hasOffscreenPass() || e22.isHidden(this.transform.zoom))
              continue;
            const o3 = i3 ? p22[i3.id] : void 0;
            ("custom" === e22.type || "raster" === e22.type || "raster-particle" === e22.type || e22.isSky() || o3 && o3.length) && this.renderLayer(this, i3, e22, o3);
          }
          this.depthRangeFor3D = [0, 1 - (l22.length + 2) * this.numSublayers * this.depthEpsilon], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, f22)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
          const b22 = "globe" === this.transform.projection.name || this.transform.isHorizonVisible(), w22 = (() => {
            if (i2.showOverdrawInspector)
              return e2.bz.black;
            const t3 = this.style.fog;
            if (t3 && this.transform.projection.supportsFog) {
              const i3 = this.style.getLut(t3.scope);
              if (!b22) {
                const o3 = t3.properties.get("color").toRenderColor(i3).toArray01();
                return new e2.bz(...o3);
              }
              if (b22) {
                const o3 = t3.properties.get("space-color").toRenderColor(i3).toArray01();
                return new e2.bz(...o3);
              }
            }
            return e2.bz.transparent;
          })();
          if (this.context.clear({ color: w22, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && b22 && this._atmosphere.drawStars(this, this.style.fog), !this.terrain)
            for (this.currentLayer = s2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const e22 = l22[this.currentLayer], i3 = t22.getLayerSourceCache(e22);
              if (e22.isSky())
                continue;
              const o3 = i3 ? (e22.is3D() ? g22 : p22)[i3.id] : void 0;
              this._renderTileClippingMasks(e22, i3, o3), this.renderLayer(this, i3, e22, o3);
            }
          if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && b22 && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || e2.a9(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible()))
            for (this.currentLayer = 0; this.currentLayer < s2.length; this.currentLayer++) {
              const e22 = l22[this.currentLayer], i3 = t22.getLayerSourceCache(e22);
              e22.isSky() && this.renderLayer(this, i3, e22, i3 ? p22[i3.id] : void 0);
            }
          function T22(e22, t3) {
            let i3;
            return t3 && (i3 = ("symbol" === e22.type ? m22 : e22.is3D() ? g22 : p22)[t3.id]), i3;
          }
          if (this.renderPass = "translucent", "globe" === this.transform.projection.name) {
            for (this.renderElevatedRasterBackface = true, this.currentLayer = 0; this.currentLayer < s2.length; ) {
              const e22 = l22[this.currentLayer];
              if ("raster" === e22.type || "raster-particle" === e22.type) {
                const i3 = t22.getLayerSourceCache(e22);
                this.renderLayer(this, i3, e22, T22(e22, i3));
              }
              ++this.currentLayer;
            }
            this.renderElevatedRasterBackface = false;
          }
          this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
          let E22 = 0;
          y22 && (E22 = y22.getShadowCastingLayerCount());
          let C22 = false, S22 = -1;
          for (let e22 = 0; e22 < s2.length; ++e22) {
            const t3 = l22[e22];
            t3.isHidden(this.transform.zoom) || t3.is3D() && (S22 = e22);
          }
          for (n22 && -1 === S22 && (a2 = true); this.currentLayer < s2.length; ) {
            const e22 = l22[this.currentLayer], i3 = t22.getLayerSourceCache(e22);
            if (e22.isSky())
              ++this.currentLayer;
            else if (this.terrain && this.style.isLayerDraped(e22)) {
              if (e22.isHidden(this.transform.zoom)) {
                ++this.currentLayer;
                continue;
              }
              this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
            } else {
              if (a2 && !C22 && this.terrain && !this.transform.isOrthographic && (C22 = true, this.blitDepth()), n22 && -1 !== S22 && this.currentLayer === S22 + 1 && !this.transform.isOrthographic && this.blitDepth(), e22.is3D() || this.terrain || this._renderTileClippingMasks(e22, i3, i3 ? _2[i3.id] : void 0), this.renderLayer(this, i3, e22, T22(e22, i3)), !this.terrain && y22 && E22 > 0 && e22.hasShadowPass() && 0 == --E22 && (y22.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
                const e3 = this.currentLayer;
                for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e3; this.currentLayer++) {
                  const e4 = l22[this.currentLayer];
                  if (!e4.hasLightBeamPass())
                    continue;
                  const i4 = t22.getLayerSourceCache(e4);
                  this.renderLayer(this, i4, e4, i4 ? p22[i4.id] : void 0);
                }
                this.currentLayer = e3, this.renderPass = "translucent";
              }
              if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                const e3 = this.currentLayer;
                this.depthOcclusion = true;
                for (const e4 of this.layersWithOcclusionOpacity) {
                  this.currentLayer = e4;
                  const i4 = l22[this.currentLayer], o3 = t22.getLayerSourceCache(i4), r3 = o3 ? p22[o3.id] : void 0;
                  i4.is3D() || this.terrain || this._renderTileClippingMasks(i4, o3, o3 ? _2[o3.id] : void 0), this.renderLayer(this, o3, i4, r3);
                }
                this.depthOcclusion = false, this.currentLayer = e3, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
              }
              ++this.currentLayer;
            }
          }
          if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
            let i3 = null;
            l22.forEach((e22) => {
              const o3 = t22.getLayerSourceCache(e22);
              o3 && !e22.isHidden(this.transform.zoom) && o3.getVisibleCoordinates().length && (!i3 || i3.getSource().maxzoom < o3.getSource().maxzoom) && (i3 = o3);
            }), i3 && this.options.showTileBoundaries && ya2.debug(this, i3, i3.getVisibleCoordinates(), e2.bz.red, false, this.options.showParseStatus);
          }
          this.terrain && this._debugParams.showTerrainProxyTiles && ya2.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e2.bz(1, 0.8, 0.1, 1), true, this.options.showParseStatus), this.options.showPadding && function(e22) {
            const t3 = e22.transform.padding;
            Zs(e22, e22.transform.height - (t3.top || 0), 3, Ns), Zs(e22, t3.bottom || 0, 3, Us), Hs(e22, t3.left || 0, 3, Gs), Hs(e22, e22.transform.width - (t3.right || 0), 3, js);
            const i3 = e22.transform.centerPoint;
            !function(e3, t4, i4, o3) {
              Ws(e3, t4 - 1, i4 - 10, 2, 20, o3), Ws(e3, t4 - 10, i4 - 1, 20, 2, o3);
            }(e22, i3.x, e22.transform.height - i3.y, Vs);
          }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), u22 || (this.conflationActive = false);
        }
        prepareLayer(e22) {
          this.gpuTimingStart(e22);
          const { unsupportedLayers: t22 } = this.transform.projection, i2 = !t22 || !t22.includes(e22.type);
          if (ba[e22.type] && (i2 || this.terrain && "custom" === e22.type)) {
            const t3 = this.style.getLayerSourceCache(e22);
            ba[e22.type](e22, t3, this);
          }
          this.gpuTimingEnd();
        }
        renderLayer(e22, t22, i2, o2) {
          i2.isHidden(this.transform.zoom) || ("background" === i2.type || "sky" === i2.type || "custom" === i2.type || "model" === i2.type || "raster" === i2.type || "raster-particle" === i2.type || o2 && o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), e22.transform.projection.unsupportedLayers && e22.transform.projection.unsupportedLayers.includes(i2.type) && (!e22.terrain || "custom" !== i2.type) || "clip" === i2.type || ya2[i2.type](e22, t22, i2, o2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
        }
        gpuTimingStart(e22) {
          if (!this.options.gpuTiming)
            return;
          const t22 = this.context.extTimerQuery, i2 = this.context.gl;
          let o2 = this.gpuTimers[e22.id];
          o2 || (o2 = this.gpuTimers[e22.id] = { calls: 0, cpuTime: 0, query: i2.createQuery() }), o2.calls++, i2.beginQuery(t22.TIME_ELAPSED_EXT, o2.query);
        }
        gpuTimingDeferredRenderStart() {
          if (this.options.gpuTimingDeferredRender) {
            const e22 = this.context.extTimerQuery, t22 = this.context.gl, i2 = t22.createQuery();
            this.deferredRenderGpuTimeQueries.push(i2), t22.beginQuery(e22.TIME_ELAPSED_EXT, i2);
          }
        }
        gpuTimingDeferredRenderEnd() {
          this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
        }
        gpuTimingEnd() {
          this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
        }
        collectGpuTimers() {
          const e22 = this.gpuTimers;
          return this.gpuTimers = {}, e22;
        }
        collectDeferredRenderGpuQueries() {
          const e22 = this.deferredRenderGpuTimeQueries;
          return this.deferredRenderGpuTimeQueries = [], e22;
        }
        queryGpuTimers(e22) {
          const t22 = {};
          for (const i2 in e22) {
            const o2 = e22[i2], r22 = this.context.extTimerQuery, s2 = r22.getQueryParameter(o2.query, this.context.gl.QUERY_RESULT) / 1e6;
            r22.deleteQueryEXT(o2.query), t22[i2] = s2;
          }
          return t22;
        }
        queryGpuTimeDeferredRender(e22) {
          if (!this.options.gpuTimingDeferredRender)
            return 0;
          const t22 = this.context.extTimerQuery, i2 = this.context.gl;
          let o2 = 0;
          for (const r22 of e22)
            o2 += t22.getQueryParameter(r22, i2.QUERY_RESULT) / 1e6, t22.deleteQueryEXT(r22);
          return o2;
        }
        translatePosMatrix(t22, i2, o2, r22, s2) {
          if (!o2[0] && !o2[1])
            return t22;
          const a2 = s2 ? "map" === r22 ? this.transform.angle : 0 : "viewport" === r22 ? -this.transform.angle : 0;
          if (a2) {
            const e22 = Math.sin(a2), t3 = Math.cos(a2);
            o2 = [o2[0] * t3 - o2[1] * e22, o2[0] * e22 + o2[1] * t3];
          }
          const n22 = [s2 ? o2[0] : e2.ak(i2, o2[0], this.transform.zoom), s2 ? o2[1] : e2.ak(i2, o2[1], this.transform.zoom), 0], l22 = new Float32Array(16);
          return e2.a6.mat4.translate(l22, t22, n22), l22;
        }
        saveTileTexture(e22) {
          const t22 = e22.size[0], i2 = this._tileTextures[t22];
          i2 ? i2.push(e22) : this._tileTextures[t22] = [e22];
        }
        getTileTexture(e22) {
          const t22 = this._tileTextures[e22];
          return t22 && t22.length > 0 ? t22.pop() : null;
        }
        terrainRenderModeElevated() {
          return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;
        }
        linearFloatFilteringSupported() {
          return null != this.context.extTextureFloatLinear;
        }
        currentGlobalDefines(e22, t22, i2) {
          const o2 = void 0 === i2 ? this.terrain && this.terrain.renderingToTexture : i2, r22 = [];
          return this.style && this.style.enable3dLights() && ("globeRaster" === e22 || "terrainRaster" === e22 ? (r22.push("LIGHTING_3D_MODE"), r22.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : o2 || r22.push("LIGHTING_3D_MODE")), "shadow" === this.renderPass ? this._shadowMapDebug || r22.push("DEPTH_TEXTURE") : this.shadowRenderer && (this.shadowRenderer.useNormalOffset ? r22.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET") : r22.push("RENDER_SHADOWS", "DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (r22.push("TERRAIN"), this.linearFloatFilteringSupported() && r22.push("TERRAIN_DEM_FLOAT_FORMAT")), "globe" === this.transform.projection.name && r22.push("GLOBE"), !this._fogVisible || o2 || void 0 !== t22 && !t22 || r22.push("FOG", "FOG_DITHERING"), o2 && r22.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && r22.push("OVERDRAW_INSPECTOR"), r22;
        }
        getOrCreateProgram(e22, t22) {
          this.cache = this.cache || {};
          const i2 = t22 && t22.defines || [], o2 = t22 && t22.config, r22 = this.currentGlobalDefines(e22, t22 && t22.overrideFog, t22 && t22.overrideRtt).concat(i2), s2 = zr.cacheKey(Io[e22], e22, r22, o2);
          return this.cache[s2] || (this.cache[s2] = new zr(this.context, e22, Io[e22], o2, cs[e22], r22)), this.cache[s2];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const e22 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e22.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e2.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));
        }
        destroy() {
          this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();
        }
        prepareDrawTile() {
          this.terrain && this.terrain.prepareDrawTile();
        }
        uploadCommonLightUniforms(t22, i2) {
          if (this.style.enable3dLights()) {
            const o2 = this.style.directionalLight, r22 = this.style.ambientLight;
            if (o2 && r22) {
              const s2 = ((t3, i3, o3) => {
                const r3 = t3.properties.get("direction"), s3 = t3.properties.get("color").toRenderColor(o3.getLut(t3.scope)).toArray01(), a2 = t3.properties.get("intensity"), n22 = i3.properties.get("color").toRenderColor(o3.getLut(i3.scope)).toArray01(), l22 = i3.properties.get("intensity"), c22 = [r3.x, r3.y, r3.z], h22 = e2.cH(n22, l22), u22 = e2.cH(s3, a2);
                return { u_lighting_ambient_color: h22, u_lighting_directional_dir: c22, u_lighting_directional_color: u22, u_ground_radiance: Lr(c22, u22, h22) };
              })(o2, r22, this.style);
              i2.setLightsUniformValues(t22, s2);
            }
          }
        }
        uploadCommonUniforms(t22, i2, o2, r22, s2) {
          if (this.uploadCommonLightUniforms(t22, i2), this.terrain && this.terrain.renderingToTexture)
            return;
          const a2 = this.style.fog;
          if (a2) {
            const s3 = a2.getOpacity(this.transform.pitch), n22 = ((t3, i3, o3, r3, s4, a3, n3, l22, c22, h22, u22, d22) => {
              const _2 = t3.transform, p22 = i3.properties.get("color").toRenderColor(t3.style.getLut(i3.scope)).toArray01();
              p22[3] = r3;
              const m22 = t3.frameCounter / 1e3 % 1, [f22, g22] = i3.properties.get("vertical-range");
              return { u_fog_matrix: o3 ? _2.calculateFogTileMatrix(o3) : d22 || t3.identityMat, u_fog_range: i3.getFovAdjustedRange(_2._fov), u_fog_color: p22, u_fog_horizon_blend: i3.properties.get("horizon-blend"), u_fog_vertical_limit: [Math.min(f22, g22), g22], u_fog_temporal_offset: m22, u_frustum_tl: s4, u_frustum_tr: a3, u_frustum_br: n3, u_frustum_bl: l22, u_globe_pos: c22, u_globe_radius: h22, u_viewport: u22, u_globe_transition: e2.a9(_2.zoom), u_is_globe: +("globe" === _2.projection.name) };
            })(this, a2, o2, s3, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e2.q.devicePixelRatio, this.transform.height * e2.q.devicePixelRatio], r22);
            i2.setFogUniformValues(t22, n22);
          }
          s2 && i2.setCutoffUniformValues(t22, s2.uniformValues);
        }
        setTileLoadedFlag(e22) {
          this.tileLoaded = e22;
        }
        saveCanvasCopy() {
          const e22 = this.canvasCopy();
          e22 && (this.frameCopies.push(e22), this.tileLoaded = false);
        }
        canvasCopy() {
          const e22 = this.context.gl, t22 = e22.createTexture();
          return e22.bindTexture(e22.TEXTURE_2D, t22), e22.copyTexImage2D(e22.TEXTURE_2D, 0, e22.RGBA, 0, 0, e22.drawingBufferWidth, e22.drawingBufferHeight, 0), t22;
        }
        getCanvasCopiesAndTimestamps() {
          return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
        }
        averageElevationNeedsEasing() {
          if (!this.transform._elevation)
            return false;
          const e22 = this.style && this.style.fog;
          return !!e22 && 0 !== e22.getOpacity(this.transform.pitch);
        }
        getBackgroundTiles() {
          const e22 = this._backgroundTiles, t22 = this._backgroundTiles = {}, i2 = this.transform.coveringTiles({ tileSize: 512 });
          for (const o2 of i2)
            t22[o2.key] = e22[o2.key] || new pt(o2, 512, this.transform.tileZoom, this);
          return t22;
        }
        clearBackgroundTiles() {
          this._backgroundTiles = {};
        }
        isSourceForClippingOrConflation(e22, t22) {
          return !(!e22.is3D() || "clip" !== e22.type && (e22.minzoom && e22.minzoom > this.transform.zoom || (this.style._clipLayerPresent || "building" !== e22.sourceLayer) && (!t22 || "batched-model" !== t22.type)));
        }
        isTileAffectedByFog(e22) {
          if (!this.style || !this.style.fog)
            return false;
          if ("globe" === this.transform.projection.name)
            return true;
          let t22 = this._cachedTileFogOpacities[e22.key];
          return t22 || (this._cachedTileFogOpacities[e22.key] = t22 = this.style.fog.getOpacityForTile(e22)), t22[0] >= Oe2 || t22[1] >= Oe2;
        }
        setupDepthForOcclusion(e22, t22, i2) {
          const o2 = this.context, r22 = o2.gl, s2 = !!i2;
          var a2;
          i2 || (i2 = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 }), o2.activeTexture.set(r22.TEXTURE3), e22 && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(r22.NEAREST, r22.CLAMP_TO_EDGE), i2.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height], i2.u_depth_range_unpack = [2 / ((a2 = this.depthRangeFor3D)[1] - a2[0]), -1 - 2 * a2[0] / (a2[1] - a2[0])], i2.u_occluder_half_size = 0.5 * this.occlusionParams.occluderSize, i2.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(r22.NEAREST, r22.CLAMP_TO_EDGE), o2.activeTexture.set(r22.TEXTURE0), s2 || t22.setTerrainUniformValues(o2, i2);
        }
      }
      function Ta2(e22, t22) {
        let i2 = false, o2 = null;
        const r22 = () => {
          o2 = null, i2 && (e22(), o2 = setTimeout(r22, t22), i2 = false);
        };
        return () => (i2 = true, o2 || r22(), o2);
      }
      class Ea2 {
        constructor(t22) {
          this._hashName = t22 && encodeURIComponent(t22), e2.aJ(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Ta2(this._updateHashUnthrottled.bind(this), 300);
        }
        addTo(e22) {
          return this._map = e22, window.addEventListener("hashchange", this._onHashChange, false), e22.on("moveend", this._updateHash), this;
        }
        remove() {
          return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
        }
        getHashString() {
          const e22 = this._map;
          if (!e22)
            return "";
          const t22 = Ca2(e22);
          if (this._hashName) {
            const e3 = this._hashName;
            let i2 = false;
            const o2 = location.hash.slice(1).split("&").map((o3) => {
              const r22 = o3.split("=")[0];
              return r22 === e3 ? (i2 = true, "".concat(r22, "=").concat(t22)) : o3;
            }).filter((e4) => e4);
            return i2 || o2.push("".concat(e3, "=").concat(t22)), "#".concat(o2.join("&"));
          }
          return "#".concat(t22);
        }
        _getCurrentHash() {
          const e22 = location.hash.replace("#", "");
          if (this._hashName) {
            let t22;
            return e22.split("&").map((e3) => e3.split("=")).forEach((e3) => {
              e3[0] === this._hashName && (t22 = e3);
            }), (t22 && t22[1] || "").split("/");
          }
          return e22.split("/");
        }
        _onHashChange() {
          const e22 = this._map;
          if (!e22)
            return false;
          const t22 = this._getCurrentHash();
          if (t22.length >= 3 && !t22.some((e3) => isNaN(e3))) {
            const i2 = e22.dragRotate.isEnabled() && e22.touchZoomRotate.isEnabled() ? +(t22[3] || 0) : e22.getBearing();
            return e22.jumpTo({ center: [+t22[2], +t22[1]], zoom: +t22[0], bearing: i2, pitch: +(t22[4] || 0) }), true;
          }
          return false;
        }
        _updateHashUnthrottled() {
          history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
        }
      }
      function Ca2(e22, t22) {
        const i2 = e22.getCenter(), o2 = Math.round(100 * e22.getZoom()) / 100, r22 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), s2 = Math.pow(10, r22), a2 = Math.round(i2.lng * s2) / s2, n22 = Math.round(i2.lat * s2) / s2, l22 = e22.getBearing(), c22 = e22.getPitch();
        let h22 = t22 ? "/".concat(a2, "/").concat(n22, "/").concat(o2) : "".concat(o2, "/").concat(n22, "/").concat(a2);
        return (l22 || c22) && (h22 += "/" + Math.round(10 * l22) / 10), c22 && (h22 += "/".concat(Math.round(c22))), h22;
      }
      const Sa2 = { linearity: 0.3, easing: e2.dp(0, 0, 0.3, 1) }, Ia2 = e2.l({ deceleration: 2500, maxSpeed: 1400 }, Sa2), Da2 = e2.l({ deceleration: 20, maxSpeed: 1400 }, Sa2), Ra2 = e2.l({ deceleration: 1e3, maxSpeed: 360 }, Sa2), Aa2 = e2.l({ deceleration: 1e3, maxSpeed: 90 }, Sa2);
      class La2 {
        constructor(e22) {
          this._map = e22, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t22) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e2.q.now(), settings: t22 });
        }
        _drainInertiaBuffer() {
          const t22 = this._inertiaBuffer, i2 = e2.q.now();
          for (; t22.length > 0 && i2 - t22[0].time > 160; )
            t22.shift();
        }
        _onMoveEnd(t22) {
          if (this._map._prefersReducedMotion())
            return;
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
            return;
          const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new e2.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: e22 } of this._inertiaBuffer)
            i2.zoom += e22.zoomDelta || 0, i2.bearing += e22.bearingDelta || 0, i2.pitch += e22.pitchDelta || 0, e22.panDelta && i2.pan._add(e22.panDelta), e22.around && (i2.around = e22.around), e22.pinchAround && (i2.pinchAround = e22.pinchAround);
          const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r22 = {};
          if (i2.pan.mag()) {
            const s2 = Ma2(i2.pan.mag(), o2, e2.l({}, Ia2, t22 || {}));
            r22.offset = i2.pan.mult(s2.amount / i2.pan.mag()), r22.center = this._map.transform.center, Pa2(r22, s2);
          }
          if (i2.zoom) {
            const e22 = Ma2(i2.zoom, o2, Da2);
            r22.zoom = this._map.transform.zoom + e22.amount, Pa2(r22, e22);
          }
          if (i2.bearing) {
            const t3 = Ma2(i2.bearing, o2, Ra2);
            r22.bearing = this._map.transform.bearing + e2.ap(t3.amount, -179, 179), Pa2(r22, t3);
          }
          if (i2.pitch) {
            const e22 = Ma2(i2.pitch, o2, Aa2);
            r22.pitch = this._map.transform.pitch + e22.amount, Pa2(r22, e22);
          }
          if (r22.zoom || r22.bearing) {
            const e22 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
            r22.around = e22 ? this._map.unproject(e22) : this._map.getCenter();
          }
          return this.clear(), r22.noMoveStart = true, r22;
        }
      }
      function Pa2(e22, t22) {
        (!e22.duration || e22.duration < t22.duration) && (e22.duration = t22.duration, e22.easing = t22.easing);
      }
      function Ma2(t22, i2, o2) {
        const { maxSpeed: r22, linearity: s2, deceleration: a2 } = o2, n22 = e2.ap(t22 * s2 / (i2 / 1e3), -r22, r22), l22 = Math.abs(n22) / (a2 * s2);
        return { easing: o2.easing, duration: 1e3 * l22, amount: n22 * (l22 / 2) };
      }
      class za2 extends e2.x {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t22, i2, o2, r22 = {}) {
          const s2 = g2(i2.getCanvasContainer(), o2), a2 = i2.unproject(s2);
          super(t22, e2.l({ point: s2, lngLat: a2, originalEvent: o2 }, r22)), this._defaultPrevented = false, this.target = i2;
        }
      }
      class Oa2 extends e2.x {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t22, i2, o2) {
          const r22 = "touchend" === t22 ? o2.changedTouches : o2.touches, s2 = v2(i2.getCanvasContainer(), r22), a2 = s2.map((e22) => i2.unproject(e22)), n22 = s2.reduce((e22, t3, i3, o3) => e22.add(t3.div(o3.length)), new e2.P(0, 0));
          super(t22, { points: s2, point: n22, lngLats: a2, lngLat: i2.unproject(n22), originalEvent: o2 }), this._defaultPrevented = false;
        }
      }
      class Fa2 extends e2.x {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e22, t22) {
          super("wheel", { originalEvent: t22 }), this._defaultPrevented = false;
        }
      }
      class ka2 {
        constructor(e22, t22) {
          this._map = e22, this._clickTolerance = t22.clickTolerance;
        }
        reset() {
          this._mousedownPos = void 0;
        }
        wheel(e22) {
          return this._firePreventable(new Fa2(this._map, e22));
        }
        mousedown(e22, t22) {
          return this._mousedownPos = t22, this._firePreventable(new za2(e22.type, this._map, e22));
        }
        mouseup(e22) {
          this._map.fire(new za2(e22.type, this._map, e22));
        }
        preclick(t22) {
          const i2 = e2.l({}, t22);
          i2.type = "preclick", this._map.fire(new za2(i2.type, this._map, i2));
        }
        click(e22, t22) {
          this._mousedownPos && this._mousedownPos.dist(t22) >= this._clickTolerance || (this.preclick(e22), this._map.fire(new za2(e22.type, this._map, e22)));
        }
        dblclick(e22) {
          return this._firePreventable(new za2(e22.type, this._map, e22));
        }
        mouseover(e22) {
          this._map.fire(new za2(e22.type, this._map, e22));
        }
        mouseout(e22) {
          this._map.fire(new za2(e22.type, this._map, e22));
        }
        touchstart(e22) {
          return this._firePreventable(new Oa2(e22.type, this._map, e22));
        }
        touchmove(e22) {
          this._map.fire(new Oa2(e22.type, this._map, e22));
        }
        touchend(e22) {
          this._map.fire(new Oa2(e22.type, this._map, e22));
        }
        touchcancel(e22) {
          this._map.fire(new Oa2(e22.type, this._map, e22));
        }
        _firePreventable(e22) {
          if (this._map.fire(e22), e22.defaultPrevented)
            return {};
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class Ba2 {
        constructor(e22) {
          this._map = e22;
        }
        reset() {
          this._delayContextMenu = false, this._contextMenuEvent = void 0;
        }
        mousemove(e22) {
          this._map.fire(new za2(e22.type, this._map, e22));
        }
        mousedown() {
          this._delayContextMenu = true;
        }
        mouseup() {
          this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new za2("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(e22) {
          this._delayContextMenu ? this._contextMenuEvent = e22 : this._map.fire(new za2(e22.type, this._map, e22)), this._map.listens("contextmenu") && e22.preventDefault();
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class Na2 {
        constructor(e22, t22) {
          this._map = e22, this._el = e22.getCanvasContainer(), this._container = e22.getContainer(), this._clickTolerance = t22.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = true);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        mousedown(e22, t22) {
          this.isEnabled() && e22.shiftKey && 0 === e22.button && (_(), this._startPos = this._lastPos = t22, this._active = true);
        }
        mousemoveWindow(e22, t22) {
          if (!this._active)
            return;
          const i2 = t22, o2 = this._startPos, r22 = this._lastPos;
          if (!o2 || !r22 || r22.equals(i2) || !this._box && i2.dist(o2) < this._clickTolerance)
            return;
          this._lastPos = i2, this._box || (this._box = l2("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e22));
          const s2 = Math.min(o2.x, i2.x), a2 = Math.max(o2.x, i2.x), n22 = Math.min(o2.y, i2.y), c22 = Math.max(o2.y, i2.y);
          this._map._requestDomTask(() => {
            this._box && (this._box.style.transform = "translate(".concat(s2, "px,").concat(n22, "px)"), this._box.style.width = a2 - s2 + "px", this._box.style.height = c22 - n22 + "px");
          });
        }
        mouseupWindow(t22, i2) {
          if (!this._active)
            return;
          const o2 = this._startPos, r22 = i2;
          if (o2 && 0 === t22.button) {
            if (this.reset(), f2(), o2.x !== r22.x || o2.y !== r22.y)
              return this._map.fire(new e2.x("boxzoomend", { originalEvent: t22 })), { cameraAnimation: (e22) => e22.fitScreenCoordinates(o2, r22, this._map.getBearing(), { linear: false }) };
            this._fireEvent("boxzoomcancel", t22);
          }
        }
        keydown(e22) {
          this._active && 27 === e22.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e22));
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), p2(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(t22, i2) {
          return this._map.fire(new e2.x(t22, { originalEvent: i2 }));
        }
      }
      function Ua2(e22, t22) {
        const i2 = {};
        for (let o2 = 0; o2 < e22.length; o2++)
          i2[e22[o2].identifier] = t22[o2];
        return i2;
      }
      class Ga2 {
        constructor(e22) {
          this.reset(), this.numTouches = e22.numTouches;
        }
        reset() {
          this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
        }
        touchstart(t22, i2, o2) {
          (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (0 === this.startTime && (this.startTime = t22.timeStamp), o2.length === this.numTouches && (this.centroid = function(t3) {
            const i3 = new e2.P(0, 0);
            for (const e22 of t3)
              i3._add(e22);
            return i3.div(t3.length);
          }(i2), this.touches = Ua2(o2, i2)));
        }
        touchmove(e22, t22, i2) {
          if (this.aborted || !this.centroid)
            return;
          const o2 = Ua2(i2, t22);
          for (const e3 in this.touches) {
            const t3 = o2[e3];
            (!t3 || t3.dist(this.touches[e3]) > 30) && (this.aborted = true);
          }
        }
        touchend(e22, t22, i2) {
          if ((!this.centroid || e22.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
            const e3 = !this.aborted && this.centroid;
            if (this.reset(), e3)
              return e3;
          }
        }
      }
      class ja2 {
        constructor(e22) {
          this.singleTap = new Ga2(e22), this.numTaps = e22.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
        }
        touchstart(e22, t22, i2) {
          this.singleTap.touchstart(e22, t22, i2);
        }
        touchmove(e22, t22, i2) {
          this.singleTap.touchmove(e22, t22, i2);
        }
        touchend(e22, t22, i2) {
          const o2 = this.singleTap.touchend(e22, t22, i2);
          if (o2) {
            const t3 = e22.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
            if (t3 && i3 || this.reset(), this.count++, this.lastTime = e22.timeStamp, this.lastTap = o2, this.count === this.numTaps)
              return this.reset(), o2;
          }
        }
      }
      class Va2 {
        constructor() {
          this._zoomIn = new ja2({ numTouches: 1, numTaps: 2 }), this._zoomOut = new ja2({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(e22, t22, i2) {
          this._zoomIn.touchstart(e22, t22, i2), this._zoomOut.touchstart(e22, t22, i2);
        }
        touchmove(e22, t22, i2) {
          this._zoomIn.touchmove(e22, t22, i2), this._zoomOut.touchmove(e22, t22, i2);
        }
        touchend(e22, t22, i2) {
          const o2 = this._zoomIn.touchend(e22, t22, i2), r22 = this._zoomOut.touchend(e22, t22, i2);
          return o2 ? (this._active = true, e22.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() + 1, around: t3.unproject(o2) }, { originalEvent: e22 }) }) : r22 ? (this._active = true, e22.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() - 1, around: t3.unproject(r22) }, { originalEvent: e22 }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      const qa2 = { 0: 1, 2: 2 };
      class Za2 {
        constructor(e22) {
          this.reset(), this._clickTolerance = e22.clickTolerance || 1;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
        }
        _correctButton(e22, t22) {
          return false;
        }
        _move(e22, t22) {
          return {};
        }
        mousedown(e22, t22) {
          if (this._lastPoint)
            return;
          const i2 = x2(e22);
          this._correctButton(e22, i2) && (this._lastPoint = t22, this._eventButton = i2);
        }
        mousemoveWindow(e22, t22) {
          const i2 = this._lastPoint;
          if (i2) {
            if (e22.preventDefault(), null != this._eventButton && function(e3, t3) {
              const i3 = qa2[t3];
              return void 0 === e3.buttons || (e3.buttons & i3) !== i3;
            }(e22, this._eventButton))
              this.reset();
            else if (this._moved || !(t22.dist(i2) < this._clickTolerance))
              return this._moved = true, this._lastPoint = t22, this._move(i2, t22);
          }
        }
        mouseupWindow(e22) {
          this._lastPoint && x2(e22) === this._eventButton && (this._moved && f2(), this.reset());
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Ha2 extends Za2 {
        mousedown(e22, t22) {
          super.mousedown(e22, t22), this._lastPoint && (this._active = true);
        }
        _correctButton(e22, t22) {
          return 0 === t22 && !e22.ctrlKey;
        }
        _move(e22, t22) {
          return { around: t22, panDelta: t22.sub(e22) };
        }
      }
      class Wa2 extends Za2 {
        _correctButton(e22, t22) {
          return 0 === t22 && e22.ctrlKey || 2 === t22;
        }
        _move(e22, t22) {
          const i2 = 0.8 * (t22.x - e22.x);
          if (i2)
            return this._active = true, { bearingDelta: i2 };
        }
        contextmenu(e22) {
          e22.preventDefault();
        }
      }
      class $a extends Za2 {
        _correctButton(e22, t22) {
          return 0 === t22 && e22.ctrlKey || 2 === t22;
        }
        _move(e22, t22) {
          const i2 = -0.5 * (t22.y - e22.y);
          if (i2)
            return this._active = true, { pitchDelta: i2 };
        }
        contextmenu(e22) {
          e22.preventDefault();
        }
      }
      class Xa2 {
        constructor(t22, i2) {
          this._map = t22, this._el = t22.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i2.clickTolerance || 1, this.reset(), e2.aJ(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
        }
        reset() {
          this._active = false, this._touches = {}, this._sum = new e2.P(0, 0);
        }
        touchstart(e22, t22, i2) {
          return this._calculateTransform(e22, t22, i2);
        }
        touchmove(t22, i2, o2) {
          if (this._active && !(o2.length < this._minTouches)) {
            if (this._map._cooperativeGestures && !this._map.isMoving()) {
              if (1 === o2.length && !e2.dq())
                return void this._showTouchPanBlockerAlert();
              "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            return t22.cancelable && t22.preventDefault(), this._calculateTransform(t22, i2, o2);
          }
        }
        touchend(e22, t22, i2) {
          this._calculateTransform(e22, t22, i2), this._active && i2.length < this._minTouches && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t22, i2, o2) {
          o2.length > 0 && (this._active = true);
          const r22 = Ua2(o2, i2), s2 = new e2.P(0, 0), a2 = new e2.P(0, 0);
          let n22 = 0;
          for (const e22 in r22) {
            const t3 = r22[e22], i3 = this._touches[e22];
            i3 && (s2._add(t3), a2._add(t3.sub(i3)), n22++, r22[e22] = t3);
          }
          if (this._touches = r22, n22 < this._minTouches || !a2.mag())
            return;
          const l22 = a2.div(n22);
          return this._sum._add(l22), this._sum.mag() < this._clickTolerance ? void 0 : { around: s2.div(n22), panDelta: l22 };
        }
        enable() {
          this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
        }
        disable() {
          this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        _addTouchPanBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = l2("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = "".concat(Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth))), "px"));
        }
        _showTouchPanBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
          }, 500);
        }
      }
      class Ya2 {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false, this._firstTwoTouches = void 0;
        }
        _start(e22) {
        }
        _move(e22, t22, i2) {
          return {};
        }
        touchstart(e22, t22, i2) {
          this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t22[0], t22[1]]));
        }
        touchmove(e22, t22, i2) {
          const o2 = this._firstTwoTouches;
          if (!o2)
            return;
          e22.preventDefault();
          const [r22, s2] = o2, a2 = Ka2(i2, t22, r22), n22 = Ka2(i2, t22, s2);
          if (!a2 || !n22)
            return;
          const l22 = this._aroundCenter ? null : a2.add(n22).div(2);
          return this._move([a2, n22], l22, e22);
        }
        touchend(e22, t22, i2) {
          if (!this._firstTwoTouches)
            return;
          const [o2, r22] = this._firstTwoTouches, s2 = Ka2(i2, t22, o2), a2 = Ka2(i2, t22, r22);
          s2 && a2 || (this._active && f2(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(e22) {
          this._enabled = true, this._aroundCenter = !!e22 && "center" === e22.around;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      function Ka2(e22, t22, i2) {
        for (let o2 = 0; o2 < e22.length; o2++)
          if (e22[o2].identifier === i2)
            return t22[o2];
      }
      function Ja2(e22, t22) {
        return Math.log(e22 / t22) / Math.LN2;
      }
      class Qa2 extends Ya2 {
        reset() {
          super.reset(), this._distance = 0, this._startDistance = 0;
        }
        _start(e22) {
          this._startDistance = this._distance = e22[0].dist(e22[1]);
        }
        _move(e22, t22) {
          const i2 = this._distance;
          if (this._distance = e22[0].dist(e22[1]), this._active || !(Math.abs(Ja2(this._distance, this._startDistance)) < 0.1))
            return this._active = true, { zoomDelta: Ja2(this._distance, i2), pinchAround: t22 };
        }
      }
      function en(e22, t22) {
        return 180 * e22.angleWith(t22) / Math.PI;
      }
      class tn extends Ya2 {
        reset() {
          super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
        }
        _start(e22) {
          this._startVector = this._vector = e22[0].sub(e22[1]), this._minDiameter = e22[0].dist(e22[1]);
        }
        _move(e22, t22) {
          const i2 = this._vector;
          if (this._vector = e22[0].sub(e22[1]), i2 && (this._active || !this._isBelowThreshold(this._vector)))
            return this._active = true, { bearingDelta: en(this._vector, i2), pinchAround: t22 };
        }
        _isBelowThreshold(e22) {
          this._minDiameter = Math.min(this._minDiameter, e22.mag());
          const t22 = 25 / (Math.PI * this._minDiameter) * 360, i2 = this._startVector;
          if (!i2)
            return false;
          const o2 = en(e22, i2);
          return Math.abs(o2) < t22;
        }
      }
      function on(e22) {
        return Math.abs(e22.y) > Math.abs(e22.x);
      }
      class rn extends Ya2 {
        constructor(e22) {
          super(), this._map = e22;
        }
        reset() {
          super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
        }
        _start(e22) {
          this._lastPoints = e22, on(e22[0].sub(e22[1])) && (this._valid = false);
        }
        _move(t22, i2, o2) {
          const r22 = this._lastPoints;
          if (!r22)
            return;
          const s2 = t22[0].sub(r22[0]), a2 = t22[1].sub(r22[1]);
          return this._map._cooperativeGestures && !e2.dq() && o2.touches.length < 3 || (this._valid = this.gestureBeginsVertically(s2, a2, o2.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t22, this._active = true, { pitchDelta: (s2.y + a2.y) / 2 * -0.5 });
        }
        gestureBeginsVertically(e22, t22, i2) {
          if (void 0 !== this._valid)
            return this._valid;
          const o2 = e22.mag() >= 2, r22 = t22.mag() >= 2;
          if (!o2 && !r22)
            return;
          if (!o2 || !r22)
            return null == this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
          const s2 = e22.y > 0 == t22.y > 0;
          return on(e22) && on(t22) && s2;
        }
      }
      const sn = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class an {
        constructor() {
          const e22 = sn;
          this._panStep = e22.panStep, this._bearingStep = e22.bearingStep, this._pitchStep = e22.pitchStep, this._rotationDisabled = false;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        keydown(e22) {
          if (e22.altKey || e22.ctrlKey || e22.metaKey)
            return;
          let t22 = 0, i2 = 0, o2 = 0, r22 = 0, s2 = 0;
          switch (e22.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              t22 = 1;
              break;
            case 189:
            case 109:
            case 173:
              t22 = -1;
              break;
            case 37:
              e22.shiftKey ? i2 = -1 : (e22.preventDefault(), r22 = -1);
              break;
            case 39:
              e22.shiftKey ? i2 = 1 : (e22.preventDefault(), r22 = 1);
              break;
            case 38:
              e22.shiftKey ? o2 = 1 : (e22.preventDefault(), s2 = -1);
              break;
            case 40:
              e22.shiftKey ? o2 = -1 : (e22.preventDefault(), s2 = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (a2) => {
            const n22 = a2.getZoom();
            a2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: nn, zoom: t22 ? Math.round(n22) + t22 * (e22.shiftKey ? 2 : 1) : n22, bearing: a2.getBearing() + i2 * this._bearingStep, pitch: a2.getPitch() + o2 * this._pitchStep, offset: [-r22 * this._panStep, -s2 * this._panStep], center: a2.getCenter() }, { originalEvent: e22 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = true;
        }
        enableRotation() {
          this._rotationDisabled = false;
        }
      }
      function nn(e22) {
        return e22 * (2 - e22);
      }
      const ln = 4.000244140625, cn = 1 / 450;
      class hn {
        constructor(t22, i2) {
          this._map = t22, this._el = t22.getCanvasContainer(), this._handler = i2, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = cn, e2.aJ(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
        }
        setZoomRate(e22) {
          this._defaultZoomRate = e22;
        }
        setWheelZoomRate(e22) {
          this._wheelZoomRate = e22;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return this._active || void 0 !== this._finishTimeout;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(e22) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e22 && "center" === e22.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
        }
        disable() {
          this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
        }
        wheel(t22) {
          if (!this.isEnabled())
            return;
          if (this._map._cooperativeGestures) {
            if (!(t22.ctrlKey || t22.metaKey || this.isZooming() || e2.dq()))
              return void this._showBlockerAlert();
            "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
          }
          let i2 = t22.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t22.deltaY : t22.deltaY;
          const o2 = e2.q.now(), r22 = o2 - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = o2, 0 !== i2 && i2 % ln == 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : r22 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = window.setTimeout(this._onTimeout, 40, t22)) : this._type || (this._type = Math.abs(r22 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), t22.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = t22, this._delta -= i2, this._active || this._start(t22)), t22.preventDefault();
        }
        _onTimeout(e22) {
          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e22);
        }
        _start(e22) {
          if (!this._delta)
            return;
          this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const t22 = g2(this._el, e22);
          this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t22, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId)
            return;
          if (this._frameId = null, !this.isActive())
            return;
          const t22 = this._map.transform;
          "wheel" === this._type && t22.projection.wrap && (t22._center.lng >= 180 || t22._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
          const i2 = () => t22._terrainEnabled() && this._aroundCoord ? t22.computeZoomRelativeTo(this._aroundCoord) : t22.zoom;
          if (0 !== this._delta) {
            const e22 = "wheel" === this._type && Math.abs(this._delta) > ln ? this._wheelZoomRate : this._defaultZoomRate;
            let o3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e22)));
            this._delta < 0 && 0 !== o3 && (o3 = 1 / o3);
            const r3 = i2(), s3 = Math.pow(2, r3), a3 = "number" == typeof this._targetZoom ? t22.zoomScale(this._targetZoom) : s3;
            this._targetZoom = Math.min(t22.maxZoom, Math.max(t22.minZoom, t22.scaleZoom(a3 * o3))), "wheel" === this._type && (this._startZoom = r3, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
          }
          const o2 = "number" == typeof this._targetZoom ? this._targetZoom : i2(), r22 = this._startZoom, s2 = this._easing;
          let a2, n22 = false;
          if ("wheel" === this._type && r22 && s2) {
            const t3 = Math.min((e2.q.now() - this._lastWheelEventTime) / 200, 1), i3 = s2(t3);
            a2 = e2.aa(r22, o2, i3), t3 < 1 ? this._frameId || (this._frameId = true) : n22 = true;
          } else
            a2 = o2, n22 = true;
          this._active = true, n22 && (this._active = false, this._finishTimeout = window.setTimeout(() => {
            this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200));
          let l22 = a2 - i2();
          return l22 * this._lastDelta < 0 && (l22 = 0), { noInertia: true, needsRenderFrame: !n22, zoomDelta: l22, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(t22) {
          let i2 = e2.dr;
          if (this._prevEase) {
            const t3 = this._prevEase, o2 = (e2.q.now() - t3.start) / t3.duration, r22 = t3.easing(o2 + 0.01) - t3.easing(o2), s2 = 0.27 / Math.sqrt(r22 * r22 + 1e-4) * 0.01, a2 = Math.sqrt(0.0729 - s2 * s2);
            i2 = e2.dp(s2, a2, 0.25, 1);
          }
          return this._prevEase = { start: e2.q.now(), duration: t22, easing: i2 }, i2;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        _addScrollZoomBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = l2("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = "".concat(Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth))), "px"));
        }
        _showBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
          }, 200);
        }
      }
      class un {
        constructor(e22, t22) {
          this._clickZoom = e22, this._tapZoom = t22;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class dn {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        blur() {
          this.reset();
        }
        dblclick(e22, t22) {
          return e22.preventDefault(), { cameraAnimation: (i2) => {
            i2.easeTo({ duration: 300, zoom: i2.getZoom() + (e22.shiftKey ? -1 : 1), around: i2.unproject(t22) }, { originalEvent: e22 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class _n {
        constructor() {
          this._tap = new ja2({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
        }
        touchstart(e22, t22, i2) {
          this._swipePoint || (this._tapTime && e22.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = t22[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(e22, t22, i2));
        }
        touchmove(e22, t22, i2) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (i2[0].identifier !== this._swipeTouch)
                return;
              const o2 = t22[0], r22 = o2.y - this._swipePoint.y;
              return this._swipePoint = o2, e22.preventDefault(), this._active = true, { zoomDelta: r22 / 128 };
            }
          } else
            this._tap.touchmove(e22, t22, i2);
        }
        touchend(e22, t22, i2) {
          this._tapTime ? this._swipePoint && 0 === i2.length && this.reset() : this._tap.touchend(e22, t22, i2) && (this._tapTime = e22.timeStamp);
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class pn {
        constructor(e22, t22, i2) {
          this._el = e22, this._mousePan = t22, this._touchPan = i2;
        }
        enable(e22) {
          this._inertiaOptions = e22 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class mn {
        constructor(e22, t22, i2) {
          this._pitchWithRotate = e22.pitchWithRotate, this._mouseRotate = t22, this._mousePitch = i2;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class fn {
        constructor(e22, t22, i2, o2) {
          this._el = e22, this._touchZoom = t22, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
        }
        enable(e22) {
          this._touchZoom.enable(e22), this._rotationDisabled || this._touchRotate.enable(e22), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = true, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      const gn = (e22) => e22.zoom || e22.drag || e22.pitch || e22.rotate;
      class vn extends e2.x {
      }
      class xn {
        constructor() {
          this.constants = [1, 1, 0.01], this.radius = 0;
        }
        setup(t22, i2) {
          const o2 = e2.a6.vec3.sub([], i2, t22);
          this.radius = e2.a6.vec3.length(o2[2] < 0 ? e2.a6.vec3.div([], o2, this.constants) : [o2[0], o2[1], 0]);
        }
        projectRay(t22) {
          e2.a6.vec3.div(t22, t22, this.constants), e2.a6.vec3.normalize(t22, t22), e2.a6.vec3.mul(t22, t22, this.constants);
          const i2 = e2.a6.vec3.scale([], t22, this.radius);
          if (i2[2] > 0) {
            const t3 = e2.a6.vec3.scale([], [0, 0, 1], e2.a6.vec3.dot(i2, [0, 0, 1])), o2 = e2.a6.vec3.scale([], e2.a6.vec3.normalize([], [i2[0], i2[1], 0]), this.radius), r22 = e2.a6.vec3.add([], i2, e2.a6.vec3.scale([], e2.a6.vec3.sub([], e2.a6.vec3.add([], o2, t3), i2), 2));
            i2[0] = r22[0], i2[1] = r22[1];
          }
          return i2;
        }
      }
      function yn(e22) {
        return e22.panDelta && e22.panDelta.mag() || e22.zoomDelta || e22.bearingDelta || e22.pitchDelta;
      }
      class bn {
        constructor(t22, i2) {
          this._map = t22, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new La2(t22), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new xn(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i2), e2.aJ(["handleEvent", "handleWindowEvent"], this);
          const o2 = this._el;
          this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [e22, t3, i3] of this._listeners) {
            const o3 = e22 === document ? this.handleWindowEvent : this.handleEvent;
            e22.addEventListener(t3, o3, i3);
          }
        }
        destroy() {
          for (const [e22, t22, i2] of this._listeners) {
            const o2 = e22 === document ? this.handleWindowEvent : this.handleEvent;
            e22.removeEventListener(t22, o2, i2);
          }
        }
        _addDefaultHandlers(e22) {
          const t22 = this._map, i2 = t22.getCanvasContainer();
          this._add("mapEvent", new ka2(t22, e22));
          const o2 = t22.boxZoom = new Na2(t22, e22);
          this._add("boxZoom", o2);
          const r22 = new Va2(), s2 = new dn();
          t22.doubleClickZoom = new un(s2, r22), this._add("tapZoom", r22), this._add("clickZoom", s2);
          const a2 = new _n();
          this._add("tapDragZoom", a2);
          const n22 = t22.touchPitch = new rn(t22);
          this._add("touchPitch", n22);
          const l22 = new Wa2(e22), c22 = new $a(e22);
          t22.dragRotate = new mn(e22, l22, c22), this._add("mouseRotate", l22, ["mousePitch"]), this._add("mousePitch", c22, ["mouseRotate"]);
          const h22 = new Ha2(e22), u22 = new Xa2(t22, e22);
          t22.dragPan = new pn(i2, h22, u22), this._add("mousePan", h22), this._add("touchPan", u22, ["touchZoom", "touchRotate"]);
          const d22 = new tn(), _2 = new Qa2();
          t22.touchZoomRotate = new fn(i2, _2, d22, a2), this._add("touchRotate", d22, ["touchPan", "touchZoom"]), this._add("touchZoom", _2, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new Ba2(t22));
          const p22 = t22.scrollZoom = new hn(t22, this);
          this._add("scrollZoom", p22, ["mousePan"]);
          const m22 = t22.keyboard = new an();
          this._add("keyboard", m22);
          for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
            e22.interactive && e22[i3] && t22[i3].enable(e22[i3]);
        }
        _add(e22, t22, i2) {
          this._handlers.push({ handlerName: e22, handler: t22, allowed: i2 }), this._handlersById[e22] = t22;
        }
        stop(e22) {
          if (!this._updatingCamera) {
            for (const { handler: e3 } of this._handlers)
              e3.reset();
            this._inertia.clear(), this._fireEvents({}, {}, e22), this._changes = [], this._originalZoom = void 0;
          }
        }
        isActive() {
          for (const { handler: e22 } of this._handlers)
            if (e22.isActive())
              return true;
          return false;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!gn(this._eventsInProgress) || this.isZooming();
        }
        _isDragging() {
          return !!this._eventsInProgress.drag;
        }
        _blockedByActive(e22, t22, i2) {
          for (const o2 in e22)
            if (o2 !== i2 && (!t22 || t22.indexOf(o2) < 0))
              return true;
          return false;
        }
        handleWindowEvent(e22) {
          this.handleEvent(e22, "".concat(e22.type, "Window"));
        }
        _getMapTouches(e22) {
          const t22 = [];
          for (const i2 of e22)
            this._el.contains(i2.target) && t22.push(i2);
          return t22;
        }
        handleEvent(e22, t22) {
          this._updatingCamera = true;
          const i2 = "renderFrame" === e22.type, o2 = i2 ? void 0 : e22, r22 = { needsRenderFrame: false }, s2 = {}, a2 = {}, n22 = e22.touches ? this._getMapTouches(e22.touches) : void 0, l22 = n22 ? v2(this._el, n22) : i2 ? void 0 : g2(this._el, e22);
          for (const { handlerName: i3, handler: c3, allowed: h3 } of this._handlers) {
            if (!c3.isEnabled())
              continue;
            let u22;
            this._blockedByActive(a2, h3, i3) ? c3.reset() : c3[t22 || e22.type] && (u22 = c3[t22 || e22.type](e22, l22, n22), this.mergeHandlerResult(r22, s2, u22, i3, o2), u22 && u22.needsRenderFrame && this._triggerRenderFrame()), (u22 || c3.isActive()) && (a2[i3] = c3);
          }
          const c22 = {};
          for (const e3 in this._previousActiveHandlers)
            a2[e3] || (c22[e3] = o2);
          this._previousActiveHandlers = a2, (Object.keys(c22).length || yn(r22)) && (this._changes.push([r22, s2, c22]), this._triggerRenderFrame()), (Object.keys(a2).length || yn(r22)) && this._map._stop(true), this._updatingCamera = false;
          const { cameraAnimation: h22 } = r22;
          h22 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h22(this._map));
        }
        mergeHandlerResult(t22, i2, o2, r22, s2) {
          if (!o2)
            return;
          e2.l(t22, o2);
          const a2 = { handlerName: r22, originalEvent: o2.originalEvent || s2 };
          void 0 !== o2.zoomDelta && (i2.zoom = a2), void 0 !== o2.panDelta && (i2.drag = a2), void 0 !== o2.pitchDelta && (i2.pitch = a2), void 0 !== o2.bearingDelta && (i2.rotate = a2);
        }
        _applyChanges() {
          const t22 = {}, i2 = {}, o2 = {};
          for (const [r22, s2, a2] of this._changes)
            r22.panDelta && (t22.panDelta = (t22.panDelta || new e2.P(0, 0))._add(r22.panDelta)), r22.zoomDelta && (t22.zoomDelta = (t22.zoomDelta || 0) + r22.zoomDelta), r22.bearingDelta && (t22.bearingDelta = (t22.bearingDelta || 0) + r22.bearingDelta), r22.pitchDelta && (t22.pitchDelta = (t22.pitchDelta || 0) + r22.pitchDelta), void 0 !== r22.around && (t22.around = r22.around), void 0 !== r22.aroundCoord && (t22.aroundCoord = r22.aroundCoord), void 0 !== r22.pinchAround && (t22.pinchAround = r22.pinchAround), r22.noInertia && (t22.noInertia = r22.noInertia), e2.l(i2, s2), e2.l(o2, a2);
          this._updateMapTransform(t22, i2, o2), this._changes = [];
        }
        _updateMapTransform(t22, i2, o2) {
          const r22 = this._map, s2 = r22.transform, a2 = (e22) => [e22.x, e22.y, e22.z];
          if (((e22) => {
            const t3 = this._eventsInProgress.drag;
            return t3 && !this._handlersById[t3.handlerName].isActive();
          })() && !yn(t22)) {
            const e22 = s2.zoom;
            s2.cameraElevationReference = "sea", null != this._originalZoom && s2._orthographicProjectionAtLowPitch && "globe" !== s2.projection.name && 0 === s2.pitch ? (s2.cameraElevationReference = "ground", s2.zoom = this._originalZoom) : (s2.recenterOnTerrain(), s2.cameraElevationReference = "ground"), e22 !== s2.zoom && this._map._update(true);
          }
          if (s2._isCameraConstrained && r22._stop(true), !yn(t22))
            return void this._fireEvents(i2, o2, true);
          let { panDelta: n22, zoomDelta: l22, bearingDelta: c22, pitchDelta: h22, around: u22, aroundCoord: d22, pinchAround: _2 } = t22;
          s2._isCameraConstrained && (l22 > 0 && (l22 = 0), s2._isCameraConstrained = false), void 0 !== _2 && (u22 = _2), (l22 || ((e22) => i2[e22] && !this._eventsInProgress[e22])("drag")) && u22 && (this._dragOrigin = a2(s2.pointCoordinate3D(u22)), this._originalZoom = s2.zoom, this._trackingEllipsoid.setup(s2._camera.position, this._dragOrigin)), s2.cameraElevationReference = "sea", r22._stop(true), u22 = u22 || r22.transform.centerPoint, c22 && (s2.bearing += c22), h22 && (s2.pitch += h22), s2._updateCameraState();
          const p22 = [0, 0, 0];
          if (n22)
            if ("mercator" === s2.projection.name) {
              const e22 = this._trackingEllipsoid.projectRay(s2.screenPointToMercatorRay(u22).dir), t3 = this._trackingEllipsoid.projectRay(s2.screenPointToMercatorRay(u22.sub(n22)).dir);
              p22[0] = t3[0] - e22[0], p22[1] = t3[1] - e22[1];
            } else {
              const t3 = s2.pointCoordinate(u22);
              if ("globe" === s2.projection.name) {
                n22 = n22.rotate(-s2.angle);
                const i3 = s2._pixelsPerMercatorPixel / s2.worldSize;
                p22[0] = -n22.x * e2.ds(e2.aM(t3.y)) * i3, p22[1] = -n22.y * e2.ds(s2.center.lat) * i3;
              } else {
                const e22 = s2.pointCoordinate(u22.sub(n22));
                t3 && e22 && (p22[0] = e22.x - t3.x, p22[1] = e22.y - t3.y);
              }
            }
          const m22 = s2.zoom, f22 = [0, 0, 0];
          if (l22) {
            const t3 = a2(d22 || s2.pointCoordinate3D(u22)), i3 = { dir: e2.a6.vec3.normalize([], e2.a6.vec3.sub([], t3, s2._camera.position)) };
            if (i3.dir[2] < 0) {
              const o3 = s2.zoomDeltaToMovement(t3, l22);
              e2.a6.vec3.scale(f22, i3.dir, o3);
            }
          }
          const g22 = e2.a6.vec3.add(p22, p22, f22);
          s2._translateCameraConstrained(g22), l22 && Math.abs(s2.zoom - m22) > 1e-4 && s2.recenterOnTerrain(), s2.cameraElevationReference = "ground", this._map._update(), t22.noInertia || this._inertia.record(t22), this._fireEvents(i2, o2, true);
        }
        _fireEvents(t22, i2, o2) {
          const r22 = gn(this._eventsInProgress), s2 = gn(t22), a2 = {};
          for (const e22 in t22) {
            const { originalEvent: i3 } = t22[e22];
            this._eventsInProgress[e22] || (a2["".concat(e22, "start")] = i3), this._eventsInProgress[e22] = t22[e22];
          }
          !r22 && s2 && this._fireEvent("movestart", s2.originalEvent);
          for (const e22 in a2)
            this._fireEvent(e22, a2[e22]);
          s2 && this._fireEvent("move", s2.originalEvent);
          for (const e22 in t22) {
            const { originalEvent: i3 } = t22[e22];
            this._fireEvent(e22, i3);
          }
          const n22 = {};
          let l22;
          for (const e22 in this._eventsInProgress) {
            const { handlerName: t3, originalEvent: o3 } = this._eventsInProgress[e22];
            this._handlersById[t3].isActive() || (delete this._eventsInProgress[e22], l22 = i2[t3] || o3, n22["".concat(e22, "end")] = l22);
          }
          for (const e22 in n22)
            this._fireEvent(e22, n22[e22]);
          const c22 = gn(this._eventsInProgress);
          if (o2 && (r22 || s2) && !c22) {
            this._updatingCamera = true;
            const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e22) => 0 !== e22 && -this._bearingSnap < e22 && e22 < this._bearingSnap;
            t3 ? (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), this._map.easeTo(t3, { originalEvent: l22 })) : (this._map.fire(new e2.x("moveend", { originalEvent: l22 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
          }
        }
        _fireEvent(t22, i2) {
          this._map.fire(new e2.x(t22, i2 ? { originalEvent: i2 } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e22) => {
            this._frameId = void 0, this.handleEvent(new vn("renderFrame", { timeStamp: e22 })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          void 0 === this._frameId && (this._frameId = this._requestFrame());
        }
      }
      const wn = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
      class Tn extends e2.E {
        constructor(t22, i2) {
          super(), this._moving = false, this._zooming = false, this.transform = t22, this._bearingSnap = i2.bearingSnap, this._respectPrefersReducedMotion = false !== i2.respectPrefersReducedMotion, e2.aJ(["_renderFrameCallback"], this);
        }
        getCenter() {
          return new e2.bK(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(e22, t22) {
          return this.jumpTo({ center: e22 }, t22);
        }
        panBy(t22, i2, o2) {
          return t22 = e2.P.convert(t22).mult(-1), this.panTo(this.transform.center, e2.l({ offset: t22 }, i2), o2);
        }
        panTo(t22, i2, o2) {
          return this.easeTo(e2.l({ center: t22 }, i2), o2);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(e22, t22) {
          return this.jumpTo({ zoom: e22 }, t22), this;
        }
        zoomTo(t22, i2, o2) {
          return this.easeTo(e2.l({ zoom: t22 }, i2), o2);
        }
        zoomIn(e22, t22) {
          return this.zoomTo(this.getZoom() + 1, e22, t22), this;
        }
        zoomOut(e22, t22) {
          return this.zoomTo(this.getZoom() - 1, e22, t22), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(e22, t22) {
          return this.jumpTo({ bearing: e22 }, t22), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(e22, t22) {
          return this.jumpTo({ padding: e22 }, t22), this;
        }
        rotateTo(t22, i2, o2) {
          return this.easeTo(e2.l({ bearing: t22 }, i2), o2);
        }
        resetNorth(t22, i2) {
          return this.rotateTo(0, e2.l({ duration: 1e3 }, t22), i2), this;
        }
        resetNorthPitch(t22, i2) {
          return this.easeTo(e2.l({ bearing: 0, pitch: 0, duration: 1e3 }, t22), i2), this;
        }
        snapToNorth(e22, t22) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e22, t22) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(e22, t22) {
          return this.jumpTo({ pitch: e22 }, t22), this;
        }
        cameraForBounds(t22, i2) {
          t22 = e2.as.convert(t22);
          const o2 = i2 && i2.bearing || 0, r22 = i2 && i2.pitch || 0, s2 = t22.getNorthWest(), a2 = t22.getSouthEast();
          return this._cameraForBounds(this.transform, s2, a2, o2, r22, i2);
        }
        _extendPadding(t22) {
          const i2 = { top: 0, right: 0, bottom: 0, left: 0 };
          return null == t22 ? e2.l({}, i2, this.transform.padding) : "number" == typeof t22 ? { top: t22, bottom: t22, right: t22, left: t22 } : e2.l({}, i2, t22);
        }
        _extendCameraOptions(t22) {
          return (t22 = e2.l({ offset: [0, 0], maxZoom: this.transform.maxZoom }, t22)).padding = this._extendPadding(t22.padding), t22;
        }
        _minimumAABBFrustumDistance(e22, t22) {
          const i2 = t22.max[0] - t22.min[0], o2 = t22.max[1] - t22.min[1];
          return i2 / o2 > e22.aspect ? i2 / (2 * Math.tan(0.5 * e22.fovX) * e22.aspect) : o2 / (2 * Math.tan(0.5 * e22.fovY) * e22.aspect);
        }
        _cameraForBoundsOnGlobe(t22, i2, o2, r22, s2, a2) {
          const n22 = t22.clone(), l22 = this._extendCameraOptions(a2);
          n22.bearing = r22, n22.pitch = s2;
          const c22 = e2.bK.convert(i2), h22 = e2.bK.convert(o2), u22 = 0.5 * (c22.lat + h22.lat), d22 = 0.5 * (c22.lng + h22.lng), _2 = e2.dt(u22, d22), p22 = e2.a6.vec3.normalize([], _2), m22 = e2.a6.vec3.normalize([], e2.a6.vec3.cross([], p22, [0, 1, 0])), f22 = e2.a6.vec3.cross([], m22, p22), g22 = [m22[0], m22[1], m22[2], 0, f22[0], f22[1], f22[2], 0, p22[0], p22[1], p22[2], 0, 0, 0, 0, 1], v22 = [_2, e2.dt(c22.lat, c22.lng), e2.dt(h22.lat, c22.lng), e2.dt(h22.lat, h22.lng), e2.dt(c22.lat, h22.lng), e2.dt(u22, c22.lng), e2.dt(u22, h22.lng), e2.dt(c22.lat, d22), e2.dt(h22.lat, d22)];
          let x22 = e2.c9.fromPoints(v22.map((t3) => [e2.a6.vec3.dot(m22, t3), e2.a6.vec3.dot(f22, t3), e2.a6.vec3.dot(p22, t3)]));
          const y22 = e2.a6.vec3.transformMat4([], x22.center, g22);
          0 === e2.a6.vec3.squaredLength(y22) && e2.a6.vec3.set(y22, 0, 0, 1), e2.a6.vec3.normalize(y22, y22), e2.a6.vec3.scale(y22, y22, e2.aq), n22.center = e2.du(y22);
          const b22 = n22.getWorldToCameraMatrix(), w22 = e2.a6.mat4.invert(new Float64Array(16), b22);
          x22 = e2.c9.applyTransform(x22, e2.a6.mat4.multiply([], b22, g22));
          const T22 = this._extendAABB(x22, n22, l22, r22);
          if (!T22)
            return void e2.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          x22 = T22, e2.a6.vec3.transformMat4(y22, y22, b22);
          const E22 = 0.5 * (x22.max[2] - x22.min[2]), C22 = this._minimumAABBFrustumDistance(n22, x22), S22 = e2.a6.vec3.scale([], [0, 0, 1], E22), I22 = e2.a6.vec3.add(S22, y22, S22), D22 = C22 + (0 === n22.pitch ? 0 : e2.a6.vec3.distance(y22, I22)), R22 = n22.globeCenterInViewSpace, A22 = e2.a6.vec3.sub([], y22, [R22[0], R22[1], R22[2]]);
          e2.a6.vec3.normalize(A22, A22), e2.a6.vec3.scale(A22, A22, D22);
          const L22 = e2.a6.vec3.add([], y22, A22);
          e2.a6.vec3.transformMat4(L22, L22, w22);
          const P22 = e2.dw / e2.aq, M22 = e2.a6.vec3.length(L22), z22 = e2.bD(Math.max(M22 * P22 - e2.dw, Number.EPSILON), 0), O22 = Math.min(n22.zoomFromMercatorZAdjusted(z22), l22.maxZoom);
          return O22 > 0.5 * (e2.c2 + e2.bU) ? (n22.setProjection({ name: "mercator" }), n22.zoom = O22, this._cameraForBounds(n22, i2, o2, r22, s2, a2)) : { center: n22.center, zoom: O22, bearing: r22, pitch: s2 };
        }
        _extendAABB(t22, i2, o2, r22) {
          const s2 = 0.5 * ((o2.padding.left || 0) + (o2.padding.right || 0)), a2 = 0.5 * ((o2.padding.top || 0) + (o2.padding.bottom || 0)), n22 = a2, l22 = s2, c22 = s2, h22 = a2, u22 = i2.width - (l22 + c22), d22 = i2.height - (n22 + h22), _2 = e2.a6.vec3.sub([], t22.max, t22.min), p22 = Math.min(u22 / _2[0], d22 / _2[1]), m22 = Math.min(i2.scaleZoom(i2.scale * p22), o2.maxZoom);
          if (isNaN(m22))
            return null;
          const f22 = i2.scale / i2.zoomScale(m22), g22 = new e2.c9([t22.min[0] - l22 * f22, t22.min[1] - h22 * f22, t22.min[2]], [t22.max[0] + c22 * f22, t22.max[1] + n22 * f22, t22.max[2]]), v22 = ("number" == typeof o2.offset.x && "number" == typeof o2.offset.y ? new e2.P(o2.offset.x, o2.offset.y) : e2.P.convert(o2.offset)).rotate(-e2.bB(r22));
          return g22.center[0] -= v22.x * f22, g22.center[1] += v22.y * f22, g22;
        }
        queryTerrainElevation(t22, i2) {
          const o2 = this.transform.elevation;
          return o2 ? (i2 = e2.l({}, { exaggerated: true }, i2), o2.getAtPoint(e2.a5.fromLngLat(t22), null, i2.exaggerated)) : null;
        }
        _cameraForBounds(t22, i2, o2, r22, s2, a2) {
          if ("globe" === t22.projection.name)
            return this._cameraForBoundsOnGlobe(t22, i2, o2, r22, s2, a2);
          const n22 = t22.clone(), l22 = this._extendCameraOptions(a2);
          n22.bearing = r22, n22.pitch = s2;
          const c22 = e2.bK.convert(i2), h22 = e2.bK.convert(o2), u22 = new e2.bK(c22.lng, h22.lat), d22 = new e2.bK(h22.lng, c22.lat), _2 = n22.project(c22), p22 = n22.project(h22), m22 = this.queryTerrainElevation(c22), f22 = this.queryTerrainElevation(h22), g22 = this.queryTerrainElevation(u22), v22 = this.queryTerrainElevation(d22), x22 = [[_2.x, _2.y, Math.min(m22 || 0, f22 || 0, g22 || 0, v22 || 0)], [p22.x, p22.y, Math.max(m22 || 0, f22 || 0, g22 || 0, v22 || 0)]];
          let y22 = e2.c9.fromPoints(x22);
          const b22 = n22.getWorldToCameraMatrix(), w22 = e2.a6.mat4.invert(new Float64Array(16), b22);
          y22 = e2.c9.applyTransform(y22, b22);
          const T22 = this._extendAABB(y22, n22, l22, r22);
          if (!T22)
            return void e2.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          y22 = T22;
          const E22 = 0.5 * e2.a6.vec3.sub([], y22.max, y22.min)[2], C22 = this._minimumAABBFrustumDistance(n22, y22), S22 = [0, 0, 1, 0];
          e2.a6.vec4.transformMat4(S22, S22, b22), e2.a6.vec4.normalize(S22, S22);
          const I22 = e2.a6.vec3.scale([], S22, C22 + E22), D22 = e2.a6.vec3.add([], y22.center, I22);
          e2.a6.vec3.transformMat4(y22.center, y22.center, w22), e2.a6.vec3.transformMat4(D22, D22, w22);
          const R22 = n22.unproject(new e2.P(y22.center[0], y22.center[1])), A22 = e2.dv(n22.projection, R22), L22 = Math.pow(2, A22), P22 = Math.min(n22._zoomFromMercatorZ(D22[2] * n22.pixelsPerMeter * L22 / n22.worldSize), l22.maxZoom);
          return n22.mercatorFromTransition && P22 < 0.5 * (e2.c2 + e2.bU) ? (n22.setProjection({ name: "globe" }), n22.zoom = P22, this._cameraForBounds(n22, i2, o2, r22, s2, a2)) : { center: R22, zoom: P22, bearing: r22, pitch: s2 };
        }
        fitBounds(e22, t22, i2) {
          const o2 = this.cameraForBounds(e22, t22);
          return this._fitInternal(o2, t22, i2);
        }
        fitScreenCoordinates(t22, i2, o2, r22, s2) {
          const a2 = e2.P.convert(t22), n22 = e2.P.convert(i2), l22 = new e2.P(Math.min(a2.x, n22.x), Math.min(a2.y, n22.y)), c22 = new e2.P(Math.max(a2.x, n22.x), Math.max(a2.y, n22.y));
          if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(a2, n22))
            return this;
          const h22 = this.transform.pointLocation3D(l22), u22 = this.transform.pointLocation3D(c22), d22 = this.transform.pointLocation3D(new e2.P(l22.x, c22.y)), _2 = this.transform.pointLocation3D(new e2.P(c22.x, l22.y)), p22 = [Math.min(h22.lng, u22.lng, d22.lng, _2.lng), Math.min(h22.lat, u22.lat, d22.lat, _2.lat)], m22 = [Math.max(h22.lng, u22.lng, d22.lng, _2.lng), Math.max(h22.lat, u22.lat, d22.lat, _2.lat)], f22 = r22 && r22.pitch ? r22.pitch : this.getPitch(), g22 = this._cameraForBounds(this.transform, p22, m22, o2, f22, r22);
          return this._fitInternal(g22, r22, s2);
        }
        _fitInternal(t22, i2, o2) {
          return t22 ? (i2 = e2.l(t22, i2)).linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2) : this;
        }
        jumpTo(t22, i2) {
          this.stop();
          const o2 = t22.preloadOnly ? this.transform.clone() : this.transform;
          let r22 = false, s2 = false, a2 = false;
          "zoom" in t22 && o2.zoom !== +t22.zoom && (r22 = true, o2.zoom = +t22.zoom), void 0 !== t22.center && (o2.center = e2.bK.convert(t22.center)), "bearing" in t22 && o2.bearing !== +t22.bearing && (s2 = true, o2.bearing = +t22.bearing), "pitch" in t22 && o2.pitch !== +t22.pitch && (a2 = true, o2.pitch = +t22.pitch);
          const n22 = "number" == typeof t22.padding ? this._extendPadding(t22.padding) : t22.padding;
          if (null != t22.padding && !o2.isPaddingEqual(n22))
            if (false === t22.retainPadding) {
              const e22 = o2.clone();
              e22.padding = n22, o2.setLocationAtPoint(o2.center, e22.centerPoint);
            } else
              o2.padding = n22;
          return t22.preloadOnly ? (this._preloadTiles(o2), this) : (this.fire(new e2.x("movestart", i2)).fire(new e2.x("move", i2)), r22 && this.fire(new e2.x("zoomstart", i2)).fire(new e2.x("zoom", i2)).fire(new e2.x("zoomend", i2)), s2 && this.fire(new e2.x("rotatestart", i2)).fire(new e2.x("rotate", i2)).fire(new e2.x("rotateend", i2)), a2 && this.fire(new e2.x("pitchstart", i2)).fire(new e2.x("pitch", i2)).fire(new e2.x("pitchend", i2)), this.fire(new e2.x("moveend", i2)));
        }
        getFreeCameraOptions() {
          return this.transform.projection.supportsFreeCamera || e2.w(wn), this.transform.getFreeCameraOptions();
        }
        setFreeCameraOptions(t22, i2) {
          const o2 = this.transform;
          if (!o2.projection.supportsFreeCamera)
            return e2.w(wn), this;
          this.stop();
          const r22 = o2.zoom, s2 = o2.pitch, a2 = o2.bearing;
          o2.setFreeCameraOptions(t22);
          const n22 = r22 !== o2.zoom, l22 = s2 !== o2.pitch, c22 = a2 !== o2.bearing;
          return this.fire(new e2.x("movestart", i2)).fire(new e2.x("move", i2)), n22 && this.fire(new e2.x("zoomstart", i2)).fire(new e2.x("zoom", i2)).fire(new e2.x("zoomend", i2)), c22 && this.fire(new e2.x("rotatestart", i2)).fire(new e2.x("rotate", i2)).fire(new e2.x("rotateend", i2)), l22 && this.fire(new e2.x("pitchstart", i2)).fire(new e2.x("pitch", i2)).fire(new e2.x("pitchend", i2)), this.fire(new e2.x("moveend", i2)), this;
        }
        easeTo(t22, i2) {
          this._stop(false, t22.easeId), (false === (t22 = e2.l({ offset: [0, 0], duration: 500, easing: e2.dr }, t22)).animate || this._prefersReducedMotion(t22)) && (t22.duration = 0);
          const o2 = this.transform, r22 = this.getZoom(), s2 = this.getBearing(), a2 = this.getPitch(), n22 = this.getPadding(), l22 = "zoom" in t22 ? +t22.zoom : r22, c22 = "bearing" in t22 ? this._normalizeBearing(t22.bearing, s2) : s2, h22 = "pitch" in t22 ? +t22.pitch : a2, u22 = this._extendPadding(t22.padding), d22 = e2.P.convert(t22.offset);
          let _2, p22, m22;
          if ("globe" === o2.projection.name) {
            const i3 = e2.a5.fromLngLat(o2.center), r3 = d22.rotate(-o2.angle);
            i3.x += r3.x / o2.worldSize, i3.y += r3.y / o2.worldSize;
            const s3 = i3.toLngLat(), a3 = e2.bK.convert(t22.center || s3);
            this._normalizeCenter(a3), _2 = o2.centerPoint.add(r3), p22 = new e2.P(i3.x, i3.y).mult(o2.worldSize), m22 = new e2.P(e2.am(a3.lng), e2.at(a3.lat)).mult(o2.worldSize).sub(p22);
          } else {
            _2 = o2.centerPoint.add(d22);
            const i3 = o2.pointLocation(_2), r3 = e2.bK.convert(t22.center || i3);
            this._normalizeCenter(r3), p22 = o2.project(i3), m22 = o2.project(r3).sub(p22);
          }
          const f22 = o2.zoomScale(l22 - r22);
          let g22, v22;
          t22.around && (g22 = e2.bK.convert(t22.around), v22 = o2.locationPoint(g22));
          const x22 = this._zooming || l22 !== r22, y22 = this._rotating || s2 !== c22, b22 = this._pitching || h22 !== a2, w22 = !o2.isPaddingEqual(u22), T22 = false === t22.retainPadding ? o2.clone() : o2, E22 = (o3) => (E3) => {
            if (x22 && (o3.zoom = e2.aa(r22, l22, E3)), y22 && (o3.bearing = e2.aa(s2, c22, E3)), b22 && (o3.pitch = e2.aa(a2, h22, E3)), w22 && (T22.interpolatePadding(n22, u22, E3), _2 = T22.centerPoint.add(d22)), g22)
              o3.setLocationAtPoint(g22, v22);
            else {
              const e22 = o3.zoomScale(o3.zoom - r22), t3 = l22 > r22 ? Math.min(2, f22) : Math.max(0.5, f22), i3 = Math.pow(t3, 1 - E3), s3 = o3.unproject(p22.add(m22.mult(E3 * i3)).mult(e22));
              o3.setLocationAtPoint(o3.renderWorldCopies ? s3.wrap() : s3, _2);
            }
            return t22.preloadOnly || this._fireMoveEvents(i2), o3;
          };
          if (t22.preloadOnly) {
            const e22 = this._emulate(E22, t22.duration, o2);
            return this._preloadTiles(e22), this;
          }
          const C22 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = x22, this._rotating = y22, this._pitching = b22, this._padding = w22, this._easeId = t22.easeId, this._prepareEase(i2, t22.noMoveStart, C22), this._ease(E22(o2), (e22) => {
            "sea" === o2.cameraElevationReference && o2.recenterOnTerrain(), this._afterEase(i2, e22);
          }, t22), this;
        }
        _prepareEase(t22, i2, o2 = {}) {
          this._moving = true, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"), i2 || o2.moving || this.fire(new e2.x("movestart", t22)), this._zooming && !o2.zooming && this.fire(new e2.x("zoomstart", t22)), this._rotating && !o2.rotating && this.fire(new e2.x("rotatestart", t22)), this._pitching && !o2.pitching && this.fire(new e2.x("pitchstart", t22));
        }
        _fireMoveEvents(t22) {
          this.fire(new e2.x("move", t22)), this._zooming && this.fire(new e2.x("zoom", t22)), this._rotating && this.fire(new e2.x("rotate", t22)), this._pitching && this.fire(new e2.x("pitch", t22));
        }
        _afterEase(t22, i2) {
          if (this._easeId && i2 && this._easeId === i2)
            return;
          this._easeId = void 0, this.transform.cameraElevationReference = "ground";
          const o2 = this._zooming, r22 = this._rotating, s2 = this._pitching;
          this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new e2.x("zoomend", t22)), r22 && this.fire(new e2.x("rotateend", t22)), s2 && this.fire(new e2.x("pitchend", t22)), this.fire(new e2.x("moveend", t22));
        }
        flyTo(t22, i2) {
          if (this._prefersReducedMotion(t22)) {
            const o3 = e2.ar(t22, ["center", "zoom", "bearing", "pitch", "around", "padding", "retainPadding"]);
            return this.jumpTo(o3, i2);
          }
          this.stop(), t22 = e2.l({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e2.dr }, t22);
          const o2 = this.transform, r22 = this.getZoom(), s2 = this.getBearing(), a2 = this.getPitch(), n22 = this.getPadding(), l22 = "zoom" in t22 ? e2.ap(+t22.zoom, o2.minZoom, o2.maxZoom) : r22, c22 = "bearing" in t22 ? this._normalizeBearing(t22.bearing, s2) : s2, h22 = "pitch" in t22 ? +t22.pitch : a2, u22 = this._extendPadding(t22.padding), d22 = o2.zoomScale(l22 - r22), _2 = e2.P.convert(t22.offset);
          let p22 = o2.centerPoint.add(_2);
          const m22 = o2.pointLocation(p22), f22 = e2.bK.convert(t22.center || m22);
          this._normalizeCenter(f22);
          const g22 = o2.project(m22), v22 = o2.project(f22).sub(g22);
          let x22 = t22.curve;
          const y22 = Math.max(o2.width, o2.height), b22 = y22 / d22, w22 = v22.mag();
          if ("minZoom" in t22) {
            const i3 = e2.ap(Math.min(t22.minZoom, r22, l22), o2.minZoom, o2.maxZoom), s3 = y22 / o2.zoomScale(i3 - r22);
            x22 = Math.sqrt(s3 / w22 * 2);
          }
          const T22 = x22 * x22;
          function E22(e22) {
            const t3 = (b22 * b22 - y22 * y22 + (e22 ? -1 : 1) * T22 * T22 * w22 * w22) / (2 * (e22 ? b22 : y22) * T22 * w22);
            return Math.log(Math.sqrt(t3 * t3 + 1) - t3);
          }
          function C22(e22) {
            return (Math.exp(e22) - Math.exp(-e22)) / 2;
          }
          function S22(e22) {
            return (Math.exp(e22) + Math.exp(-e22)) / 2;
          }
          const I22 = E22(0);
          let D22 = function(e22) {
            return S22(I22) / S22(I22 + x22 * e22);
          }, R22 = function(e22) {
            return y22 * ((S22(I22) * (C22(t3 = I22 + x22 * e22) / S22(t3)) - C22(I22)) / T22) / w22;
            var t3;
          }, A22 = (E22(1) - I22) / x22;
          if (Math.abs(w22) < 1e-6 || !isFinite(A22)) {
            if (Math.abs(y22 - b22) < 1e-6)
              return this.easeTo(t22, i2);
            const e22 = b22 < y22 ? -1 : 1;
            A22 = Math.abs(Math.log(b22 / y22)) / x22, R22 = function() {
              return 0;
            }, D22 = function(t3) {
              return Math.exp(e22 * x22 * t3);
            };
          }
          t22.duration = "duration" in t22 ? +t22.duration : 1e3 * A22 / ("screenSpeed" in t22 ? +t22.screenSpeed / x22 : +t22.speed), t22.maxDuration && t22.duration > t22.maxDuration && (t22.duration = 0);
          const L22 = s2 !== c22, P22 = h22 !== a2, M22 = !o2.isPaddingEqual(u22), z22 = false === t22.retainPadding ? o2.clone() : o2, O22 = (o3) => (d3) => {
            const m3 = d3 * A22, x3 = 1 / D22(m3);
            o3.zoom = 1 === d3 ? l22 : r22 + o3.scaleZoom(x3), L22 && (o3.bearing = e2.aa(s2, c22, d3)), P22 && (o3.pitch = e2.aa(a2, h22, d3)), M22 && (z22.interpolatePadding(n22, u22, d3), p22 = z22.centerPoint.add(_2));
            const y3 = 1 === d3 ? f22 : o3.unproject(g22.add(v22.mult(R22(m3))).mult(x3));
            return o3.setLocationAtPoint(o3.renderWorldCopies ? y3.wrap() : y3, p22), o3._updateCameraOnTerrain(), t22.preloadOnly || this._fireMoveEvents(i2), o3;
          };
          if (t22.preloadOnly) {
            const e22 = this._emulate(O22, t22.duration, o2);
            return this._preloadTiles(e22), this;
          }
          return this._zooming = true, this._rotating = L22, this._pitching = P22, this._padding = M22, this._prepareEase(i2, false), this._ease(O22(o2), () => this._afterEase(i2), t22), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _requestRenderFrame(e22) {
        }
        _cancelRenderFrame(e22) {
        }
        _stop(e22, t22) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
            const e3 = this._onEaseEnd;
            this._onEaseEnd = void 0, e3.call(this, t22);
          }
          if (!e22) {
            const e3 = this.handlers;
            e3 && e3.stop(false);
          }
          return this;
        }
        _ease(t22, i2, o2) {
          false === o2.animate || 0 === o2.duration ? (t22(1), i2()) : (this._easeStart = e2.q.now(), this._easeOptions = o2, this._onEaseFrame = t22, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _renderFrameCallback() {
          const t22 = Math.min((e2.q.now() - this._easeStart) / this._easeOptions.duration, 1), i2 = this._onEaseFrame;
          i2 && i2(this._easeOptions.easing(t22)), t22 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }
        _normalizeBearing(t22, i2) {
          t22 = e2.bA(t22, -180, 180);
          const o2 = Math.abs(t22 - i2);
          return Math.abs(t22 - 360 - i2) < o2 && (t22 -= 360), Math.abs(t22 + 360 - i2) < o2 && (t22 += 360), t22;
        }
        _normalizeCenter(e22) {
          const t22 = this.transform;
          if (t22.maxBounds)
            return;
          if ("globe" !== t22.projection.name && !t22.renderWorldCopies)
            return;
          const i2 = e22.lng - t22.center.lng;
          e22.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
        }
        _prefersReducedMotion(t22) {
          return this._respectPrefersReducedMotion && e2.q.prefersReducedMotion && !(t22 && t22.essential);
        }
        _emulate(e22, t22, i2) {
          const o2 = Math.ceil(15 * t22 / 1e3), r22 = [], s2 = e22(i2.clone());
          for (let e3 = 0; e3 <= o2; e3++) {
            const t3 = s2(e3 / o2);
            r22.push(t3.clone());
          }
          return r22;
        }
        _preloadTiles(e22, t22) {
        }
      }
      class En {
        constructor(t22 = {}) {
          this.options = t22, e2.aJ(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(e22) {
          const t22 = this.options && this.options.compact, i2 = e22._getUIString("AttributionControl.ToggleAttribution");
          this._map = e22, this._container = l2("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = l2("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", i2);
          const o2 = l2("span", "mapboxgl-ctrl-icon", this._compactButton);
          return o2.setAttribute("aria-hidden", "true"), o2.setAttribute("title", i2), this._innerContainer = l2("div", "mapboxgl-ctrl-attrib-inner", this._container), t22 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t22 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
        }
        _toggleAttribution() {
          this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
        }
        _updateEditLink() {
          let t22 = this._editLink;
          t22 || (t22 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
          const i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e2.e.ACCESS_TOKEN }];
          if (t22) {
            const o2 = i2.reduce((e22, t3, o3) => (t3.value && (e22 += "".concat(t3.key, "=").concat(t3.value).concat(o3 < i2.length - 1 ? "&" : "")), e22), "?");
            t22.href = "".concat(e2.e.FEEDBACK_URL, "/").concat(o2, "#").concat(Ca2(this._map, true)), t22.rel = "noopener nofollow";
          }
        }
        _updateData(e22) {
          !e22 || "metadata" !== e22.sourceDataType && "visibility" !== e22.sourceDataType && "style" !== e22.dataType || (this._updateAttributions(), this._updateEditLink());
        }
        _updateAttributions() {
          if (!this._map.style)
            return;
          let e22 = [];
          if (this._map.style.stylesheet) {
            const e3 = this._map.style.stylesheet;
            this.styleOwner = e3.owner, this.styleId = e3.id;
          }
          const t22 = this._map.style._mergedSourceCaches;
          for (const i3 in t22) {
            const o2 = t22[i3];
            if (o2.used) {
              const t3 = o2.getSource();
              t3.attribution && e22.indexOf(t3.attribution) < 0 && e22.push(t3.attribution);
            }
          }
          e22.sort((e3, t3) => e3.length - t3.length), e22 = e22.filter((t3, i3) => {
            for (let o2 = i3 + 1; o2 < e22.length; o2++)
              if (e22[o2].indexOf(t3) >= 0)
                return false;
            return true;
          }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e22 = [...this.options.customAttribution, ...e22] : e22.unshift(this.options.customAttribution));
          const i2 = e22.join(" | ");
          i2 !== this._attribHTML && (this._attribHTML = i2, e22.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
        _updateCompact() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
        }
      }
      class Cn {
        constructor() {
          e2.aJ(["_updateLogo", "_updateCompact"], this);
        }
        onAdd(e22) {
          this._map = e22, this._container = l2("div", "mapboxgl-ctrl");
          const t22 = l2("a", "mapboxgl-ctrl-logo");
          return t22.target = "_blank", t22.rel = "noopener nofollow", t22.href = "https://www.mapbox.com/", t22.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t22.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t22), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _updateLogo(e22) {
          e22 && "metadata" !== e22.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
        }
        _logoRequired() {
          if (!this._map.style)
            return true;
          const e22 = this._map.style._sourceCaches;
          if (0 === Object.entries(e22).length)
            return true;
          for (const t22 in e22) {
            const i2 = e22[t22].getSource();
            if (i2.hasOwnProperty("mapbox_logo") && !i2.mapbox_logo)
              return false;
          }
          return true;
        }
        _updateCompact() {
          const e22 = this._container.children;
          if (e22.length) {
            const t22 = e22[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? t22.classList.add("mapboxgl-compact") : t22.classList.remove("mapboxgl-compact");
          }
        }
      }
      class Sn {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        }
        add(e22) {
          const t22 = ++this._id;
          return this._queue.push({ callback: e22, id: t22, cancelled: false }), t22;
        }
        remove(e22) {
          const t22 = this._currentlyRunning, i2 = t22 ? this._queue.concat(t22) : this._queue;
          for (const t3 of i2)
            if (t3.id === e22)
              return void (t3.cancelled = true);
        }
        run(e22 = 0) {
          const t22 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const i2 of t22)
            if (!i2.cancelled && (i2.callback(e22), this._cleared))
              break;
          this._cleared = false, this._currentlyRunning = false;
        }
        clear() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        }
      }
      class In {
        constructor(e22) {
          this.jumpTo(e22);
        }
        getValue(t22) {
          if (t22 <= this._startTime)
            return this._start;
          if (t22 >= this._endTime)
            return this._end;
          const i2 = e2.cw((t22 - this._startTime) / (this._endTime - this._startTime));
          return this._start * (1 - i2) + this._end * i2;
        }
        isEasing(e22) {
          return e22 >= this._startTime && e22 <= this._endTime;
        }
        jumpTo(e22) {
          this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e22, this._end = e22;
        }
        easeTo(e22, t22, i2) {
          this._start = this.getValue(t22), this._end = e22, this._startTime = t22, this._endTime = t22 + i2;
        }
      }
      const Dn = { "AttributionControl.ToggleAttribution": "Toggle attribution", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox homepage", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use ⌘ + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" };
      class Rn {
        registerParameter() {
        }
        registerButton() {
        }
        registerBinding() {
        }
        refreshUI() {
        }
      }
      class An {
        constructor(e22) {
          this.map = e22, this.interactionsByType = /* @__PURE__ */ new Map(), this.typeById = /* @__PURE__ */ new Map(), this.filters = /* @__PURE__ */ new Map(), this.handleType = this.handleType.bind(this);
        }
        add(t22, i2) {
          if (this.typeById.has(t22))
            throw new Error('Interaction id "'.concat(t22, '" already exists.'));
          const { type: o2, filter: r22 } = i2;
          if (r22) {
            const i3 = e2.M(r22, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
            if ("error" === i3.result)
              throw new Error(i3.value.map((e22) => "".concat(e22.key, ": ").concat(e22.message)).join(", "));
            this.filters.set(t22, i3.value);
          }
          const s2 = this.interactionsByType.get(o2) || /* @__PURE__ */ new Map();
          0 === s2.size && (this.map.on(o2, this.handleType), this.interactionsByType.set(o2, s2)), s2.set(t22, i2), this.typeById.set(t22, o2);
        }
        remove(e22) {
          const t22 = this.typeById.get(e22);
          if (!t22)
            return;
          this.typeById.delete(e22), this.filters.delete(e22);
          const i2 = this.interactionsByType.get(t22);
          i2 && (i2.delete(e22), 0 === i2.size && this.map.off(t22, this.handleType));
        }
        handleType(e22) {
          const t22 = e22.features || this.map.queryRenderedFeatures(e22.point);
          if (!t22)
            return;
          const i2 = this.interactionsByType.get(e22.type), o2 = { zoom: 0 };
          for (const [e3, r22] of i2) {
            const i3 = this.filters.get(e3), { handler: s2, layers: a2 } = r22;
            for (const n22 of t22)
              if ((!a2 || a2.includes(n22.layer.id)) && (!i3 || i3.evaluate(o2, n22)) && false !== s2({ id: e3, feature: n22, interaction: r22 }))
                break;
          }
        }
      }
      const Ln = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, antialias: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: true, crossSourceCollisions: true, collectResourceTiming: false, testMode: false, precompilePrograms: true }, Pn = { showCompass: true, showZoom: true, visualizePitch: false };
      class Mn {
        constructor(t22, i2, o2 = false) {
          this._clickTolerance = 10, this.element = i2, this.mouseRotate = new Wa2({ clickTolerance: t22.dragRotate._mouseRotate._clickTolerance }), this.map = t22, o2 && (this.mousePitch = new $a({ clickTolerance: t22.dragRotate._mousePitch._clickTolerance })), e2.aJ(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i2.addEventListener("mousedown", this.mousedown), i2.addEventListener("touchstart", this.touchstart, { passive: false }), i2.addEventListener("touchmove", this.touchmove), i2.addEventListener("touchend", this.touchend), i2.addEventListener("touchcancel", this.reset);
        }
        down(e22, t22) {
          this.mouseRotate.mousedown(e22, t22), this.mousePitch && this.mousePitch.mousedown(e22, t22), _();
        }
        move(e22, t22) {
          const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(e22, t22), r22 = o2 && o2.bearingDelta;
          if (r22 && i2.setBearing(i2.getBearing() + r22), this.mousePitch) {
            const o3 = this.mousePitch.mousemoveWindow(e22, t22), r3 = o3 && o3.pitchDelta;
            r3 && i2.setPitch(i2.getPitch() + r3);
          }
        }
        off() {
          const e22 = this.element;
          e22.removeEventListener("mousedown", this.mousedown), e22.removeEventListener("touchstart", this.touchstart, { passive: false }), e22.removeEventListener("touchmove", this.touchmove), e22.removeEventListener("touchend", this.touchend), e22.removeEventListener("touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          p2(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
        }
        mousedown(t22) {
          this.down(e2.l({}, t22, { ctrlKey: true, preventDefault: () => t22.preventDefault() }), g2(this.element, t22)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
        }
        mousemove(e22) {
          this.move(e22, g2(this.element, e22));
        }
        mouseup(e22) {
          this.mouseRotate.mouseupWindow(e22), this.mousePitch && this.mousePitch.mouseupWindow(e22), this.offTemp();
        }
        touchstart(e22) {
          1 !== e22.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = v2(this.element, e22.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e22.preventDefault() }, this._startPos));
        }
        touchmove(e22) {
          1 !== e22.targetTouches.length ? this.reset() : (this._lastPos = v2(this.element, e22.targetTouches)[0], this.move({ preventDefault: () => e22.preventDefault() }, this._lastPos));
        }
        touchend(e22) {
          0 === e22.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }
        reset() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        }
      }
      function zn(t22, i2, o2) {
        if (t22 = new e2.bK(t22.lng, t22.lat), i2) {
          const r22 = new e2.bK(t22.lng - 360, t22.lat), s2 = new e2.bK(t22.lng + 360, t22.lat), a2 = 360 * Math.ceil(Math.abs(t22.lng - o2.center.lng) / 360), n22 = o2.locationPoint(t22).distSqr(i2), l22 = i2.x < 0 || i2.y < 0 || i2.x > o2.width || i2.y > o2.height;
          o2.locationPoint(r22).distSqr(i2) < n22 && (l22 || Math.abs(r22.lng - o2.center.lng) < a2) ? t22 = r22 : o2.locationPoint(s2).distSqr(i2) < n22 && (l22 || Math.abs(s2.lng - o2.center.lng) < a2) && (t22 = s2);
        }
        for (; Math.abs(t22.lng - o2.center.lng) > 180; ) {
          const e22 = o2.locationPoint(t22);
          if (e22.x >= 0 && e22.y >= 0 && e22.x <= o2.width && e22.y <= o2.height)
            break;
          t22.lng > o2.center.lng ? t22.lng -= 360 : t22.lng += 360;
        }
        return t22;
      }
      const On = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      class Fn extends e2.E {
        constructor(t22, i2) {
          if (super(), (t22 instanceof HTMLElement || i2) && (t22 = e2.l({ element: t22 }, i2)), e2.aJ(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t22 && t22.anchor || "center", this._color = t22 && t22.color || "#3FB1CE", this._scale = t22 && t22.scale || 1, this._draggable = t22 && t22.draggable || false, this._clickTolerance = t22 && t22.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t22 && t22.rotation || 0, this._rotationAlignment = t22 && t22.rotationAlignment || "auto", this._pitchAlignment = t22 && t22.pitchAlignment && t22.pitchAlignment || "auto", this._updateMoving = () => this._update(true), this._occludedOpacity = t22 && t22.occludedOpacity || 0.2, t22 && t22.element)
            this._element = t22.element, this._offset = e2.P.convert(t22 && t22.offset || [0, 0]);
          else {
            this._defaultMarker = true, this._element = l2("div");
            const i3 = 41, o3 = 27, r3 = c2("svg", { display: "block", height: i3 * this._scale + "px", width: o3 * this._scale + "px", viewBox: "0 0 ".concat(o3, " ").concat(i3) }, this._element), s2 = c2("radialGradient", { id: "shadowGradient" }, c2("defs", {}, r3));
            c2("stop", { offset: "10%", "stop-opacity": 0.4 }, s2), c2("stop", { offset: "100%", "stop-opacity": 0.05 }, s2), c2("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r3), c2("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r3), c2("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r3), c2("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r3), this._offset = e2.P.convert(t22 && t22.offset || [0, -14]);
          }
          this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e22) => {
            e22.preventDefault();
          }), this._element.addEventListener("mousedown", (e22) => {
            e22.preventDefault();
          });
          const o2 = this._element.classList;
          for (const e22 in On)
            o2.remove("mapboxgl-marker-anchor-".concat(e22));
          o2.add("mapboxgl-marker-anchor-".concat(this._anchor));
          const r22 = t22 && t22.className ? t22.className.trim().split(/\s+/) : [];
          o2.add(...r22), this._popup = null;
        }
        addTo(e22) {
          return e22 === this._map || (this.remove(), this._map = e22, e22.getCanvasContainer().appendChild(this._element), e22.on("move", this._updateMoving), e22.on("moveend", this._update), e22.on("remove", this._clearFadeTimer), e22._addMarker(this), this.setDraggable(this._draggable), this._update(), e22.on("click", this._onMapClick)), this;
        }
        remove() {
          const e22 = this._map;
          return e22 && (e22.off("click", this._onMapClick), e22.off("move", this._updateMoving), e22.off("moveend", this._update), e22.off("mousedown", this._addDragHandler), e22.off("touchstart", this._addDragHandler), e22.off("mouseup", this._onUp), e22.off("touchend", this._onUp), e22.off("mousemove", this._onMove), e22.off("touchmove", this._onMove), e22.off("remove", this._clearFadeTimer), e22._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t22) {
          return this._lngLat = e2.bK.convert(t22), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(e22) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e22) {
            if (!("offset" in e22.options)) {
              const t22 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
              e22.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t22], "bottom-left": [o2, -1 * (t22 - i2 + o2)], "bottom-right": [-o2, -1 * (t22 - i2 + o2)], left: [i2, -1 * (t22 - i2)], right: [-i2, -1 * (t22 - i2)] } : this._offset;
            }
            this._popup = e22, e22._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
          }
          return this;
        }
        _onKeyPress(e22) {
          const t22 = e22.code, i2 = e22.charCode || e22.keyCode;
          "Space" !== t22 && "Enter" !== t22 && 32 !== i2 && 13 !== i2 || this.togglePopup();
        }
        _onMapClick(e22) {
          const t22 = e22.originalEvent.target, i2 = this._element;
          this._popup && (t22 === i2 || i2.contains(t22)) && this.togglePopup();
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const e22 = this._popup;
          return e22 ? (e22.isOpen() ? (e22.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e22.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
        }
        _behindTerrain() {
          const e22 = this._map, t22 = this._pos;
          if (!e22 || !t22)
            return false;
          const i2 = e22.unproject(t22), o2 = e22.getFreeCameraOptions();
          if (!o2.position)
            return false;
          const r22 = o2.position.toLngLat();
          return r22.distanceTo(i2) < 0.9 * r22.distanceTo(this._lngLat);
        }
        _evaluateOpacity() {
          const t22 = this._map;
          if (!t22)
            return;
          const i2 = this._pos;
          if (!i2 || i2.x < 0 || i2.x > t22.transform.width || i2.y < 0 || i2.y > t22.transform.height)
            return void this._clearFadeTimer();
          const o2 = t22.unproject(i2);
          let r22;
          t22._showingGlobe() && e2.dz(t22.transform, this._lngLat) ? r22 = 0 : (r22 = 1 - t22._queryFogOpacity(o2), t22.transform._terrainEnabled() && t22.getTerrain() && this._behindTerrain() && (r22 *= this._occludedOpacity)), this._element.style.opacity = "".concat(r22), this._element.style.pointerEvents = r22 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r22), this._fadeTimer = null;
        }
        _clearFadeTimer() {
          this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
        }
        _updateDOM() {
          const e22 = this._pos;
          if (!e22 || !this._map)
            return;
          const t22 = this._offset.mult(this._scale);
          this._element.style.transform = "\n            translate(".concat(e22.x, "px,").concat(e22.y, "px)\n            ").concat(On[this._anchor], "\n            ").concat(this._calculateXYTransform(), " ").concat(this._calculateZTransform(), "\n            translate(").concat(t22.x, "px,").concat(t22.y, "px)\n        ");
        }
        _calculateXYTransform() {
          const t22 = this._pos, i2 = this._map, o2 = this.getPitchAlignment();
          if (!i2 || !t22 || "map" !== o2)
            return "";
          if (!i2._showingGlobe()) {
            const e22 = i2.getPitch();
            return e22 ? "rotateX(".concat(e22, "deg)") : "";
          }
          const r22 = e2.c0(e2.dA(i2.transform, this._lngLat)), s2 = t22.sub(e2.dB(i2.transform)), a2 = Math.abs(s2.x) + Math.abs(s2.y);
          if (0 === a2)
            return "";
          const n22 = r22 / a2;
          return "rotateX(".concat(-s2.y * n22, "deg) rotateY(").concat(s2.x * n22, "deg)");
        }
        _calculateZTransform() {
          const t22 = this._pos, i2 = this._map;
          if (!i2 || !t22)
            return "";
          let o2 = 0;
          const r22 = this.getRotationAlignment();
          if ("map" === r22)
            if (i2._showingGlobe()) {
              const t3 = i2.project(new e2.bK(this._lngLat.lng, this._lngLat.lat + 1e-3)), r3 = i2.project(new e2.bK(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(t3);
              o2 = e2.c0(Math.atan2(r3.y, r3.x)) - 90;
            } else
              o2 = -i2.getBearing();
          else if ("horizon" === r22) {
            const r3 = e2.a7(4, 6, i2.getZoom()), s2 = e2.dB(i2.transform);
            s2.y += r3 * i2.transform.height;
            const a2 = t22.sub(s2), n22 = e2.c0(Math.atan2(a2.y, a2.x));
            o2 = (n22 > 90 ? n22 - 270 : n22 + 90) * (1 - r3);
          }
          return o2 += this._rotation, o2 ? "rotateZ(".concat(o2, "deg)") : "";
        }
        _update(e22) {
          cancelAnimationFrame(this._updateFrameId);
          const t22 = this._map;
          t22 && (t22.transform.renderWorldCopies && (this._lngLat = zn(this._lngLat, this._pos, t22.transform)), this._pos = t22.project(this._lngLat), true === e22 ? this._updateFrameId = requestAnimationFrame(() => {
            this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
          }) : this._pos = this._pos.round(), t22._requestDomTask(() => {
            this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t22._showingGlobe() || t22.getTerrain() || t22.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));
          }));
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t22) {
          return this._offset = e2.P.convert(t22), this._update(), this;
        }
        addClassName(e22) {
          return this._element.classList.add(e22), this;
        }
        removeClassName(e22) {
          return this._element.classList.remove(e22), this;
        }
        toggleClassName(e22) {
          return this._element.classList.toggle(e22);
        }
        _onMove(t22) {
          const i2 = this._map;
          if (!i2)
            return;
          const o2 = this._pointerdownPos, r22 = this._positionDelta;
          if (o2 && r22) {
            if (!this._isDragging) {
              const e22 = this._clickTolerance || i2._clickTolerance;
              if (t22.point.dist(o2) < e22)
                return;
              this._isDragging = true;
            }
            this._pos = t22.point.sub(r22), this._lngLat = i2.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e2.x("dragstart"))), this.fire(new e2.x("drag"));
          }
        }
        _onUp() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
          const t22 = this._map;
          t22 && (t22.off("mousemove", this._onMove), t22.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e2.x("dragend")), this._state = "inactive";
        }
        _addDragHandler(e22) {
          const t22 = this._map, i2 = this._pos;
          t22 && i2 && this._element.contains(e22.originalEvent.target) && (e22.preventDefault(), this._positionDelta = e22.point.sub(i2), this._pointerdownPos = e22.point, this._state = "pending", t22.on("mousemove", this._onMove), t22.on("touchmove", this._onMove), t22.once("mouseup", this._onUp), t22.once("touchend", this._onUp));
        }
        setDraggable(e22) {
          this._draggable = !!e22;
          const t22 = this._map;
          return t22 && (e22 ? (t22.on("mousedown", this._addDragHandler), t22.on("touchstart", this._addDragHandler)) : (t22.off("mousedown", this._addDragHandler), t22.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(e22) {
          return this._rotation = e22 || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(e22) {
          return this._rotationAlignment = e22 || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
        }
        setPitchAlignment(e22) {
          return this._pitchAlignment = e22 || "auto", this._update(), this;
        }
        getPitchAlignment() {
          return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
        }
        setOccludedOpacity(e22) {
          return this._occludedOpacity = e22 || 0.2, this._update(), this;
        }
        getOccludedOpacity() {
          return this._occludedOpacity;
        }
      }
      const kn = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, Bn = { maxWidth: 100, unit: "metric" }, Nn = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, Un = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, Gn = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function jn(t22 = new e2.P(0, 0), i2 = "bottom") {
        if ("number" == typeof t22) {
          const o2 = Math.round(Math.sqrt(0.5 * Math.pow(t22, 2)));
          switch (i2) {
            case "top":
              return new e2.P(0, t22);
            case "top-left":
              return new e2.P(o2, o2);
            case "top-right":
              return new e2.P(-o2, o2);
            case "bottom":
              return new e2.P(0, -t22);
            case "bottom-left":
              return new e2.P(o2, -o2);
            case "bottom-right":
              return new e2.P(-o2, -o2);
            case "left":
              return new e2.P(t22, 0);
            case "right":
              return new e2.P(-t22, 0);
          }
          return new e2.P(0, 0);
        }
        return t22 instanceof e2.P || Array.isArray(t22) ? e2.P.convert(t22) : e2.P.convert(t22[i2] || [0, 0]);
      }
      return { version: t2, supported: n2.supported, setRTLTextPlugin: e2.dC, getRTLTextPluginStatus: e2.dD, Map: class extends Tn {
        constructor(t22) {
          o.mark(i.create);
          const r22 = t22;
          if (null != (t22 = e2.l({}, Ln, t22)).minZoom && null != t22.maxZoom && t22.minZoom > t22.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (null != t22.minPitch && null != t22.maxPitch && t22.minPitch > t22.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (null != t22.minPitch && t22.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (null != t22.maxPitch && t22.maxPitch > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (t22.antialias && e2.dx(window) && (t22.antialias = false, e2.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Hi2(t22.minZoom, t22.maxZoom, t22.minPitch, t22.maxPitch, t22.renderWorldCopies), t22), this._repaint = !!t22.repaint, this._interactive = t22.interactive, this._minTileCacheSize = t22.minTileCacheSize, this._maxTileCacheSize = t22.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t22.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t22.preserveDrawingBuffer, this._antialias = t22.antialias, this._trackResize = t22.trackResize, this._bearingSnap = t22.bearingSnap, this._refreshExpiredTiles = t22.refreshExpiredTiles, this._fadeDuration = t22.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t22.crossSourceCollisions, this._collectResourceTiming = t22.collectResourceTiming, this._language = this._parseLanguage(t22.language), this._worldview = t22.worldview, this._renderTaskQueue = new Sn(), this._domRenderTaskQueue = new Sn(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e2.aP(), this._locale = e2.l({}, Dn, t22.locale), this._clickTolerance = t22.clickTolerance, this._cooperativeGestures = t22.cooperativeGestures, this._performanceMetricsCollection = t22.performanceMetricsCollection, this._tessellationStep = t22.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = true, this._precompilePrograms = t22.precompilePrograms, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new In(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._frameId = 0, this._requestManager = new T2(t22.transformRequest, t22.accessToken, t22.testMode), this._silenceAuthErrors = !!t22.testMode, this._contextCreateOptions = t22.contextCreateOptions ? { ...t22.contextCreateOptions } : {}, "string" == typeof t22.container) {
            const e22 = document.getElementById(t22.container);
            if (!e22)
              throw new Error("Container '".concat(t22.container.toString(), "' not found."));
            this._container = e22;
          } else {
            if (!(t22.container instanceof HTMLElement))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = t22.container;
          }
          if (this._container.childNodes.length > 0 && e2.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t22.maxBounds && this.setMaxBounds(t22.maxBounds), e2.aJ(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._tp || (this._tp = new Rn()), this._tp.registerParameter(this, ["Debug"], "showOverdrawInspector"), this._tp.registerParameter(this, ["Debug"], "showTileBoundaries"), this._tp.registerParameter(this, ["Debug"], "showParseStatus"), this._tp.registerParameter(this, ["Debug"], "repaint"), this._tp.registerParameter(this, ["Debug"], "showTileAABBs"), this._tp.registerParameter(this, ["Debug"], "showPadding"), this._tp.registerParameter(this, ["Debug"], "showCollisionBoxes", { noSave: true }), this._tp.registerParameter(this.transform, ["Debug"], "freezeTileCoverage", { noSave: true }, () => {
            this._update();
          }), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showTerrainWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers2DWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers3DWireframe"), this._setupPainter(), void 0 === this.painter)
            throw new Error("Failed to initialize WebGL.");
          if (this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, false), window.addEventListener("resize", this._onWindowResize, false), window.addEventListener("orientationchange", this._onWindowResize, false), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.addEventListener("visibilitychange", this._onVisibilityChange, false), this.handlers = new bn(this, t22), this._localFontFamily = t22.localFontFamily, this._localIdeographFontFamily = t22.localIdeographFontFamily, (t22.style || !t22.testMode) && this.setStyle(t22.style || e2.e.DEFAULT_STYLE, { config: t22.config, localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t22.projection && this.setProjection(t22.projection), t22.hash && (this._hash = new Ea2("string" == typeof t22.hash && t22.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
            null == r22.center && null == r22.zoom || (this.transform._unmodified = false), this.jumpTo({ center: t22.center, zoom: t22.zoom, bearing: t22.bearing, pitch: t22.pitch });
            const i2 = t22.bounds;
            i2 && (this.resize(), this.fitBounds(i2, e2.l({}, t22.fitBoundsOptions, { duration: 0 })));
          }
          this.resize(), t22.attributionControl && this.addControl(new En({ customAttribution: t22.customAttribution })), this._logoControl = new Cn(), this.addControl(this._logoControl, t22.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();
          }), this.on("data", (t3) => {
            this._update("style" === t3.dataType), this.fire(new e2.x("".concat(t3.dataType, "data"), t3));
          }), this.on("dataloading", (t3) => {
            this.fire(new e2.x("".concat(t3.dataType, "dataloading"), t3));
          }), this._interactions = new An(this);
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(t22, i2) {
          if (void 0 === i2 && (i2 = t22.getDefaultPosition ? t22.getDefaultPosition() : "top-right"), !t22 || !t22.onAdd)
            return this.fire(new e2.t(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const o2 = t22.onAdd(this);
          this._controls.push(t22);
          const r22 = this._controlPositions[i2];
          return -1 !== i2.indexOf("bottom") ? r22.insertBefore(o2, r22.firstChild) : r22.appendChild(o2), this;
        }
        removeControl(t22) {
          if (!t22 || !t22.onRemove)
            return this.fire(new e2.t(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const i2 = this._controls.indexOf(t22);
          return i2 > -1 && this._controls.splice(i2, 1), t22.onRemove(this), this;
        }
        hasControl(e22) {
          return this._controls.indexOf(e22) > -1;
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        resize(t22) {
          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
            return this;
          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
          const i2 = !this._moving;
          return i2 && this.fire(new e2.x("movestart", t22)).fire(new e2.x("move", t22)), this.fire(new e2.x("resize", t22)), i2 && this.fire(new e2.x("moveend", t22)), this;
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds() || null;
        }
        setMaxBounds(t22) {
          return this.transform.setMaxBounds(e2.as.convert(t22)), this._update();
        }
        setMinZoom(t22) {
          if ((t22 = t22 != null ? t22 : -2) >= -2 && t22 <= this.transform.maxZoom)
            return this.transform.minZoom = t22, this._update(), this.getZoom() < t22 ? this.setZoom(t22) : this.fire(new e2.x("zoomstart")).fire(new e2.x("zoom")).fire(new e2.x("zoomend")), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(t22) {
          if ((t22 = t22 != null ? t22 : 22) >= this.transform.minZoom)
            return this.transform.maxZoom = t22, this._update(), this.getZoom() > t22 ? this.setZoom(t22) : this.fire(new e2.x("zoomstart")).fire(new e2.x("zoom")).fire(new e2.x("zoomend")), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(t22) {
          if ((t22 = t22 != null ? t22 : 0) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (t22 >= 0 && t22 <= this.transform.maxPitch)
            return this.transform.minPitch = t22, this._update(), this.getPitch() < t22 ? this.setPitch(t22) : this.fire(new e2.x("pitchstart")).fire(new e2.x("pitch")).fire(new e2.x("pitchend")), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(t22) {
          if ((t22 = t22 != null ? t22 : 85) > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (t22 >= this.transform.minPitch)
            return this.transform.maxPitch = t22, this._update(), this.getPitch() > t22 ? this.setPitch(t22) : this.fire(new e2.x("pitchstart")).fire(new e2.x("pitch")).fire(new e2.x("pitchend")), this;
          throw new Error("maxPitch must be greater than or equal to minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(e22) {
          return this.transform.renderWorldCopies = e22, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
        }
        getLanguage() {
          return this._language;
        }
        _parseLanguage(e22) {
          return "auto" === e22 ? navigator.language : Array.isArray(e22) ? 0 === e22.length ? void 0 : e22.map((e3) => "auto" === e3 ? navigator.language : e3) : e22;
        }
        setLanguage(e22) {
          const t22 = this._parseLanguage(e22);
          if (!this.style || t22 === this._language)
            return this;
          this._language = t22, this.style.reloadSources();
          for (const e3 of this._controls)
            e3._setLanguage && e3._setLanguage(this._language);
          return this;
        }
        getWorldview() {
          return this._worldview;
        }
        setWorldview(e22) {
          return this.style && e22 !== this._worldview ? (this._worldview = e22, this.style.reloadSources(), this) : this;
        }
        getProjection() {
          return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
        }
        _showingGlobe() {
          return "globe" === this.transform.projection.name;
        }
        setProjection(e22) {
          return this._lazyInitEmptyStyle(), e22 ? "string" == typeof e22 && (e22 = { name: e22 }) : e22 = null, this._useExplicitProjection = !!e22, this._prioritizeAndUpdateProjection(e22, this.style.projection);
        }
        _updateProjectionTransition() {
          if ("globe" !== this.getProjection().name)
            return;
          const t22 = this.transform, i2 = t22.projection.name;
          let o2;
          "globe" === i2 && t22.zoom >= e2.bU ? (t22.setMercatorFromTransition(), o2 = true) : "mercator" === i2 && t22.zoom < e2.bU && (t22.setProjection({ name: "globe" }), o2 = true), o2 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
        }
        _prioritizeAndUpdateProjection(e22, t22) {
          return this._updateProjection(e22 || t22 || { name: "mercator" });
        }
        _updateProjection(t22) {
          let i2;
          return i2 = "globe" === t22.name && this.transform.zoom >= e2.bU ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t22), this.style.applyProjectionUpdate(), i2 && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(true), this._forceMarkerAndPopupUpdate(true)), this;
        }
        project(t22) {
          return this.transform.locationPoint3D(e2.bK.convert(t22));
        }
        unproject(t22) {
          return this.transform.pointLocation3D(e2.P.convert(t22));
        }
        isMoving() {
          return this._moving || this.handlers && this.handlers.isMoving() || false;
        }
        isZooming() {
          return this._zooming || this.handlers && this.handlers.isZooming() || false;
        }
        isRotating() {
          return this._rotating || this.handlers && this.handlers.isRotating() || false;
        }
        _isDragging() {
          return this.handlers && this.handlers._isDragging() || false;
        }
        _createDelegatedListener(e22, t22, i2) {
          if ("mouseenter" === e22 || "mouseover" === e22) {
            let o2 = false;
            const r22 = (r3) => {
              const s3 = t22.filter((e3) => this.getLayer(e3)), a2 = s3.length ? this.queryRenderedFeatures(r3.point, { layers: s3 }) : [];
              a2.length ? o2 || (o2 = true, i2.call(this, new za2(e22, this, r3.originalEvent, { features: a2 }))) : o2 = false;
            }, s2 = () => {
              o2 = false;
            };
            return { layers: new Set(t22), listener: i2, delegates: { mousemove: r22, mouseout: s2 } };
          }
          if ("mouseleave" === e22 || "mouseout" === e22) {
            let o2 = false;
            const r22 = (r3) => {
              const s3 = t22.filter((e3) => this.getLayer(e3));
              (s3.length ? this.queryRenderedFeatures(r3.point, { layers: s3 }) : []).length ? o2 = true : o2 && (o2 = false, i2.call(this, new za2(e22, this, r3.originalEvent)));
            }, s2 = (t3) => {
              o2 && (o2 = false, i2.call(this, new za2(e22, this, t3.originalEvent)));
            };
            return { layers: new Set(t22), listener: i2, delegates: { mousemove: r22, mouseout: s2 } };
          }
          {
            const o2 = (e3) => {
              const o3 = t22.filter((e4) => this.getLayer(e4)), r22 = o3.length ? this.queryRenderedFeatures(e3.point, { layers: o3 }) : [];
              r22.length && (e3.features = r22, i2.call(this, e3), delete e3.features);
            };
            return { layers: new Set(t22), listener: i2, delegates: { [e22]: o2 } };
          }
        }
        on(e22, t22, i2) {
          if ("function" == typeof t22 || void 0 === i2)
            return super.on(e22, t22);
          if (Array.isArray(t22) || (t22 = [t22]), t22) {
            for (const e3 of t22)
              if (!this._isValidId(e3))
                return this;
          }
          const o2 = this._createDelegatedListener(e22, t22, i2);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e22] = this._delegatedListeners[e22] || [], this._delegatedListeners[e22].push(o2);
          for (const e3 in o2.delegates)
            this.on(e3, o2.delegates[e3]);
          return this;
        }
        once(e22, t22, i2) {
          if ("function" == typeof t22 || void 0 === i2)
            return super.once(e22, t22);
          if (Array.isArray(t22) || (t22 = [t22]), t22) {
            for (const e3 of t22)
              if (!this._isValidId(e3))
                return this;
          }
          const o2 = this._createDelegatedListener(e22, t22, i2);
          for (const e3 in o2.delegates)
            this.once(e3, o2.delegates[e3]);
          return this;
        }
        off(e22, t22, i2) {
          if ("function" == typeof t22 || void 0 === i2)
            return super.off(e22, t22);
          const o2 = new Set(Array.isArray(t22) ? t22 : [t22]);
          for (const e3 of o2)
            if (!this._isValidId(e3))
              return this;
          const r22 = (e3, t3) => {
            if (e3.size !== t3.size)
              return false;
            for (const i3 of e3)
              if (!t3.has(i3))
                return false;
            return true;
          }, s2 = this._delegatedListeners ? this._delegatedListeners[e22] : void 0;
          return s2 && ((e3) => {
            for (let t3 = 0; t3 < e3.length; t3++) {
              const s3 = e3[t3];
              if (s3.listener === i2 && r22(s3.layers, o2)) {
                for (const e4 in s3.delegates)
                  this.off(e4, s3.delegates[e4]);
                return e3.splice(t3, 1), this;
              }
            }
          })(s2), this;
        }
        queryRenderedFeatures(t22, i2) {
          if (!this.style)
            return [];
          if (void 0 !== i2 || void 0 === t22 || t22 instanceof e2.P || Array.isArray(t22) || (i2 = t22, t22 = void 0), t22 = t22 || [[0, 0], [this.transform.width, this.transform.height]], (i2 = i2 || {}).layers && Array.isArray(i2.layers)) {
            for (const e22 of i2.layers)
              if (!this._isValidId(e22))
                return [];
          }
          return this.style.queryRenderedFeatures(t22, i2, this.transform);
        }
        querySourceFeatures(e22, t22) {
          return this._isValidId(e22) ? this.style.querySourceFeatures(e22, t22) : [];
        }
        isPointOnSurface(t22) {
          const { name: i2 } = this.transform.projection;
          return "globe" !== i2 && "mercator" !== i2 && e2.w("".concat(i2, " projection does not support isPointOnSurface, this API may behave unexpectedly.")), this.transform.isPointOnSurface(e2.P.convert(t22));
        }
        addInteraction(e22, t22) {
          return this._interactions.add(e22, t22), this;
        }
        removeInteraction(e22) {
          return this._interactions.remove(e22), this;
        }
        setStyle(t22, i2) {
          return i2 = e2.l({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i2), this.style && t22 && false !== i2.diff && i2.localFontFamily === this._localFontFamily && i2.localIdeographFontFamily === this._localIdeographFontFamily && !i2.config ? (this.style._diffStyle(t22, (o2, r22) => {
            o2 ? (e2.w("Unable to perform style diff: ".concat(String(o2.message || o2.error || o2), ". Rebuilding the style from scratch.")), this._updateStyle(t22, i2)) : r22 && this._update(true);
          }, () => {
            this._postStyleLoadEvent();
          }), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._localFontFamily = i2.localFontFamily, this._updateStyle(t22, i2));
        }
        _getUIString(e22) {
          const t22 = this._locale[e22];
          if (null == t22)
            throw new Error("Missing UI string '".concat(e22, "'"));
          return t22;
        }
        _updateStyle(t22, i2) {
          if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), t22) {
            const o2 = e2.l({}, i2);
            i2 && i2.config && (o2.initialConfig = i2.config, delete o2.config), this.style = new co(this, o2).load(t22), this.style.setEventedParent(this, { style: this.style });
          }
          return this._updateTerrain(), this;
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new co(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        getStyle() {
          if (this.style)
            return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : (e2.w("There is no style added to the map."), false);
        }
        _isValidId(t22) {
          return null == t22 ? (this.fire(new e2.t(new Error("IDs can't be empty."))), false) : !e2.cn(t22) || (this.fire(new e2.t(new Error("IDs can't contain special symbols: \"".concat(t22, '".')))), false);
        }
        addSource(e22, t22) {
          return this._isValidId(e22) ? (this._lazyInitEmptyStyle(), this.style.addSource(e22, t22), this._update(true)) : this;
        }
        isSourceLoaded(e22) {
          return !!this._isValidId(e22) && !!this.style && this.style._isSourceCacheLoaded(e22);
        }
        areTilesLoaded() {
          return this.style.areTilesLoaded();
        }
        addSourceType(e22, t22, i2) {
          this._lazyInitEmptyStyle(), this.style.addSourceType(e22, t22, i2);
        }
        removeSource(e22) {
          return this._isValidId(e22) ? (this.style.removeSource(e22), this._updateTerrain(), this._update(true)) : this;
        }
        getSource(e22) {
          return this._isValidId(e22) ? this.style.getOwnSource(e22) : null;
        }
        addImage(t22, i2, { pixelRatio: o2 = 1, sdf: r22 = false, stretchX: s2, stretchY: a2, content: n22 } = {}) {
          if (this._lazyInitEmptyStyle(), i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap) {
            const { width: l22, height: c22, data: h22 } = e2.q.getImageData(i2);
            this.style.addImage(t22, { data: new e2.r({ width: l22, height: c22 }, h22), pixelRatio: o2, stretchX: s2, stretchY: a2, content: n22, sdf: r22, version: 0 });
          } else if (void 0 === i2.width || void 0 === i2.height)
            this.fire(new e2.t(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          else {
            const { width: l22, height: c22 } = i2, h22 = i2;
            this.style.addImage(t22, { data: new e2.r({ width: l22, height: c22 }, new Uint8Array(h22.data)), pixelRatio: o2, stretchX: s2, stretchY: a2, content: n22, sdf: r22, version: 0, userImage: h22 }), h22.onAdd && h22.onAdd(this, t22);
          }
        }
        updateImage(t22, i2) {
          this._lazyInitEmptyStyle();
          const o2 = this.style.getImage(t22);
          if (!o2)
            return void this.fire(new e2.t(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const r22 = i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap ? e2.q.getImageData(i2) : i2, { width: s2, height: a2, data: n22 } = r22;
          if (void 0 === s2 || void 0 === a2)
            return void this.fire(new e2.t(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (s2 !== o2.data.width || a2 !== o2.data.height)
            return void this.fire(new e2.t(new Error("The width and height of the updated image (".concat(s2, ", ").concat(a2, ")\n                must be that same as the previous version of the image\n                (").concat(o2.data.width, ", ").concat(o2.data.height, ")"))));
          const l22 = !(i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap);
          o2.data.replace(n22, l22), this.style.updateImage(t22, o2);
        }
        hasImage(t22) {
          return t22 ? !!this.style && !!this.style.getImage(t22) : (this.fire(new e2.t(new Error("Missing required image id"))), false);
        }
        removeImage(e22) {
          this.style.removeImage(e22);
        }
        loadImage(t22, i2) {
          e2.o(this._requestManager.transformRequest(t22, e2.R.Image), (t3, o2) => {
            i2(t3, o2 instanceof HTMLImageElement ? e2.q.getImageData(o2) : o2);
          });
        }
        listImages() {
          return this.style.listImages();
        }
        addModel(e22, t22) {
          this._lazyInitEmptyStyle(), this.style.addModel(e22, t22);
        }
        hasModel(t22) {
          return t22 ? this.style.hasModel(t22) : (this.fire(new e2.t(new Error("Missing required model id"))), false);
        }
        removeModel(e22) {
          this.style.removeModel(e22);
        }
        listModels() {
          return this.style.listModels();
        }
        addLayer(e22, t22) {
          return this._isValidId(e22.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e22, t22), this._update(true)) : this;
        }
        getSlot(e22) {
          const t22 = this.getLayer(e22);
          return t22 && t22.slot || null;
        }
        setSlot(e22, t22) {
          return this.style.setSlot(e22, t22), this.style.mergeLayers(), this._update(true);
        }
        addImport(e22, t22) {
          return this.style.addImport(e22, t22), this;
        }
        updateImport(e22, t22) {
          return "string" != typeof t22 && t22.id !== e22 ? (this.removeImport(e22), this.addImport(t22)) : (this.style.updateImport(e22, t22), this._update(true));
        }
        removeImport(e22) {
          return this.style.removeImport(e22), this;
        }
        moveImport(e22, t22) {
          return this.style.moveImport(e22, t22), this._update(true);
        }
        moveLayer(e22, t22) {
          return this._isValidId(e22) ? (this.style.moveLayer(e22, t22), this._update(true)) : this;
        }
        removeLayer(e22) {
          return this._isValidId(e22) ? (this.style.removeLayer(e22), this._update(true)) : this;
        }
        getLayer(e22) {
          if (!this._isValidId(e22))
            return null;
          const t22 = this.style.getOwnLayer(e22);
          return t22 ? "custom" === t22.type ? t22.implementation : t22.serialize() : void 0;
        }
        getSlots() {
          return this.style.getSlots();
        }
        setLayerZoomRange(e22, t22, i2) {
          return this._isValidId(e22) ? (this.style.setLayerZoomRange(e22, t22, i2), this._update(true)) : this;
        }
        setFilter(e22, t22, i2 = {}) {
          return this._isValidId(e22) ? (this.style.setFilter(e22, t22, i2), this._update(true)) : this;
        }
        getFilter(e22) {
          return this._isValidId(e22) ? this.style.getFilter(e22) : null;
        }
        setPaintProperty(e22, t22, i2, o2 = {}) {
          return this._isValidId(e22) ? (this.style.setPaintProperty(e22, t22, i2, o2), this._update(true)) : this;
        }
        getPaintProperty(e22, t22) {
          return this._isValidId(e22) ? this.style.getPaintProperty(e22, t22) : null;
        }
        setLayoutProperty(e22, t22, i2, o2 = {}) {
          return this._isValidId(e22) ? (this.style.setLayoutProperty(e22, t22, i2, o2), this._update(true)) : this;
        }
        getLayoutProperty(e22, t22) {
          return this._isValidId(e22) ? this.style.getLayoutProperty(e22, t22) : null;
        }
        getSchema(e22) {
          return this.style.getSchema(e22);
        }
        setSchema(e22, t22) {
          return this.style.setSchema(e22, t22), this._update(true);
        }
        getConfig(e22) {
          return this.style.getConfig(e22);
        }
        setConfig(e22, t22) {
          return this.style.setConfig(e22, t22), this._update(true);
        }
        getConfigProperty(e22, t22) {
          return this.style.getConfigProperty(e22, t22);
        }
        setConfigProperty(e22, t22, i2) {
          return this.style.setConfigProperty(e22, t22, i2), this._update(true);
        }
        setLights(e22) {
          if (this._lazyInitEmptyStyle(), e22 && 1 === e22.length && "flat" === e22[0].type) {
            const t22 = e22[0];
            t22.properties ? this.style.setFlatLight(t22.properties, t22.id, {}) : this.style.setFlatLight({}, "flat");
          } else
            this.style.setLights(e22), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = true);
          return this._update(true);
        }
        getLights() {
          const e22 = this.style.getLights() || [];
          return 0 === e22.length && e22.push({ id: this.style.light.id, type: "flat", properties: this.style.getFlatLight() }), e22;
        }
        setLight(e22, t22 = {}) {
          return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{ id: "flat", type: "flat", properties: e22 }]);
        }
        getLight() {
          return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
        }
        setTerrain(e22) {
          return this._lazyInitEmptyStyle(), !e22 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e22), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
        }
        getTerrain() {
          return this.style ? this.style.getTerrain() : null;
        }
        setFog(e22) {
          return this._lazyInitEmptyStyle(), this.style.setFog(e22), this._update(true);
        }
        getFog() {
          return this.style ? this.style.getFog() : null;
        }
        setColorTheme(e22) {
          return this._lazyInitEmptyStyle(), this.style.setColorTheme(e22), this._update(true);
        }
        setCamera(e22) {
          return this.style.setCamera(e22), this._triggerCameraUpdate(e22);
        }
        _triggerCameraUpdate(e22) {
          return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === e22["camera-projection"]));
        }
        getCamera() {
          return this.style.camera;
        }
        _queryFogOpacity(t22) {
          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e2.bK.convert(t22), this.transform) : 0;
        }
        setFeatureState(e22, t22) {
          return this._isValidId(e22.source) ? (this.style.setFeatureState(e22, t22), this._update()) : this;
        }
        removeFeatureState(e22, t22) {
          return this._isValidId(e22.source) ? (this.style.removeFeatureState(e22, t22), this._update()) : this;
        }
        getFeatureState(e22) {
          return this._isValidId(e22.source) ? this.style.getFeatureState(e22) : null;
        }
        _updateContainerDimensions() {
          if (!this._container)
            return;
          const e22 = this._container.getBoundingClientRect().width || 400, t22 = this._container.getBoundingClientRect().height || 300;
          let i2, o2, r22, s2 = this._container;
          for (; s2 && (!o2 || !r22); ) {
            const e3 = window.getComputedStyle(s2).transform;
            e3 && "none" !== e3 && (i2 = e3.match(/matrix.*\((.+)\)/)[1].split(", "), i2[0] && "0" !== i2[0] && "1" !== i2[0] && (o2 = i2[0]), i2[3] && "0" !== i2[3] && "1" !== i2[3] && (r22 = i2[3])), s2 = s2.parentElement;
          }
          this._containerWidth = o2 ? Math.abs(e22 / o2) : e22, this._containerHeight = r22 ? Math.abs(t22 / r22) : t22;
        }
        _detectMissingCSS() {
          "rgb(250, 128, 114)" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e2.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }
        _setupContainer() {
          const e22 = this._container;
          e22.classList.add("mapboxgl-map"), (this._missingCSSCanary = l2("div", "mapboxgl-canary", e22)).style.visibility = "hidden", this._detectMissingCSS();
          const t22 = this._canvasContainer = l2("div", "mapboxgl-canvas-container", e22);
          this._canvas = l2("canvas", "mapboxgl-canvas", t22), this._interactive && (t22.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
          const i2 = this._controlContainer = l2("div", "mapboxgl-control-container", e22), o2 = this._controlPositions = {};
          ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"].forEach((e3) => {
            o2[e3] = l2("div", "mapboxgl-ctrl-".concat(e3), i2);
          }), this._container.addEventListener("scroll", this._onMapScroll, false);
        }
        _resizeCanvas(t22, i2) {
          const o2 = e2.q.devicePixelRatio || 1;
          this._canvas.width = o2 * Math.ceil(t22), this._canvas.height = o2 * Math.ceil(i2), this._canvas.style.width = "".concat(t22, "px"), this._canvas.style.height = "".concat(i2, "px");
        }
        _addMarker(e22) {
          this._markers.push(e22);
        }
        _removeMarker(e22) {
          const t22 = this._markers.indexOf(e22);
          -1 !== t22 && this._markers.splice(t22, 1);
        }
        _addPopup(e22) {
          this._popups.push(e22);
        }
        _removePopup(e22) {
          const t22 = this._popups.indexOf(e22);
          -1 !== t22 && this._popups.splice(t22, 1);
        }
        _setupPainter() {
          const t22 = e2.l({}, n2.supported.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), i2 = this._canvas.getContext("webgl2", t22);
          i2 ? (G2(i2, true), this.painter = new wa2(i2, this._contextCreateOptions, this.transform, this._tp), this.on("data", (e22) => {
            "source" === e22.dataType && this.painter.setTileLoadedFlag(true);
          }), e2.m.testSupport(i2)) : this.fire(new e2.t(new Error("Failed to initialize WebGL")));
        }
        _contextLost(t22) {
          t22.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e2.x("webglcontextlost", { originalEvent: t22 }));
        }
        _contextRestored(t22) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new e2.x("webglcontextrestored", { originalEvent: t22 }));
        }
        _onMapScroll(e22) {
          if (e22.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
        }
        idle() {
          return !this.isMoving() && this.loaded();
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        frameReady() {
          return this.loaded() && !this._placementDirty;
        }
        _update(e22) {
          return this.style ? (this._styleDirty = this._styleDirty || e22, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(e22) {
          return this._update(), this._renderTaskQueue.add(e22);
        }
        _cancelRenderFrame(e22) {
          this._renderTaskQueue.remove(e22);
        }
        _requestDomTask(e22) {
          !this.loaded() || this.loaded() && !this.isMoving() ? e22() : this._domRenderTaskQueue.add(e22);
        }
        _render(t22) {
          let r22;
          this.fire(new e2.x("renderstart")), ++this._frameId;
          const s2 = this.painter.context.extTimerQuery, a2 = e2.q.now(), n22 = this.painter.context.gl;
          if (this.listens("gpu-timing-frame") && (r22 = n22.createQuery(), n22.beginQuery(s2.TIME_ELAPSED_EXT, r22)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t22), this._domRenderTaskQueue.run(t22), this._removed)
            return;
          this._updateProjectionTransition();
          const l22 = this._isInitialLoad ? 0 : this._fadeDuration;
          if (this.style && this._styleDirty) {
            this._styleDirty = false;
            const t3 = this.transform.zoom, i2 = this.transform.pitch, o2 = e2.q.now(), r3 = new e2.a3(t3, { now: o2, fadeDuration: l22, pitch: i2, transition: this.style.transition });
            this.style.update(r3);
          }
          this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
          let c22 = false;
          this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), c22 = this._updateAverageElevation(a2), this.style.updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : c22 = this._updateAverageElevation(a2);
          const h22 = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, l22, this._crossSourceCollisions, this.painter.replacementSource);
          if (h22 && (this._placementDirty = h22.needsRerender), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showParseStatus: this.showParseStatus, wireframe: { terrain: this.showTerrainWireframe, layers2D: this.showLayers2DWireframe, layers3D: this.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: l22, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e2.x("render")), this.loaded() && !this._loaded && (this._loaded = true, o.mark(i.load), this.fire(new e2.x("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), r22) {
            const t3 = e2.q.now() - a2;
            n22.endQuery(s2.TIME_ELAPSED_EXT), setTimeout(() => {
              const i2 = n22.getQueryParameter(r22, n22.QUERY_RESULT) / 1e6;
              n22.deleteQuery(r22), this.fire(new e2.x("gpu-timing-frame", { cpuTime: t3, gpuTime: i2 }));
            }, 50);
          }
          if (this.listens("gpu-timing-layer")) {
            const t3 = this.painter.collectGpuTimers();
            setTimeout(() => {
              const i2 = this.painter.queryGpuTimers(t3);
              this.fire(new e2.x("gpu-timing-layer", { layerTimes: i2 }));
            }, 50);
          }
          if (this.listens("gpu-timing-deferred-render")) {
            const t3 = this.painter.collectDeferredRenderGpuQueries();
            setTimeout(() => {
              const i2 = this.painter.queryGpuTimeDeferredRender(t3);
              this.fire(new e2.x("gpu-timing-deferred-render", { gpuTime: i2 }));
            }, 50);
          }
          const u22 = this._sourcesDirty || this._styleDirty || this._placementDirty || c22;
          if (u22 || this._repaint)
            this.triggerRepaint();
          else {
            const t3 = this.idle();
            if (t3 && (c22 = this._updateAverageElevation(a2, true)), c22)
              this.triggerRepaint();
            else if (this._triggerFrame(false), t3 && (this.fire(new e2.x("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
              const t4 = this._calculateSpeedIndex();
              this.fire(new e2.x("speedindexcompleted", { speedIndex: t4 })), this.speedIndexTiming = false;
            }
          }
          !this._loaded || this._fullyLoaded || u22 || (this._fullyLoaded = true, o.mark(i.fullLoad), this._performanceMetricsCollection && k2(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
        }
        _forceMarkerAndPopupUpdate(e22) {
          for (const t22 of this._markers)
            e22 && !this.getRenderWorldCopies() && (t22._lngLat = t22._lngLat.wrap()), t22._update();
          for (const t22 of this._popups)
            !e22 || this.getRenderWorldCopies() || t22._trackPointer || (t22._lngLat = t22._lngLat.wrap()), t22._update();
        }
        _updateAverageElevation(e22, t22 = false) {
          const i2 = (e3) => (this.transform.averageElevation = e3, this._update(false), true);
          if (!this.painter.averageElevationNeedsEasing())
            return 0 !== this.transform.averageElevation && i2(0);
          const o2 = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
          if (o2 || (t22 || e22 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e22)) {
            const t3 = this.transform.averageElevation;
            let r22 = this.transform.sampleAverageElevation();
            null != this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(r22) ? r22 = 0 : this._averageElevationLastSampledAt = e22;
            const s2 = Math.abs(t3 - r22);
            if (s2 > 1) {
              if (this._isInitialLoad || o2)
                return this._averageElevation.jumpTo(r22), i2(r22);
              this._averageElevation.easeTo(r22, e22, 300);
            } else if (s2 > 1e-4)
              return this._averageElevation.jumpTo(r22), i2(r22);
          }
          return !!this._averageElevation.isEasing(e22) && i2(this._averageElevation.getValue(e22));
        }
        _authenticate() {
          N2(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t22) => {
            if (t22 && (t22.message === w2 || 401 === t22.status)) {
              const t3 = this.painter.context.gl;
              G2(t3, false), this._logoControl instanceof Cn && this._logoControl._updateLogo(), t3 && t3.clear(t3.DEPTH_BUFFER_BIT | t3.COLOR_BUFFER_BIT | t3.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e2.t(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
            }
          }), M2(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
          });
        }
        _postStyleLoadEvent() {
          this.style.globalId && O2(this._requestManager._customAccessToken, { map: this, skuToken: this._requestManager._skuToken, style: this.style.globalId, importedStyles: this.style.getImportGlobalIds() });
        }
        _updateTerrain() {
          const e22 = this._isDragging();
          this.painter.updateTerrain(this.style, e22);
        }
        _calculateSpeedIndex() {
          const e22 = this.painter.canvasCopy(), t22 = this.painter.getCanvasCopiesAndTimestamps();
          t22.timeStamps.push(performance.now());
          const i2 = this.painter.context.gl, o2 = i2.createFramebuffer();
          function r22(e3) {
            i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, e3, 0);
            const t3 = new Uint8Array(i2.drawingBufferWidth * i2.drawingBufferHeight * 4);
            return i2.readPixels(0, 0, i2.drawingBufferWidth, i2.drawingBufferHeight, i2.RGBA, i2.UNSIGNED_BYTE, t3), t3;
          }
          return i2.bindFramebuffer(i2.FRAMEBUFFER, o2), this._canvasPixelComparison(r22(e22), t22.canvasCopies.map(r22), t22.timeStamps);
        }
        _canvasPixelComparison(e22, t22, i2) {
          let o2 = i2[1] - i2[0];
          const r22 = e22.length / 4;
          for (let s2 = 0; s2 < t22.length; s2++) {
            const a2 = t22[s2];
            let n22 = 0;
            for (let t3 = 0; t3 < a2.length; t3 += 4)
              a2[t3] === e22[t3] && a2[t3 + 1] === e22[t3 + 1] && a2[t3 + 2] === e22[t3 + 2] && a2[t3 + 3] === e22[t3 + 3] && (n22 += 1);
            o2 += (i2[s2 + 2] - i2[s2 + 1]) * (1 - n22 / r22);
          }
          return o2;
        }
        remove() {
          this._hash && this._hash.remove();
          for (const e22 of this._controls)
            e22.onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, false), window.removeEventListener("orientationchange", this._onWindowResize, false), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.removeEventListener("online", this._onWindowOnline, false), window.removeEventListener("visibilitychange", this._onVisibilityChange, false);
          const t22 = this.painter.context.gl.getExtension("WEBGL_lose_context");
          t22 && t22.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), U2.delete(this.painter.context.gl), B2.remove(), P2.remove(), this._removed = true, this.fire(new e2.x("remove"));
        }
        triggerRepaint() {
          this._triggerFrame(true);
        }
        _triggerFrame(t22) {
          this._renderNextFrame = this._renderNextFrame || t22, this.style && !this._frame && (this._frame = e2.q.frame((e22) => {
            const t3 = !!this._renderNextFrame;
            this._frame = null, this._renderNextFrame = null, t3 && this._render(e22);
          }));
        }
        _preloadTiles(t22) {
          const i2 = this.style ? this.style.getSourceCaches() : [];
          return e2.bf(i2, (e22, i3) => e22._preloadTiles(t22, i3), () => {
            this.triggerRepaint();
          }), this;
        }
        _onWindowOnline() {
          this._update();
        }
        _onWindowResize(e22) {
          this._trackResize && this.resize({ originalEvent: e22 })._update();
        }
        _onVisibilityChange() {
          "hidden" === document.visibilityState && this._visibilityHidden++;
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(e22) {
          this._showTileBoundaries !== e22 && (this._showTileBoundaries = e22, this._tp.refreshUI(), this._update());
        }
        get showParseStatus() {
          return !!this._showParseStatus;
        }
        set showParseStatus(e22) {
          this._showParseStatus !== e22 && (this._showParseStatus = e22, this._tp.refreshUI(), this._update());
        }
        get showTerrainWireframe() {
          return !!this._showTerrainWireframe;
        }
        set showTerrainWireframe(e22) {
          this._showTerrainWireframe !== e22 && (this._showTerrainWireframe = e22, this._tp.refreshUI(), this._update());
        }
        get showLayers2DWireframe() {
          return !!this._showLayers2DWireframe;
        }
        set showLayers2DWireframe(e22) {
          this._showLayers2DWireframe !== e22 && (this._showLayers2DWireframe = e22, this._tp.refreshUI(), this._update());
        }
        get showLayers3DWireframe() {
          return !!this._showLayers3DWireframe;
        }
        set showLayers3DWireframe(e22) {
          this._showLayers3DWireframe !== e22 && (this._showLayers3DWireframe = e22, this._tp.refreshUI(), this._update());
        }
        get speedIndexTiming() {
          return !!this._speedIndexTiming;
        }
        set speedIndexTiming(e22) {
          this._speedIndexTiming !== e22 && (this._speedIndexTiming = e22, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(e22) {
          this._showPadding !== e22 && (this._showPadding = e22, this._tp.refreshUI(), this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(e22) {
          this._showCollisionBoxes !== e22 && (this._showCollisionBoxes = e22, this._tp.refreshUI(), e22 ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(e22) {
          this._showOverdrawInspector !== e22 && (this._showOverdrawInspector = e22, this._tp.refreshUI(), this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(e22) {
          this._repaint !== e22 && (this._repaint = e22, this._tp.refreshUI(), this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(e22) {
          this._vertices = e22, this._update();
        }
        get showTileAABBs() {
          return !!this._showTileAABBs;
        }
        set showTileAABBs(e22) {
          this._showTileAABBs !== e22 && (this._showTileAABBs = e22, this._tp.refreshUI(), e22 && this._update());
        }
        _setCacheLimits(t22, i2) {
          e2.dy(t22, i2);
        }
        get version() {
          return t2;
        }
      }, NavigationControl: class {
        constructor(t22 = {}) {
          this.options = e2.l({}, Pn, t22), this._container = l2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e22) => e22.preventDefault()), this.options.showZoom && (e2.aJ(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e22) => {
            this._map && this._map.zoomIn({}, { originalEvent: e22 });
          }), l2("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e22) => {
            this._map && this._map.zoomOut({}, { originalEvent: e22 });
          }), l2("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e2.aJ(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e22) => {
            const t3 = this._map;
            t3 && (this.options.visualizePitch ? t3.resetNorthPitch({}, { originalEvent: e22 }) : t3.resetNorth({}, { originalEvent: e22 }));
          }), this._compassIcon = l2("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        _updateZoomButtons() {
          const e22 = this._map;
          if (!e22)
            return;
          const t22 = e22.getZoom(), i2 = t22 === e22.getMaxZoom(), o2 = t22 === e22.getMinZoom();
          this._zoomInButton.disabled = i2, this._zoomOutButton.disabled = o2, this._zoomInButton.setAttribute("aria-disabled", i2.toString()), this._zoomOutButton.setAttribute("aria-disabled", o2.toString());
        }
        _rotateCompassArrow() {
          const e22 = this._map;
          if (!e22)
            return;
          const t22 = this.options.visualizePitch ? "scale(".concat(1 / Math.pow(Math.cos(e22.transform.pitch * (Math.PI / 180)), 0.5), ") rotateX(").concat(e22.transform.pitch, "deg) rotateZ(").concat(e22.transform.angle * (180 / Math.PI), "deg)") : "rotate(".concat(e22.transform.angle * (180 / Math.PI), "deg)");
          e22._requestDomTask(() => {
            this._compassIcon && (this._compassIcon.style.transform = t22);
          });
        }
        onAdd(e22) {
          return this._map = e22, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e22.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e22.on("pitch", this._rotateCompassArrow), e22.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Mn(e22, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          const e22 = this._map;
          e22 && (this._container.remove(), this.options.showZoom && e22.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e22.off("pitch", this._rotateCompassArrow), e22.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
        }
        _createButton(e22, t22) {
          const i2 = l2("button", e22, this._container);
          return i2.type = "button", i2.addEventListener("click", t22), i2;
        }
        _setButtonTitle(e22, t22) {
          if (!this._map)
            return;
          const i2 = this._map._getUIString("NavigationControl.".concat(t22));
          e22.setAttribute("aria-label", i2), e22.firstElementChild && e22.firstElementChild.setAttribute("title", i2);
        }
      }, GeolocateControl: class extends e2.E {
        constructor(t22 = {}) {
          super();
          const i2 = navigator.geolocation;
          this.options = e2.l({ geolocation: i2 }, kn, t22), e2.aJ(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Ta2(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
        }
        onAdd(e22) {
          return this._map = e22, this._container = l2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
        }
        onRemove() {
          void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
        }
        _checkGeolocationSupport(e22) {
          const t22 = (t3 = !!this.options.geolocation) => {
            this._supportsGeolocation = t3, e22(t3);
          };
          void 0 !== this._supportsGeolocation ? e22(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({ name: "geolocation" }).then((e3) => t22("denied" !== e3.state)).catch(() => t22()) : t22();
        }
        _isOutOfMapMaxBounds(e22) {
          const t22 = this._map.getMaxBounds(), i2 = e22.coords;
          return !!t22 && (i2.longitude < t22.getWest() || i2.longitude > t22.getEast() || i2.latitude < t22.getSouth() || i2.latitude > t22.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }
        _onSuccess(t22) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(t22))
              return this._setErrorState(), this.fire(new e2.x("outofmaxbounds", t22)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = t22, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t22), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t22), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new e2.x("geolocate", t22)), this._finish();
          }
        }
        _updateCamera(t22) {
          const i2 = new e2.bK(t22.coords.longitude, t22.coords.latitude), o2 = t22.coords.accuracy, r22 = this._map.getBearing(), s2 = e2.l({ bearing: r22 }, this.options.fitBoundsOptions);
          this._map.fitBounds(i2.toBounds(o2), s2, { geolocateSource: true });
        }
        _updateMarker(t22) {
          if (t22) {
            const i2 = new e2.bK(t22.coords.longitude, t22.coords.latitude);
            this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t22.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }
        _updateCircleRadius() {
          const t22 = this._map.transform, i2 = e2.bD(1, t22._center.lat) * t22.worldSize, o2 = Math.ceil(2 * this._accuracy * i2);
          this._circleElement.style.width = "".concat(o2, "px"), this._circleElement.style.height = "".concat(o2, "px");
        }
        _onZoom() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }
        _updateMarkerRotation() {
          this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
        }
        _onError(t22) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (1 === t22.code) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                const e22 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.setAttribute("aria-label", e22), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e22), void 0 !== this._geolocationWatchID && this._clearWatch();
              } else {
                if (3 === t22.code && this._noTimeout)
                  return;
                this._setErrorState();
              }
            "OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new e2.x("error", t22)), this._finish();
          }
        }
        _finish() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }
        _setupUI(t22) {
          if (void 0 !== this._map) {
            if (this._container.addEventListener("contextmenu", (e22) => e22.preventDefault()), this._geolocateButton = l2("button", "mapboxgl-ctrl-geolocate", this._container), l2("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === t22) {
              e2.w("Geolocation support is not available so the GeolocateControl will be disabled.");
              const t3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t3);
            } else {
              const e22 = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.setAttribute("aria-label", e22), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e22);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = l2("div", "mapboxgl-user-location"), this._dotElement.appendChild(l2("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(l2("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Fn({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = l2("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Fn({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t3) => {
              t3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t3.originalEvent && "resize" === t3.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e2.x("trackuserlocationend")));
            });
          }
        }
        _onDeviceOrientation(e22) {
          this._userLocationDotMarker && (e22.webkitCompassHeading ? this._heading = e22.webkitCompassHeading : true === e22.absolute && (this._heading = -1 * e22.alpha), this._updateMarkerRotationThrottled());
        }
        trigger() {
          if (!this._setup)
            return e2.w("Geolocate control triggered before added to a map"), false;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new e2.x("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e2.x("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e2.x("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
              this._clearWatch();
            else if (void 0 === this._geolocationWatchID) {
              let e22;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e22 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e22 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e22), this.options.showUserHeading && this._addDeviceOrientationListener();
            }
          } else
            this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4);
          return true;
        }
        _addDeviceOrientationListener() {
          const e22 = () => {
            "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
          };
          "undefined" != typeof DeviceMotionEvent && "function" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t22) => {
            "granted" === t22 && e22();
          }).catch(console.error) : e22();
        }
        _clearWatch() {
          this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, AttributionControl: En, ScaleControl: class {
        constructor(t22 = {}) {
          this.options = e2.l({}, Bn, t22), this._isNumberFormatSupported = function() {
            try {
              return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), true;
            } catch (e22) {
              return false;
            }
          }(), e2.aJ(["_update", "_setScale", "setUnit"], this);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _update() {
          const e22 = this.options.maxWidth || 100, t22 = this._map, i2 = t22._containerHeight / 2, o2 = t22._containerWidth / 2 - e22 / 2, r22 = t22.unproject([o2, i2]), s2 = t22.unproject([o2 + e22, i2]), a2 = r22.distanceTo(s2);
          if ("imperial" === this.options.unit) {
            const t3 = 3.2808 * a2;
            t3 > 5280 ? this._setScale(e22, t3 / 5280, "mile") : this._setScale(e22, t3, "foot");
          } else
            "nautical" === this.options.unit ? this._setScale(e22, a2 / 1852, "nautical-mile") : a2 >= 1e3 ? this._setScale(e22, a2 / 1e3, "kilometer") : this._setScale(e22, a2, "meter");
        }
        _setScale(e22, t22, i2) {
          this._map._requestDomTask(() => {
            const o2 = function(e3) {
              const t3 = Math.pow(10, "".concat(Math.floor(e3)).length - 1);
              let i3 = e3 / t3;
              return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(e4) {
                const t4 = Math.pow(10, Math.ceil(-Math.log(e4) / Math.LN10));
                return Math.round(e4 * t4) / t4;
              }(i3), t3 * i3;
            }(t22), r22 = o2 / t22;
            this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i2 ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: i2 }).format(o2) : "".concat(o2, "&nbsp;").concat(Nn[i2]), this._container.style.width = e22 * r22 + "px";
          });
        }
        onAdd(e22) {
          return this._map = e22, this._language = e22.getLanguage(), this._container = l2("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e22.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("move", this._update), this._map = void 0;
        }
        _setLanguage(e22) {
          this._language = e22, this._update();
        }
        setUnit(e22) {
          this.options.unit = e22, this._update();
        }
      }, FullscreenControl: class {
        constructor(t22 = {}) {
          this._fullscreen = false, t22 && t22.container && (t22.container instanceof HTMLElement ? this._container = t22.container : e2.w("Full screen control 'container' must be a DOM element.")), e2.aJ(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
        }
        onAdd(t22) {
          return this._map = t22, this._container || (this._container = this._map.getContainer()), this._controlContainer = l2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e2.w("This device does not support fullscreen mode.")), this._controlContainer;
        }
        onRemove() {
          this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }
        _checkFullscreenSupport() {
          return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
        }
        _setupUI() {
          const e22 = this._fullscreenButton = l2("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          l2("span", "mapboxgl-ctrl-icon", e22).setAttribute("aria-hidden", "true"), e22.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
        }
        _updateTitle() {
          const e22 = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", e22), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e22);
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _changeIcon() {
          (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }
        _onClickFullscreen() {
          this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        }
      }, Popup: class extends e2.E {
        constructor(t22) {
          super(), this.options = e2.l(Object.create(Un), t22), e2.aJ(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t22 && t22.className ? t22.className.trim().split(/\s+/) : []);
        }
        addTo(t22) {
          return this._map && this.remove(), this._map = t22, this.options.closeOnClick && t22.on("preclick", this._onClose), this.options.closeOnMove && t22.on("move", this._onClose), t22.on("remove", this.remove), this._update(), t22._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t22.on("mousemove", this._onMouseEvent), t22.on("mouseup", this._onMouseEvent), t22._canvasContainer.classList.add("mapboxgl-track-pointer")) : t22.on("move", this._update), this.fire(new e2.x("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        remove() {
          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
          const t22 = this._map;
          return t22 && (t22.off("move", this._update), t22.off("move", this._onClose), t22.off("preclick", this._onClose), t22.off("click", this._onClose), t22.off("remove", this.remove), t22.off("mousemove", this._onMouseEvent), t22.off("mouseup", this._onMouseEvent), t22.off("drag", this._onMouseEvent), t22._canvasContainer && t22._canvasContainer.classList.remove("mapboxgl-track-pointer"), t22._removePopup(this), this._map = void 0), this.fire(new e2.x("close")), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t22) {
          this._lngLat = e2.bK.convert(t22), this._pos = null, this._trackPointer = false, this._update();
          const i2 = this._map;
          return i2 && (i2.on("move", this._update), i2.off("mousemove", this._onMouseEvent), i2._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }
        trackPointer() {
          this._trackPointer = true, this._pos = null, this._update();
          const e22 = this._map;
          return e22 && (e22.off("move", this._update), e22.on("mousemove", this._onMouseEvent), e22.on("drag", this._onMouseEvent), e22._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(e22) {
          return this.setDOMContent(document.createTextNode(e22));
        }
        setHTML(e22) {
          const t22 = document.createDocumentFragment(), i2 = document.createElement("body");
          let o2;
          for (i2.innerHTML = e22; o2 = i2.firstChild, o2; )
            t22.appendChild(o2);
          return this.setDOMContent(t22);
        }
        getMaxWidth() {
          return this._container && this._container.style.maxWidth;
        }
        setMaxWidth(e22) {
          return this.options.maxWidth = e22, this._update(), this;
        }
        setDOMContent(e22) {
          let t22 = this._content;
          if (t22)
            for (; t22.hasChildNodes(); )
              t22.firstChild && t22.removeChild(t22.firstChild);
          else
            t22 = this._content = l2("div", "mapboxgl-popup-content", this._container || void 0);
          if (t22.appendChild(e22), this.options.closeButton) {
            const e3 = this._closeButton = l2("button", "mapboxgl-popup-close-button", t22);
            e3.type = "button", e3.setAttribute("aria-label", "Close popup"), e3.setAttribute("aria-hidden", "true"), e3.innerHTML = "&#215;", e3.addEventListener("click", this._onClose);
          }
          return this._update(), this._focusFirstElement(), this;
        }
        addClassName(e22) {
          return this._classList.add(e22), this._updateClassList(), this;
        }
        removeClassName(e22) {
          return this._classList.delete(e22), this._updateClassList(), this;
        }
        setOffset(e22) {
          return this.options.offset = e22, this._update(), this;
        }
        toggleClassName(e22) {
          let t22;
          return this._classList.delete(e22) ? t22 = false : (this._classList.add(e22), t22 = true), this._updateClassList(), t22;
        }
        _onMouseEvent(e22) {
          this._update(e22.point);
        }
        _getAnchor(e22) {
          if (this.options.anchor)
            return this.options.anchor;
          const t22 = this._map, i2 = this._container, o2 = this._pos;
          if (!t22 || !i2 || !o2)
            return "bottom";
          const r22 = i2.offsetWidth, s2 = i2.offsetHeight, a2 = o2.x < r22 / 2, n22 = o2.x > t22.transform.width - r22 / 2;
          if (o2.y + e22 < s2)
            return a2 ? "top-left" : n22 ? "top-right" : "top";
          if (o2.y > t22.transform.height - s2) {
            if (a2)
              return "bottom-left";
            if (n22)
              return "bottom-right";
          }
          return a2 ? "left" : n22 ? "right" : "bottom";
        }
        _updateClassList() {
          const e22 = this._container;
          if (!e22)
            return;
          const t22 = [...this._classList];
          t22.push("mapboxgl-popup"), this._anchor && t22.push("mapboxgl-popup-anchor-".concat(this._anchor)), this._trackPointer && t22.push("mapboxgl-popup-track-pointer"), e22.className = t22.join(" ");
        }
        _update(t22) {
          const i2 = this._map, o2 = this._content;
          if (!i2 || !this._lngLat && !this._trackPointer || !o2)
            return;
          let r22 = this._container;
          if (r22 || (r22 = this._container = l2("div", "mapboxgl-popup", i2.getContainer()), this._tip = l2("div", "mapboxgl-popup-tip", r22), r22.appendChild(o2)), this.options.maxWidth && r22.style.maxWidth !== this.options.maxWidth && (r22.style.maxWidth = this.options.maxWidth), i2.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = zn(this._lngLat, this._pos, i2.transform)), !this._trackPointer || t22) {
            const o3 = this._pos = this._trackPointer && t22 instanceof e2.P ? t22 : i2.project(this._lngLat), r3 = jn(this.options.offset), s2 = this._anchor = this._getAnchor(r3.y), a2 = jn(this.options.offset, s2), n22 = o3.add(a2).round();
            i2._requestDomTask(() => {
              this._container && s2 && (this._container.style.transform = "".concat(On[s2], " translate(").concat(n22.x, "px,").concat(n22.y, "px)"));
            });
          }
          if (!this._marker && i2._showingGlobe()) {
            const t3 = e2.dz(i2.transform, this._lngLat) ? 0 : 1;
            this._setOpacity(t3);
          }
          this._updateClassList();
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container)
            return;
          const e22 = this._container.querySelector(Gn);
          e22 && e22.focus();
        }
        _onClose() {
          this.remove();
        }
        _setOpacity(e22) {
          this._container && (this._container.style.opacity = "".concat(e22)), this._content && (this._content.style.pointerEvents = e22 ? "auto" : "none");
        }
      }, Marker: Fn, Style: co, LngLat: e2.bK, LngLatBounds: e2.as, Point: e2.P, MercatorCoordinate: e2.a5, FreeCameraOptions: Ui2, Evented: e2.E, config: e2.e, prewarm: e2.dE, clearPrewarmedResources: e2.dF, get accessToken() {
        return e2.e.ACCESS_TOKEN;
      }, set accessToken(t22) {
        e2.e.ACCESS_TOKEN = t22;
      }, get baseApiUrl() {
        return e2.e.API_URL;
      }, set baseApiUrl(t22) {
        e2.e.API_URL = t22;
      }, get workerCount() {
        return e2.dG.workerCount;
      }, set workerCount(t22) {
        e2.dG.workerCount = t22;
      }, get maxParallelImageRequests() {
        return e2.e.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(t22) {
        e2.e.MAX_PARALLEL_IMAGE_REQUESTS = t22;
      }, clearStorage(t22) {
        e2.dH(t22);
      }, get workerUrl() {
        return e2.dI.workerUrl;
      }, set workerUrl(t22) {
        e2.dI.workerUrl = t22;
      }, get workerClass() {
        return e2.dI.workerClass;
      }, set workerClass(t22) {
        e2.dI.workerClass = t22;
      }, get workerParams() {
        return e2.dI.workerParams;
      }, set workerParams(t22) {
        e2.dI.workerParams = t22;
      }, get dracoUrl() {
        return e2.dJ();
      }, set dracoUrl(t22) {
        e2.dK(t22);
      }, get meshoptUrl() {
        return e2.dL();
      }, set meshoptUrl(t22) {
        e2.dM(t22);
      }, setNow: e2.q.setNow, restoreNow: e2.q.restoreNow };
    });
    var mapboxgl$1 = mapboxgl2;
    return mapboxgl$1;
  });
})(mapboxGl);
var mapboxGlExports = mapboxGl.exports;
const mapboxgl = /* @__PURE__ */ getDefaultExportFromCjs(mapboxGlExports);
const SuccessModal = ({ isOpen, locationName, dismiss: dismiss2, infoText }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IonModal, { id: "success-modal", isOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonContent, { style: { display: "flex", alignItems: "center" }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { className: "ion-text-center", children: "Success!" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { color: "light", onClick: () => dismiss2(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { src: "/assets/icons/close.svg" }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "success-modal", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonImg, { src: "/assets/icons/success.png" }),
      "The location ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: locationName }),
      " was successfully ",
      infoText,
      "."
    ] })
  ] }) });
};
function uuid() {
  const hashTable = [
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
  ];
  let uuid2 = [];
  for (let i = 0; i < 36; i++) {
    if (i === 8 || i === 13 || i === 18 || i === 23) {
      uuid2[i] = "-";
    } else {
      uuid2[i] = hashTable[Math.ceil(Math.random() * hashTable.length - 1)];
    }
  }
  return uuid2.join("");
}
var uuid_1 = uuid;
const uuid$1 = /* @__PURE__ */ getDefaultExportFromCjs(uuid_1);
const LocationEditor = ({
  showDescriptionForm,
  setShowDescriptionForm,
  onChangeLocationName,
  locationName,
  onChangeLocationComment,
  locationComment,
  setSelectedType,
  selectedType,
  resetForms,
  location: location2,
  onSaveForm
}) => {
  var _a, _b, _c;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IonModal,
    {
      className: "add-location",
      initialBreakpoint: 0.6,
      breakpoints: [0.2, 0.6],
      backdropDismiss: true,
      backdropBreakpoint: 0.3,
      isOpen: location2 !== null,
      onIonModalDidDismiss: resetForms,
      mode: "ios",
      children: !showDescriptionForm ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Menu,
        {
          headline: "Add new location",
          paragraphText: (_a = location2 == null ? void 0 : location2.address) != null ? _a : "",
          disabled: selectedType === null,
          buttonText: "Next",
          onClick: () => setShowDescriptionForm(true),
          onDismiss: resetForms,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: MENU_ITEMS.map((item) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              MenuItem,
              {
                item,
                onClick: () => setSelectedType(item.type),
                showSelectedIcon: selectedType === item.type
              },
              item.id
            );
          }) })
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        Menu,
        {
          headline: "Add description",
          paragraphText: (_b = location2 == null ? void 0 : location2.address) != null ? _b : "",
          disabled: locationName === "",
          buttonText: "Save",
          onClick: onSaveForm,
          onDismiss: resetForms,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "add-location-menu-item", onClick: () => {
              setShowDescriptionForm(false);
            }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "add-location-menu-item-label", style: { alignItems: "center" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IonIcon,
                  {
                    "aria-hidden": "true",
                    src: "/assets/icons/".concat(selectedType, ".svg")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { children: (_c = MENU_ITEMS.find((item) => item.type === selectedType)) == null ? void 0 : _c.title })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IonIcon,
                {
                  "aria-hidden": "true",
                  src: "/assets/icons/renew.svg"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonInput,
              {
                type: "text",
                label: "Location Name",
                labelPlacement: "stacked",
                placeholder: "Please enter a name...",
                value: locationName,
                onIonInput: onChangeLocationName,
                required: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonTextarea,
              {
                label: "(Optional) Comment",
                labelPlacement: "stacked",
                placeholder: "Enter a comment for this location ...",
                value: locationComment,
                onIonInput: onChangeLocationComment
              }
            ) })
          ] })
        }
      )
    }
  );
};
const LocationEditorContainer = ({ onSaveLocation, onFormDismiss, location: location2 }) => {
  const [showDescriptionForm, setShowDescriptionForm] = reactExports.useState(false);
  const [selectedType, setSelectedType] = reactExports.useState("type" in location2 ? location2 == null ? void 0 : location2.type : null);
  const [locationName, setLocationName] = reactExports.useState("name" in location2 ? location2.name : "");
  const [locationComment, setLocationComment] = reactExports.useState("description" in location2 ? location2.description : "");
  const onChangeLocationName = (e2) => {
    if (e2.detail.value) {
      setLocationName(e2.detail.value);
    }
  };
  const onChangeLocationComment = (e2) => {
    if (e2.detail.value) {
      setLocationComment(e2.detail.value);
    }
  };
  const resetForms = () => {
    onFormDismiss();
    setSelectedType(null);
    setLocationName("");
    setLocationComment("");
    setShowDescriptionForm(false);
  };
  const onSaveForm = () => {
    if (selectedType !== null) {
      let newLocation;
      if ("visitDate" in location2) {
        console.log(location2);
        newLocation = {
          id: location2.id,
          type: selectedType,
          description: locationComment,
          latitude: location2.latitude,
          longitude: location2.longitude,
          address: location2.address,
          name: locationName,
          visitDate: location2.visitDate
        };
      } else {
        newLocation = {
          id: uuid$1(),
          type: selectedType,
          description: locationComment,
          latitude: location2.latitude,
          longitude: location2.longitude,
          address: location2.address,
          name: locationName,
          visitDate: (/* @__PURE__ */ new Date()).toLocaleDateString()
        };
      }
      resetForms();
      onSaveLocation(newLocation);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LocationEditor,
    {
      location: location2,
      locationName,
      onChangeLocationComment,
      locationComment,
      onChangeLocationName,
      showDescriptionForm,
      setShowDescriptionForm,
      selectedType,
      setSelectedType,
      resetForms,
      onSaveForm
    }
  );
};
const AddLocation = ({
  locationName,
  location: location2,
  showSuccessModal,
  setShowSuccessModal,
  onSaveForm,
  setClickedLocation
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SuccessModal, { infoText: "added", locationName, dismiss: () => setShowSuccessModal(false), isOpen: showSuccessModal }),
    location2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      LocationEditorContainer,
      {
        location: location2,
        onSaveLocation: onSaveForm,
        onFormDismiss: () => setClickedLocation(null)
      }
    )
  ] });
};
const AddLocationContainer = () => {
  const { clickedLocation, mapRef, setClickedLocation, setRefetch, setRebuildMap } = useMapbox();
  const [showSuccessModal, setShowSuccessModal] = reactExports.useState(false);
  const [locationName, setLocationName] = reactExports.useState("");
  const marker = reactExports.useMemo(() => new mapboxgl.Marker(), []);
  reactExports.useEffect(() => {
    if (mapRef && mapRef.current) {
      if (clickedLocation) {
        marker.setLngLat({ lat: clickedLocation.latitude, lon: clickedLocation.longitude }).addTo(mapRef.current);
      } else {
        marker.remove();
      }
    }
    return () => {
      marker.remove();
    };
  }, [clickedLocation, mapRef, marker]);
  const onSaveForm = async (location2) => {
    if (mapRef == null ? void 0 : mapRef.current) {
      await storeLocation(location2);
      setRefetch(true);
      setRebuildMap(true);
      setLocationName(location2.name);
      setShowSuccessModal(true);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    AddLocation,
    {
      location: clickedLocation,
      onSaveForm,
      showSuccessModal,
      setShowSuccessModal,
      locationName,
      setClickedLocation
    }
  );
};
const Map$1 = ({
  isLoading,
  clickedMarker,
  setClickedMarker,
  onDeleteLocation,
  showSuccessModal,
  setShowSuccessModal,
  showEditForm,
  setShowEditForm,
  onUpdateLocation
}) => {
  var _a;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    isLoading && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(IonSpinner, { className: "spinner", name: "circular", color: "light" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "map-overlay" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "map", className: isLoading ? "map-loading" : "" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SuccessModal,
      {
        locationName: (_a = clickedMarker == null ? void 0 : clickedMarker.name) != null ? _a : "",
        dismiss: () => setShowSuccessModal(false),
        isOpen: showSuccessModal,
        infoText: "deleted"
      }
    ),
    clickedMarker && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: showEditForm ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      LocationEditorContainer,
      {
        onSaveLocation: onUpdateLocation,
        onFormDismiss: () => {
          setShowEditForm(false);
          setClickedMarker(void 0);
        },
        location: clickedMarker
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      IonModal,
      {
        initialBreakpoint: 0.45,
        breakpoints: [0, 0.45],
        backdropDismiss: true,
        backdropBreakpoint: 0.3,
        isOpen: !!clickedMarker && !showEditForm,
        onIonModalDidDismiss: () => setClickedMarker(void 0),
        mode: "ios",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonToolbar, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonButtons,
              {
                slot: "start",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonButton, { color: "medium", onClick: () => setClickedMarker(void 0), children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { src: "/assets/icons/close.svg" }) })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonTitle, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "map-popover-title ion-align-items-center ion-justify-content-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonIcon, { src: "/assets/icons/".concat(clickedMarker.type, ".svg") }),
              clickedMarker.name
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IonButtons, { slot: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonButton,
              {
                onClick: () => {
                  setShowEditForm(true);
                },
                children: "Edit"
              }
            ) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IonContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "map-popover-content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { style: { fontWeight: "500" }, children: "Address" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: clickedMarker.address })
            ] }),
            clickedMarker.description !== "" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IonLabel, { style: { fontWeight: "500" }, children: "Comment" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { fontStyle: "italic" }, children: [
                '"',
                clickedMarker.description,
                '"'
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IonButton,
              {
                shape: "round",
                fill: "clear",
                style: { width: "100%" },
                color: "danger",
                onClick: onDeleteLocation,
                children: "Delete Location"
              }
            )
          ] }) })
        ]
      }
    ) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AddLocationContainer, {})
  ] });
};
const MapContainer = () => {
  const { isLoading, clickedMarker, setClickedMarker, setRefetch, setRebuildMap, setIsLoading } = useMapbox();
  const [showSuccessModal, setShowSuccessModal] = reactExports.useState(false);
  const [showEditForm, setShowEditForm] = reactExports.useState(false);
  const onDeleteLocation = async () => {
    if (clickedMarker) {
      setIsLoading(true);
      setRefetch(true);
      setRebuildMap(true);
      setShowSuccessModal(true);
      await deleteLocation(clickedMarker.id);
      setClickedMarker(void 0);
      setIsLoading(false);
    } else {
      console.error("No Marker clicked.");
    }
  };
  const onUpdateLocation = async (location2) => {
    await updateLocation(location2);
    setClickedMarker(void 0);
    setShowEditForm(false);
    setRefetch(true);
    setRebuildMap(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Map$1,
    {
      isLoading,
      clickedMarker,
      setClickedMarker,
      onDeleteLocation,
      showSuccessModal,
      setShowSuccessModal,
      setShowEditForm,
      showEditForm,
      onUpdateLocation
    }
  );
};
const HomeContainer = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IonPage, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SearchLocationContainer, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MapContainer, {})
  ] });
};
const Geolocation = registerPlugin("Geolocation", {
  web: () => __vitePreload(() => import("./web-DI9BheiW.js"), true ? __vite__mapDeps([]) : void 0, import.meta.url).then((m2) => new m2.GeolocationWeb())
});
async function requestLocation() {
  try {
    const status = await Geolocation.checkPermissions();
    if (status.location !== "granted") {
      await Geolocation.requestPermissions();
    }
    if (status.location === "granted") {
      return await Geolocation.getCurrentPosition();
    } else {
      console.warn("Location permission not granted");
      return null;
    }
  } catch (error) {
    console.error(error);
    return null;
  }
}
mapboxgl.accessToken = { "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false, "LEGACY": false }.VITE_MAPBOX_KEY;
const getMap = async (containerId) => {
  const location2 = await requestLocation();
  const map2 = new mapboxgl.Map({
    container: containerId,
    style: "mapbox://styles/mapbox/streets-v12",
    zoom: 17.15,
    pitch: 15,
    center: location2 ? [location2.coords.longitude, location2.coords.latitude] : [30, 70]
    // Dummy center value
  });
  map2.addControl(new mapboxGlExports.NavigationControl());
  return map2;
};
const getMarkerBackgroundColor = (type) => {
  return {
    [LocationTypes.RESTAURANT]: "#7BFFAD",
    [LocationTypes.TOURISTIC]: "#FFE18D",
    [LocationTypes.EVENT_VENUE]: "#FFA4C4",
    [LocationTypes.PUBLIC_FACILITY]: "#B1D7FF",
    [LocationTypes.CUSTOM]: "#FF9999"
  }[type] || "transparent";
};
const createMarkerElement = (id2, type) => {
  const el2 = document.createElement("div");
  el2.className = "marker";
  el2.id = id2;
  el2.style.backgroundColor = getMarkerBackgroundColor(type);
  const icon = document.createElement("div");
  icon.style.backgroundImage = "url('/assets/icons/".concat(type, ".svg')");
  icon.className = "marker-icon";
  el2.appendChild(icon);
  return el2;
};
const getAddressFromCoordinates = async (lng, lat) => {
  const response = await fetch(
    "https://api.mapbox.com/geocoding/v5/mapbox.places/".concat(lng, ",").concat(lat, ".json?access_token=").concat({ "BASE_URL": "./", "MODE": "production", "DEV": false, "PROD": true, "SSR": false, "LEGACY": false }.VITE_MAPBOX_KEY)
  );
  if (!response.ok) {
    console.error("Failed to fetch address:", response.statusText);
    return "";
  }
  const data = await response.json();
  const features = data.features;
  return features.length > 0 ? features[0].place_name : "";
};
const loadImages = async (map2) => {
  const images = [
    { url: "/assets/icons/".concat(LocationTypes.RESTAURANT, ".png"), id: LocationTypes.RESTAURANT },
    { url: "/assets/icons/".concat(LocationTypes.TOURISTIC, ".png"), id: LocationTypes.TOURISTIC },
    { url: "/assets/icons/".concat(LocationTypes.PUBLIC_FACILITY, ".png"), id: LocationTypes.PUBLIC_FACILITY },
    { url: "/assets/icons/".concat(LocationTypes.EVENT_VENUE, ".png"), id: LocationTypes.EVENT_VENUE },
    { url: "/assets/icons/".concat(LocationTypes.CUSTOM, ".png"), id: LocationTypes.CUSTOM }
  ];
  await Promise.all(images.map(
    ({ url, id: id2 }) => new Promise((resolve, reject) => {
      if (map2.hasImage(id2))
        return resolve();
      map2.loadImage(url, (error, image) => {
        if (error) {
          reject(error);
        } else {
          map2.addImage(id2, image);
          resolve();
        }
      });
    })
  ));
};
const getLocationSource = (filteredLocations) => {
  return {
    "type": "geojson",
    "data": {
      "type": "FeatureCollection",
      "features": filteredLocations.map((location2) => ({
        "type": "Feature",
        "geometry": {
          "type": "Point",
          "coordinates": [location2.longitude, location2.latitude]
        },
        "properties": {
          "id": location2.id,
          "type": location2.type,
          "name": location2.name,
          "description": location2.description,
          "address": location2.address,
          "visitDate": location2.visitDate
        }
      }))
    },
    "cluster": true,
    "clusterRadius": 30,
    clusterProperties: {
      has_restaurant: ["any", ["==", ["get", "type"], LocationTypes.RESTAURANT], false],
      has_touristic: ["any", ["==", ["get", "type"], LocationTypes.TOURISTIC], false],
      has_public_facility: ["any", ["==", ["get", "type"], LocationTypes.PUBLIC_FACILITY], false],
      has_event: ["any", ["==", ["get", "type"], LocationTypes.EVENT_VENUE], false],
      has_custom: ["any", ["==", ["get", "type"], LocationTypes.CUSTOM], false]
    }
  };
};
const clustersBackgroundConfig = {
  id: "clusters-background",
  type: "circle",
  source: "locations",
  filter: ["has", "point_count"],
  paint: {
    "circle-color": [
      "case",
      ["get", "has_restaurant"],
      "#7BFFAD",
      ["get", "has_touristic"],
      "#FFE18D",
      ["get", "has_event"],
      "#FFA4C4",
      ["get", "has_public_facility"],
      "#B1D7FF",
      ["get", "has_custom"],
      "#FF9999",
      "#51bbd6"
      // Default background color
    ],
    "circle-radius": 20
  }
};
const clustersSymbolConfig = {
  id: "clusters",
  type: "symbol",
  source: "locations",
  filter: ["has", "point_count"],
  layout: {
    "icon-image": [
      "case",
      ["get", "has_restaurant"],
      LocationTypes.RESTAURANT,
      ["get", "has_touristic"],
      LocationTypes.TOURISTIC,
      ["get", "has_public_facility"],
      LocationTypes.PUBLIC_FACILITY,
      ["get", "has_event"],
      LocationTypes.EVENT_VENUE,
      ["get", "has_custom"],
      LocationTypes.CUSTOM,
      LocationTypes.PUBLIC_FACILITY
      // Default icon
    ],
    "icon-size": 0.25,
    "icon-allow-overlap": true
  }
};
const clustersCountBackgroundConfig = {
  id: "clusters-count-bg",
  type: "circle",
  source: "locations",
  filter: ["has", "point_count"],
  paint: {
    "circle-translate": [15, -15],
    "circle-color": "#E60000",
    "circle-radius": 8
  }
};
const clusterCountConfig = {
  id: "cluster-count",
  type: "symbol",
  source: "locations",
  filter: ["has", "point_count"],
  paint: {
    "text-color": "#FFFFFF",
    "text-translate": [15, -15]
  },
  layout: {
    "text-field": "{point_count_abbreviated}",
    "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
    "text-size": 12,
    "text-allow-overlap": true
  }
};
const INITIAL_FILTERS = [
  LocationTypes.RESTAURANT,
  LocationTypes.TOURISTIC,
  LocationTypes.CUSTOM,
  LocationTypes.PUBLIC_FACILITY,
  LocationTypes.EVENT_VENUE
];
const MapboxProvider = ({ containerId, children }) => {
  const mapRef = reactExports.useRef(null);
  const markerRef = reactExports.useRef(null);
  const [refetch, setRefetch] = reactExports.useState(false);
  const [rebuildMap, setRebuildMap] = reactExports.useState(false);
  const [locations, setLocations] = reactExports.useState([]);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [activeFilters, setActiveFilters] = reactExports.useState(INITIAL_FILTERS);
  const [clickedMarker, setClickedMarker] = reactExports.useState();
  const [clickedLocation, setClickedLocation] = reactExports.useState(null);
  reactExports.useEffect(() => {
    const map2 = mapRef.current;
    if (clickedMarker && map2) {
      if (markerRef.current) {
        markerRef.current.remove();
      }
      map2.flyTo({
        center: [clickedMarker.longitude, clickedMarker.latitude],
        essential: true
      });
      markerRef.current = new mapboxGlExports.Marker().setLngLat({ lat: clickedMarker.latitude, lng: clickedMarker.longitude }).addTo(map2);
    } else if (clickedMarker === void 0 && markerRef.current) {
      markerRef.current.remove();
      markerRef.current = null;
    }
  }, [clickedMarker]);
  reactExports.useEffect(() => {
    const fetchLocations = async () => {
      const fetchedLocations = await getAllLocations();
      setLocations(fetchedLocations.locations);
      setRefetch(false);
    };
    fetchLocations();
  }, [refetch]);
  reactExports.useEffect(() => {
    setupMap();
    return () => {
      const map2 = mapRef.current;
      if (map2) {
        map2.remove();
      }
    };
  }, [containerId, activeFilters]);
  reactExports.useEffect(() => {
    if (rebuildMap) {
      setupMap().then(() => {
        setRebuildMap(false);
      });
    }
  }, [rebuildMap]);
  const filterLocationsByActiveFilters = (locations2) => {
    return locations2.filter((location2) => activeFilters.includes(location2.type));
  };
  async function setupMap() {
    setIsLoading(true);
    mapRef.current = await getMap(containerId);
    const map2 = mapRef.current;
    const fetchedLocations = await getAllLocations();
    const filteredLocations = filterLocationsByActiveFilters(fetchedLocations.locations);
    if (map2) {
      await loadImages(map2);
      map2.addControl(
        new mapboxgl.GeolocateControl({
          // positionOptions: { enableHighAccuracy: true },
          // showUserHeading: true,
          showUserLocation: true
        })
      );
      map2.on("load", () => {
        if (!map2.getSource("locations")) {
          map2.addSource("locations", getLocationSource(filteredLocations));
          map2.addLayer(clustersBackgroundConfig);
          map2.addLayer(clustersSymbolConfig);
          map2.addLayer(clustersCountBackgroundConfig);
          map2.addLayer(clusterCountConfig);
          initMarkers(map2);
        }
        map2.on("click", async (event) => {
          setIsLoading(true);
          const { lng, lat } = event.lngLat;
          const address = await getAddressFromCoordinates(lng, lat);
          setClickedLocation({ latitude: lat, longitude: lng, address });
          setIsLoading(false);
        });
      });
      setIsLoading(false);
    }
  }
  const initMarkers = (map2) => {
    const markers = {};
    let markersOnScreen = {};
    const updateMarkers = () => {
      const newMarkers = {};
      const features = map2.querySourceFeatures("locations");
      for (const feature of features) {
        let coords;
        if ("coordinates" in feature.geometry) {
          coords = feature.geometry.coordinates;
        }
        const props = feature.properties;
        if (!(props == null ? void 0 : props.cluster)) {
          const id2 = props == null ? void 0 : props.id;
          let marker = markers[id2];
          if (!marker) {
            const el2 = createMarkerElement(id2, props == null ? void 0 : props.type);
            marker = markers[id2] = new mapboxgl.Marker({ element: el2 }).setLngLat(coords);
            el2.addEventListener("click", (event) => {
              event.stopPropagation();
              setClickedMarker({
                id: props.id,
                type: props.type,
                latitude: coords[1],
                longitude: coords[0],
                visitDate: props.visitDate,
                address: props.address,
                name: props.name,
                description: props.description
              });
            });
          }
          newMarkers[id2] = marker;
          if (!markersOnScreen[id2]) {
            marker.addTo(map2);
          }
        }
      }
      for (const id2 in markersOnScreen) {
        if (!newMarkers[id2])
          markersOnScreen[id2].remove();
      }
      markersOnScreen = newMarkers;
    };
    map2.on("render", () => {
      if (map2.getSource("locations") && map2.isSourceLoaded("locations")) {
        updateMarkers();
      }
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MapboxContext.Provider,
    {
      value: {
        clickedMarker,
        setClickedMarker,
        activeFilters,
        setActiveFilters,
        clickedLocation,
        setClickedLocation,
        isLoading,
        setIsLoading,
        mapRef,
        locations,
        refetch,
        setRefetch,
        rebuildMap,
        setRebuildMap
      },
      children
    }
  );
};
setupIonicReact();
const App2 = () => {
  reactExports.useEffect(() => {
    initializeStorage().then();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IonApp, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IonReactRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IonRouterOutlet, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { exact: true, path: "/home", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MapboxProvider, { containerId: "map", children: /* @__PURE__ */ jsxRuntimeExports.jsx(HomeContainer, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { exact: true, path: "/", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Redirect, { to: "/home" }) })
  ] }) }) });
};
const container = document.getElementById("root");
const root = createRoot(container);
root.render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App2, {}) })
);
export {
  Keyboard as K,
  WebPlugin as W,
  __vite_legacy_guard,
  clamp as a,
  componentOnReady as b,
  createGesture as c,
  doc$1 as d,
  addEventListener$1 as e,
  findClosestIonContent as f,
  removeEventListener as g,
  KeyboardResize as h,
  isRTL$1 as i,
  win$2 as j,
  raf as k,
  getScrollElement as l,
  scrollByPoint as m,
  createAnimation as n,
  getIonPageElement as o,
  pointerCoord as p,
  readTask as r,
  scrollToTop as s,
  writeTask$1 as w
};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = []
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}